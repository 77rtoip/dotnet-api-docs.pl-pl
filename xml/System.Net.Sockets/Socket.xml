<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0e53ed559329dd82f20e5b4a3c153091d170154c" /><Meta Name="ms.sourcegitcommit" Value="f991677a7374c45590a432ff7ab830beb05f2ccd" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/27/2019" /><Meta Name="ms.locfileid" Value="68591537" /></Metadata><TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Implementuje interfejs Berkeley Sockets.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> Klasa zawiera rozbudowany zestaw metod i właściwości komunikacji sieciowej. Klasa umożliwia przeprowadzenie synchronicznego i asynchronicznego transferu danych przy użyciu dowolnego protokołu komunikacyjnego wymienionego <xref:System.Net.Sockets.ProtocolType> w wyliczeniu. <xref:System.Net.Sockets.Socket>  
  
 Klasa <xref:System.Net.Sockets.Socket> jest zgodna ze wzorcem nazewnictwa .NET Framework dla metod asynchronicznych. Na przykład metoda synchroniczna <xref:System.Net.Sockets.Socket.Receive%2A> odnosi się do metod asynchronicznych <xref:System.Net.Sockets.Socket.EndReceive%2A> <xref:System.Net.Sockets.Socket.BeginReceive%2A> i.  
  
 Jeśli aplikacja wymaga tylko jednego wątku podczas wykonywania, należy użyć następujących metod, które są przeznaczone do trybu operacji synchronicznej.  
  
-   Jeśli używasz protokołu opartego na połączeniu, takiego jak TCP, serwer może nasłuchiwać połączeń przy użyciu <xref:System.Net.Sockets.Socket.Listen%2A> metody. Metoda przetwarza wszystkie przychodzące żądania połączenia i <xref:System.Net.Sockets.Socket> zwraca wartość, której można użyć do przekazywania danych z hosta zdalnego. <xref:System.Net.Sockets.Socket.Accept%2A> Użyj tego zwrócenia <xref:System.Net.Sockets.Socket> do <xref:System.Net.Sockets.Socket.Send%2A> wywołania metody lub <xref:System.Net.Sockets.Socket.Receive%2A> . Wywołaj <xref:System.Net.Sockets.Socket.Listen%2A> metodę przed wywołaniem metody, jeśli chcesz określić lokalny adres IP i numer portu. <xref:System.Net.Sockets.Socket.Bind%2A> Użyj numeru portu równego zero, jeśli chcesz, aby źródłowy Dostawca usługi przypisał dla Ciebie bezpłatny port. Jeśli chcesz nawiązać połączenie z hostem nasłuchiwania, <xref:System.Net.Sockets.Socket.Connect%2A> Wywołaj metodę. Aby przekazać dane, wywołaj <xref:System.Net.Sockets.Socket.Send%2A> metodę <xref:System.Net.Sockets.Socket.Receive%2A> lub.  
  
-   Jeśli używasz protokołu bezpołączeniowego, takiego jak UDP, nie musisz nasłuchiwać połączeń w ogóle. Wywołaj <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodę, aby zaakceptować wszystkie przychodzące datagramy. Użyj metody <xref:System.Net.Sockets.Socket.SendTo%2A> , aby wysłać datagramy do hosta zdalnego.  
  
 Aby przetwarzać komunikację przy użyciu oddzielnych wątków podczas wykonywania, należy użyć następujących metod, które są przeznaczone do trybu operacji asynchronicznej.  
  
-   Jeśli używasz protokołu opartego na połączeniu, takiego jak TCP, użyj <xref:System.Net.Sockets.Socket>metod, i <xref:System.Net.Sockets.Socket.EndConnect%2A> , <xref:System.Net.Sockets.Socket.BeginConnect%2A>aby nawiązać połączenie z hostem nasłuchiwania. Użyj metod <xref:System.Net.Sockets.Socket.EndSend%2A> ilub<xref:System.Net.Sockets.Socket.BeginReceive%2A> ,<xref:System.Net.Sockets.Socket.EndReceive%2A> aby komunikować dane asynchronicznie. <xref:System.Net.Sockets.Socket.BeginSend%2A> Przychodzące żądania połączeń mogą być przetwarzane przy <xref:System.Net.Sockets.Socket.BeginAccept%2A> użyciu <xref:System.Net.Sockets.Socket.EndAccept%2A>i.  
  
-   Jeśli używasz protokołu bezpołączeniowego, takiego jak UDP, możesz <xref:System.Net.Sockets.Socket.BeginSendTo%2A> użyć i <xref:System.Net.Sockets.Socket.EndSendTo%2A> do <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> wysyłania Datagrams <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> oraz do odbierania Datagrams.  
  
 W przypadku wykonywania wielu operacji asynchronicznych w gnieździe nie są one koniecznie wykonywane w kolejności, w której zostały uruchomione.  
  
 Gdy skończysz wysyłać i odbierać dane, użyj <xref:System.Net.Sockets.Socket.Shutdown%2A> metody, aby <xref:System.Net.Sockets.Socket>wyłączyć. Po wywołaniu <xref:System.Net.Sockets.Socket.Shutdown%2A>należy <xref:System.Net.Sockets.Socket.Close%2A> wywołać metodę, aby zwolnić <xref:System.Net.Sockets.Socket>wszystkie zasoby skojarzone z.  
  
 Klasa umożliwia konfigurowanie przy użyciu <xref:System.Net.Sockets.Socket.SetSocketOption%2A>metody. <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket> Pobierz te ustawienia przy użyciu <xref:System.Net.Sockets.Socket.GetSocketOption%2A> metody.  
  
> [!NOTE]
>  Jeśli piszesz stosunkowo prostą aplikację i nie potrzebujesz maksymalnej wydajności, rozważ użycie <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, i <xref:System.Net.Sockets.UdpClient>. Te klasy zapewniają prostsze i bardziej przyjazny dla użytkownika interfejs do <xref:System.Net.Sockets.Socket> komunikacji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Net.Sockets.Socket> jak można użyć klasy do wysyłania danych do serwera http i odbierania odpowiedzi. Ten przykład blokuje do momentu otrzymania całej strony.  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Aby nawiązać połączenie wychodzące lub zaakceptować żądanie przychodzące.</permission>
    <threadsafe>Wystąpienia tej klasy są bezpieczne wątkowo.</threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
    <related type="Article" href="~/docs/framework/network-programming/index.md">Programowanie dla sieci w .NET Framework</related>
    <related type="Article" href="~/docs/framework/network-programming/best-practices-for-system-net-classes.md">Najlepsze rozwiązania dotyczące klas System.Net</related>
    <related type="Article" href="~/docs/framework/network-programming/cache-management-for-network-applications.md">Zarządzanie pamięcią podręczną dla aplikacji sieciowych</related>
    <related type="Article" href="~/docs/framework/network-programming/internet-protocol-version-6.md">Protokół IPv6</related>
    <related type="Article" href="~/docs/framework/network-programming/network-programming-samples.md">Przykłady programowania sieciowego</related>
    <related type="Article" href="~/docs/framework/network-programming/network-tracing.md">Śledzenie sieci w .NET Framework</related>
    <related type="Article" href="~/docs/framework/network-programming/security-in-network-programming.md">Zabezpieczenia w programowaniu sieciowym</related>
    <related type="Article" href="~/docs/framework/network-programming/socket-performance-enhancements-in-version-3-5.md">Ulepszenia wydajności gniazda w wersji 3.5</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.Socket" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="socketInformation">Informacje o gnieździe zwrócone <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />przez.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Net.Sockets.Socket" /> klasy przy użyciu określonej wartości zwróconej z <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku wywołania <xref:System.Net.Sockets.Socket.%23ctor%2A> konstruktora wiele razy z tą samą tablicą bajtową co argument dla każdego wywołania, utworzysz wiele zarządzanych <xref:System.Net.Sockets.Socket>s z tym samym gniazdem podstawowym. Jest to zdecydowanie odradzane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType">Jedna z <see cref="T:System.Net.Sockets.SocketType" /> wartości.</param>
        <param name="protocolType">Jedna z <see cref="T:System.Net.Sockets.ProtocolType" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Net.Sockets.Socket" /> klasy przy użyciu określonego typu gniazda i protokołu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr określa typ <xref:System.Net.Sockets.Socket> klasy, a `protocolType` parametr określa protokół używany przez <xref:System.Net.Sockets.Socket>. `socketType` Dwa parametry nie są niezależne. <xref:System.Net.Sockets.Socket> Często typ jest niejawny w protokole. Jeśli kombinacja <xref:System.Net.Sockets.Socket> typu i typu protokołu powoduje nieprawidłowy <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.SocketException>, ten konstruktor zgłasza.  
  
> [!NOTE]
>  Jeśli ten konstruktor zgłosi <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Kombinacja <paramref name="socketType" /> i<paramref name="protocolType" /> skutkuje nieprawidłowym gniazdem.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily">Jedna z <see cref="T:System.Net.Sockets.AddressFamily" /> wartości.</param>
        <param name="socketType">Jedna z <see cref="T:System.Net.Sockets.SocketType" /> wartości.</param>
        <param name="protocolType">Jedna z <see cref="T:System.Net.Sockets.ProtocolType" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Net.Sockets.Socket" /> klasy przy użyciu określonej rodziny adresów, typu gniazda i protokołu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> `socketType` <xref:System.Net.Sockets.Socket> `protocolType` Parametr określa schemat adresowania używany przez klasę, parametr określa typ klasy, a parametr określa protokół używany przez <xref:System.Net.Sockets.Socket>. `addressFamily` Trzy parametry nie są niezależne. Niektóre rodziny adresów ograniczają, które protokoły mogą być używane z nimi i często <xref:System.Net.Sockets.Socket> typ jest niejawny w protokole. Jeśli kombinacja rodziny adresów, <xref:System.Net.Sockets.Socket> typu i typu protokołu powoduje nieprawidłowy <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.SocketException>, ten konstruktor zgłasza.  
  
> [!NOTE]
>  Jeśli ten konstruktor zgłosi <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób tworzenia wystąpienia <xref:System.Net.Sockets.Socket> klasy.  
  
 [!code-cpp[Socket_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Kombinacja <paramref name="addressFamily" />, <paramref name="socketType" />i skutkujenieprawidłowymgniazdem.<paramref name="protocolType" /></exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowy <see cref="T:System.Net.Sockets.Socket" /> dla nowo utworzonego połączenia.</summary>
        <returns>A <see cref="T:System.Net.Sockets.Socket" /> dla nowo utworzonego połączenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A>synchronicznie wyodrębnia pierwsze oczekujące żądanie połączenia z kolejki żądań połączeń gniazda nasłuchiwania, a następnie tworzy i zwraca nowy <xref:System.Net.Sockets.Socket>. Nie można użyć tej zwracanej <xref:System.Net.Sockets.Socket> w celu zaakceptowania wszelkich dodatkowych połączeń z kolejki połączeń. Można jednak wywołać <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> metodę zwracaną <xref:System.Net.Sockets.Socket> , aby zidentyfikować adres sieciowy i numer portu hosta zdalnego.  
  
 W bloku tryb blokowania <xref:System.Net.Sockets.Socket.Accept%2A> do momentu, gdy zostanie umieszczona próba połączenia przychodzącego. Po zaakceptowaniu połączenia oryginalna <xref:System.Net.Sockets.Socket> Usługa kontynuuje przychodzące żądania połączenia do momentu jego zamknięcia.  
  
 W przypadku wywołania tej metody przy użyciu funkcji nieblokującej <xref:System.Net.Sockets.Socket>, a żadne żądania połączenia nie są umieszczane w kolejce, <xref:System.Net.Sockets.Socket.Accept%2A> zgłasza <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Przed wywołaniem <xref:System.Net.Sockets.Socket.Accept%2A> metody należy najpierw <xref:System.Net.Sockets.Socket.Listen%2A> wywołać metodę w celu nasłuchiwania przychodzących żądań połączeń i ich kolejki.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu akceptuje proste <xref:System.Net.Sockets.Socket> połączenie.  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Gniazdo akceptujące nie nasłuchuje połączeń. Musisz wywołać metodę <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> i <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> przed wywołaniem metody <see cref="M:System.Net.Sockets.Socket.Accept" />.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Obiekt <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> , który ma być używany dla tej asynchronicznej operacji gniazda.</param>
        <summary>Rozpoczyna operację asynchroniczną w celu zaakceptowania próby połączenia przychodzącego.</summary>
        <returns><see langword="true" />Jeśli operacja we/wy jest w stanie oczekiwania. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie<paramref name="e" /> na parametrze zostanie wywołane po zakończeniu operacji.  
  
 <see langword="false" />Jeśli operacja we/wy została ukończona synchronicznie. Zdarzenie na parametrze nie zostanie zgłoszone, a obiektprzesuniętyjakoparametrmożezostaćzbadanynatychmiastpowywołaniumetody,abypobraćwynikoperacji.<paramref name="e" /> <paramref name="e" /> <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protokoły zorientowane na połączenia mogą używać <xref:System.Net.Sockets.Socket.AcceptAsync%2A> metody do asynchronicznego przetwarzania przychodzących prób połączeń. Akceptowanie połączeń asynchronicznie daje możliwość wysyłania i odbierania danych w osobnym wątku wykonania. Przed wywołaniem <xref:System.Net.Sockets.Socket.AcceptAsync%2A> metody należy <xref:System.Net.Sockets.Socket.Listen%2A> wywołać metodę, aby nasłuchiwać przychodzących żądań połączeń i kolejkować je.  
  
 Aby otrzymywać powiadomienia o zakończeniu, należy utworzyć metodę wywołania zwrotnego, która implementuje delegata EventHandler\<SocketAsyncEventArgs > i przechwytuje go <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> do zdarzenia.  
  
 Wymagane są następujące właściwości i zdarzenia dotyczące <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiektu:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Obiekt wywołujący może opcjonalnie określić istniejący <xref:System.Net.Sockets.Socket> do użycia dla połączenia przychodzącego, <xref:System.Net.Sockets.Socket> określając element do użycia z <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> właściwością.  
  
 <xref:System.Net.Sockets.Socket.ProtocolType%2A> <xref:System.Net.Sockets.Socket.SocketType%2A> <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.AddressFamily%2A> <xref:System.Net.Sockets.Socket> Jeśli właściwość ma wartość null, Nowa jest zbudowana z tą samą, i jako bieżącą i ustawioną jako <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> właściwość. <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>  
  
 Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość na dowolny obiekt stanu użytkownika przed <xref:System.Net.Sockets.Socket.AcceptAsync%2A> wywołaniem metody, tak aby informacje były możliwe do pobierania w metodzie wywołania zwrotnego. Jeśli wywołanie zwrotne wymaga więcej informacji niż pojedynczy obiekt, można utworzyć małą klasę w celu przechowywania innych wymaganych informacji o stanie jako członków.  
  
 Opcjonalnie można określić bufor, który ma otrzymać początkowy blok danych w gnieździe po pomyślnym zakończeniu <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metody. W tym przypadku <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> właściwość musi być ustawiona na bufor zawierający dane do odebrania, <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> a właściwość musi być ustawiona na maksymalną liczbę bajtów danych do odebrania w buforze. Te właściwości można ustawić za pomocą <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> metody. Część przenoszonego buforu zostanie użyta wewnętrznie do użycia przez bazowe wywołanie AcceptEx. Oznacza to, że ilość zwracanych danych będzie zawsze mniejsza niż wartość <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> właściwości <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> w podanym wystąpieniu. Ilość bufora używana wewnętrznie zależy od rodziny adresów gniazda. Minimalny wymagany rozmiar buforu to 288 bajtów. Jeśli zostanie określony większy rozmiar buforu, <xref:System.Net.Sockets.Socket> będzie on oczekiwać pewnej ilości dodatkowych danych niż dane adresowe odbierane przez wywołanie Winsock AcceptEx i będą oczekiwać na odebranie tych dodatkowych danych. W przypadku wystąpienia limitu czasu połączenie zostanie zresetowane. Tak więc jeśli w przypadku danych dodatkowych jest oczekiwana określona ilość, rozmiar buforu powinien być ustawiony na minimalny rozmiar buforu Plus ta kwota.  
  
 Metoda wywołania zwrotnego ukończenia powinna sprawdzić <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> właściwość, aby określić, <xref:System.Net.Sockets.Socket.AcceptAsync%2A> czy operacja zakończyła się pomyślnie.  
  
 Zdarzenie może wystąpić w niektórych przypadkach, gdy żadne połączenie nie zostało zaakceptowane i spowoduje <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> , że właściwość jest ustawiona <xref:System.Net.Sockets.SocketError.ConnectionReset>na. <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Może się to zdarzyć w wyniku skanowania portów przy użyciu pół-otwartego skanowania typu SYN (syn-> SYN-ACK-> RST). Aplikacje korzystające <xref:System.Net.Sockets.Socket.AcceptAsync%2A> z metody powinny być przygotowane do obsługi tego warunku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Argument jest nieprawidłowy. Ten wyjątek występuje, jeśli podany bufor nie jest wystarczająco duży. Bufor musi mieć co najmniej 2 * (sizeof (SOCKADDR_STORAGE + 16) b.  
  
Ten wyjątek występuje również wtedy, gdy określono wiele buforów <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> , właściwość nie ma wartości null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Argument jest poza zakresem. Wyjątek występuje, jeśli wartość <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> jest mniejsza od 0.</exception>
        <exception cref="T:System.InvalidOperationException">Zażądano nieprawidłowej operacji. Ten wyjątek występuje, jeśli akceptowanie <see cref="T:System.Net.Sockets.Socket" /> nie nasłuchuje połączeń lub zaakceptowano gniazdo jest powiązane.  
  
Przed wywołaniem <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> metodynależy<see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> wywołać metodę i.  
  
Ten wyjątek występuje również wtedy, gdy gniazdo jest już połączone lub operacja gniazda była już w toku przy użyciu podanego <paramref name="e" /> parametru.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda wymaga systemu Windows XP lub nowszego.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rodzinę <see cref="T:System.Net.Sockets.Socket" />adresów.</summary>
        <value>Jedna z <see cref="T:System.Net.Sockets.AddressFamily" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określa schemat adresowania, którego może używać wystąpienie <xref:System.Net.Sockets.Socket> klasy. <xref:System.Net.Sockets.AddressFamily> Ta właściwość jest tylko do odczytu i jest ustawiana podczas <xref:System.Net.Sockets.Socket> tworzenia.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, i <xref:System.Net.Sockets.ProtocolType> do konsoli programu.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość danych odebranych z sieci i jest dostępna do odczytu.</summary>
        <value>Liczba bajtów danych odebranych z sieci i dostępnych do odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz nieblokującego <xref:System.Net.Sockets.Socket>, to dobry sposób <xref:System.Net.Sockets.Socket.Available%2A> , aby określić, czy dane są umieszczane w kolejce do odczytu, przed <xref:System.Net.Sockets.Socket.Receive%2A>wywołaniem. Dostępne dane to całkowita ilość danych znajdujących się w kolejce w buforze sieciowym na potrzeby odczytu. Jeśli żadne dane nie są umieszczane w buforze <xref:System.Net.Sockets.Socket.Available%2A> sieciowym, zwraca wartość 0.  
  
 Jeśli host zdalny zamknie lub zamknie połączenie, <xref:System.Net.Sockets.Socket.Available%2A> może <xref:System.Net.Sockets.SocketException>zgłosić. Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu porównuje wyniki wywołania IOControl z FIONREAD i dostępne właściwości.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna operację asynchroniczną w celu zaakceptowania próby połączenia przychodzącego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegat.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Rozpoczyna operację asynchroniczną w celu zaakceptowania próby połączenia przychodzącego.</summary>
        <returns>, Który odwołuje się <see cref="T:System.Net.Sockets.Socket" /> do asynchronicznego tworzenia. <see cref="T:System.IAsyncResult" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protokoły zorientowane na połączenia mogą używać <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody do asynchronicznego przetwarzania przychodzących prób połączeń. Akceptowanie połączeń asynchronicznie daje możliwość wysyłania i odbierania danych w osobnym wątku wykonania. Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody należy <xref:System.Net.Sockets.Socket.Listen%2A> wywołać metodę, aby nasłuchiwać przychodzących żądań połączeń i kolejkować je.  
  
 Należy utworzyć metodę wywołania zwrotnego implementującą <xref:System.AsyncCallback> delegata i przekazać jej nazwę <xref:System.Net.Sockets.Socket.BeginAccept%2A> do metody. Aby to zrobić, w bardzo minimalnym czasie należy przekazać obiekt nasłuchujący <xref:System.Net.Sockets.Socket> do <xref:System.Net.Sockets.Socket.BeginAccept%2A> za pomocą `state` parametru. Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małą klasę do przechowywania <xref:System.Net.Sockets.Socket> i innych wymaganych informacji. Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody `state` za pomocą parametru.  
  
 Metoda wywołania zwrotnego powinna wywołać <xref:System.Net.Sockets.Socket.EndAccept%2A> metodę. Gdy aplikacja jest wywoływana <xref:System.Net.Sockets.Socket.BeginAccept%2A>, system zazwyczaj używa oddzielnego wątku do wykonywania określonej metody wywołania zwrotnego i <xref:System.Net.Sockets.Socket.EndAccept%2A> blokuje się do momentu pobrania oczekującego połączenia. <xref:System.Net.Sockets.Socket.EndAccept%2A>zwróci nowy <xref:System.Net.Sockets.Socket> obiekt, za pomocą którego można wysyłać i odbierać dane przy użyciu hosta zdalnego. Nie można użyć tej zwracanej <xref:System.Net.Sockets.Socket> w celu zaakceptowania wszelkich dodatkowych połączeń z kolejki połączeń. Jeśli chcesz, aby oryginalny wątek blokował po wywołaniu <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, użyj. <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Wywołaj metodę <xref:System.Threading.ManualResetEvent> Set w metodzie wywołania zwrotnego, jeśli chcesz, aby oryginalny wątek kontynuował wykonywanie.  
  
 System może również użyć wątku wywołującego do wywołania metody wywołania zwrotnego. W takim przypadku <xref:System.IAsyncResult.CompletedSynchronously%2A> Właściwość zwracanej <xref:System.IAsyncResult> wartości zostanie <xref:System.Net.Sockets.Socket.BeginAccept%2A> ustawiona, aby wskazać, że metoda została ukończona synchronicznie.  
  
 Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego [, zobacz kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, <xref:System.Net.Sockets.Socket>Zamknij. Gdy metoda jest wywoływana w trakcie trwającej operacji asynchronicznej, wywołanie zwrotne dostarczone <xref:System.Net.Sockets.Socket.BeginAccept%2A> do metody jest wywoływana. <xref:System.Net.Sockets.Socket.Close%2A>  Kolejne wywołanie <xref:System.Net.Sockets.Socket.EndAccept%2A> metody spowoduje <xref:System.ObjectDisposedException> zgłoszenie do wskazania, że operacja została anulowana.  
  
> [!NOTE]
>  Możesz użyć <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> właściwości zwracanej <xref:System.Net.Sockets.Socket> , aby zidentyfikować adres sieciowy i numer portu hosta zdalnego.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> . Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu próbuje odebrać połączenie przychodzące asynchronicznie.  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Dla tej metody wymagany jest system Windows NT.</exception>
        <exception cref="T:System.InvalidOperationException">Gniazdo akceptujące nie nasłuchuje połączeń. Musisz wywołać metodę <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> i <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> przed wywołaniem metody <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
—lub— 
Zaakceptowane gniazdo jest powiązane.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" />jest mniejsza niż 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="receiveSize">Liczba bajtów, które mają zostać zaakceptowane od nadawcy.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegat.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Rozpoczyna operację asynchroniczną w celu zaakceptowania próby połączenia przychodzącego i odebrania pierwszego bloku danych wysyłanych przez aplikację kliencką.</summary>
        <returns>, Który odwołuje się <see cref="T:System.Net.Sockets.Socket" /> do asynchronicznego tworzenia. <see cref="T:System.IAsyncResult" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protokoły zorientowane na połączenia mogą używać <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody do asynchronicznego przetwarzania przychodzących prób połączeń. Akceptowanie połączeń asynchronicznie umożliwia wysyłanie i odbieranie danych w osobnym wątku wykonania. To Przeciążenie pozwala określić liczbę bajtów do zaakceptowania w początkowym transferze w `receiveSize` parametrze.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody należy <xref:System.Net.Sockets.Socket.Listen%2A> wywołać metodę, aby nasłuchiwać przychodzących żądań połączeń i kolejkować je.  
  
 Należy utworzyć metodę wywołania zwrotnego implementującą <xref:System.AsyncCallback> delegata i przekazać jej nazwę <xref:System.Net.Sockets.Socket.BeginAccept%2A> do metody. Aby to zrobić, w bardzo minimalnym czasie należy przekazać obiekt nasłuchujący <xref:System.Net.Sockets.Socket> do <xref:System.Net.Sockets.Socket.BeginAccept%2A> za pomocą `state` parametru. Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małą klasę do przechowywania <xref:System.Net.Sockets.Socket> i innych wymaganych informacji. Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody `state` za pomocą parametru.  
  
 Metoda wywołania zwrotnego powinna wywołać <xref:System.Net.Sockets.Socket.EndAccept%2A> metodę. Gdy aplikacja jest wywoływana <xref:System.Net.Sockets.Socket.BeginAccept%2A>, system zazwyczaj używa oddzielnego wątku do wykonywania określonej metody wywołania zwrotnego i <xref:System.Net.Sockets.Socket.EndAccept%2A> blokuje się do momentu pobrania oczekującego połączenia.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>zwraca nowy <xref:System.Net.Sockets.Socket> , którego można użyć do wysyłania i odbierania danych za pomocą hosta zdalnego. Nie można użyć tej zwracanej <xref:System.Net.Sockets.Socket> w celu zaakceptowania wszelkich dodatkowych połączeń z kolejki połączeń. Jeśli chcesz, aby oryginalny wątek blokował po wywołaniu <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, użyj. <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Wywołaj metodę <xref:System.Threading.ManualResetEvent> Set w metodzie wywołania zwrotnego, jeśli chcesz, aby oryginalny wątek kontynuował wykonywanie.  
  
 System może również użyć wątku wywołującego do wywołania metody wywołania zwrotnego. W takim przypadku <xref:System.IAsyncResult.CompletedSynchronously%2A> Właściwość zwracanej <xref:System.IAsyncResult> wartości zostanie <xref:System.Net.Sockets.Socket.BeginAccept%2A> ustawiona, aby wskazać, że metoda została ukończona synchronicznie.  
  
 Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego [, zobacz kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, <xref:System.Net.Sockets.Socket>Zamknij.  Gdy metoda jest wywoływana w trakcie trwającej operacji asynchronicznej, wywołanie zwrotne dostarczone <xref:System.Net.Sockets.Socket.BeginAccept%2A> do metody jest wywoływana. <xref:System.Net.Sockets.Socket.Close%2A>  Kolejne wywołanie <xref:System.Net.Sockets.Socket.EndAccept%2A> metody spowoduje <xref:System.ObjectDisposedException> zgłoszenie do wskazania, że operacja została anulowana.  
  
> [!NOTE]
>  Możesz wywołać użycie <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> właściwości zwracanego <xref:System.Net.Sockets.Socket> obiektu, aby zidentyfikować adres sieciowy i numer portu hosta zdalnego.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> . Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera gniazdo i akceptuje połączenie asynchroniczne. W tym przykładzie gniazdo akceptuje pierwsze 10 bajtów danych. Liczba odebranych bajtów i dane są wyświetlane w konsoli przez delegata wywołania zwrotnego. Zobacz <xref:System.Net.Sockets.Socket.BeginReceive%2A> , aby dowiedzieć się, jak są otrzymywane pozostałe dane.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Dla tej metody wymagany jest system Windows NT.</exception>
        <exception cref="T:System.InvalidOperationException">Gniazdo akceptujące nie nasłuchuje połączeń. Musisz wywołać metodę <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> i <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> przed wywołaniem metody <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
—lub— 
Zaakceptowane gniazdo jest powiązane.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" />jest mniejsza niż 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="receiveSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">Zaakceptowany <see cref="T:System.Net.Sockets.Socket" /> obiekt. Ta wartość może być <see langword="null" />równa.</param>
        <param name="receiveSize">Maksymalna liczba bajtów do odebrania.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegat.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Rozpoczyna operację asynchroniczną w celu zaakceptowania próby połączenia przychodzącego z określonego gniazda i odbioru pierwszego bloku danych wysłanych przez aplikację kliencką.</summary>
        <returns>Obiekt, który odwołuje się <see cref="T:System.Net.Sockets.Socket" /> do asynchronicznego tworzenia obiektów. <see cref="T:System.IAsyncResult" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protokoły zorientowane na połączenia mogą używać <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody do asynchronicznego przetwarzania przychodzących prób połączeń. Akceptowanie połączeń asynchronicznie daje możliwość wysyłania i odbierania danych w osobnym wątku wykonania. To przeciążenie umożliwia określenie zaakceptowanego gniazda w `acceptSocket` parametrze. Jeśli ten parametr to `null`, zaakceptowane gniazdo jest tworzone <xref:System.Net.Sockets.Socket.BeginAccept%2A> przez metodę. Możesz określić liczbę bajtów, które mają być akceptowane w początkowym transferze w `receiveSize` parametrze.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody należy <xref:System.Net.Sockets.Socket.Listen%2A> wywołać metodę, aby nasłuchiwać przychodzących żądań połączeń i kolejkować je.  
  
 Należy utworzyć metodę wywołania zwrotnego implementującą <xref:System.AsyncCallback> delegata i przekazać jej nazwę <xref:System.Net.Sockets.Socket.BeginAccept%2A> do metody. Aby to zrobić, w bardzo minimalnym czasie należy przekazać obiekt nasłuchujący <xref:System.Net.Sockets.Socket> do <xref:System.Net.Sockets.Socket.BeginAccept%2A> za pomocą `state` parametru. Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małą klasę do przechowywania <xref:System.Net.Sockets.Socket> i innych wymaganych informacji. Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody `state` za pomocą parametru.  
  
 Metoda wywołania zwrotnego powinna wywołać <xref:System.Net.Sockets.Socket.EndAccept%2A> metodę. Gdy aplikacja jest wywoływana <xref:System.Net.Sockets.Socket.BeginAccept%2A>, system zazwyczaj używa oddzielnego wątku do wykonywania określonej metody wywołania zwrotnego i <xref:System.Net.Sockets.Socket.EndAccept%2A> blokuje się do momentu pobrania oczekującego połączenia.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>zwraca nowy <xref:System.Net.Sockets.Socket> obiekt, za pomocą którego można wysyłać i odbierać dane przy użyciu hosta zdalnego. Nie można użyć tej zwracanej <xref:System.Net.Sockets.Socket> w celu zaakceptowania wszelkich dodatkowych połączeń z kolejki połączeń. Jeśli chcesz, aby oryginalny wątek blokował po wywołaniu <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, użyj. <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Wywołaj metodę <xref:System.Threading.ManualResetEvent> Set w metodzie wywołania zwrotnego, jeśli chcesz, aby oryginalny wątek kontynuował wykonywanie.  
  
 System może również użyć wątku wywołującego do wywołania metody wywołania zwrotnego. W takim przypadku <xref:System.IAsyncResult.CompletedSynchronously%2A> Właściwość zwracanej <xref:System.IAsyncResult> wartości zostanie <xref:System.Net.Sockets.Socket.BeginAccept%2A> ustawiona, aby wskazać, że metoda została ukończona synchronicznie.  
  
 Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego, zobacz [kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, <xref:System.Net.Sockets.Socket>Zamknij. Gdy metoda jest wywoływana w trakcie trwającej operacji asynchronicznej, wywołanie zwrotne dostarczone <xref:System.Net.Sockets.Socket.BeginAccept%2A> do metody jest wywoływana. <xref:System.Net.Sockets.Socket.Close%2A>  Kolejne wywołanie <xref:System.Net.Sockets.Socket.EndAccept%2A> metody spowoduje <xref:System.ObjectDisposedException> zgłoszenie do wskazania, że operacja została anulowana.  
  
> [!NOTE]
>  Aby zidentyfikować adres sieciowy <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> i numer portu hosta <xref:System.Net.Sockets.Socket> zdalnego, można użyć Właściwości zwróconego obiektu.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> . Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera gniazdo i akceptuje połączenie asynchroniczne. W tym przykładzie gniazdo akceptuje pierwsze 10 bajtów danych, a `acceptSocket` parametr jest `null`, co wymusza <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody utworzenia zaakceptowanego gniazda. Liczba odebranych bajtów i dane są wyświetlane w konsoli przez delegata wywołania zwrotnego. Zobacz <xref:System.Net.Sockets.Socket.BeginReceive%2A> , aby dowiedzieć się, jak są otrzymywane pozostałe dane.  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Dla tej metody wymagany jest system Windows NT.</exception>
        <exception cref="T:System.InvalidOperationException">Gniazdo akceptujące nie nasłuchuje połączeń. Musisz wywołać metodę <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> i <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> przed wywołaniem metody <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
—lub— 
Zaakceptowane gniazdo jest powiązane.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" />jest mniejsza niż 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna asynchroniczne żądanie połączenia z hostem zdalnym.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> Reprezentuje hosta zdalnego.</param>
        <param name="end_point"><see cref="T:System.Net.EndPoint" /> Reprezentuje hosta zdalnego.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegat.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Rozpoczyna asynchroniczne żądanie połączenia z hostem zdalnym.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Odwołujący się do połączenia asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz protokołu zorientowanego na połączenie, <xref:System.Net.Sockets.Socket.BeginConnect%2A> Metoda uruchamia asynchroniczne żądanie dla połączenia `remoteEP` z parametrem. Jeśli używasz protokołu bezpołączeniowego, program <xref:System.Net.Sockets.Socket.BeginConnect%2A> ustanowi domyślnego hosta zdalnego. Połączenie lub ustawienie domyślnego hosta zdalnego asynchronicznie umożliwia wysyłanie i odbieranie danych w osobnym wątku wykonania.  
  
 Można utworzyć metodę wywołania zwrotnego implementującą <xref:System.AsyncCallback> delegata i przekazać jej nazwę <xref:System.Net.Sockets.Socket.BeginConnect%2A> do metody. W bardzo minimalnym czasie należy przekazać <xref:System.Net.Sockets.Socket> do <xref:System.Net.Sockets.Socket.BeginConnect%2A> za pomocą `state` parametru. Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małą klasę do przechowywania <xref:System.Net.Sockets.Socket>i innych wymaganych informacji. Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody `state` za pomocą parametru.  
  
 Metoda wywołania zwrotnego powinna wywołać <xref:System.Net.Sockets.Socket.EndConnect%2A> metodę. Gdy aplikacja jest wywoływana <xref:System.Net.Sockets.Socket.BeginConnect%2A>, system użyje oddzielnego wątku do wykonania określonej metody wywołania zwrotnego i <xref:System.Net.Sockets.Socket.EndConnect%2A> zablokuje się do momentu <xref:System.Net.Sockets.Socket> pomyślnego nawiązania połączenia lub wyrzuca wyjątek. Jeśli chcesz, aby oryginalny wątek blokował po wywołaniu <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody, użyj. <xref:System.Threading.WaitHandle.WaitOne%2A> Wywołaj metodę <xref:System.Threading.ManualResetEvent> Set w metodzie wywołania zwrotnego, jeśli chcesz, aby oryginalny wątek kontynuował wykonywanie. Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego [, zobacz kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Jeśli używasz protokołu bezpołączeniowego, takiego jak UDP, nie musisz wywoływać <xref:System.Net.Sockets.Socket.BeginConnect%2A> przed wysłaniem i odebraniem danych. Za pomocą <xref:System.Net.Sockets.Socket.BeginSendTo%2A> programu i <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> można komunikować się z hostem zdalnym. Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.BeginConnect%2A>, wszelkie datagramy, które dotarły do adresu innego niż określona wartość domyślna zostaną odrzucone. Jeśli chcesz ustawić domyślny host zdalny na adres emisji, musisz najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> i ustawić emisję do. `true` Jeśli nie jest to <xref:System.Net.Sockets.Socket.BeginConnect%2A> możliwe, program <xref:System.Net.Sockets.SocketException>zgłosi.  
  
 Jeśli używasz protokołu zorientowanego na połączenia i nie wywołuj <xref:System.Net.Sockets.Socket.Bind%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.BeginConnect%2A>, Dostawca usługi bazowej przypisze najbardziej odpowiedni lokalny adres sieciowy i numer portu. Jeśli używasz bezpołączeniowego protokołu, dostawca usług nie przypisze lokalnego adresu sieciowego i numeru portu do momentu wywołania <xref:System.Net.Sockets.Socket.BeginSend%2A> metody lub. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Jeśli chcesz zmienić domyślnego hosta zdalnego, wywołaj <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodę ponownie z żądanym punktem końcowym.  
  
 Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody, <xref:System.Net.Sockets.Socket>Zamknij. Gdy metoda jest wywoływana w trakcie trwającej operacji asynchronicznej, wywołanie zwrotne dostarczone <xref:System.Net.Sockets.Socket.BeginConnect%2A> do metody jest wywoływana. <xref:System.Net.Sockets.Socket.Close%2A>  Kolejne wywołanie <xref:System.Net.Sockets.Socket.EndConnect%2A> metody spowoduje <xref:System.ObjectDisposedException> zgłoszenie do wskazania, że operacja została anulowana.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Jeśli gniazdo zostało wcześniej odłączone, <xref:System.Net.Sockets.Socket.BeginConnect%2A> należy wywołać go w wątku, który nie zostanie zakończony do momentu zakończenia operacji. Jest to ograniczenie podstawowego dostawcy.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> . Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu inicjuje próbę połączenia asynchronicznego.  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący znajdujący się wyżej w stosie wywołań nie ma uprawnienia do żądanej operacji.</exception>
        <exception cref="T:System.InvalidOperationException">Został umieszczony w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />lub asynchroniczna operacja jest już w toku. <see cref="T:System.Net.Sockets.Socket" /></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><see cref="T:System.Net.IPAddress" /> Hosta zdalnego.</param>
        <param name="port">Numer portu hosta zdalnego.</param>
        <param name="requestCallback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po ukończeniu operacji łączenia.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po ukończeniu operacji łączenia.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji łączenia. Ten obiekt jest przesyłany do <paramref name="requestCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Rozpoczyna asynchroniczne żądanie połączenia z hostem zdalnym. Host jest określony przez <see cref="T:System.Net.IPAddress" /> i numer portu.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Odwołujący się do połączenia asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacja asynchroniczna <xref:System.Net.Sockets.Socket.BeginConnect%2A> musi być zakończona przez <xref:System.Net.Sockets.Socket.EndConnect%2A> wywołanie metody. Zazwyczaj Metoda jest wywoływana przez `requestCallback` delegata.  
  
 Ta metoda nie jest blokowana do momentu ukończenia operacji. Aby zablokować do momentu ukończenia operacji, użyj jednego z <xref:System.Net.Sockets.Socket.Connect%2A> przeciążeń metody lub. <xref:System.Net.Sockets.Socket.EndConnect%2A>  
  
 Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody, <xref:System.Net.Sockets.Socket>Zamknij. Gdy metoda jest wywoływana w trakcie trwającej operacji asynchronicznej, wywołanie zwrotne dostarczone <xref:System.Net.Sockets.Socket.BeginConnect%2A> do metody jest wywoływana. <xref:System.Net.Sockets.Socket.Close%2A>  Kolejne wywołanie <xref:System.Net.Sockets.Socket.EndConnect%2A> metody spowoduje <xref:System.ObjectDisposedException> zgłoszenie do wskazania, że operacja została anulowana.  
  
 Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [wywoływanie metod synchronicznych asynchronicznie](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Jeśli gniazdo zostało wcześniej odłączone, <xref:System.Net.Sockets.Socket.BeginConnect%2A> należy wywołać go w wątku, który nie zostanie zakończony do momentu zakończenia operacji. Jest to ograniczenie podstawowego dostawcy. <xref:System.Net.EndPoint> Również, który jest używany, musi być inny.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> . Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu inicjuje próbę połączenia asynchronicznego.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Nie <see cref="T:System.Net.Sockets.Socket" /> znajduje się w rodzinie gniazd.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentException">Długość <paramref name="address" /> wynosi zero.</exception>
        <exception cref="T:System.InvalidOperationException">Został umieszczony w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />lub asynchroniczna operacja jest już w toku. <see cref="T:System.Net.Sockets.Socket" /></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="addresses">Co najmniej jeden <see cref="T:System.Net.IPAddress" />, wyznaczający hosta zdalnego.</param>
        <param name="port">Numer portu hosta zdalnego.</param>
        <param name="requestCallback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po ukończeniu operacji łączenia.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po ukończeniu operacji łączenia.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji łączenia. Ten obiekt jest przesyłany do <paramref name="requestCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Rozpoczyna asynchroniczne żądanie połączenia z hostem zdalnym. Host jest określony przez <see cref="T:System.Net.IPAddress" /> tablicę i numer portu.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Odwołujący się do połączeń asynchronicznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacja asynchroniczna <xref:System.Net.Sockets.Socket.BeginConnect%2A> musi być zakończona przez <xref:System.Net.Sockets.Socket.EndConnect%2A> wywołanie metody. Zazwyczaj Metoda jest wywoływana przez `requestCallback` delegata.  
  
 Ta metoda nie jest blokowana do momentu ukończenia operacji. Aby zablokować do momentu ukończenia operacji, użyj jednego z <xref:System.Net.Sockets.Socket.Connect%2A> przeciążeń metody.  
  
 Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody, <xref:System.Net.Sockets.Socket>Zamknij. Gdy metoda jest wywoływana w trakcie trwającej operacji asynchronicznej, wywołanie zwrotne dostarczone <xref:System.Net.Sockets.Socket.BeginConnect%2A> do metody jest wywoływana. <xref:System.Net.Sockets.Socket.Close%2A>  Kolejne wywołanie <xref:System.Net.Sockets.Socket.EndConnect%2A> metody spowoduje <xref:System.ObjectDisposedException> zgłoszenie do wskazania, że operacja została anulowana.  
  
 Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [Asynchroniczne wywoływanie metod synchronicznych](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Jeśli gniazdo zostało wcześniej odłączone, <xref:System.Net.Sockets.Socket.BeginConnect%2A> należy wywołać go w wątku, który nie zostanie zakończony do momentu zakończenia operacji. Jest to ograniczenie podstawowego dostawcy. <xref:System.Net.EndPoint> Również, który jest używany, musi być inny.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> . Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu inicjuje próbę połączenia asynchronicznego.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda jest prawidłowa dla gniazd korzystających <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> z <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />lub.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentException">Długość <paramref name="address" /> wynosi zero.</exception>
        <exception cref="T:System.InvalidOperationException">Został umieszczony w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />lub asynchroniczna operacja jest już w toku. <see cref="T:System.Net.Sockets.Socket" /></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="host">Nazwa hosta zdalnego.</param>
        <param name="port">Numer portu hosta zdalnego.</param>
        <param name="requestCallback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po ukończeniu operacji łączenia.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po ukończeniu operacji łączenia.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji łączenia. Ten obiekt jest przesyłany do <paramref name="requestCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Rozpoczyna asynchroniczne żądanie połączenia z hostem zdalnym. Host jest określony przez nazwę hosta i numer portu.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Odwołujący się do połączenia asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacja asynchroniczna <xref:System.Net.Sockets.Socket.BeginConnect%2A> musi być zakończona przez <xref:System.Net.Sockets.Socket.EndConnect%2A> wywołanie metody. Zazwyczaj Metoda jest wywoływana przez `requestCallback` delegata.  
  
 Ta metoda nie jest blokowana do momentu ukończenia operacji. Aby zablokować do momentu ukończenia operacji, użyj jednego z <xref:System.Net.Sockets.Socket.Connect%2A> przeciążeń metody.  
  
 Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody, <xref:System.Net.Sockets.Socket>Zamknij. Gdy metoda jest wywoływana w trakcie trwającej operacji asynchronicznej, wywołanie zwrotne dostarczone <xref:System.Net.Sockets.Socket.BeginConnect%2A> do metody jest wywoływana. <xref:System.Net.Sockets.Socket.Close%2A>  Kolejne wywołanie <xref:System.Net.Sockets.Socket.EndConnect%2A> metody spowoduje <xref:System.ObjectDisposedException> zgłoszenie do wskazania, że operacja została anulowana.  
  
 Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [wywoływanie metod synchronicznych asynchronicznie](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Jeśli gniazdo zostało wcześniej odłączone, <xref:System.Net.Sockets.Socket.BeginConnect%2A> należy wywołać go w wątku, który nie zostanie zakończony do momentu zakończenia operacji. Jest to ograniczenie podstawowego dostawcy. <xref:System.Net.EndPoint> Również, który jest używany, musi być inny.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> . Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu inicjuje próbę połączenia asynchronicznego.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda jest prawidłowa dla gniazd w <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> w rodzinach.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Został umieszczony w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />lub asynchroniczna operacja jest już w toku. <see cref="T:System.Net.Sockets.Socket" /></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="reuseSocket"><see langword="true" />Jeśli tego gniazda można użyć ponownie po zamknięciu połączenia; w przeciwnym razie. <see langword="false" /></param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegat.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Rozpoczyna asynchroniczne żądanie rozłączenia ze zdalnego punktu końcowego.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt, który odwołuje się do operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz protokołu zorientowanego na połączenie, możesz wywołać <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> metodę, aby zażądać rozłączenia ze zdalnego punktu końcowego. Jeśli `reuseSocket` jest`true`, możesz ponownie użyć gniazda.  
  
 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> Metoda używa oddzielnego wątku do wywołania określonej metody wywołania zwrotnego. <xref:System.Net.Sockets.Socket.EndDisconnect%2A> Metoda blokuje się do momentu ukończenia oczekującego rozłączenia. Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego, zobacz [kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Jeśli wystąpi <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> wyjątek, użyj właściwości, aby uzyskać określony kod błędu. <xref:System.Net.Sockets.SocketException> Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy gniazdo do komunikacji asynchronicznej i wysyła niektóre dane do hosta zdalnego. Po wysłaniu dane są wywoływane, <xref:System.Net.Sockets.Socket.Shutdown%2A> aby zatrzymać działanie wysyłania i odbierania. Następnie <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> jest wywoływana w celu rozpoczęcia żądania rozłączenia. Po zakończeniu żądania <xref:System.Net.Sockets.Socket.Connected%2A> właściwość zostanie zbadana, aby sprawdzić, czy gniazdo jest odłączone.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">System operacyjny to Windows 2000 lub starszy, a ta metoda wymaga systemu Windows XP.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna asynchroniczne odbieranie danych z połączonej <see cref="T:System.Net.Sockets.Socket" />usługi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegat, który odwołuje się do metody do wywołania po zakończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji odbierania. Ten obiekt jest przesyłany do <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegata po zakończeniu operacji.</param>
        <summary>Rozpoczyna asynchroniczne odbieranie danych z połączonej <see cref="T:System.Net.Sockets.Socket" />usługi.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Odwołuje się do odczytu asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacja asynchroniczna <xref:System.Net.Sockets.Socket.BeginReceive%2A> musi być zakończona przez <xref:System.Net.Sockets.Socket.EndReceive%2A> wywołanie metody. Zazwyczaj Metoda jest wywoływana przez `callback` delegata.  
  
 Ta metoda nie jest blokowana do momentu ukończenia operacji. Aby zablokować do momentu ukończenia operacji, użyj jednego z <xref:System.Net.Sockets.Socket.Receive%2A> przeciążeń metody.  
  
 Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceive%2A>, <xref:System.Net.Sockets.Socket.Close%2A> Wywołaj metodę.  
  
 Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [Asynchroniczne wywoływanie metod synchronicznych](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Wszystkie we/wy zainicjowane przez dany wątek zostało anulowane po zakończeniu tego wątku. Oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek zostanie zakończony przed ukończeniem operacji.  
  
> [!NOTE]
>  `state`jest wystąpieniem klasy zdefiniowanej przez użytkownika.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> . Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="errorCode"><see cref="T:System.Net.Sockets.SocketError" /> Obiekt, który przechowuje błąd gniazda.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegat, który odwołuje się do metody do wywołania po zakończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji odbierania. Ten obiekt jest przesyłany do <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegata po zakończeniu operacji.</param>
        <summary>Rozpoczyna asynchroniczne odbieranie danych z połączonej <see cref="T:System.Net.Sockets.Socket" />usługi.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Odwołuje się do odczytu asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacja asynchroniczna <xref:System.Net.Sockets.Socket.BeginReceive%2A> musi być zakończona przez <xref:System.Net.Sockets.Socket.EndReceive%2A> wywołanie metody. Zazwyczaj Metoda jest wywoływana przez `callback` delegata.  
  
 Ta metoda nie jest blokowana do momentu ukończenia operacji. Aby zablokować do momentu ukończenia operacji, użyj jednego z <xref:System.Net.Sockets.Socket.Receive%2A> przeciążeń metody.  
  
 Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceive%2A>, <xref:System.Net.Sockets.Socket.Close%2A> Wywołaj metodę.  
  
 Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [Asynchroniczne wywoływanie metod synchronicznych](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Wszystkie we/wy zainicjowane przez dany wątek zostało anulowane po zakończeniu tego wątku. Oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek zostanie zakończony przed ukończeniem operacji.  
  
> [!NOTE]
>  `state`jest wystąpieniem klasy zdefiniowanej przez użytkownika.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> . Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</param>
        <param name="offset">Pozycja od zera w <paramref name="buffer" /> parametrze, w którym mają być przechowywane odebrane dane.</param>
        <param name="size">Liczba bajtów do odebrania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="socket_flags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegat, który odwołuje się do metody do wywołania po zakończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji odbierania. Ten obiekt jest przesyłany do <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegata po zakończeniu operacji.</param>
        <summary>Rozpoczyna asynchroniczne odbieranie danych z połączonej <see cref="T:System.Net.Sockets.Socket" />usługi.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Odwołuje się do odczytu asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacja asynchroniczna <xref:System.Net.Sockets.Socket.BeginReceive%2A> musi być zakończona przez <xref:System.Net.Sockets.Socket.EndReceive%2A> wywołanie metody. Zazwyczaj Metoda jest wywoływana przez `callback` delegata.  
  
 Ta metoda nie jest blokowana do momentu ukończenia operacji. Aby zablokować do momentu ukończenia operacji, użyj jednego z <xref:System.Net.Sockets.Socket.Receive%2A> przeciążeń metody.  
  
 Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceive%2A>, <xref:System.Net.Sockets.Socket.Close%2A> Wywołaj metodę.  
  
 Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [Asynchroniczne wywoływanie metod synchronicznych](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Wszystkie we/wy zainicjowane przez dany wątek zostało anulowane po zakończeniu tego wątku. Oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek zostanie zakończony przed ukończeniem operacji.  
  
> [!NOTE]
>  `state`jest wystąpieniem klasy zdefiniowanej przez użytkownika.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> . Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu rozpoczyna asynchroniczne odbieranie danych z połączenia <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />został zamknięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" />jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości <paramref name="offset" /> parametru.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</param>
        <param name="offset">Lokalizacja w programie <paramref name="buffer" /> do przechowywania odebranych danych.</param>
        <param name="size">Liczba bajtów do odebrania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="flags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="errorCode"><see cref="T:System.Net.Sockets.SocketError" /> Obiekt, który przechowuje błąd gniazda.</param>
        <param name="error"><see cref="T:System.Net.Sockets.SocketError" /> Obiekt, który przechowuje błąd gniazda.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegat, który odwołuje się do metody do wywołania po zakończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji odbierania. Ten obiekt jest przesyłany do <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegata po zakończeniu operacji.</param>
        <summary>Rozpoczyna asynchroniczne odbieranie danych z połączonej <see cref="T:System.Net.Sockets.Socket" />usługi.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Odwołuje się do odczytu asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacja asynchroniczna <xref:System.Net.Sockets.Socket.BeginReceive%2A> musi być zakończona przez <xref:System.Net.Sockets.Socket.EndReceive%2A> wywołanie metody. Zazwyczaj Metoda jest wywoływana przez `callback` delegata.  
  
 Ta metoda nie jest blokowana do momentu ukończenia operacji. Aby zablokować do momentu ukończenia operacji, użyj jednego z <xref:System.Net.Sockets.Socket.Receive%2A> przeciążeń metody.  
  
 Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceive%2A>, <xref:System.Net.Sockets.Socket.Close%2A> Wywołaj metodę.  
  
 Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [Asynchroniczne wywoływanie metod synchronicznych](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Wszystkie we/wy zainicjowane przez dany wątek zostało anulowane po zakończeniu tego wątku. Oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek zostanie zakończony przed ukończeniem operacji.  
  
> [!NOTE]
>  `state`jest wystąpieniem klasy zdefiniowanej przez użytkownika.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> . Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />został zamknięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" />jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości <paramref name="offset" /> parametru.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</param>
        <param name="offset">Pozycja od zera w <paramref name="buffer" /> parametrze, w którym mają być przechowywane dane.</param>
        <param name="size">Liczba bajtów do odebrania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="socket_flags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> Reprezentuje źródło danych.</param>
        <param name="remote_end"><see cref="T:System.Net.EndPoint" /> Reprezentuje źródło danych.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegat.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Rozpoczyna asynchroniczne odbieranie danych z określonego urządzenia sieciowego.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Odwołuje się do odczytu asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Metoda uruchamia asynchroniczne odczytywanie bezpołączeniowych datagramów z hosta zdalnego. <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Wywołanie metody daje możliwość odbierania danych w osobnym wątku wykonania.  
  
 Można utworzyć metodę wywołania zwrotnego implementującą <xref:System.AsyncCallback> delegata i przekazać jej nazwę <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> do metody. Aby to zrobić, w bardzo minimalnym `state` czasie parametr musi zawierać połączony lub domyślny <xref:System.Net.Sockets.Socket> używany do komunikacji. Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małą klasę do przechowywania <xref:System.Net.Sockets.Socket> i innych wymaganych informacji. Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody `state` za pomocą parametru.  
  
 Metoda wywołania zwrotnego powinna wywołać <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> metodę. Gdy aplikacja jest wywoływana <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, system użyje oddzielnego wątku do wykonania określonej metody wywołania zwrotnego i będzie <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> blokować się do momentu, <xref:System.Net.Sockets.Socket> aż odczytuje dane lub zgłosi wyjątek. Jeśli chcesz, aby oryginalny wątek blokował po wywołaniu <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody, użyj. <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Wywołaj metodę Set na T:System.Threading.ManualResetEvent w metodzie wywołania zwrotnego, jeśli chcesz, aby oryginalny wątek kontynuował wykonywanie. Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego, zobacz [kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Przed <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>wywołaniem należy jawnie <xref:System.Net.Sockets.Socket.Bind%2A> <xref:System.Net.Sockets.Socket> powiązać z lokalnym punktem końcowym za pomocą metody lub <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> zgłosić <xref:System.Net.Sockets.SocketException>.  
  
 Ta metoda odczytuje dane do `buffer` parametru i przechwytuje punkt końcowy hosta zdalnego, z którego są wysyłane dane. Aby uzyskać informacje na temat pobierania tego punktu końcowego, zapoznaj się z <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>tematem. Ta metoda jest najbardziej przydatna, jeśli zamierzasz asynchronicznie odbierać bezpołączeniowe datagramy z nieznanego hosta lub wielu hostów. W takich przypadkach <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> program odczyta pierwszy zakolejce datagram otrzymany do buforu sieci lokalnej. Jeśli odbierany datagram jest większy `buffer`niż rozmiar <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> , Metoda wypełni `buffer` tyle <xref:System.Net.Sockets.SocketException>wiadomości jak to możliwe, i wygeneruje. Jeśli korzystasz z wiarygodnego protokołu, nadmiarowe dane zostaną utracone. Jeśli używasz niezawodnego protokołu, nadwyżkowe dane będą przechowywane przez dostawcę usługi i można je pobrać, wywołując <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodę z wystarczającą ilością buforu.  
  
 Aby zagwarantować, że punkt końcowy hosta zdalnego jest zawsze zwracany, aplikacja powinna jawnie <xref:System.Net.Sockets.Socket> powiązać do lokalnego punktu końcowego <xref:System.Net.Sockets.Socket.Bind%2A> przy użyciu <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody, a następnie `optionLevel` wywołać metodę z parametrem ustawionym na <xref:System.Net.Sockets.SocketOptionLevel.IP> <xref:System.Net.Sockets.SocketOptionName.PacketInformation>lub `optionName` ,w`optionValue` zależności od tego, parametru, aby włączyć tę opcję przed wywołaniem <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody. <xref:System.Net.Sockets.SocketOptionLevel.IPv6> W przeciwnym razie możliwe jest, aby punkt końcowy hosta zdalnego nie był zwracany, gdy nadawca wysłał liczbę datagramów, zanim odbiornik wywołał <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodę.  
  
 Chociaż <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> jest przeznaczony dla protokołów bezpołączeniowych, można również użyć protokołu z zorientowanymi połączeniami. Jeśli zdecydujesz się to zrobić, musisz <xref:System.Net.Sockets.Socket.Connect%2A> najpierw nawiązać połączenie z hostem zdalnym, wywołując  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodę lub <xref:System.Net.Sockets.Socket.Accept%2A> akceptując żądanie połączenia przychodzącego przez wywołanie metody lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> . Jeśli wywołasz <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodę przed nawiązaniem lub zaakceptowaniem połączenia, <xref:System.Net.Sockets.SocketException>otrzymasz. Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody można również ustanowić domyślnego hosta zdalnego dla bezpołączeniowego protokołu. W każdym z tych przypadków <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Metoda `remoteEP` zignoruje parametr i będzie odbierać tylko dane z podłączonego lub domyślnego hosta zdalnego.  
  
 W przypadku gniazd zorientowanych na połączenia <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> program odczyta tyle danych, ile jest dostępnych do liczby bajtów określonej `size` przez parametr.  
  
 Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, <xref:System.Net.Sockets.Socket.Close%2A> Wywołaj metodę.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> . Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu asynchronicznie odbiera bezpołączeniowe datagramy z hosta zdalnego.  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="remoteEP" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" />jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący znajdujący się wyżej w stosie wywołań nie ma uprawnienia do żądanej operacji.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</param>
        <param name="offset">Pozycja od zera w <paramref name="buffer" /> parametrze, w którym mają być przechowywane dane.</param>
        <param name="size">Liczba bajtów do odebrania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> Reprezentuje źródło danych.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegat.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Rozpoczyna asynchroniczne odbieranie określonej liczby bajtów danych w określonej lokalizacji buforu danych przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />i przechowywanie informacji o punkcie końcowym i pakiecie.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Odwołuje się do odczytu asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczne odbieranie operacji musi zostać zakończone przez wywołanie <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> metody. Zazwyczaj Metoda jest wywoływana przez `asyncCallback` delegata.  
  
 Ta metoda nie jest blokowana do momentu zakończenia operacji. Aby zablokować do momentu zakończenia operacji, użyj <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metody.  
  
 Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, <xref:System.Net.Sockets.Socket.Close%2A> Wywołaj metodę.  
  
 Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [wywoływanie metod synchronicznych asynchronicznie](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Ta metoda odczytuje dane do `buffer` parametru i przechwytuje punkt końcowy hosta zdalnego, z którego są wysyłane dane, a także informacje o odebranym pakiecie. Aby uzyskać informacje na temat pobierania tego punktu końcowego, zapoznaj się z <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>tematem. Ta metoda jest najbardziej przydatna, jeśli zamierzasz asynchronicznie odbierać bezpołączeniowe datagramy z nieznanego hosta lub wielu hostów.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> . Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="remoteEP" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" />jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">System operacyjny to Windows 2000 lub starszy, a ta metoda wymaga systemu Windows XP.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wysyła dane asynchronicznie do połączonej <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegat.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Wysyła dane asynchronicznie do połączonej <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns><see cref="T:System.IAsyncResult" /> , Który odwołuje się do wysyłania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Accept%2A>Metoda uruchamia asynchroniczną operację wysyłania do hosta zdalnego, który został ustanowiony w metodzie,, lub. <xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.Socket.BeginSend%2A>zgłosi wyjątek, jeśli nie zostanie najpierw <xref:System.Net.Sockets.Socket.Accept%2A>wywołana, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. <xref:System.Net.Sockets.Socket.BeginSend%2A> Wywołanie metody daje możliwość wysyłania danych w osobnym wątku wykonania.  
  
 Można utworzyć metodę wywołania zwrotnego implementującą <xref:System.AsyncCallback> delegata i przekazać jej nazwę <xref:System.Net.Sockets.Socket.BeginSend%2A> do metody. Aby to zrobić, w bardzo minimalnym `state` czasie parametr musi zawierać połączony lub domyślny <xref:System.Net.Sockets.Socket> używany do komunikacji. Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małą klasę lub strukturę w celu przechowywania <xref:System.Net.Sockets.Socket> i innych wymaganych informacji. Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginSend%2A> metody `state` za pomocą parametru.  
  
 Metoda wywołania zwrotnego powinna wywołać <xref:System.Net.Sockets.Socket.EndSend%2A> metodę. Gdy aplikacja wywołuje <xref:System.Net.Sockets.Socket.BeginSend%2A>program, system użyje oddzielnego wątku do wykonania określonej metody wywołania zwrotnego i <xref:System.Net.Sockets.Socket.EndSend%2A> zablokuje się do momentu <xref:System.Net.Sockets.Socket> wysłania żądania, gdy liczba bajtów lub zgłosi wyjątek. Jeśli chcesz, aby oryginalny wątek blokował po wywołaniu <xref:System.Net.Sockets.Socket.BeginSend%2A> metody, <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Użyj metody. Wywołaj metodę Set na T:System.Threading.ManualResetEvent w metodzie wywołania zwrotnego, jeśli chcesz, aby oryginalny wątek kontynuował wykonywanie. Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego [, zobacz kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Chociaż przeznaczone dla protokołów zorientowanych na połączenia, <xref:System.Net.Sockets.Socket.BeginSend%2A> działa również dla protokołów bezpołączeniowych, pod warunkiem, <xref:System.Net.Sockets.Socket.Connect%2A> że <xref:System.Net.Sockets.Socket.BeginConnect%2A> najpierw wywołanie metody lub do ustanowienia domyślnego hosta zdalnego. Jeśli używasz bezpołączeniowego protokołu i planujesz wysyłać dane do kilku różnych hostów, użyj polecenia <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Nie można jej używać <xref:System.Net.Sockets.Socket.BeginSendTo%2A> nawet po ustanowieniu domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>programu. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSend%2A> , wykonując inne <xref:System.Net.Sockets.Socket.Connect%2A> wywołanie lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. W przypadku protokołów bez połączenia należy również upewnić się, że rozmiar buforu nie przekracza maksymalnego rozmiaru pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.  
  
 Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketflags` jako parametr, wysyłane dane nie będą kierowane.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Wszystkie we/wy zainicjowane przez dany wątek zostało anulowane po zakończeniu tego wątku. Oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek zostanie zakończony przed ukończeniem operacji.  
  
> [!NOTE]
>  `state`jest wystąpieniem klasy zdefiniowanej przez użytkownika.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie. Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> . Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" />jest puste.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="errorCode"><see cref="T:System.Net.Sockets.SocketError" /> Obiekt, który przechowuje błąd gniazda.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegat.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Wysyła dane asynchronicznie do połączonej <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns><see cref="T:System.IAsyncResult" /> , Który odwołuje się do wysyłania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Accept%2A>Metoda uruchamia asynchroniczną operację wysyłania do hosta zdalnego, który został ustanowiony w metodzie,, lub. <xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.Socket.BeginSend%2A>zgłosi wyjątek, jeśli nie zostanie najpierw <xref:System.Net.Sockets.Socket.Accept%2A>wywołana, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. <xref:System.Net.Sockets.Socket.BeginSend%2A> Wywołanie metody daje możliwość wysyłania danych w osobnym wątku wykonania.  
  
 Można utworzyć metodę wywołania zwrotnego implementującą <xref:System.AsyncCallback> delegata i przekazać jej nazwę <xref:System.Net.Sockets.Socket.BeginSend%2A> do metody. Aby to zrobić, w bardzo minimalnym `state` czasie parametr musi zawierać połączony lub domyślny <xref:System.Net.Sockets.Socket> używany do komunikacji. Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małą klasę lub strukturę w celu przechowywania <xref:System.Net.Sockets.Socket> i innych wymaganych informacji. Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginSend%2A> metody `state` za pomocą parametru.  
  
 Metoda wywołania zwrotnego powinna wywołać <xref:System.Net.Sockets.Socket.EndSend%2A> metodę. Gdy aplikacja wywołuje <xref:System.Net.Sockets.Socket.BeginSend%2A>program, system użyje oddzielnego wątku do wykonania określonej metody wywołania zwrotnego i <xref:System.Net.Sockets.Socket.EndSend%2A> zablokuje się do momentu <xref:System.Net.Sockets.Socket> wysłania żądania, gdy liczba bajtów lub zgłosi wyjątek. Jeśli chcesz, aby oryginalny wątek blokował po wywołaniu <xref:System.Net.Sockets.Socket.BeginSend%2A> metody, <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Użyj metody. Wywołaj metodę <xref:System.Threading.ManualResetEvent> Set w metodzie wywołania zwrotnego, jeśli chcesz, aby oryginalny wątek kontynuował wykonywanie. Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego [, zobacz kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Chociaż przeznaczone dla protokołów zorientowanych na połączenia, <xref:System.Net.Sockets.Socket.BeginSend%2A> działa również dla protokołów bezpołączeniowych, pod warunkiem, <xref:System.Net.Sockets.Socket.Connect%2A> że <xref:System.Net.Sockets.Socket.BeginConnect%2A> najpierw wywołanie metody lub do ustanowienia domyślnego hosta zdalnego. Jeśli używasz bezpołączeniowego protokołu i planujesz wysyłać dane do kilku różnych hostów, użyj polecenia <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Nie można jej używać <xref:System.Net.Sockets.Socket.BeginSendTo%2A> nawet po ustanowieniu domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>programu. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSend%2A> , wykonując inne <xref:System.Net.Sockets.Socket.Connect%2A> wywołanie lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. W przypadku protokołów bez połączenia należy również upewnić się, że rozmiar buforu nie przekracza maksymalnego rozmiaru pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.  
  
 Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketflags` jako parametr, wysyłane dane nie będą kierowane.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Wszystkie we/wy zainicjowane przez dany wątek zostało anulowane po zakończeniu tego wątku. Oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek zostanie zakończony przed ukończeniem operacji.  
  
> [!NOTE]
>  `state`jest wystąpieniem klasy zdefiniowanej przez użytkownika.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie. Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> . Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" />jest puste.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</param>
        <param name="offset">Pozycja od zera w <paramref name="buffer" /> parametrze, od którego należy rozpocząć wysyłanie danych.</param>
        <param name="size">Liczba bajtów do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="errorCode"><see cref="T:System.Net.Sockets.SocketError" /> Obiekt, który przechowuje błąd gniazda.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegat.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Wysyła dane asynchronicznie do połączonej <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns><see cref="T:System.IAsyncResult" /> , Który odwołuje się do wysyłania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Accept%2A>Metoda uruchamia asynchroniczną operację wysyłania do hosta zdalnego, który został ustanowiony w metodzie,, lub. <xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.Socket.BeginSend%2A>zgłosi wyjątek, jeśli nie zostanie najpierw <xref:System.Net.Sockets.Socket.Accept%2A>wywołana, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. <xref:System.Net.Sockets.Socket.BeginSend%2A> Wywołanie metody daje możliwość wysyłania danych w osobnym wątku wykonania.  
  
 Można utworzyć metodę wywołania zwrotnego implementującą <xref:System.AsyncCallback> delegata i przekazać jej nazwę <xref:System.Net.Sockets.Socket.BeginSend%2A> do metody. Aby to zrobić, w bardzo minimalnym `state` czasie parametr musi zawierać połączony lub domyślny <xref:System.Net.Sockets.Socket> używany do komunikacji. Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małą klasę lub strukturę w celu przechowywania <xref:System.Net.Sockets.Socket> i innych wymaganych informacji. Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginSend%2A> metody `state` za pomocą parametru.  
  
 Metoda wywołania zwrotnego powinna wywołać <xref:System.Net.Sockets.Socket.EndSend%2A> metodę. Gdy aplikacja wywołuje <xref:System.Net.Sockets.Socket.BeginSend%2A>program, system użyje oddzielnego wątku do wykonania określonej metody wywołania zwrotnego i <xref:System.Net.Sockets.Socket.EndSend%2A> zablokuje się do momentu <xref:System.Net.Sockets.Socket> wysłania żądania, gdy liczba bajtów lub zgłosi wyjątek. Jeśli chcesz, aby oryginalny wątek blokował po wywołaniu <xref:System.Net.Sockets.Socket.BeginSend%2A> metody, <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Użyj metody. Wywołaj metodę Set na T:System.Threading.ManualResetEvent w metodzie wywołania zwrotnego, jeśli chcesz, aby oryginalny wątek kontynuował wykonywanie. Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego [, zobacz kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Chociaż przeznaczone dla protokołów zorientowanych na połączenia, <xref:System.Net.Sockets.Socket.BeginSend%2A> działa również dla protokołów bezpołączeniowych, pod warunkiem, <xref:System.Net.Sockets.Socket.Connect%2A> że <xref:System.Net.Sockets.Socket.BeginConnect%2A> najpierw wywołanie metody lub do ustanowienia domyślnego hosta zdalnego. Jeśli używasz bezpołączeniowego protokołu i planujesz wysyłać dane do kilku różnych hostów, użyj polecenia <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Nie można jej używać <xref:System.Net.Sockets.Socket.BeginSendTo%2A> nawet po ustanowieniu domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>programu. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSend%2A> , wykonując inne <xref:System.Net.Sockets.Socket.Connect%2A> wywołanie lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. W przypadku protokołów bez połączenia należy również upewnić się, że rozmiar buforu nie przekracza maksymalnego rozmiaru pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.  
  
 Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketflags` jako parametr, wysyłane dane nie będą kierowane.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Wszystkie we/wy zainicjowane przez dany wątek zostało anulowane po zakończeniu tego wątku. Oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek zostanie zakończony przed ukończeniem operacji.  
  
> [!NOTE]
>  `state`jest wystąpieniem klasy zdefiniowanej przez użytkownika.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie. Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> . Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" />jest mniejsza niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</param>
        <param name="offset">Pozycja od zera w <paramref name="buffer" /> parametrze, od którego należy rozpocząć wysyłanie danych.</param>
        <param name="size">Liczba bajtów do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="socket_flags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegat.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Wysyła dane asynchronicznie do połączonej <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns><see cref="T:System.IAsyncResult" /> , Który odwołuje się do wysyłania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Accept%2A>Metoda uruchamia asynchroniczną operację wysyłania do hosta zdalnego, który został ustanowiony w metodzie,, lub. <xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.Socket.BeginSend%2A>zgłosi wyjątek, jeśli nie zostanie najpierw <xref:System.Net.Sockets.Socket.Accept%2A>wywołana, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. <xref:System.Net.Sockets.Socket.BeginSend%2A> Wywołanie metody daje możliwość wysyłania danych w osobnym wątku wykonania.  
  
 Można utworzyć metodę wywołania zwrotnego implementującą <xref:System.AsyncCallback> delegata i przekazać jej nazwę <xref:System.Net.Sockets.Socket.BeginSend%2A> do metody. Aby to zrobić, w bardzo minimalnym `state` czasie parametr musi zawierać połączony lub domyślny <xref:System.Net.Sockets.Socket> używany do komunikacji. Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małą klasę lub strukturę w celu przechowywania <xref:System.Net.Sockets.Socket> i innych wymaganych informacji. Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginSend%2A> metody `state` za pomocą parametru.  
  
 Metoda wywołania zwrotnego powinna wywołać <xref:System.Net.Sockets.Socket.EndSend%2A> metodę. Gdy aplikacja wywołuje <xref:System.Net.Sockets.Socket.BeginSend%2A>program, system użyje oddzielnego wątku do wykonania określonej metody wywołania zwrotnego i <xref:System.Net.Sockets.Socket.EndSend%2A> zablokuje się do momentu <xref:System.Net.Sockets.Socket> wysłania żądania, gdy liczba bajtów lub zgłosi wyjątek. Jeśli chcesz, aby oryginalny wątek blokował po wywołaniu <xref:System.Net.Sockets.Socket.BeginSend%2A> metody, <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Użyj metody. Wywołaj metodę Set na T:System.Threading.ManualResetEvent w metodzie wywołania zwrotnego, jeśli chcesz, aby oryginalny wątek kontynuował wykonywanie. Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego [, zobacz kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Chociaż przeznaczone dla protokołów zorientowanych na połączenia, <xref:System.Net.Sockets.Socket.BeginSend%2A> działa również dla protokołów bezpołączeniowych, pod warunkiem, <xref:System.Net.Sockets.Socket.Connect%2A> że <xref:System.Net.Sockets.Socket.BeginConnect%2A> najpierw wywołanie metody lub do ustanowienia domyślnego hosta zdalnego. Jeśli używasz bezpołączeniowego protokołu i planujesz wysyłać dane do kilku różnych hostów, użyj polecenia <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Nie można jej używać <xref:System.Net.Sockets.Socket.BeginSendTo%2A> nawet po ustanowieniu domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>programu. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSend%2A> , wykonując inne <xref:System.Net.Sockets.Socket.Connect%2A> wywołanie lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. W przypadku protokołów bez połączenia należy również upewnić się, że rozmiar buforu nie przekracza maksymalnego rozmiaru pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.  
  
 Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketflags` jako parametr, wysyłane dane nie będą kierowane.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Wszystkie we/wy zainicjowane przez dany wątek zostało anulowane po zakończeniu tego wątku. Oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek zostanie zakończony przed ukończeniem operacji.  
  
> [!NOTE]
>  `state`jest wystąpieniem klasy zdefiniowanej przez użytkownika.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie. Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> . Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu rozpoczyna asynchroniczne wysyłanie danych do hosta zdalnego.  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" />jest mniejsza niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wysyła plik asynchronicznie do połączonego <see cref="T:System.Net.Sockets.Socket" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Ciąg, który zawiera ścieżkę i nazwę pliku do wysłania. Ten parametr może być <see langword="null" />.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegat.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Wysyła plik <paramref name="fileName" /> do obiektu połączonego <see cref="T:System.Net.Sockets.Socket" /> przy użyciu <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> flagi.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt, który reprezentuje wysyłanie asynchroniczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie wysyła plik `fileName` do połączonego gniazda. Jeśli `fileName` znajduje się w katalogu lokalnym, może być identyfikowana przy użyciu tylko nazwy pliku; w przeciwnym razie należy określić pełną ścieżkę i nazwę pliku. Symbole wieloznaczne (".. \\\\\\\\obsługiwane są \myfile.txt ") i nazwy udziałów UNC (" \shared Directory \myfile.txt "). \\ Jeśli plik nie zostanie znaleziony, zostanie zgłoszony wyjątek <xref:System.IO.FileNotFoundException> .  
  
 Ta metoda używa `TransmitFile` funkcji znalezionej w interfejsie API Windows Sockets 2. Aby uzyskać więcej informacji na `TransmitFile` temat funkcji i jej flag, zobacz dokumentację usługi [Windows Sockets](/windows/desktop/WinSock/) .  
  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Accept%2A>Metoda uruchamia asynchroniczną operację wysyłania do hosta zdalnego ustanowionego w metodach,, lub. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> <xref:System.Net.Sockets.Socket.BeginSendFile%2A>zgłasza wyjątek, jeśli nie używasz pierwszego <xref:System.Net.Sockets.Socket.Accept%2A>wywołania, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Wywołanie metody umożliwia wysłanie pliku w osobnym wątku wykonania.  
  
 Aby ukończyć operację, można utworzyć metodę wywołania zwrotnego, która jest wywoływana przez <xref:System.AsyncCallback> parametr delegata. Aby to zrobić, w bardzo minimalnym `state` czasie parametr musi <xref:System.Net.Sockets.Socket> zawierać obiekt używany do komunikacji. Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć klasę lub strukturę do przechowywania <xref:System.Net.Sockets.Socket> i innych wymaganych informacji. Przekaż wystąpienie tego obiektu niestandardowego do <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metody `state` za pomocą parametru.  
  
 Metoda wywołania zwrotnego musi wywoływać <xref:System.Net.Sockets.Socket.EndSendFile%2A> metodę. Gdy aplikacja jest wywoływana <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, system używa oddzielnego wątku do wykonywania określonej metody wywołania zwrotnego i <xref:System.Net.Sockets.Socket.EndSendFile%2A> blokuje się do momentu <xref:System.Net.Sockets.Socket> wysłania całego pliku lub wyrzuca wyjątek. Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego [, zobacz kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Chociaż przeznaczone dla protokołów zorientowanych na połączenia, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> działa również dla protokołów bezpołączeniowych, pod warunkiem, <xref:System.Net.Sockets.Socket.Connect%2A> że <xref:System.Net.Sockets.Socket.BeginConnect%2A> najpierw wywołanie metody lub do ustanowienia domyślnego hosta zdalnego. W przypadku protokołów bez połączenia należy upewnić się, że rozmiar pliku nie przekracza maksymalnego rozmiaru pakietu dostawcy usługi. Jeśli tak, datagram nie jest wysyłany i <xref:System.Net.Sockets.Socket.BeginSendFile%2A> <xref:System.Net.Sockets.SocketException> zgłasza wyjątek.  
  
> [!NOTE]
>  Jeśli wystąpi <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> wyjątek, użyj właściwości, aby uzyskać określony kod błędu. <xref:System.Net.Sockets.SocketException> Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> . Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy i łączy gniazdo do komunikacji asynchronicznej. Najpierw plik "text. txt" jest wysyłany asynchronicznie do hosta zdalnego. Delegat wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndSendFile%2A> do ukończenia transmisji.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Gniazdo nie jest połączone z hostem zdalnym.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono <paramref name="fileName" /> pliku.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Ciąg, który zawiera ścieżkę i nazwę pliku do wysłania. Ten parametr może być <see langword="null" />.</param>
        <param name="preBuffer"><see cref="T:System.Byte" /> Tablica zawierająca dane, które mają zostać wysłane przed wysłaniem pliku. Ten parametr może być <see langword="null" />.</param>
        <param name="postBuffer"><see cref="T:System.Byte" /> Tablica zawierająca dane, które mają zostać wysłane po wysłaniu pliku. Ten parametr może być <see langword="null" />.</param>
        <param name="flags">Bitowa kombinacja <see cref="T:System.Net.Sockets.TransmitFileOptions" /> wartości.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegat do wywołania po zakończeniu tej operacji. Ten parametr może być <see langword="null" />.</param>
        <param name="state">Zdefiniowany przez użytkownika obiekt zawierający informacje o stanie dla tego żądania. Ten parametr może być <see langword="null" />.</param>
        <summary>Wysyła plik i bufory danych asynchronicznie do połączonego <see cref="T:System.Net.Sockets.Socket" /> obiektu.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt, który reprezentuje operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie wymaga nazwy pliku, który chcesz wysłać, oraz bitowej kombinacji <xref:System.Net.Sockets.TransmitFileOptions> wartości. `preBuffer` Parametr zawiera wszystkie dane, które mają poprzedzać plik. `postBuffer`zawiera dane, które mają być zgodne z plikiem. Jeśli `fileName` znajduje się w katalogu lokalnym, może być identyfikowana przy użyciu tylko nazwy pliku; w przeciwnym razie należy określić pełną ścieżkę i nazwę pliku. Symbole wieloznaczne (".. \\\\\\\\obsługiwane są \myfile.txt ") i nazwy udziałów UNC (" \shared Directory \myfile.txt "). \\ Jeśli plik nie zostanie znaleziony, zostanie zgłoszony wyjątek <xref:System.IO.FileNotFoundException> .  
  
 `flags` Parametr udostępnia dostawcy usługi okna Sockets z dodatkowymi informacjami na temat transferu plików. Aby uzyskać więcej informacji na temat korzystania z tego parametru, <xref:System.Net.Sockets.TransmitFileOptions>Zobacz.  
  
 Ta metoda używa `TransmitFile` funkcji znalezionej w interfejsie API Windows Sockets 2. Aby uzyskać więcej informacji na `TransmitFile` temat funkcji i jej flag, zobacz dokumentację usługi [Windows Sockets](/windows/desktop/WinSock/) .  
  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Accept%2A>Metoda uruchamia asynchroniczną operację wysyłania do hosta zdalnego ustanowionego w metodach,, lub. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> <xref:System.Net.Sockets.Socket.BeginSendFile%2A>zgłasza wyjątek, jeśli nie używasz pierwszego <xref:System.Net.Sockets.Socket.Accept%2A>wywołania, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Wywołanie metody daje możliwość wysyłania pliku w osobnym wątku wykonania.  
  
 Aby ukończyć operację, można utworzyć metodę wywołania zwrotnego, która jest wywoływana przez <xref:System.AsyncCallback> parametr delegata. Aby to zrobić, w bardzo minimalnym `state` czasie parametr musi <xref:System.Net.Sockets.Socket> zawierać obiekt używany do komunikacji. Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć klasę lub strukturę do przechowywania <xref:System.Net.Sockets.Socket> i innych wymaganych informacji. Przekaż wystąpienie tego obiektu niestandardowego do <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metody `state` za pomocą parametru.  
  
 Metoda wywołania zwrotnego musi wywoływać <xref:System.Net.Sockets.Socket.EndSendFile%2A> metodę. Gdy aplikacja jest wywoływana <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, system używa oddzielnego wątku do wykonywania określonej metody wywołania zwrotnego i <xref:System.Net.Sockets.Socket.EndSendFile%2A> blokuje się do momentu <xref:System.Net.Sockets.Socket> wysłania całego pliku lub wyrzuca wyjątek. Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego [, zobacz kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Chociaż przeznaczone dla protokołów zorientowanych na połączenia, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> działa również dla protokołów bezpołączeniowych, pod warunkiem, <xref:System.Net.Sockets.Socket.Connect%2A> że <xref:System.Net.Sockets.Socket.BeginConnect%2A> najpierw wywołanie metody lub do ustanowienia domyślnego hosta zdalnego. W przypadku protokołów bez połączenia należy również upewnić się, że rozmiar pliku nie przekracza maksymalnego rozmiaru pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie jest wysyłany i <xref:System.Net.Sockets.Socket.BeginSendFile%2A> <xref:System.Net.Sockets.SocketException> zgłasza wyjątek.  
  
> [!NOTE]
>  Jeśli wystąpi <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> wyjątek, użyj właściwości, aby uzyskać określony kod błędu. <xref:System.Net.Sockets.SocketException> Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> . Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy i łączy gniazdo do komunikacji asynchronicznej i zaczyna wysyłać plik "text. txt" asynchronicznie do hosta zdalnego. W tym przykładzie `preBuffer` jest tworzone `postBuffer` i a danych do wysłania z plikiem, a wartość domyślna <xref:System.Net.Sockets.TransmitFileOptions> jest używana. Delegat wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndSendFile%2A> do ukończenia transmisji.  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej.</exception>
        <exception cref="T:System.NotSupportedException">System operacyjny nie jest systemem Windows NT lub nowszym.  
  
—lub—
  
 Gniazdo nie jest połączone z hostem zdalnym.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono <paramref name="fileName" /> pliku.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</param>
        <param name="offset">Pozycja od zera, w <paramref name="buffer" /> której rozpoczyna się wysyłanie danych.</param>
        <param name="size">Liczba bajtów do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="socket_flags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> Reprezentuje urządzenie zdalne.</param>
        <param name="remote_end"><see cref="T:System.Net.EndPoint" /> Reprezentuje urządzenie zdalne.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> Delegat.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Wysyła dane asynchronicznie do określonego hosta zdalnego.</summary>
        <returns><see cref="T:System.IAsyncResult" /> , Który odwołuje się do wysyłania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda uruchamia asynchroniczną operację wysyłania do hosta zdalnego określonego `remoteEP` w parametrze. <xref:System.Net.Sockets.Socket.BeginSendTo%2A> <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Wywołanie metody daje możliwość wysyłania danych w osobnym wątku wykonania. Chociaż przeznaczone dla protokołów bezpołączeniowych, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> działa z protokołami bezpołączeniowymi i zorientowanymi na połączenia.  
  
 Można utworzyć metodę wywołania zwrotnego implementującą <xref:System.AsyncCallback> delegata i przekazać jej nazwę <xref:System.Net.Sockets.Socket.BeginSendTo%2A> do metody. Aby to zrobić, w bardzo minimalnym `state` czasie parametr musi zawierać połączony lub domyślny <xref:System.Net.Sockets.Socket> używany do komunikacji. Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małą klasę do przechowywania <xref:System.Net.Sockets.Socket>i innych wymaganych informacji. Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metody `state` za pomocą parametru.  
  
 Metoda wywołania zwrotnego powinna wywołać <xref:System.Net.Sockets.Socket.EndSendTo%2A> metodę. Gdy aplikacja wywołuje <xref:System.Net.Sockets.Socket.BeginSendTo%2A>program, system użyje oddzielnego wątku do wykonania określonej metody wywołania zwrotnego i <xref:System.Net.Sockets.Socket.EndSendTo%2A> zablokuje się do momentu <xref:System.Net.Sockets.Socket> wysłania żądania, gdy liczba bajtów lub zgłosi wyjątek. Jeśli chcesz, aby oryginalny wątek blokował po wywołaniu <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metody, <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Użyj metody. Wywołaj metodę Set na T:System.Threading.ManualResetEvent w metodzie wywołania zwrotnego, jeśli chcesz, aby oryginalny wątek kontynuował wykonywanie. Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego [, zobacz kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 W przypadku korzystania z protokołu zorientowanego na połączenia należy najpierw wywołać <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>metodę,, <xref:System.Net.Sockets.SocketException> <xref:System.Net.Sockets.Socket.Accept%2A>, lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> , lub <xref:System.Net.Sockets.Socket.BeginSendTo%2A> zgłosić. <xref:System.Net.Sockets.Socket.BeginSendTo%2A>program zignoruje `remoteEP` parametr i wyśle dane <xref:System.Net.EndPoint> do ustalonej <xref:System.Net.Sockets.Socket.Connect%2A>metody, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> .  
  
 Jeśli używasz bezpołączeniowego protokołu, nie musisz nawiązać domyślnego hosta zdalnego z <xref:System.Net.Sockets.Socket.Connect%2A> metodą lub <xref:System.Net.Sockets.Socket.BeginConnect%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>. Wystarczy wykonać tę czynność tylko wtedy, gdy zamierzasz wywołać <xref:System.Net.Sockets.Socket.BeginSend%2A> metodę. Jeśli wywołaniu <xref:System.Net.Sockets.Socket.Connect%2A> metody lub <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.SendTo%2A>przed wywołaniem, parametrzastąpiokreślonydomyślnyhostzdalnydlatejoperacjiwysyłania.`remoteEP` Nie jest również wymagane wywoływanie <xref:System.Net.Sockets.Socket.Bind%2A> metody. W takim przypadku Dostawca usługi podstawowej będzie przypisywać najbardziej odpowiedni lokalny adres sieciowy i numer portu. Użyj numeru portu równego zero, jeśli chcesz, aby Dostawca usługi podstawowej wybierał bezpłatny port. Jeśli trzeba zidentyfikować przypisany adres sieci lokalnej i numer portu, można użyć <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwości <xref:System.Net.Sockets.Socket.EndSendTo%2A> po pomyślnym ukończeniu metody.  
  
 Jeśli chcesz wysłać dane do adresu emisji, musisz najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodę i ustawić opcję gniazda na. <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> — Należy również upewnić się, że rozmiar buforu nie przekracza maksymalnego rozmiaru pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.EndSendTo%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.  
  
 Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketflags` jako parametr, wysyłane dane nie będą kierowane.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> . Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu asynchronicznie wysyła dane do określonego hosta zdalnego.  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="remoteEP" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" />jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący znajdujący się wyżej w stosie wywołań nie ma uprawnienia do żądanej operacji.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">Lokalna <see cref="T:System.Net.EndPoint" /> do skojarzenia <see cref="T:System.Net.Sockets.Socket" />z.</param>
        <summary>Kojarzy <see cref="T:System.Net.Sockets.Socket" /> a z lokalnym punktem końcowym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj metody <xref:System.Net.Sockets.Socket.Bind%2A> , jeśli musisz użyć określonego lokalnego punktu końcowego. Musisz wywołać <xref:System.Net.Sockets.Socket.Bind%2A> , <xref:System.Net.Sockets.Socket.Listen%2A> aby można było wywołać metodę. Nie trzeba wywoływać <xref:System.Net.Sockets.Socket.Bind%2A> przed użyciem metody, <xref:System.Net.Sockets.Socket.Connect%2A> chyba że trzeba użyć określonego lokalnego punktu końcowego. <xref:System.Net.Sockets.Socket.Bind%2A> Metody można użyć zarówno w przypadku połączeń bezpołączeniowych, jak i dla protokołów zorientowanych na połączenia.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.Bind%2A>należy najpierw utworzyć lokalne <xref:System.Net.IPEndPoint> , z którego mają być przekazywane dane. Jeśli nie wiesz, który adres lokalny jest przypisany, możesz utworzyć <xref:System.Net.IPEndPoint> parametr używany <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> jako adres, a usługodawca źródłowy przypisze najbardziej odpowiedni adres sieciowy. Może to pomóc uprościć aplikację, jeśli masz wiele interfejsów sieciowych. Jeśli nie wiesz, który port lokalny jest używany, możesz utworzyć <xref:System.Net.IPEndPoint> numer portu za pomocą wartości 0. W takim przypadku dostawca usług przypisze dostępny numer portu z zakresu od 1024 do 5000.  
  
 W przypadku korzystania z powyższego podejścia można ustalić, który adres sieci lokalnej i numer portu zostały przypisane przez wywołanie <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>. W przypadku korzystania z protokołu <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> zorientowanego na połączenia program nie zwróci lokalnie przypisanego adresu sieciowego do momentu wywołania <xref:System.Net.Sockets.Socket.Connect%2A> metody lub <xref:System.Net.Sockets.Socket.EndConnect%2A> . Jeśli używasz bezpołączeniowego protokołu, nie będziesz mieć dostępu do tych informacji, dopóki nie zakończy się wysyłanie ani odbieranie.  
  
 Jeśli gniazdo UDP chce otrzymywać informacje o interfejsie dla odebranych pakietów, <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Metoda powinna być jawnie wywołana z opcją gniazda ustawioną na <xref:System.Net.Sockets.SocketOptionName.PacketInformation> natychmiast po wywołaniu <xref:System.Net.Sockets.Socket.Bind%2A> metody.  
  
> [!NOTE]
>  Jeśli zamierzasz odbierać datagramy multiemisji, należy wywołać <xref:System.Net.Sockets.Socket.Bind%2A> metodę z numerem portu multiemisji.  
  
> [!NOTE]
>  Należy wywołać metodę, <xref:System.Net.Sockets.Socket.Bind%2A> Jeśli zamierzasz odbierać bezpołączeniowe datagramy <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> przy użyciu metody.  
  
> [!NOTE]
>  Jeśli podczas <xref:System.Net.Sockets.SocketException> <xref:System.Net.Sockets.Socket.Bind%2A> wywoływania metody zostanie wyświetlony komunikat o błędzie, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wiąże się z <xref:System.Net.Sockets.Socket> przy użyciu określonego lokalnego punktu końcowego.  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="localEP" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący znajdujący się wyżej w stosie wywołań nie ma uprawnienia do żądanej operacji.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z hosta zdefiniowanego <paramref name="localEP" />przez program. Skojarzone Wyliczenie:<see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Net.Sockets.Socket" /> jest w trybie blokowania.</summary>
        <value><see langword="true" />Jeśli zostanie zablokowanie; w przeciwnym razie, <see langword="false" />. <see cref="T:System.Net.Sockets.Socket" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość <xref:System.Net.Sockets.Socket.Blocking%2A> wskazuje, <xref:System.Net.Sockets.Socket> czy jest w trybie blokowania.  
  
 Jeśli jesteś w trybie blokowania i utworzysz wywołanie metody, które nie zostanie natychmiast zakończone, aplikacja będzie blokować wykonywanie do momentu ukończenia żądanej operacji. Jeśli chcesz kontynuować wykonywanie, mimo że żądana operacja nie została ukończona, Zmień <xref:System.Net.Sockets.Socket.Blocking%2A> właściwość na. `false` <xref:System.Net.Sockets.Socket.Blocking%2A> Właściwość nie ma wpływu na metody asynchroniczne. Jeśli wysyłasz i otrzymujesz dane asynchronicznie i chcesz zablokować wykonywanie, użyj <xref:System.Threading.ManualResetEvent> klasy.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Obiekt używany do żądania połączenia z hostem zdalnym przez wywołanie jednej <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> z metod. <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /></param>
        <summary>Anuluje asynchroniczne żądanie połączenia z hostem zdalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> Metoda anuluje asynchroniczne żądanie połączenia hosta zdalnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr nie może mieć wartości null <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> i nie może mieć wartości null. <paramref name="e" /></exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący znajdujący się wyżej w stosie wywołań nie ma uprawnienia do żądanej operacji.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> Zamyka połączenie i zwalnia wszystkie skojarzone z nim zasoby.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> Zamyka połączenie i zwalnia wszystkie skojarzone z nim zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zamyka połączenie hosta zdalnego i zwalnia wszystkie zarządzane i niezarządzane zasoby skojarzone <xref:System.Net.Sockets.Socket>z. <xref:System.Net.Sockets.Socket.Close%2A> Po zamknięciu <xref:System.Net.Sockets.Socket.Connected%2A> właściwość jest ustawiona na `false`.  
  
 W przypadku protokołów zorientowanych na połączenia zaleca się wywołanie <xref:System.Net.Sockets.Socket.Shutdown%2A> przed <xref:System.Net.Sockets.Socket.Close%2A> wywołaniem metody. Gwarantuje to, że wszystkie dane zostaną wysłane i odebrane w podłączonym gnieździe przed jego zamknięciem.  
  
 Jeśli zachodzi konieczność <xref:System.Net.Sockets.Socket.Close%2A> wywołania bez uprzedniego wywołania <xref:System.Net.Sockets.Socket.Shutdown%2A>, można upewnić się, że dane w kolejce do transmisji wychodzącej będą `false` wysyłane przez ustawienie <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> opcji i określanie interwału limitu czasu niezerowego. <xref:System.Net.Sockets.Socket.Close%2A>Program zablokuje do momentu wysłania tych danych lub aż do upływu określonego limitu czasu. Jeśli ustawisz <xref:System.Net.Sockets.SocketOptionName.DontLinger> `false` wartość i określisz interwał limitu czasu, program <xref:System.Net.Sockets.Socket.Close%2A> zwolni połączenie i automatycznie odrzuci wychodzące dane znajdujące się w kolejce.  
  
> [!NOTE]
>  Aby <xref:System.Net.Sockets.SocketOptionName.DontLinger> ustawić opcję gniazda na <xref:System.Net.Sockets.LingerOption> `false`, Utwórz, ustaw właściwość Enabled na `true`, a następnie ustaw <xref:System.Net.Sockets.LingerOption.LingerTime%2A> właściwość na żądany limit czasu. Użyj tego <xref:System.Net.Sockets.LingerOption> programu wraz <xref:System.Net.Sockets.SocketOptionName.DontLinger> z opcją <xref:System.Net.Sockets.Socket.SetSocketOption%2A> gniazda, aby wywołać metodę.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu zamyka a <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="timeout">Zaczekaj <paramref name="timeout" /> do sekund, aby wysłać wszystkie pozostałe dane, a następnie zamknij gniazdo.</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> Zamyka połączenie i zwalnia wszystkie skojarzone zasoby z określonym limitem czasu, aby umożliwić wysyłanie w kolejce danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zamyka połączenie hosta zdalnego i zwalnia wszystkie zarządzane i niezarządzane zasoby skojarzone <xref:System.Net.Sockets.Socket>z. <xref:System.Net.Sockets.Socket.Close%2A> Po zamknięciu <xref:System.Net.Sockets.Socket.Connected%2A> właściwość jest ustawiona na `false`.  
  
 W przypadku protokołów zorientowanych na połączenia zaleca się wywołanie <xref:System.Net.Sockets.Socket.Shutdown%2A> przed wywołaniem metody. <xref:System.Net.Sockets.Socket.Close%2A> Gwarantuje to, że wszystkie dane zostaną wysłane i odebrane w podłączonym gnieździe przed jego zamknięciem.  
  
 Jeśli zachodzi konieczność <xref:System.Net.Sockets.Socket.Close%2A> wywołania bez uprzedniego wywołania <xref:System.Net.Sockets.Socket.Shutdown%2A>, można upewnić się, że dane w kolejce do transmisji wychodzącej będą `false` wysyłane przez ustawienie <xref:System.Net.Sockets.SocketOptionName.DontLinger> opcji i określanie interwału limitu czasu niezerowego. <xref:System.Net.Sockets.Socket.Close%2A>Program zablokuje do momentu wysłania tych danych lub aż do upływu określonego limitu czasu. Jeśli ustawisz <xref:System.Net.Sockets.SocketOptionName.DontLinger> `false` wartość i określisz interwał limitu czasu, program <xref:System.Net.Sockets.Socket.Close%2A> zwolni połączenie i automatycznie odrzuci wychodzące dane znajdujące się w kolejce.  
  
> [!NOTE]
>  Aby <xref:System.Net.Sockets.SocketOptionName.DontLinger> ustawić opcję gniazda na <xref:System.Net.Sockets.LingerOption> `false`, Utwórz, ustaw właściwość Enabled na `true`wartość i ustaw <xref:System.Net.Sockets.LingerOption.LingerTime%2A> właściwość na żądany limit czasu. Użyj tego <xref:System.Net.Sockets.LingerOption> programu wraz <xref:System.Net.Sockets.SocketOptionName.DontLinger> z opcją <xref:System.Net.Sockets.Socket.SetSocketOption%2A> gniazda, aby wywołać metodę.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, <xref:System.Net.Sockets.Socket>jak zamknąć.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustanawia połączenie z hostem zdalnym.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> Reprezentuje urządzenie zdalne.</param>
        <summary>Ustanawia połączenie z hostem zdalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz protokołu opartego na połączeniu, takiego jak TCP, <xref:System.Net.Sockets.Socket.Connect%2A> Metoda synchronicznie ustanawia połączenie sieciowe między <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> i określonym zdalnym punktem końcowym. Jeśli używasz protokołu bezpołączeniowego, program <xref:System.Net.Sockets.Socket.Connect%2A> ustanowi domyślnego hosta zdalnego. Po wywołaniu <xref:System.Net.Sockets.Socket.Connect%2A>programu można wysłać dane do urządzenia zdalnego <xref:System.Net.Sockets.Socket.Send%2A> za pomocą metody lub odebrać dane z urządzenia zdalnego za pomocą <xref:System.Net.Sockets.Socket.Receive%2A> metody.  
  
 Jeśli używasz protokołu bezpołączeniowego, takiego jak UDP, nie musisz wywoływać <xref:System.Net.Sockets.Socket.Connect%2A> przed wysłaniem i odebraniem danych. Za pomocą <xref:System.Net.Sockets.Socket.SendTo%2A> programu i <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> można synchronicznie komunikować się z hostem zdalnym. Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.Connect%2A>, wszelkie datagramy, które dotarły do adresu innego niż określona wartość domyślna zostaną odrzucone. Jeśli chcesz ustawić domyślny host zdalny na adres emisji <xref:System.Net.Sockets.Socket.SetSocketOption%2A> , musisz najpierw wywołać metodę i ustawić opcję Socket na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>lub <xref:System.Net.Sockets.Socket.Connect%2A> zgłosić <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
 Metoda zostanie zablokowana, chyba `false` że przed wywołaniem <xref:System.Net.Sockets.Socket.Blocking%2A> <xref:System.Net.Sockets.Socket.Connect%2A>zostanie wybrana właściwość. <xref:System.Net.Sockets.Socket.Connect%2A> Jeśli używasz protokołu opartego na połączeniu, takiego jak TCP, i wyłączyć blokowanie, program zgłosi plik <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.SocketException> , ponieważ potrzebuje czasu na nawiązanie połączenia. Protokoły bez połączenia nie zgłaszają wyjątku, ponieważ po prostu nawiązują domyślnego hosta zdalnego. Można użyć <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu. Jeśli błąd zwrócił WSAEWOULDBLOCK, połączenie hosta zdalnego zostało zainicjowane przez zorientowane <xref:System.Net.Sockets.Socket>na połączenie, ale jeszcze nie zostało zakończone pomyślnie. Użyj metody, aby określić, <xref:System.Net.Sockets.Socket> Kiedy zakończy się nawiązywanie połączenia. <xref:System.Net.Sockets.Socket.Poll%2A>  
  
> [!NOTE]
>  Jeśli używasz protokołu zorientowanego na połączenia i nie wywołuje <xref:System.Net.Sockets.Socket.Bind%2A> się przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>, Dostawca usługi bazowej przypisze lokalny adres sieciowy i numer portu. Jeśli używasz bezpołączeniowego protokołu, dostawca usług nie przypisze lokalnego adresu sieciowego i numeru portu do momentu ukończenia operacji wysyłania lub odbierania. Jeśli chcesz zmienić domyślnego hosta zdalnego, wywołaj <xref:System.Net.Sockets.Socket.Connect%2A> ponownie z żądanym punktem końcowym.  
  
> [!NOTE]
>  Jeśli gniazdo zostało wcześniej odłączone, nie można użyć tej metody do przywrócenia połączenia. Użyj jednej z metod asynchronicznych <xref:System.Net.Sockets.Socket.BeginConnect%2A> , aby ponownie nawiązać połączenie. Jest to ograniczenie podstawowego dostawcy.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu łączy się ze zdalnym punktem końcowym, a następnie weryfikuje połączenie.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący znajdujący się wyżej w stosie wywołań nie ma uprawnienia do żądanej operacji.</exception>
        <exception cref="T:System.InvalidOperationException">Został umieszczony w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />. <see cref="T:System.Net.Sockets.Socket" /></exception>
        <permission cref="T:System.Net.SocketPermission">do nawiązania połączenia z hostem zdalnym. Skojarzone Wyliczenie:<see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Adres IP hosta zdalnego.</param>
        <param name="port">Numer portu hosta zdalnego.</param>
        <summary>Ustanawia połączenie z hostem zdalnym. Host jest określony przez adres IP i numer portu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz protokołu opartego na połączeniu, takiego jak TCP, <xref:System.Net.Sockets.Socket.Connect%2A> Metoda synchronicznie ustanawia połączenie sieciowe między <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> i określonym zdalnym punktem końcowym. Jeśli używasz protokołu bezpołączeniowego, program <xref:System.Net.Sockets.Socket.Connect%2A> ustanowi domyślnego hosta zdalnego. Po wywołaniu <xref:System.Net.Sockets.Socket.Connect%2A> można wysłać dane do urządzenia zdalnego <xref:System.Net.Sockets.Socket.Send%2A> za pomocą metody lub odebrać dane z urządzenia zdalnego za pomocą <xref:System.Net.Sockets.Socket.Receive%2A> metody.  
  
 Jeśli używasz protokołu bezpołączeniowego, takiego jak UDP, nie musisz wywoływać <xref:System.Net.Sockets.Socket.Connect%2A> przed wysłaniem i odebraniem danych. Za pomocą <xref:System.Net.Sockets.Socket.SendTo%2A> programu i <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> można synchronicznie komunikować się z hostem zdalnym. Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.Connect%2A> jakakolwiek datagramy, które dotarły do adresu innego niż określony, zostanie odrzucone. Jeśli chcesz ustawić domyślny host zdalny na adres emisji <xref:System.Net.Sockets.Socket.SetSocketOption%2A> , musisz najpierw wywołać metodę i ustawić opcję Socket na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>lub <xref:System.Net.Sockets.Socket.Connect%2A> zgłosić <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>Metoda zostanie zablokowana, chyba że <xref:System.Net.Sockets.Socket.Blocking%2A> `false` przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>zostanie wybrana właściwość. Jeśli używasz protokołu opartego na połączeniu, takiego jak TCP, i wyłączyć blokowanie, program zgłosi plik <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.SocketException> , ponieważ potrzebuje czasu na nawiązanie połączenia. Protokoły bez połączenia nie zgłaszają wyjątku, ponieważ po prostu nawiązują domyślnego hosta zdalnego. Można użyć <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu. Jeśli błąd zwrócił WSAEWOULDBLOCK, połączenie hosta zdalnego zostało zainicjowane przez zorientowane <xref:System.Net.Sockets.Socket>na połączenie, ale jeszcze nie zostało zakończone pomyślnie. Użyj metody, aby określić, <xref:System.Net.Sockets.Socket> Kiedy zakończy się nawiązywanie połączenia. <xref:System.Net.Sockets.Socket.Poll%2A>  
  
> [!NOTE]
>  Jeśli używasz protokołu zorientowanego na połączenia i nie wywołuje <xref:System.Net.Sockets.Socket.Bind%2A> się przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>, Dostawca usługi bazowej przypisze lokalny adres sieciowy i numer portu. Jeśli używasz bezpołączeniowego protokołu, dostawca usług nie przypisze lokalnego adresu sieciowego i numeru portu do momentu ukończenia operacji wysyłania lub odbierania. Jeśli chcesz zmienić domyślnego hosta zdalnego, wywołaj <xref:System.Net.Sockets.Socket.Connect%2A> ponownie z żądanym punktem końcowym.  
  
> [!NOTE]
>  Jeśli gniazdo zostało wcześniej odłączone, nie można użyć tej metody do przywrócenia połączenia. Użyj jednej z metod asynchronicznych <xref:System.Net.Sockets.Socket.BeginConnect%2A> , aby ponownie nawiązać połączenie. Jest to ograniczenie podstawowego dostawcy.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu łączy się ze zdalnym punktem końcowym, a następnie weryfikuje połączenie.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda jest prawidłowa dla gniazd w <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> w rodzinach.</exception>
        <exception cref="T:System.ArgumentException">Długość <paramref name="address" /> wynosi zero.</exception>
        <exception cref="T:System.InvalidOperationException">Został umieszczony w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />. <see cref="T:System.Net.Sockets.Socket" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="addresses">Adresy IP hosta zdalnego.</param>
        <param name="port">Numer portu hosta zdalnego.</param>
        <summary>Ustanawia połączenie z hostem zdalnym. Host jest określony przez tablicę adresów IP i numer portu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest zwykle używana natychmiast po wywołaniu <xref:System.Net.Dns.GetHostAddresses%2A>metody, która może zwracać wiele adresów IP dla jednego hosta. Jeśli używasz protokołu opartego na połączeniu, takiego jak TCP, <xref:System.Net.Sockets.Socket.Connect%2A> Metoda synchronicznie ustanawia połączenie sieciowe między <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> i określonym zdalnym punktem końcowym. Jeśli używasz protokołu bezpołączeniowego, program <xref:System.Net.Sockets.Socket.Connect%2A> ustanowi domyślnego hosta zdalnego. Po wywołaniu <xref:System.Net.Sockets.Socket.Connect%2A> można wysłać dane do urządzenia zdalnego <xref:System.Net.Sockets.Socket.Send%2A> za pomocą metody lub odebrać dane z urządzenia zdalnego za pomocą <xref:System.Net.Sockets.Socket.Receive%2A> metody.  
  
 Jeśli używasz protokołu bezpołączeniowego, takiego jak UDP, nie musisz wywoływać <xref:System.Net.Sockets.Socket.Connect%2A> przed wysłaniem i odebraniem danych. Za pomocą <xref:System.Net.Sockets.Socket.SendTo%2A> programu i <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> można synchronicznie komunikować się z hostem zdalnym. Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.Connect%2A> jakakolwiek datagramy, które dotarły do adresu innego niż określony, zostanie odrzucone. Jeśli chcesz ustawić domyślny host zdalny na adres emisji <xref:System.Net.Sockets.Socket.SetSocketOption%2A> , musisz najpierw wywołać metodę i ustawić opcję Socket na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>lub <xref:System.Net.Sockets.Socket.Connect%2A> zgłosić <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>Metoda zostanie zablokowana, chyba że <xref:System.Net.Sockets.Socket.Blocking%2A> `false` przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>zostanie wybrana właściwość. Jeśli używasz protokołu opartego na połączeniu, takiego jak TCP, i wyłączyć blokowanie, program zgłosi plik <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.SocketException> , ponieważ potrzebuje czasu na nawiązanie połączenia. Protokoły bez połączenia nie zgłaszają wyjątku, ponieważ po prostu nawiązują domyślnego hosta zdalnego. Można użyć <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu. Jeśli błąd zwrócił WSAEWOULDBLOCK, połączenie hosta zdalnego zostało zainicjowane przez zorientowane <xref:System.Net.Sockets.Socket>na połączenie, ale jeszcze nie zostało zakończone pomyślnie. Użyj metody, aby określić, <xref:System.Net.Sockets.Socket> Kiedy zakończy się nawiązywanie połączenia. <xref:System.Net.Sockets.Socket.Poll%2A>  
  
> [!NOTE]
>  Jeśli używasz protokołu zorientowanego na połączenia i nie wywołuje <xref:System.Net.Sockets.Socket.Bind%2A> się przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>, Dostawca usługi bazowej przypisze lokalny adres sieciowy i numer portu. Jeśli używasz bezpołączeniowego protokołu, dostawca usług nie przypisze lokalnego adresu sieciowego i numeru portu do momentu ukończenia operacji wysyłania lub odbierania. Jeśli chcesz zmienić domyślnego hosta zdalnego, wywołaj <xref:System.Net.Sockets.Socket.Connect%2A> ponownie z żądanym punktem końcowym.  
  
> [!NOTE]
>  Jeśli gniazdo zostało wcześniej odłączone, nie można użyć tej metody do przywrócenia połączenia. Użyj jednej z metod asynchronicznych <xref:System.Net.Sockets.Socket.BeginConnect%2A> , aby ponownie nawiązać połączenie. Jest to ograniczenie podstawowego dostawcy.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu łączy się ze zdalnym punktem końcowym, a następnie weryfikuje połączenie.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda jest prawidłowa dla gniazd w <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> w rodzinach.</exception>
        <exception cref="T:System.ArgumentException">Długość <paramref name="address" /> wynosi zero.</exception>
        <exception cref="T:System.InvalidOperationException">Został umieszczony w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />. <see cref="T:System.Net.Sockets.Socket" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="host">Nazwa hosta zdalnego.</param>
        <param name="port">Numer portu hosta zdalnego.</param>
        <summary>Ustanawia połączenie z hostem zdalnym. Host jest określony przez nazwę hosta i numer portu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz protokołu opartego na połączeniu, takiego jak TCP, <xref:System.Net.Sockets.Socket.Connect%2A> Metoda synchronicznie ustanawia połączenie sieciowe między <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> i określonym hostem zdalnym. Jeśli używasz protokołu bezpołączeniowego, program <xref:System.Net.Sockets.Socket.Connect%2A> ustanowi domyślnego hosta zdalnego. Po wywołaniu <xref:System.Net.Sockets.Socket.Connect%2A> można wysłać dane do urządzenia zdalnego <xref:System.Net.Sockets.Socket.Send%2A> za pomocą metody lub odebrać dane z urządzenia zdalnego za pomocą <xref:System.Net.Sockets.Socket.Receive%2A> metody.  
  
 Jeśli używasz protokołu bezpołączeniowego, takiego jak UDP, nie musisz wywoływać <xref:System.Net.Sockets.Socket.Connect%2A> przed wysłaniem i odebraniem danych. Za pomocą <xref:System.Net.Sockets.Socket.SendTo%2A> programu i <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> można synchronicznie komunikować się z hostem zdalnym. Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.Connect%2A> jakakolwiek datagramy, które dotarły do adresu innego niż określony, zostanie odrzucone. Jeśli chcesz ustawić domyślny host zdalny na adres emisji <xref:System.Net.Sockets.Socket.SetSocketOption%2A> , musisz najpierw wywołać metodę i ustawić opcję Socket na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>lub <xref:System.Net.Sockets.Socket.Connect%2A> zgłosić <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>Metoda zostanie zablokowana, chyba że <xref:System.Net.Sockets.Socket.Blocking%2A> `false` przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>zostanie wybrana właściwość. Jeśli używasz protokołu opartego na połączeniu, takiego jak TCP, i wyłączyć blokowanie, program zgłosi plik <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.SocketException> , ponieważ potrzebuje czasu na nawiązanie połączenia. Protokoły bez połączenia nie zgłaszają wyjątku, ponieważ po prostu nawiązują domyślnego hosta zdalnego. Można użyć <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu. Jeśli błąd zwrócił WSAEWOULDBLOCK, połączenie hosta zdalnego zostało zainicjowane przez zorientowane <xref:System.Net.Sockets.Socket>na połączenie, ale jeszcze nie zostało zakończone pomyślnie. Użyj metody, aby określić, <xref:System.Net.Sockets.Socket> Kiedy zakończy się nawiązywanie połączenia. <xref:System.Net.Sockets.Socket.Poll%2A>  
  
 Jeśli protokół IPv6 jest włączony i <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> wywoływana jest metoda w celu nawiązania połączenia z hostem, który jest rozpoznawany jako adres IPv6 i IPv4, połączenie z adresem IPv6 zostanie podjęte najpierw przed adresem IPv4. Może to skutkować opóźnieniami czasu na nawiązanie połączenia, Jeśli host nie nasłuchuje na adresie IPv6.  
  
> [!NOTE]
>  Jeśli używasz protokołu zorientowanego na połączenia i nie wywołuje <xref:System.Net.Sockets.Socket.Bind%2A> się przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>, Dostawca usługi bazowej przypisze lokalny adres sieciowy i numer portu. Jeśli używasz bezpołączeniowego protokołu, dostawca usług nie przypisze lokalnego adresu sieciowego i numeru portu do momentu ukończenia operacji wysyłania lub odbierania. Jeśli chcesz zmienić domyślnego hosta zdalnego, wywołaj <xref:System.Net.Sockets.Socket.Connect%2A> ponownie z żądanym punktem końcowym.  
  
> [!NOTE]
>  Jeśli gniazdo zostało wcześniej odłączone, nie można użyć tej metody do przywrócenia połączenia. Użyj jednej z metod asynchronicznych <xref:System.Net.Sockets.Socket.BeginConnect%2A> , aby ponownie nawiązać połączenie. Jest to ograniczenie podstawowego dostawcy.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu łączy się ze zdalnym punktem końcowym, a następnie weryfikuje połączenie.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda jest prawidłowa dla gniazd w <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> w rodzinach.</exception>
        <exception cref="T:System.InvalidOperationException">Został umieszczony w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />. <see cref="T:System.Net.Sockets.Socket" /></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna asynchroniczne żądanie połączenia z hostem zdalnym.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Obiekt <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> , który ma być używany dla tej asynchronicznej operacji gniazda.</param>
        <summary>Rozpoczyna asynchroniczne żądanie połączenia z hostem zdalnym.</summary>
        <returns><see langword="true" />Jeśli operacja we/wy jest w stanie oczekiwania. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie<paramref name="e" /> na parametrze zostanie wywołane po zakończeniu operacji.  
  
 <see langword="false" />Jeśli operacja we/wy została ukończona synchronicznie. W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie <paramref name="e" /> na parametrze <paramref name="e" /> nie zostanie zgłoszone i obiekt przenoszony jako parametr może zostać zbadany natychmiast po wywołaniu metody, aby pobrać wynik operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W <xref:System.Net.Sockets.Socket.ConnectAsync%2A> przypadku korzystania z protokołu zorientowanego na połączenia Metoda uruchamia asynchroniczne żądanie dla połączenia z hostem zdalnym. Jeśli używasz protokołu bezpołączeniowego, program <xref:System.Net.Sockets.Socket.ConnectAsync%2A> ustanowi domyślnego hosta zdalnego.  
  
 Aby otrzymywać powiadomienia o zakończeniu, należy utworzyć metodę wywołania zwrotnego implementującą delegata\<EventHandler SocketAsyncEventArgs > i dołączyć wywołanie zwrotne <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> do zdarzenia.  
  
 Obiekt wywołujący musi ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Właściwość <xref:System.Net.IPEndPoint> na hoście zdalnym, z którym ma zostać nawiązane połączenie.  
  
 Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość na dowolny obiekt stanu użytkownika przed <xref:System.Net.Sockets.Socket.ConnectAsync%2A> wywołaniem metody, tak aby informacje były możliwe do pobierania w metodzie wywołania zwrotnego. Jeśli wywołanie zwrotne wymaga więcej informacji niż pojedynczy obiekt, można utworzyć małą klasę w celu przechowywania innych wymaganych informacji o stanie jako członków.  
  
 Jeśli używasz protokołu bezpołączeniowego, takiego jak UDP, nie musisz wywoływać <xref:System.Net.Sockets.Socket.ConnectAsync%2A> przed wysłaniem i odebraniem danych. Za pomocą <xref:System.Net.Sockets.Socket.SendToAsync%2A> programu i <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> można komunikować się z hostem zdalnym. Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, wszelkie datagramy, które dotarły do adresu innego niż określona wartość domyślna zostaną odrzucone. Jeśli chcesz zmienić domyślnego hosta zdalnego, wywołaj <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodę ponownie z żądanym punktem końcowym.  
  
 Jeśli chcesz ustawić domyślny host zdalny na adres emisji, musisz najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> i ustawić emisję do. `true` Jeśli to nie zrobisz, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Metoda <xref:System.Net.Sockets.SocketException>wygeneruje.  
  
 Wymagane są następujące właściwości i zdarzenia dotyczące <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiektu:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 Opcjonalnie można dostarczyć bufor, który będzie niepodzielny w gnieździe po pomyślnym zakończeniu <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metody. W tym przypadku <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> właściwość musi być ustawiona na bufor zawierający dane do wysłania, <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> a właściwość musi być ustawiona na liczbę bajtów danych do wysłania z bufora. Po nawiązaniu połączenia zostanie wysłany ten bufor danych.  
  
 Jeśli używasz protokołu zorientowanego na połączenia i nie wywołuj <xref:System.Net.Sockets.Socket.Bind%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, Dostawca usługi bazowej przypisze najbardziej odpowiedni lokalny adres sieciowy i numer portu.  
  
 Jeśli używasz bezpołączeniowego protokołu, dostawca usług nie przypisze lokalnego adresu IP i numeru portu do momentu wywołania <xref:System.Net.Sockets.Socket.SendAsync%2A> metody lub. <xref:System.Net.Sockets.Socket.ReceiveAsync%2A>  
  
 Metoda zgłasza <xref:System.NotSupportedException> , czy <xref:System.Net.Sockets.Socket> Rodzinaadresówiniejesttąsamąrodzinąadresów.<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> <xref:System.Net.Sockets.Socket.ConnectAsync%2A>  
  
> [!NOTE]
>  Jeśli podczas wywoływania tej <xref:System.Net.Sockets.SocketException> metody zostanie wyświetlony komunikat o błędzie, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Argument jest nieprawidłowy. Ten wyjątek występuje, jeśli określono wiele buforów, <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> właściwość nie ma wartości null.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr nie może mieć wartości null <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> i nie może mieć wartości null. <paramref name="e" /></exception>
        <exception cref="T:System.InvalidOperationException">Operacja nasłuchuje lub gniazdo <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> <paramref name="e" /> <see cref="T:System.Net.Sockets.Socket" /> jest już w toku przy użyciu obiektu określonego w parametrze.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda wymaga systemu Windows XP lub nowszego. Ten wyjątek występuje również wtedy, gdy lokalny punkt końcowy <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> i program nie mają tej samej rodziny adresów.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący znajdujący się wyżej w stosie wywołań nie ma uprawnienia do żądanej operacji.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType">Jedna z <see cref="T:System.Net.Sockets.SocketType" /> wartości.</param>
        <param name="protocolType">Jedna z <see cref="T:System.Net.Sockets.ProtocolType" /> wartości.</param>
        <param name="e">Obiekt <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> , który ma być używany dla tej asynchronicznej operacji gniazda.</param>
        <summary>Rozpoczyna asynchroniczne żądanie połączenia z hostem zdalnym.</summary>
        <returns><see langword="true" />Jeśli operacja we/wy jest w stanie oczekiwania. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie<paramref name="e" /> na parametrze zostanie wywołane po zakończeniu operacji.  
  
 <see langword="false" />Jeśli operacja we/wy została ukończona synchronicznie. W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie <paramref name="e" /> na parametrze <paramref name="e" /> nie zostanie zgłoszone i obiekt przenoszony jako parametr może zostać zbadany natychmiast po wywołaniu metody, aby pobrać wynik operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz protokołu zorientowanego na połączenie, Metoda M:System.Net.Sockets.Socket.ConnectAsync (System .NET. Sockets. SocketType, system .NET. Sockets. ProtocolType, system .NET. Sockets. SocketAsyncEventArgs) uruchamia asynchroniczne żądanie dla połączenie z hostem zdalnym. W przypadku korzystania z bezpołączeniowego protokołu <xref:System.Net.Sockets.Socket.ConnectAsync%2A> program ustanawia domyślny host zdalny określony `socketType` przez parametry i `protocolType` .  
  
 Aby otrzymywać powiadomienia o zakończeniu, należy utworzyć metodę wywołania zwrotnego implementującą delegata\<EventHandler SocketAsyncEventArgs > i dołączyć wywołanie zwrotne <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> do zdarzenia.  
  
 Obiekt wywołujący musi ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Właściwość <xref:System.Net.IPEndPoint> na hoście zdalnym, z którym ma zostać nawiązane połączenie.  
  
 Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość na dowolny obiekt stanu użytkownika przed <xref:System.Net.Sockets.Socket.ConnectAsync%2A> wywołaniem metody, tak aby informacje były możliwe do pobierania w metodzie wywołania zwrotnego. Jeśli wywołanie zwrotne wymaga więcej informacji niż pojedynczy obiekt, można utworzyć małą klasę w celu przechowywania innych wymaganych informacji o stanie jako członków.  
  
 Jeśli używasz protokołu bezpołączeniowego, takiego jak UDP, nie musisz wywoływać <xref:System.Net.Sockets.Socket.ConnectAsync%2A> przed wysłaniem i odebraniem danych. Za pomocą <xref:System.Net.Sockets.Socket.SendToAsync%2A> programu i <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> można komunikować się z hostem zdalnym. Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, wszelkie datagramy, które dotarły do adresu innego niż określona wartość domyślna zostaną odrzucone. Jeśli chcesz zmienić domyślnego hosta zdalnego, wywołaj <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodę ponownie z żądanym punktem końcowym.  
  
 Jeśli chcesz ustawić domyślny host zdalny na adres emisji, musisz najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> i ustawić emisję do. `true` Jeśli to nie zrobisz, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Metoda <xref:System.Net.Sockets.SocketException>wygeneruje.  
  
 Wymagane są następujące właściwości i zdarzenia dotyczące <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiektu:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 Opcjonalnie można dostarczyć bufor, który będzie niepodzielny w gnieździe po pomyślnym zakończeniu <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metody. W tym przypadku <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> właściwość musi być ustawiona na bufor zawierający dane do wysłania, <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> a właściwość musi być ustawiona na liczbę bajtów danych do wysłania z bufora. Po nawiązaniu połączenia zostanie wysłany ten bufor danych.  
  
 Jeśli używasz protokołu zorientowanego na połączenia i nie wywołuj <xref:System.Net.Sockets.Socket.Bind%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, Dostawca usługi bazowej przypisze najbardziej odpowiedni lokalny adres sieciowy i numer portu.  
  
 Jeśli używasz bezpołączeniowego protokołu, dostawca usług nie przypisze lokalnego adresu IP i numeru portu do momentu wywołania <xref:System.Net.Sockets.Socket.SendAsync%2A> metody lub. <xref:System.Net.Sockets.Socket.ReceiveAsync%2A>  
  
 Metoda zgłasza <xref:System.NotSupportedException> , czy <xref:System.Net.Sockets.Socket> Rodzinaadresówiniejesttąsamąrodzinąadresów.<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> <xref:System.Net.Sockets.Socket.ConnectAsync%2A>  
  
> [!NOTE]
>  Jeśli podczas wywoływania tej <xref:System.Net.Sockets.SocketException> metody zostanie wyświetlony komunikat o błędzie, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Argument jest nieprawidłowy. Ten wyjątek występuje, jeśli określono wiele buforów, <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> właściwość nie ma wartości null.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr nie może mieć wartości null <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> i nie może mieć wartości null. <paramref name="e" /></exception>
        <exception cref="T:System.InvalidOperationException">Operacja nasłuchuje lub gniazdo <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> <paramref name="e" /> <see cref="T:System.Net.Sockets.Socket" /> jest już w toku przy użyciu obiektu określonego w parametrze.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda wymaga systemu Windows XP lub nowszego. Ten wyjątek występuje również wtedy, gdy lokalny punkt końcowy <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> i program nie mają tej samej rodziny adresów.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący znajdujący się wyżej w stosie wywołań nie ma uprawnienia do żądanej operacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Net.Sockets.Socket" /> jest połączony z hostem zdalnym w ramach ostatniej <see cref="Overload:System.Net.Sockets.Socket.Send" /> lub <see cref="Overload:System.Net.Sockets.Socket.Receive" /> operacji.</summary>
        <value><see langword="true" />Jeśli został podłączony do zasobu zdalnego w ramach najnowszej operacji; <see langword="false" />w przeciwnym razie. <see cref="T:System.Net.Sockets.Socket" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość pobiera stan <xref:System.Net.Sockets.Socket> połączenia z ostatniej operacji we/wy. `Connected` Gdy zwróci wartość `false` <xref:System.Net.Sockets.Socket> , nigdy nie nawiązano połączenia lub nie jest już połączony.  
  
 Wartość <xref:System.Net.Sockets.Socket.Connected%2A> właściwości odzwierciedla stan połączenia w ramach najnowszej operacji. Aby określić bieżący stan połączenia, należy wykonać nieblokujące wywołanie wysyłania bez bajtów. Jeśli wywołanie zwróci się pomyślnie lub zgłosi kod błędu WAEWOULDBLOCK (10035), gniazdo jest nadal połączone; w przeciwnym razie gniazdo nie jest już połączone.  
  
 Jeśli wywołasz <xref:System.Net.Sockets.Socket.Connect%2A> w gnieździe UDP (User Datagram Protocol) <xref:System.Net.Sockets.Socket.Connected%2A> , właściwość zawsze zwróci wartość `true`, jednak ta akcja nie powoduje zmiany bezpołączeniowego charakteru protokołu UDP.  
  
   
  
## Examples  
 Poniższy przykład kodu łączy się ze zdalnym punktem końcowym, sprawdza <xref:System.Net.Sockets.Socket.Connected%2A> Właściwość i sprawdza bieżący stan połączenia.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="reuseSocket"><see langword="true" />Jeśli tego gniazda można użyć ponownie po zamknięciu bieżącego połączenia; w przeciwnym razie. <see langword="false" /></param>
        <summary>Zamyka połączenie gniazda i umożliwia ponowne użycie gniazda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz protokołu zorientowanego na połączenie, możesz użyć tej metody, aby zamknąć gniazdo. Ta metoda przerywa połączenie i ustawia <xref:System.Net.Sockets.Socket.Connected%2A> właściwość na. `false` Jeśli `reuseSocket` jednak jest to `true`możliwe, możesz ponownie użyć gniazda.  
  
 Aby upewnić się, że wszystkie dane są wysyłane i odbierane przed zamknięciem gniazda, <xref:System.Net.Sockets.Socket.Shutdown%2A> należy wywołać przed <xref:System.Net.Sockets.Socket.Disconnect%2A> wywołaniem metody.  
  
 Jeśli zachodzi konieczność <xref:System.Net.Sockets.Socket.Disconnect%2A> wywołania bez uprzedniego wywołania <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.Shutdown%2A> <xref:System.Net.Sockets.SocketOptionName.DontLinger> , można ustawić opcję na `false` i określić niezerowy limit czasu, aby upewnić się, że dane są wysyłane do kolejki transmisji wychodzącej. <xref:System.Net.Sockets.Socket.Disconnect%2A>następnie bloki do momentu wysłania danych lub aż do upływu określonego limitu czasu. Jeśli ustawisz <xref:System.Net.Sockets.SocketOptionName.DontLinger> `false` wartość i określisz interwał limitu czasu, program <xref:System.Net.Sockets.Socket.Close%2A> zwolni połączenie i automatycznie odrzuci wychodzące dane znajdujące się w kolejce.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy gniazdo do komunikacji synchronicznej i wysyła niektóre dane do hosta zdalnego. Następnie wywołuje <xref:System.Net.Sockets.Socket.Shutdown%2A>, aby zatrzymać działanie wysyłania i odbierania, a <xref:System.Net.Sockets.Socket.Disconnect%2A>następnie zamknąć połączenie gniazda.  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Ta metoda wymaga systemu Windows 2000 lub starszego lub wyjątek zostanie wygenerowany.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e">Obiekt <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> , który ma być używany dla tej asynchronicznej operacji gniazda.</param>
        <summary>Rozpoczyna asynchroniczne żądanie rozłączenia ze zdalnego punktu końcowego.</summary>
        <returns><see langword="true" />Jeśli operacja we/wy jest w stanie oczekiwania. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie<paramref name="e" /> na parametrze zostanie wywołane po zakończeniu operacji.  
  
 <see langword="false" />Jeśli operacja we/wy została ukończona synchronicznie. W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie <paramref name="e" /> na parametrze <paramref name="e" /> nie zostanie zgłoszone i obiekt przenoszony jako parametr może zostać zbadany natychmiast po wywołaniu metody, aby pobrać wynik operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku korzystania z protokołu zorientowanego na połączenia wywoływanie <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> metody powoduje odłączenie ze zdalnego punktu końcowego. Jeśli ustawisz <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> wartość `true` w `e` parametrze, gniazdo może być ponownie używane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> Parametr nie może mieć wartości null.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja gniazda była już w toku przy użyciu <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiektu określonego <paramref name="e" /> w parametrze.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda wymaga systemu Windows XP lub nowszego.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Net.Sockets.Socket" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Net.Sockets.Socket" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj `Dispose` po zakończeniu korzystania z <xref:System.Net.Sockets.Socket>. `Dispose` Metoda<xref:System.Net.Sockets.Socket> pozostawia w stanie niezdatnym do użytku. Po wywołaniu `Dispose`należy wydać wszystkie odwołania <xref:System.Net.Sockets.Socket> do, aby moduł wyrzucania elementów bezużytecznych mógł odwoływać pamięć <xref:System.Net.Sockets.Socket> , którą zajmował.  
  
 Aby uzyskać więcej informacji, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i implementowanie [metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Zawsze wywołuj `Dispose` przed wydaniem ostatniego odwołania <xref:System.Net.Sockets.Socket>do. W przeciwnym razie używane zasoby nie zostaną zwolnione do momentu wywołania <xref:System.Net.Sockets.Socket> `Finalize` metody obiektu przez moduł zbierający elementy bezużyteczne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> zwalnia tylko niezarządzane zasoby.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Net.Sockets.Socket" />program i opcjonalnie usuwa zarządzane zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną `Dispose()` <xref:System.Object.Finalize%2A> i metodę. `Dispose()`wywołuje metodę chronioną `Dispose(Boolean)` `disposing` z parametrem ustawionym `true`na. <xref:System.Object.Finalize%2A>wywołuje `Dispose` `false`z `disposing` ustawionym na.  
  
 Gdy parametr ma wartość `true`, ta metoda zwalnia wszystkie zasoby przechowywane przez wszystkie obiekty zarządzane, do <xref:System.Net.Sockets.Socket> których odwołują się te odwołania. `disposing` Ta metoda wywołuje `Dispose()` metodę każdego przywoływanego obiektu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" />może być wywoływana wiele razy przez inne obiekty. Podczas zastępowania <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />należy zachować ostrożność, aby nie odwoływać się do obiektów, które zostały wcześniej usunięte <see langword="Dispose" />w ramach wcześniejszego wywołania do. Aby uzyskać więcej informacji na temat sposobu <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />implementacji, zobacz [implementowanie metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Aby uzyskać więcej informacji <see langword="Dispose" /> na <see cref="M:System.Object.Finalize" />temat i, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [Zastępowanie metody Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określającą, <see cref="T:System.Net.Sockets.Socket" /> czy mają być pofragmentowane datagramy protokołu IP.</summary>
        <value><see langword="true" />Jeśli zezwala <see cref="T:System.Net.Sockets.Socket" /> na fragmentację datagramów; <see langword="false" />w przeciwnym razie. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Datagramy wymagają fragmentacji, gdy ich rozmiar przekracza maksymalną jednostkę transferu (MTU) nośnika transmisji. Wszystkie datagramy mogą być pofragmentowane przez hosta wysyłającego (wszystkie wersje protokołu internetowego) lub do pośredniego routera (tylko protokół internetowy w wersji 4). Jeśli datagram musi być pofragmentowany, a <xref:System.Net.Sockets.Socket.DontFragment%2A> opcja jest ustawiona, datagram zostaje odrzucony, a komunikat o błędzie protokołu ICMP (Internet Control Message Protocol) zostanie wysłany z powrotem do nadawcy datagramu.  
  
 Ustawienie tej właściwości w gnieździe Transmission Control Protocol (TCP) nie będzie miało żadnego efektu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.DontFragment%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Tę właściwość można ustawić tylko dla gniazd w <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> w rodzinach.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określającą, <see cref="T:System.Net.Sockets.Socket" /> czy jest to gniazdo dwukierunkowe używane dla protokołów IPv4 i IPv6.</summary>
        <value><see langword="true" />Jeśli jest to gniazdo dwutrybowe, <see langword="false" />w przeciwnym razie. <see cref="T:System.Net.Sockets.Socket" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">Identyfikator procesu docelowego, w którym jest tworzone duplikaty odwołania gniazda.</param>
        <summary>Duplikuje odwołanie do gniazda dla procesu docelowego i zamyka gniazdo dla tego procesu.</summary>
        <returns>Odwołanie do gniazda, które ma zostać przesłane do procesu docelowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Proces docelowy powinien użyć <xref:System.Net.Sockets.Socket.%23ctor%2A> do utworzenia zduplikowanego wystąpienia gniazda.  
  
 W przypadku wywołania <xref:System.Net.Sockets.Socket.%23ctor%2A> konstruktora wiele razy z tą samą tablicą bajtową, co argument dla każdego wywołania, utworzysz wiele wystąpień zarządzanych <xref:System.Net.Sockets.Socket> z tym samym gniazdem podstawowym. Jest to zdecydowanie odradzane.  
  
 Jeśli proces tworzenia gniazda używa metod asynchronicznych (<xref:System.Net.Sockets.Socket.BeginReceive%2A> lub <xref:System.Net.Sockets.Socket.BeginSend%2A>), <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> proces musi najpierw ustawić właściwość na true; w przeciwnym razie gniazdo jest powiązane z portem zakończenia procesu tworzenia, co może spowodować wystąpienie <xref:System.ArgumentNullException> do zgłoszenia w procesie docelowym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="targetProcessID" />nie jest prawidłowym identyfikatorem procesu. 
—lub— 
Duplikowanie odwołania gniazda nie powiodło się.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określającą, <see cref="T:System.Net.Sockets.Socket" /> czy można wysyłać i odbierać pakiety emisji.</summary>
        <value><see langword="true" />Jeśli zezwala <see cref="T:System.Net.Sockets.Socket" /> na pakiety emisji, <see langword="false" />w przeciwnym razie. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Emisja jest ograniczona do określonej podsieci i musi korzystać z protokołu UDP (User Datagram Protocol). W przypadku protokołu internetowego w wersji 4 można emitować do podsieci lokalnej, wysyłając pakiet do wersji 255.255.255.255; można też użyć adresu emisji kierowanej, który jest częścią sieci adresu IP, ze wszystkimi bitami ustawionymi w części hosta. Na przykład, jeśli adres IP to 192.168.1.40 (adres klasy C, z maską sieci 255.255.255.0) — część sieciowa to pierwsze trzy oktety, a część hosta jest ostatnim oktetem), kierowany adres emisji to 192.168.1.255.  
  
 Ustawienie tej właściwości w gnieździe Transmission Control Protocol (TCP) nie będzie miało żadnego efektu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ta opcja jest prawidłowa tylko dla gniazda datagram.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asynchronicznie akceptuje próbę połączenia przychodzącego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierającego Bajty przesłane.</param>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> Obiekt, który przechowuje informacje o stanie dla tej operacji asynchronicznej, a także wszystkie dane zdefiniowane przez użytkownika.</param>
        <summary>Asynchronicznie akceptuje próbę połączenia przychodzącego i tworzy <see cref="T:System.Net.Sockets.Socket" /> nowy obiekt do obsługi komunikacji z hostem zdalnym. Ta metoda zwraca bufor zawierający dane wstępne przesłane.</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> Obiekt obsługujący komunikację z hostem zdalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>kończy wywołanie metody <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginAccept%2A>należy utworzyć metodę wywołania zwrotnego, która jest wywoływana <xref:System.AsyncCallback> przez delegata. Ta metoda wywołania zwrotnego jest wykonywana w osobnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginAccept%2A> powrocie metody.  
  
 W metodzie wywołania zwrotnego Wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę `asyncResult` parametru, aby uzyskać, <xref:System.Net.Sockets.Socket> na którym nastąpiło próba połączenia. Po uzyskaniu <xref:System.Net.Sockets.Socket>można <xref:System.Net.Sockets.Socket.EndAccept%2A> wywołać metodę, aby pomyślnie zakończyć próbę połączenia. Parametr tego przeciążenia zawiera dane odebrane w <xref:System.Net.Sockets.Socket.BeginAccept%2A> wywołaniu metody, a `bytesTransferred` parametr zawiera liczbę bajtów przesłanych w wywołaniu. `buffer`  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Metoda blokuje się do momentu oczekiwania połączenia w kolejce połączeń przychodzących. Metoda akceptuje połączenie przychodzące i zwraca nową <xref:System.Net.Sockets.Socket> , która może być używana do wysyłania danych do i odbierania danych z hosta zdalnego. <xref:System.Net.Sockets.Socket.EndAccept%2A>  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Net.Sockets.Socket.BeginAccept%2A> do tworzenia i łączenia gniazda i akceptowania pierwszych 10 bajtów danych. Delegat <xref:System.Net.Sockets.Socket.EndAccept%2A> wywołania zwrotnego zakończył asynchroniczne żądanie. Liczba przesłanych bajtów i dane są zwracane w `buffer` parametrach i `bytesTransferred` w tej metodzie i są wyświetlane w konsoli programu.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Dla tej metody wymagany jest system Windows NT.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest puste.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został utworzony przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />Metoda została wcześniej wywołana.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do<see cref="T:System.Net.Sockets.Socket" /></exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> Przechowuje informacje o stanie dla tej operacji asynchronicznej, a także wszystkie dane zdefiniowane przez użytkownika.</param>
        <param name="result"><see cref="T:System.IAsyncResult" /> Przechowuje informacje o stanie dla tej operacji asynchronicznej, a także wszystkie dane zdefiniowane przez użytkownika.</param>
        <summary>Asynchronicznie akceptuje próbę połączenia przychodzącego i tworzy <see cref="T:System.Net.Sockets.Socket" /> nową do obsługi komunikacji z hostem zdalnym.</summary>
        <returns>A <see cref="T:System.Net.Sockets.Socket" /> do obsługi komunikacji z hostem zdalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>kończy wywołanie metody <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginAccept%2A>należy utworzyć metodę wywołania zwrotnego <xref:System.AsyncCallback> implementującą delegata. Ta metoda wywołania zwrotnego jest wykonywana w osobnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginAccept%2A> powrocie metody. Musi akceptować `asyncResult` parametr zwracany <xref:System.Net.Sockets.Socket.BeginAccept%2A> przez metodę.  
  
 W metodzie wywołania zwrotnego Wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę `asyncResult` parametru, aby uzyskać, <xref:System.Net.Sockets.Socket> na którym nastąpiło próba połączenia. Po uzyskaniu <xref:System.Net.Sockets.Socket>można <xref:System.Net.Sockets.Socket.EndAccept%2A> wywołać metodę, aby pomyślnie zakończyć próbę połączenia.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Metoda blokuje się do momentu oczekiwania połączenia w kolejce połączeń przychodzących. Metoda akceptuje połączenie przychodzące i zwraca nową <xref:System.Net.Sockets.Socket> , która może być używana do wysyłania danych do i odbierania danych z hosta zdalnego. <xref:System.Net.Sockets.Socket.EndAccept%2A>  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu zamyka żądanie asynchroniczne i tworzy nowy <xref:System.Net.Sockets.Socket> , aby zaakceptować żądanie połączenia przychodzącego. Aby zapoznać się z kompletnym przykładem, który pokazuje asynchroniczne komunikację z gniazdami, zobacz [przykłady kodu gniazda](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został utworzony przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz sekcję Spostrzeżenia, aby uzyskać więcej informacji.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />Metoda została wcześniej wywołana.</exception>
        <exception cref="T:System.NotSupportedException">Dla tej metody wymagany jest system Windows NT.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  *  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bytesTransferred" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierającego Bajty przesłane.</param>
        <param name="bytesTransferred">Liczba bajtów przesłanych.</param>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> Obiekt, który przechowuje informacje o stanie dla tej operacji asynchronicznej, a także wszystkie dane zdefiniowane przez użytkownika.</param>
        <summary>Asynchronicznie akceptuje próbę połączenia przychodzącego i tworzy <see cref="T:System.Net.Sockets.Socket" /> nowy obiekt do obsługi komunikacji z hostem zdalnym. Ta metoda zwraca bufor zawierający dane początkowe oraz liczbę przesłanych bajtów.</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> Obiekt obsługujący komunikację z hostem zdalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>kończy wywołanie metody <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginAccept%2A>należy utworzyć metodę wywołania zwrotnego, która jest wywoływana <xref:System.AsyncCallback> przez delegata. Ta metoda wywołania zwrotnego jest wykonywana w osobnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginAccept%2A> powrocie metody. Musi akceptować `asyncResult` parametr zwracany <xref:System.Net.Sockets.Socket.BeginAccept%2A> przez metodę.  
  
 W metodzie wywołania zwrotnego Wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę `asyncResult` parametru, aby uzyskać, <xref:System.Net.Sockets.Socket> na którym nastąpiło próba połączenia. Po uzyskaniu <xref:System.Net.Sockets.Socket>można <xref:System.Net.Sockets.Socket.EndAccept%2A> wywołać metodę, aby pomyślnie zakończyć próbę połączenia. Parametr tego przeciążenia zawiera dane odebrane w <xref:System.Net.Sockets.Socket.BeginAccept%2A> wywołaniu metody, a `bytesTransferred` parametr zawiera liczbę bajtów przesłanych w wywołaniu. `buffer`  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Metoda blokuje się do momentu oczekiwania połączenia w kolejce połączeń przychodzących. Metoda akceptuje połączenie przychodzące i zwraca nową <xref:System.Net.Sockets.Socket> , która może być używana do wysyłania danych do i odbierania danych z hosta zdalnego. <xref:System.Net.Sockets.Socket.EndAccept%2A>  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Net.Sockets.Socket.BeginAccept%2A> do tworzenia i łączenia gniazda i akceptowania pierwszych 10 bajtów danych. Delegat <xref:System.Net.Sockets.Socket.EndAccept%2A> wywołania zwrotnego zakończył asynchroniczne żądanie. Liczba przesłanych bajtów i dane są zwracane w `buffer` parametrach i `bytesTransferred` w tej metodzie i są wyświetlane w konsoli programu.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Dla tej metody wymagany jest system Windows NT.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest puste.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został utworzony przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />Metoda została wcześniej wywołana.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu <see cref="T:System.Net.Sockets.Socket" />do elementu.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> Przechowujące informacje o stanie i wszystkie dane zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</param>
        <param name="result"><see cref="T:System.IAsyncResult" /> Przechowujące informacje o stanie i wszystkie dane zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</param>
        <summary>Zakończenie oczekiwania na asynchroniczne żądanie połączenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A>to metoda blokująca, która kończy asynchroniczne żądanie połączenia zdalnego hosta uruchomione w <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodzie.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginConnect%2A>należy utworzyć metodę wywołania zwrotnego <xref:System.AsyncCallback> implementującą delegata. Ta metoda wywołania zwrotnego jest wykonywana w osobnym wątku i jest wywoływana przez system <xref:System.Net.Sockets.Socket.BeginConnect%2A> po powrocie. Metoda wywołania zwrotnego musi akceptować <xref:System.IAsyncResult> zwrócone <xref:System.Net.Sockets.Socket.BeginConnect%2A> przez metodę jako parametr.  
  
 W metodzie wywołania zwrotnego Wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę <xref:System.IAsyncResult> parametru, aby uzyskać, <xref:System.Net.Sockets.Socket> na którym nastąpiło próba połączenia. Po uzyskaniu <xref:System.Net.Sockets.Socket>można <xref:System.Net.Sockets.Socket.EndConnect%2A> wywołać metodę, aby pomyślnie zakończyć próbę połączenia.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu przerywa próbę połączenia asynchronicznego. Aby zapoznać się z kompletnym przykładem, który pokazuje asynchroniczne komunikację z gniazdami, zobacz [przykłady kodu gniazda](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został zwrócony przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />zostało wcześniej wywołane dla połączenia asynchronicznego.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> Obiekt, który przechowuje informacje o stanie i wszystkie dane zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</param>
        <summary>Przerywa oczekujące asynchroniczne żądanie rozłączenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A>kończy wywołanie metody <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>. <xref:System.Net.Sockets.Socket.EndDisconnect%2A> Metoda blokuje się do momentu zakończenia rozłączenia. Aby uzyskać informacje o operacjach asynchronicznych, zobacz temat Omówienie programowania asynchronicznego w bibliotece MSDN.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy gniazdo do komunikacji asynchronicznej i wysyła niektóre dane do hosta zdalnego. Po wysłaniu dane są wywoływane, <xref:System.Net.Sockets.Socket.Shutdown%2A> aby zatrzymać działanie wysyłania i odbierania. Następnie <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> jest wywoływana w celu rozpoczęcia żądania rozłączenia. Delegat <xref:System.Net.Sockets.Socket.EndDisconnect%2A> wywołania zwrotnego zakończył asynchroniczne żądanie. Po zakończeniu żądania <xref:System.Net.Sockets.Socket.Connected%2A> właściwość zostanie zbadana, aby sprawdzić, czy gniazdo jest odłączone.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">System operacyjny to Windows 2000 lub starszy, a ta metoda wymaga systemu Windows XP.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został zwrócony przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />zostało wcześniej wywołane dla połączenia asynchronicznego.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.Net.WebException">Upłynął limit czasu żądania rozłączenia.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zakończenie oczekiwania na odczyt asynchroniczny.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> Przechowujące informacje o stanie i wszystkie dane zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</param>
        <param name="result"><see cref="T:System.IAsyncResult" /> Przechowujące informacje o stanie i wszystkie dane zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</param>
        <summary>Zakończenie oczekiwania na odczyt asynchroniczny.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda kończy asynchroniczne operacje odczytu rozpoczęte <xref:System.Net.Sockets.Socket.BeginReceive%2A> w metodzie. <xref:System.Net.Sockets.Socket.EndReceive%2A>  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginReceive%2A>należy utworzyć metodę wywołania zwrotnego <xref:System.AsyncCallback> implementującą delegata. Ta metoda wywołania zwrotnego jest wykonywana w osobnym wątku i jest wywoływana przez system <xref:System.Net.Sockets.Socket.BeginReceive%2A> po powrocie. Metoda wywołania zwrotnego musi akceptować <xref:System.IAsyncResult> zwrócone <xref:System.Net.Sockets.Socket.BeginReceive%2A> przez metodę jako parametr.  
  
 W metodzie wywołania zwrotnego Wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę <xref:System.IAsyncResult> , aby uzyskać obiekt <xref:System.Net.Sockets.Socket.BeginReceive%2A> stanu przekazaną do metody. Wyodrębnij odebranie <xref:System.Net.Sockets.Socket> z tego obiektu stanu. Po uzyskaniu <xref:System.Net.Sockets.Socket>można <xref:System.Net.Sockets.Socket.EndReceive%2A> wywołać metodę, aby pomyślnie zakończyć operację odczytu i zwrócić liczbę odczytanych bajtów.  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> Metoda zostanie zablokowana do momentu udostępnienia danych. W przypadku korzystania z bezpołączeniowego protokołu <xref:System.Net.Sockets.Socket.EndReceive%2A> program odczytaje pierwszy znajdujący się w kolejce datagram dostępny w buforze sieci przychodzącej. Jeśli używasz protokołu zorientowanego na połączenie, <xref:System.Net.Sockets.Socket.EndReceive%2A> Metoda odczyta tyle danych, ile jest dostępnych do liczby bajtów określonych `size` w parametrze <xref:System.Net.Sockets.Socket.BeginReceive%2A> metody. Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.EndReceive%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.  
  
 Aby uzyskać odebrane dane, wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę <xref:System.IAsyncResult>i Wyodrębnij bufor zawarty w obiekcie stanu wyników.  
  
 Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceive%2A>, <xref:System.Net.Sockets.Socket.Close%2A> Wywołaj metodę.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Wszystkie we/wy zainicjowane przez dany wątek zostało anulowane po zakończeniu tego wątku. Oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek zostanie zakończony przed ukończeniem operacji.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu kończący oczekujący odczyt asynchroniczny. Aby zapoznać się z kompletnym przykładem, który pokazuje asynchroniczne komunikację z gniazdami, zobacz [przykłady kodu gniazda](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został zwrócony przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />zostało wcześniej wywołane dla odczytu asynchronicznego.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult *  -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> Przechowujące informacje o stanie i wszystkie dane zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</param>
        <param name="errorCode"><see cref="T:System.Net.Sockets.SocketError" /> Obiekt, który przechowuje błąd gniazda.</param>
        <summary>Zakończenie oczekiwania na odczyt asynchroniczny.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda kończy asynchroniczne operacje odczytu rozpoczęte <xref:System.Net.Sockets.Socket.BeginReceive%2A> w metodzie. <xref:System.Net.Sockets.Socket.EndReceive%2A>  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginReceive%2A>należy utworzyć metodę wywołania zwrotnego <xref:System.AsyncCallback> implementującą delegata. Ta metoda wywołania zwrotnego jest wykonywana w osobnym wątku i jest wywoływana przez system <xref:System.Net.Sockets.Socket.BeginReceive%2A> po powrocie. Metoda wywołania zwrotnego musi akceptować <xref:System.IAsyncResult> zwrócone <xref:System.Net.Sockets.Socket.BeginReceive%2A> przez metodę jako parametr.  
  
 W metodzie wywołania zwrotnego Wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę <xref:System.IAsyncResult> , aby uzyskać obiekt <xref:System.Net.Sockets.Socket.BeginReceive%2A> stanu przekazaną do metody. Wyodrębnij odebranie <xref:System.Net.Sockets.Socket> z tego obiektu stanu. Po uzyskaniu <xref:System.Net.Sockets.Socket>można <xref:System.Net.Sockets.Socket.EndReceive%2A> wywołać metodę, aby pomyślnie zakończyć operację odczytu i zwrócić liczbę odczytanych bajtów.  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> Metoda zostanie zablokowana do momentu udostępnienia danych. W przypadku korzystania z bezpołączeniowego protokołu <xref:System.Net.Sockets.Socket.EndReceive%2A> program odczytaje pierwszy znajdujący się w kolejce datagram dostępny w buforze sieci przychodzącej. Jeśli używasz protokołu zorientowanego na połączenie, <xref:System.Net.Sockets.Socket.EndReceive%2A> Metoda odczyta tyle danych, ile jest dostępnych do liczby bajtów określonych `size` w parametrze <xref:System.Net.Sockets.Socket.BeginReceive%2A> metody. Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.EndReceive%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.  
  
 Aby uzyskać odebrane dane, wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę <xref:System.IAsyncResult>i Wyodrębnij bufor zawarty w obiekcie stanu wyników.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Wszystkie we/wy zainicjowane przez dany wątek zostało anulowane po zakończeniu tego wątku. Oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek zostanie zakończony przed ukończeniem operacji.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został zwrócony przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />zostało wcześniej wywołane dla odczytu asynchronicznego.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult *  -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> Przechowujące informacje o stanie i wszystkie dane zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</param>
        <param name="result"><see cref="T:System.IAsyncResult" /> Przechowujące informacje o stanie i wszystkie dane zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</param>
        <param name="endPoint">Źródło <see cref="T:System.Net.EndPoint" />.</param>
        <param name="end_point">Źródło <see cref="T:System.Net.EndPoint" />.</param>
        <summary>Zamyka oczekujące asynchroniczne odczyt z określonego punktu końcowego.</summary>
        <returns>Jeśli to się powiedzie, liczba odebranych bajtów. Jeśli nie powiedzie się, zwraca wartość 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda kończy asynchroniczne operacje odczytu rozpoczęte <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> w metodzie. <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>należy utworzyć metodę wywołania zwrotnego <xref:System.AsyncCallback> implementującą delegata. Ta metoda wywołania zwrotnego jest wykonywana w osobnym wątku i jest wywoływana przez system <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> po powrocie. Metoda wywołania zwrotnego musi akceptować <xref:System.IAsyncResult> zwrócone <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> przez metodę jako parametr.  
  
 W metodzie wywołania zwrotnego Wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę <xref:System.IAsyncResult> , aby uzyskać obiekt <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> stanu przekazaną do metody. Wyodrębnij odebranie <xref:System.Net.Sockets.Socket> z tego obiektu stanu. Po uzyskaniu <xref:System.Net.Sockets.Socket>można <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> wywołać metodę, aby pomyślnie zakończyć operację odczytu i zwrócić liczbę odczytanych bajtów.  
  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Metoda zostanie zablokowana do momentu udostępnienia danych. W przypadku korzystania z bezpołączeniowego protokołu <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> program odczytaje pierwszy znajdujący się w kolejce datagram dostępny w buforze sieci przychodzącej. Jeśli używasz protokołu zorientowanego na połączenie, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Metoda odczyta tyle danych, ile jest dostępnych do liczby bajtów określonych `size` w parametrze <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody. Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Metoda zakończy się natychmiast i zwróci zero bajtów. Aby uzyskać odebrane dane, wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę <xref:System.IAsyncResult> obiektu i Wyodrębnij bufor zawarty w obiekcie stanu wyników. Aby zidentyfikować hosta źródłowego, Wyodrębnij <xref:System.Net.EndPoint> go i przerzutj <xref:System.Net.IPEndPoint>na. Użyj metody, aby uzyskać adres IP <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> i metodę w celu uzyskania numeru portu. <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu zamyka oczekujące asynchroniczne odczyt z określonego <xref:System.Net.EndPoint>.  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został zwrócony przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />zostało wcześniej wywołane dla odczytu asynchronicznego.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult *  *  *  -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> Przechowujące informacje o stanie i wszystkie dane zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości dla odebranego pakietu.</param>
        <param name="endPoint">Źródło <see cref="T:System.Net.EndPoint" />.</param>
        <param name="ipPacketInformation">Interfejs <see cref="T:System.Net.IPAddress" /> i odebrany pakiet.</param>
        <summary>Zamyka oczekujące asynchroniczne odczyt z określonego punktu końcowego. Ta metoda ujawnia również więcej informacji na temat pakietu niż <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</summary>
        <returns>Jeśli to się powiedzie, liczba odebranych bajtów. Jeśli nie powiedzie się, zwraca wartość 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli operacja nie została ukończona, ta metoda jest blokowana, dopóki nie zostanie wykonana.  
  
 Aby wykonać tę operację synchronicznie, użyj <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metody.  
  
 Sprawdź `ipPacketInformation` , czy musisz wiedzieć, czy datagram został wysłany przy użyciu adresu emisji pojedynczej, multiemisji lub emisji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />była<see langword="null" />  
  
—lub— 
 <paramref name="endPoint" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został zwrócony przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />zostało wcześniej wywołane dla odczytu asynchronicznego.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zakończenie oczekiwania na wysłanie asynchroniczne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> Przechowujący informacje o stanie dla tej operacji asynchronicznej.</param>
        <param name="result"><see cref="T:System.IAsyncResult" /> Przechowujący informacje o stanie dla tej operacji asynchronicznej.</param>
        <summary>Zakończenie oczekiwania na wysłanie asynchroniczne.</summary>
        <returns>Jeśli to się powiedzie, liczba bajtów wysłanych <see cref="T:System.Net.Sockets.Socket" />do; w przeciwnym razie <see cref="T:System.Net.Sockets.Socket" /> , nieprawidłowy błąd.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A>kończy asynchroniczne operacje wysyłania rozpoczęte w <xref:System.Net.Sockets.Socket.BeginSend%2A>.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSend%2A>należy utworzyć metodę wywołania zwrotnego <xref:System.AsyncCallback> implementującą delegata. Ta metoda wywołania zwrotnego jest wykonywana w osobnym wątku i jest wywoływana przez system <xref:System.Net.Sockets.Socket.BeginSend%2A> po powrocie. Metoda wywołania zwrotnego musi akceptować <xref:System.IAsyncResult> zwrócone <xref:System.Net.Sockets.Socket.BeginSend%2A> przez metodę jako parametr.  
  
 W metodzie wywołania zwrotnego Wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę <xref:System.IAsyncResult> parametru, aby uzyskać wysyłanie <xref:System.Net.Sockets.Socket>. Po uzyskaniu <xref:System.Net.Sockets.Socket>można <xref:System.Net.Sockets.Socket.EndSend%2A> wywołać metodę, aby pomyślnie zakończyć operację wysyłania i zwrócić liczbę wysłanych bajtów.  
  
 Jeśli używasz bezpołączeniowego protokołu, <xref:System.Net.Sockets.Socket.EndSend%2A> program zablokuje do momentu wysłania datagramu. Jeśli używasz protokołu zorientowanego na połączenie, <xref:System.Net.Sockets.Socket.EndSend%2A> program zablokuje do momentu wysłania niektórych buforów. Jeśli wartość zwracana z <xref:System.Net.Sockets.Socket.EndSend%2A> wskazuje, że bufor nie został całkowicie wysłany, <xref:System.Net.Sockets.Socket.BeginSend%2A> Wywołaj metodę ponownie, modyfikując bufor do przechowywania niewysłanych danych.  
  
 Nie ma żadnej gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci. Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.BeginSend%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Wszystkie we/wy zainicjowane przez dany wątek zostało anulowane po zakończeniu tego wątku. Oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek zostanie zakończony przed ukończeniem operacji.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie. Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu zamyka oczekujące asynchroniczne wysyłanie.  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został zwrócony przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />została wcześniej wywołana dla wysyłania asynchronicznego.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult *  -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> Przechowujący informacje o stanie dla tej operacji asynchronicznej.</param>
        <param name="errorCode"><see cref="T:System.Net.Sockets.SocketError" /> Obiekt, który przechowuje błąd gniazda.</param>
        <summary>Zakończenie oczekiwania na wysłanie asynchroniczne.</summary>
        <returns>Jeśli to się powiedzie, liczba bajtów wysłanych <see cref="T:System.Net.Sockets.Socket" />do; w przeciwnym razie <see cref="T:System.Net.Sockets.Socket" /> , nieprawidłowy błąd.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A>kończy asynchroniczne operacje wysyłania rozpoczęte w <xref:System.Net.Sockets.Socket.BeginSend%2A>.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSend%2A>należy utworzyć metodę wywołania zwrotnego <xref:System.AsyncCallback> implementującą delegata. Ta metoda wywołania zwrotnego jest wykonywana w osobnym wątku i jest wywoływana przez system <xref:System.Net.Sockets.Socket.BeginSend%2A> po powrocie. Metoda wywołania zwrotnego musi akceptować <xref:System.IAsyncResult> zwrócone <xref:System.Net.Sockets.Socket.BeginSend%2A> przez metodę jako parametr.  
  
 W metodzie wywołania zwrotnego Wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę <xref:System.IAsyncResult> parametru, aby uzyskać wysyłanie <xref:System.Net.Sockets.Socket>. Po uzyskaniu <xref:System.Net.Sockets.Socket>można <xref:System.Net.Sockets.Socket.EndSend%2A> wywołać metodę, aby pomyślnie zakończyć operację wysyłania i zwrócić liczbę wysłanych bajtów.  
  
 Jeśli używasz bezpołączeniowego protokołu, <xref:System.Net.Sockets.Socket.EndSend%2A> program zablokuje do momentu wysłania datagramu. Jeśli używasz protokołu zorientowanego na połączenie, <xref:System.Net.Sockets.Socket.EndSend%2A> program zablokuje do momentu wysłania niektórych buforów. Jeśli wartość zwracana z <xref:System.Net.Sockets.Socket.EndSend%2A> wskazuje, że bufor nie został całkowicie wysłany, <xref:System.Net.Sockets.Socket.BeginSend%2A> Wywołaj metodę ponownie, modyfikując bufor do przechowywania niewysłanych danych.  
  
 Nie ma żadnej gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci. Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.BeginSend%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Wszystkie we/wy zainicjowane przez dany wątek zostało anulowane po zakończeniu tego wątku. Oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek zostanie zakończony przed ukończeniem operacji.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie. Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został zwrócony przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />została wcześniej wywołana dla wysyłania asynchronicznego.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> Obiekt, który przechowuje informacje o stanie dla tej operacji asynchronicznej.</param>
        <summary>Zamyka oczekujące asynchroniczne wysyłanie pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A>kończy asynchroniczne operacje wysyłania rozpoczęte w <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSendFile%2A>należy utworzyć metodę wywołania zwrotnego <xref:System.AsyncCallback> implementującą delegata. Ta metoda wywołania zwrotnego jest wykonywana w osobnym wątku i jest wywoływana przez system <xref:System.Net.Sockets.Socket.BeginSendFile%2A> po powrocie. Metoda wywołania zwrotnego musi akceptować <xref:System.IAsyncResult> obiekt zwracany <xref:System.Net.Sockets.Socket.BeginSendFile%2A> przez metodę jako parametr.  
  
 W metodzie wywołania zwrotnego Wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę <xref:System.IAsyncResult> parametru, aby uzyskać wysyłanie <xref:System.Net.Sockets.Socket>. Po uzyskaniu <xref:System.Net.Sockets.Socket>można <xref:System.Net.Sockets.Socket.EndSendFile%2A> wywołać metodę, aby pomyślnie zakończyć operację wysyłania.  
  
 Jeśli używasz bezpołączeniowego protokołu, <xref:System.Net.Sockets.Socket.EndSendFile%2A> bloki do momentu wysłania datagramu. Jeśli używasz protokołu zorientowanego na połączenia, <xref:System.Net.Sockets.Socket.EndSendFile%2A> bloki do momentu wysłania całego pliku. Nie ma żadnej gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci. Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy i łączy gniazdo do komunikacji asynchronicznej i zaczyna wysyłać plik "text. txt" asynchronicznie do hosta zdalnego. Delegat wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndSendFile%2A> do ukończenia transmisji.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Dla tej metody wymagany jest system Windows NT.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest puste.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został zwrócony przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />zostało wcześniej wywołane dla asynchronicznej <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> Przechowujące informacje o stanie i wszystkie dane zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</param>
        <param name="result"><see cref="T:System.IAsyncResult" /> Przechowujące informacje o stanie i wszystkie dane zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</param>
        <summary>Zamyka oczekujące wysyłanie asynchroniczne do określonej lokalizacji.</summary>
        <returns>W przypadku powodzenia — liczba wysłanych bajtów; w przeciwnym razie nieprawidłowy <see cref="T:System.Net.Sockets.Socket" /> błąd.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A>kończy asynchroniczne operacje wysyłania rozpoczęte w <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSendTo%2A>należy utworzyć metodę wywołania zwrotnego <xref:System.AsyncCallback> implementującą delegata. Ta metoda wywołania zwrotnego jest wykonywana w osobnym wątku i jest wywoływana przez system <xref:System.Net.Sockets.Socket.BeginReceive%2A> po powrocie. Metoda wywołania zwrotnego musi akceptować <xref:System.IAsyncResult> zwrócone <xref:System.Net.Sockets.Socket.BeginSendTo%2A> przez metodę jako parametr.  
  
 W metodzie wywołania zwrotnego Wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę <xref:System.IAsyncResult> parametru, aby uzyskać wysyłanie <xref:System.Net.Sockets.Socket>. Po uzyskaniu <xref:System.Net.Sockets.Socket>można <xref:System.Net.Sockets.Socket.EndSendTo%2A> wywołać metodę, aby pomyślnie zakończyć operację wysyłania i zwrócić liczbę wysłanych bajtów.  
  
 Jeśli używasz bezpołączeniowego protokołu, <xref:System.Net.Sockets.Socket.EndSendTo%2A> program zablokuje do momentu wysłania datagramu. Jeśli używasz protokołu zorientowanego na połączenie, <xref:System.Net.Sockets.Socket.EndSendTo%2A> program zablokuje do momentu wysłania żądanej liczby bajtów. Nie ma żadnej gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci. Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu przerywa wysyłanie asynchroniczne do określonej lokalizacji.  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został zwrócony przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />została wcześniej wywołana dla wysyłania asynchronicznego.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określającą, <see cref="T:System.Net.Sockets.Socket" /> czy zezwala tylko jednemu procesowi na powiązanie z portem.</summary>
        <value><see langword="true" />Jeśli zezwala tylko jednemu gnieździi na powiązanie z określonym portem; w przeciwnym razie, <see langword="false" />. <see cref="T:System.Net.Sockets.Socket" /> Wartość domyślna to <see langword="true" /> Windows Server 2003 i Windows XP z dodatkiem Service Pack 2 <see langword="false" /> oraz dla wszystkich innych wersji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> jest `false` ,<xref:System.Net.Sockets.Socket.Bind%2A> wiele gniazd może używać metody do powiązania z określonym portem; jednak tylko jedno z gniazd może wykonywać operacje w ruchu sieciowym wysyłanym do portu. Jeśli więcej niż jedno gniazdo próbuje użyć <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> metody do powiązania z określonym portem, to ten z bardziej szczegółowym adresem IP będzie obsługiwać ruch sieciowy wysyłany do tego portu.  
  
 Jeśli <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> <xref:System.Net.Sockets.Socket.Bind%2A> <xref:System.Net.Sockets.Socket.Bind%2A> jest `true`, pierwsze użycie metody w celu utworzenia powiązania z określonym portem, bez względu na adres protokołu internetowego (IP), powiedzie się; wszystkie kolejne zastosowania metody w celu utworzenia powiązania z tym portem będą nie powiodło się, dopóki oryginalne powiązane gniazdo nie zostanie zniszczone.  
  
 Ta właściwość musi być ustawiona przed <xref:System.Net.Sockets.Socket.Bind%2A> wywołaniem metody; <xref:System.InvalidOperationException> w przeciwnym razie zostanie wygenerowany.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />został wywołany dla tego <see cref="T:System.Net.Sockets.Socket" />elementu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.Net.Sockets.Socket" /> klasę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Finalizator klasy wywołuje metodę w celu zamknięcia <xref:System.Net.Sockets.Socket> i zwolnienia zasobów skojarzonych z <xref:System.Net.Sockets.Socket>. <xref:System.Net.Sockets.Socket.Close%2A> <xref:System.Net.Sockets.Socket>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla <see cref="T:System.Net.Sockets.Socket" /> wystąpienia.</summary>
        <returns>Wartość skrótu liczb całkowitych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Metoda GetHashCode zwraca kod skrótu tego wystąpienia. Ta wartość może być używana jako klucz w tabelach skrótów.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość <see cref="T:System.Net.Sockets.Socket" /> opcji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Jedna z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</param>
        <param name="optionName">Jedna z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</param>
        <summary>Zwraca wartość określonej <see cref="T:System.Net.Sockets.Socket" /> opcji reprezentowanej jako obiekt.</summary>
        <returns>Obiekt, który reprezentuje wartość opcji. Gdy parametr jest ustawiony na <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> wartość zwracaną, <see cref="T:System.Net.Sockets.LingerOption" /> jest wystąpieniem klasy. <paramref name="optionName" /> Gdy <paramref name="optionName" /> jest ustawiona na <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> lub <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, wartość zwracana jest wystąpieniem <see cref="T:System.Net.Sockets.MulticastOption" /> klasy. Gdy <paramref name="optionName" /> jest dowolną inną wartością, zwracana wartość jest liczbą całkowitą.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>opcje określają zachowanie bieżącego <xref:System.Net.Sockets.Socket>elementu. Użyj tego <xref:System.Net.Sockets.SocketOptionName.Linger>przeciążenia, aby uzyskać opcje <xref:System.Net.Sockets.SocketOptionName.AddMembership>, i <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> . <xref:System.Net.Sockets.Socket> Dla opcji Użyj`optionLevel` parametru. <xref:System.Net.Sockets.SocketOptionName.Linger> Dla <xref:System.Net.Sockets.SocketOptionName.AddMembership> i <xref:System.Net.Sockets.SocketOptionName.DropMembership>, użyj <xref:System.Net.Sockets.SocketOptionLevel.IP>. Jeśli chcesz ustawić wartość dowolnej z wymienionych powyżej opcji, użyj <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera <xref:System.Net.Sockets.LingerOption> wartości i <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu i wyświetla je w konsoli programu.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.  
  
—lub— 
 <paramref name="optionName" />ustawiono nieobsługiwaną wartość <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Jedna z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</param>
        <param name="optionName">Jedna z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</param>
        <param name="optionValue">Tablica typu <see cref="T:System.Byte" /> , który ma otrzymać ustawienie opcji.</param>
        <summary>Zwraca określone <see cref="T:System.Net.Sockets.Socket" /> ustawienie opcji reprezentowane jako tablica bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>opcje określają zachowanie bieżącego <xref:System.Net.Sockets.Socket>elementu. Po pomyślnym zakończeniu tej metody tablica określona przez `optionValue` parametr zawiera wartość określonej <xref:System.Net.Sockets.Socket> opcji.  
  
 Gdy długość `optionValue` tablicy jest mniejsza niż liczba bajtów wymagana do przechowania wartości określonej <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.SocketException>opcji, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> program wygeneruje. Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu. Użyj tego przeciążenia dla wszystkich gniazd, które są reprezentowane przez wartości logiczne lub liczby całkowite.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera <xref:System.Net.Sockets.LingerOption> wartości i <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu i wyświetla je w konsoli programu.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.  
  
—lub— 
W .NET Compact Framework aplikacji Windows CE domyślna przestrzeń buforu jest ustawiona na 32768 bajtów. Można zmienić miejsce w buforze na gniazdo, wywołując <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />metodę.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionLength" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Jedna z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</param>
        <param name="optionName">Jedna z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</param>
        <param name="optionLength">Długość (w bajtach) oczekiwanej wartości zwracanej.</param>
        <summary>Zwraca wartość określonej <see cref="T:System.Net.Sockets.Socket" /> opcji w tablicy.</summary>
        <returns>Tablica typu <see cref="T:System.Byte" /> , która zawiera wartość opcji gniazda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `optionLength` Parametr ustawia maksymalny rozmiar zwracanej tablicy bajtów. Jeśli wartość opcji wymaga mniejszej liczby bajtów, tablica będzie zawierać tylko liczbę bajtów. Jeśli wartość opcji wymaga większej liczby bajtów, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> program <xref:System.Net.Sockets.SocketException>wygeneruje. Użyj tego przeciążenia dla wszystkich gniazd, które są reprezentowane przez wartości logiczne lub liczby całkowite.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera <xref:System.Net.Sockets.LingerOption> wartości i <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu i wyświetla je w konsoli programu.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.  
  
—lub— 
W .NET Compact Framework aplikacji Windows CE domyślna przestrzeń buforu jest ustawiona na 32768 bajtów. Można zmienić miejsce w buforze na gniazdo, wywołując <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />metodę.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwyt systemu operacyjnego dla <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Reprezentuje dojście systemu operacyjnego <see cref="T:System.Net.Sockets.Socket" />dla. <see cref="T:System.IntPtr" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia Tryby operacyjne niskiego poziomu dla <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ioControlCode"><see cref="T:System.Int32" /> Wartość określająca kod sterujący operacji do wykonania.</param>
        <param name="optionInValue"><see cref="T:System.Byte" /> Tablica zawierająca dane wejściowe wymagane przez operację.</param>
        <param name="optionOutValue"><see cref="T:System.Byte" /> Tablica zawierająca dane wyjściowe zwrócone przez operację.</param>
        <summary>Ustawia Tryby operacyjne niskiego poziomu dla <see cref="T:System.Net.Sockets.Socket" /> kodów kontroli liczbowej.</summary>
        <returns>Liczba bajtów w <paramref name="optionOutValue" /> parametrze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zapewnia dostęp niskiego poziomu do systemu <xref:System.Net.Sockets.Socket> operacyjnego bazowego bieżącego wystąpienia <xref:System.Net.Sockets.Socket> klasy. <xref:System.Net.Sockets.Socket.IOControl%2A> Aby uzyskać więcej informacji, zapoznaj się z dokumentacją [WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) .  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu porównuje wyniki FIONREAD i dostępne właściwości.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę zmiany trybu blokowania bez użycia <see cref="P:System.Net.Sockets.Socket.Blocking" /> właściwości.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby wykonać kod niezarządzany. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ioControlCode"><see cref="T:System.Net.Sockets.IOControlCode" /> Wartość, która określa kod sterujący operacji do wykonania.</param>
        <param name="optionInValue">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane wejściowe wymagane przez operację.</param>
        <param name="optionOutValue">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane wyjściowe zwrócone przez operację.</param>
        <summary>Ustawia Tryby operacyjne niskiego poziomu dla <see cref="T:System.Net.Sockets.Socket" /> wyliczenia przy użyciu, <see cref="T:System.Net.Sockets.IOControlCode" /> aby określić kody kontroli.</summary>
        <returns>Liczba bajtów w <paramref name="optionOutValue" /> parametrze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zapewnia dostęp niskiego poziomu do systemu <xref:System.Net.Sockets.Socket> operacyjnego odpowiadającego bieżącemu wystąpieniu <xref:System.Net.Sockets.Socket> klasy. Aby uzyskać więcej informacji, zapoznaj się z dokumentacją [WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) .  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu porównuje wyniki wywołania <xref:System.Net.Sockets.Socket.IOControl%2A> z <xref:System.Net.Sockets.IOControlCode.DataToRead> i <xref:System.Net.Sockets.Socket.Available%2A> właściwości.  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę zmiany trybu blokowania bez użycia <see cref="P:System.Net.Sockets.Socket.Blocking" /> właściwości.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby wykonać kod niezarządzany. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Net.Sockets.Socket" /> jest powiązana z określonym portem lokalnym.</summary>
        <value><see langword="true" />Jeśli jest powiązany z portem lokalnym; w przeciwnym razie <see langword="false" />,. <see cref="T:System.Net.Sockets.Socket" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gniazdo jest uznawane za powiązane z portem lokalnym, jeśli jest ono jawnie powiązane przez <xref:System.Net.Sockets.Socket.Bind%2A> wywołanie metody lub niejawnie powiązanej przez wywołujących <xref:System.Net.Sockets.Socket.SendTo%2A>członków, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>takich jak <xref:System.Net.Sockets.Socket.Connect%2A>, lub, które używają portu lokalnego na czas dłuższy niż 1024 wybrana przez system operacyjny). Serwery używają <xref:System.Net.Sockets.Socket.Bind%2A> metody do powiązania z dobrze znanym portem, dzięki czemu klienci mogą się z nimi łączyć.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.IsBound%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy <see cref="T:System.Net.Sockets.Socket" /> opóźnienie zamknie gniazdo w trakcie próby wysłania wszystkich oczekujących danych.</summary>
        <value>Obiekt <see cref="T:System.Net.Sockets.LingerOption" /> , który określa sposób pokutujący podczas zamykania gniazda.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość zmienia sposób <xref:System.Net.Sockets.Socket.Close%2A> zachowania metody. <xref:System.Net.Sockets.Socket.LingerState%2A> Ta właściwość po ustawieniu modyfikuje warunki, w których połączenie może być resetowane przez usługę Winsock. Resetowanie połączeń może nadal odbywać się w zależności od zachowania protokołu IP.  
  
 Ta właściwość określa czas, przez jaki połączenie zorientowane na połączenie pozostanie otwarte po wywołaniu <xref:System.Net.Sockets.Socket.Close%2A> , gdy dane zostaną wysłane.  
  
 Gdy wywołujesz metody wysyłania danych do elementu równorzędnego, te dane są umieszczane w buforze sieci wychodzącej. Ta właściwość może służyć do upewnienia się, że te dane są wysyłane do hosta zdalnego przed <xref:System.Net.Sockets.TcpClient.Close%2A> odrzuceniem połączenia przez metodę.  
  
 Aby włączyć pokutujący, Utwórz <xref:System.Net.Sockets.LingerOption> wystąpienie zawierające wymagane wartości, a następnie <xref:System.Net.Sockets.Socket.LingerState%2A> ustaw właściwość na to wystąpienie.  
  
 W poniższej tabeli opisano <xref:System.Net.Sockets.Socket.Close%2A> zachowanie metody dla możliwych wartości <xref:System.Net.Sockets.LingerOption.Enabled%2A> właściwości i <xref:System.Net.Sockets.LingerOption.LingerTime%2A> właściwości przechowywanej we <xref:System.Net.Sockets.Socket.LingerState%2A> właściwości.  
  
|LingerState.Enabled|LingerState.LingerTime|Zachowanie|  
|-------------------------|----------------------------|--------------|  
|`false`(wyłączone), wartość domyślna|Limit czasu nie ma zastosowania (wartość domyślna).|Próbuje wysłać oczekujące dane do momentu wygaśnięcia domyślnego limitu czasu protokołu IP.|  
|`true`dostępny|Limit czasu różny od zera|Próbuje wysłać oczekujące dane do czasu wygaśnięcia określonego limitu czasu, a jeśli próba nie powiedzie się, usługa Winsock resetuje połączenie.|  
|`true`dostępny|Limit czasu równy zero.|Odrzuca wszystkie oczekujące dane. W przypadku gniazda zorientowanego na połączenia (na przykład TCP), Winsock resetuje połączenie.|  
  
 Stos IP oblicza domyślny limit czasu protokołu IP do użycia na podstawie czasu błądzenia połączenia. W większości przypadków limit czasu obliczony przez stos jest bardziej istotny niż jeden zdefiniowany przez aplikację. Jest to domyślne zachowanie dla gniazda, gdy <xref:System.Net.Sockets.Socket.LingerState%2A> właściwość nie jest ustawiona.  
  
 Gdy właściwość przechowywana <xref:System.Net.Sockets.Socket.LingerState%2A> we właściwości jest ustawiona na wartość większą niż domyślny limit czasu protokołu IP, domyślny limit czasu protokołu IP będzie nadal stosowany i przesłonięty. <xref:System.Net.Sockets.LingerOption.LingerTime%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.LingerState%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">Maksymalna długość kolejki oczekujących połączeń.</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> Umieszcza w stanie nasłuchiwania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A>powoduje nawiązanie <xref:System.Net.Sockets.Socket> połączenia w celu nasłuchiwania prób połączenia przychodzącego. `backlog` Parametr określa liczbę połączeń przychodzących, które można umieścić w kolejce do akceptacji. Aby określić maksymalną liczbę połączeń, które można określić, należy pobrać <xref:System.Net.Sockets.SocketOptionName.MaxConnections> wartość. <xref:System.Net.Sockets.Socket.Listen%2A>nie blokuje.  
  
 Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu. Użyj <xref:System.Net.Sockets.Socket.Accept%2A> lub<xref:System.Net.Sockets.Socket.BeginAccept%2A> , aby zaakceptować połączenie z kolejki.  
  
> [!NOTE]
>  Należy wywołać <xref:System.Net.Sockets.Socket.Bind%2A> metodę przed wywołaniem <xref:System.Net.Sockets.Socket.Listen%2A>lub <xref:System.Net.Sockets.Socket.Listen%2A> zgłosić <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Parametr zaległości jest ograniczony do różnych wartości w zależności od systemu operacyjnego. Możesz określić wyższą wartość, ale zaległości będą ograniczone w zależności od systemu operacyjnego.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Net.Sockets.Socket> do nasłuchiwania połączeń przychodzących.  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lokalny punkt końcowy.</summary>
        <value><see cref="T:System.Net.EndPoint" /> Używany<see cref="T:System.Net.Sockets.Socket" /> do komunikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość pobiera, który zawiera lokalny adres IP i numer <xref:System.Net.Sockets.Socket> portu, z którym jest powiązany. <xref:System.Net.EndPoint> <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Należy rzutować to <xref:System.Net.EndPoint> <xref:System.Net.IPEndPoint> przed pobraniem jakichkolwiek informacji. Następnie można wywołać <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> metodę w celu pobrania lokalnego <xref:System.Net.IPAddress>i <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> metody pobrania numeru portu lokalnego.  
  
 Właściwość jest zazwyczaj ustawiana po wywołaniu <xref:System.Net.Sockets.Socket.Bind%2A> metody. <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Jeśli zezwolisz systemowi na przypisanie lokalnego adresu IP i numeru portu gniazda, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwość zostanie ustawiona po pierwszej operacji we/wy. W przypadku protokołów zorientowanych na połączenia pierwszą operacją we/wy będzie wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> metody lub. <xref:System.Net.Sockets.Socket.Accept%2A> W przypadku protokołów bezpołączeniowych Pierwsza operacja we/wy będzie dowolna z wywołań wysyłania lub odbierania.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera i wyświetla lokalne i zdalne punkty końcowe.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy wychodzące pakiety multiemisji są dostarczane do aplikacji wysyłającej.</summary>
        <value><see langword="true" />Jeśli odbiera wychodzące pakiety multiemisji; <see langword="false" />w przeciwnym razie. <see cref="T:System.Net.Sockets.Socket" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multiemisja to skalowalna Metoda komunikacji wiele-do-wielu w Internecie. Proces subskrybuje adres multiemisji; następnie wszystkie pakiety wysyłane przez proces subskrybowany są odbierane przez każdy inny proces subskrybowany na adres multiemisji.  
  
 Ustawienie tej właściwości w gnieździe Transmission Control Protocol (TCP) nie będzie miało żadnego efektu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określającą, czy strumień <see cref="T:System.Net.Sockets.Socket" /> używa algorytmu nagle.</summary>
        <value><see langword="false" />Jeśli używa algorytmu nagle; <see langword="true" />w przeciwnym razie. <see cref="T:System.Net.Sockets.Socket" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algorytm nagle został zaprojektowany w celu zmniejszenia ruchu sieciowego przez spowodowanie, że gniazdo buforuje małe pakiety, a następnie łączy i wysyła je w jednym pakiecie w pewnych okolicznościach. Pakiet TCP składa się z 40 bajtów nagłówka i wysyłanych danych. Gdy małe pakiety danych są wysyłane przy użyciu protokołu TCP, obciążenie wynikające z nagłówka TCP może stać się znaczną częścią ruchu sieciowego. W przypadku silnie załadowanej sieci Przeciążenie wynikające z tego obciążenia może spowodować utratę datagramów i retransmisji, a także nadmierny czas propagacji spowodowany przeciążeniem. Algorytm nagle hamuje wysłanie nowych wychodzących danych TCP segmentswhen przez użytkownika, jeśli jakiekolwiek dane previouslytransmitted połączenia nie zostaną potwierdzone.  
  
 Większość aplikacji sieciowych powinna używać algorytmu nagle.  
  
 Ustawienie tej właściwości w gnieździe UDP (User Datagram Protocol) nie będzie miało żadnego efektu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.NoDelay%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu <see cref="T:System.Net.Sockets.Socket" />do elementu.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy podstawowy system operacyjny i karty sieciowe obsługują protokół internetowy w wersji 4 (IPv4).</summary>
        <value><see langword="true" />Jeśli system operacyjny i adaptery sieciowe obsługują protokół IPv4; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 System operacyjny może obsługiwać zarówno Protokoły IPv4, jak i IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy podstawowy system operacyjny i karty sieciowe obsługują protokół internetowy w wersji 6 (IPv6).</summary>
        <value><see langword="true" />Jeśli system operacyjny i karty sieciowe obsługują protokół IPv6; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 System operacyjny może obsługiwać zarówno Protokoły IPv4, jak i IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="microSeconds">Czas oczekiwania na odpowiedź w mikrosekundach.</param>
        <param name="mode">Jedna z <see cref="T:System.Net.Sockets.SelectMode" /> wartości.</param>
        <summary>Określa stan <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Stan <see cref="T:System.Net.Sockets.Socket" /> na podstawie wartości trybu sondowania przekazaną <paramref name="mode" /> w parametrze.  
  
 <list type="table"><listheader><term> Tryb 
 </term><description> Wartość zwracana 
 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><see langword="true" />Jeśli <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> został wywołany, a połączenie jest w stanie oczekiwania; 
—lub— 
 <see langword="true" />Jeśli dane są dostępne do odczytu; 
—lub— 
 <see langword="true" />Jeśli połączenie zostało zamknięte, zresetowane lub przerwane; 
w przeciwnym razie <see langword="false" />zwraca.  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><see langword="true" />, w przypadku przetwarzania <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />a, a połączenie zakończyło się pomyślnie; 
—lub— 
 <see langword="true" />Jeśli dane mogą być wysyłane; 
w przeciwnym razie <see langword="false" />zwraca.  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description><see langword="true" />Jeśli przetwarzanie <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> , które nie jest blokowane, a połączenie nie powiodło się; 
—lub— 
 <see langword="true" />Jeśli <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> nie jest ustawiona i dostępne są dane poza pasmem; 
w przeciwnym razie <see langword="false" />zwraca.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda sprawdzi stan <xref:System.Net.Sockets.Socket>. <xref:System.Net.Sockets.Socket.Poll%2A> Określ <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> parametr, aby określić, <xref:System.Net.Sockets.Socket> czy ma być możliwy do odczytu. `selectMode` Określ <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> , aby określić, <xref:System.Net.Sockets.Socket> czy ma być zapisywalny. Użyj <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> , aby wykryć warunek błędu. <xref:System.Net.Sockets.Socket.Poll%2A>spowoduje zablokowanie wykonania do określonego przedziału czasu `microseconds`, mierzoną w, upłynie. `microSeconds` Ustaw parametr na ujemną liczbę całkowitą, jeśli chcesz czekać w nieskończoność na odpowiedź. Jeśli chcesz sprawdzić stan wielu gniazd, warto użyć <xref:System.Net.Sockets.Socket.Select%2A> metody.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ta metoda nie może wykryć niektórych rodzajów problemów z połączeniami, takich jak przerwany kabel sieciowy lub że host zdalny został zamknięty nieprawidłowo. Należy podjąć próbę wysłania lub odebrania danych w celu wykrycia tego rodzaju błędów.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy gniazdo, nawiązuje połączenie z serwerem i używa <xref:System.Net.Sockets.Socket.Poll%2A> do sprawdzenia stanu gniazda.  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Parametr nie jest jedną <see cref="T:System.Net.Sockets.SelectMode" /> z wartości. <paramref name="mode" /></exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ <see cref="T:System.Net.Sockets.Socket" />protokołu.</summary>
        <value>Jedna z <see cref="T:System.Net.Sockets.ProtocolType" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest ustawiana <xref:System.Net.Sockets.Socket> podczas tworzenia i określa protokół używany przez program <xref:System.Net.Sockets.Socket>. <xref:System.Net.Sockets.Socket.ProtocolType%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, i <xref:System.Net.Sockets.ProtocolType> do konsoli programu.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odbiera dane z powiązania <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</param>
        <summary>Odbiera dane ze powiązanego <see cref="T:System.Net.Sockets.Socket" /> buforu odbioru.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczytuje dane do parametru buforu i zwraca liczbę pomyślnie odczytywanych bajtów. Można wywoływać <xref:System.Net.Sockets.Socket.Receive%2A> zarówno gniazda zorientowane na połączenia, jak i bezpołączeni.  
  
 To Przeciążenie wymaga tylko podania buforu odbioru. Wartość domyślna przesunięcia buforu równa 0, rozmiar domyślny to długość parametru buforu, a wartością <xref:System.Net.Sockets.SocketFlags> <xref:System.Net.Sockets.SocketFlags.None>domyślną jest.  
  
 W przypadku korzystania z protokołu zorientowanego na połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym lub <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenie przychodzące przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. Metoda będzie odczytywać tylko dane przychodzące z hosta zdalnego ustanowione <xref:System.Net.Sockets.Socket.Connect%2A> w lub <xref:System.Net.Sockets.Socket.Accept%2A> w metodzie. <xref:System.Net.Sockets.Socket.Receive%2A> Jeśli używasz bezpołączeniowego protokołu, możesz również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>pozwoli Ci odbierać dane przychodzące z dowolnego hosta.  
  
 Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie Zablokowani do momentu udostępnienia danych, chyba że wartość limitu czasu została ustawiona <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>przy użyciu. W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Receive%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość. Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w buforze stosu protokołu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie zakończona natychmiast i <xref:System.Net.Sockets.SocketException>zostanie wyświetlona. Możesz użyć właściwości, <xref:System.Net.Sockets.Socket.Available%2A> aby określić, czy dane są dostępne do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.  
  
 Jeśli używasz zorientowanej <xref:System.Net.Sockets.Socket>na połączenie <xref:System.Net.Sockets.Socket.Receive%2A> , Metoda odczytaje tyle danych, ile jest dostępnych, aż do rozmiaru buforu. Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.  
  
 Jeśli używasz bezpołączeniowego <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> program odczytaje pierwszy datagram umieszczony w kolejce na <xref:System.Net.Sockets.Socket.Connect%2A> adres docelowy określony w metodzie. Jeśli odbierany datagram jest większy niż rozmiar `buffer` parametru, `buffer` jest wypełniany pierwszą częścią komunikatu, nadmiarowe <xref:System.Net.Sockets.SocketException> dane są tracone i zostaje zgłoszone.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu odbiera dane połączone <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z sieci. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Lista <see cref="T:System.ArraySegment`1" />s typu <see cref="T:System.Byte" /> , która zawiera odebrane dane.</param>
        <summary>Odbiera dane ze powiązanego <see cref="T:System.Net.Sockets.Socket" /> z listą buforów odbioru.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje dane do parametru buffers i zwraca liczbę pomyślnie odczytywanych bajtów. Można wywoływać zarówno gniazda zorientowane na połączenia, jak i bezpołączeni.  
  
 To Przeciążenie wymaga podania co najmniej jednego bufora odbierania.  
  
 W przypadku korzystania z protokołu zorientowanego na połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym lub <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenie przychodzące przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. Metoda będzie odczytywać tylko dane przychodzące z połączenia hosta zdalnego ustanowione <xref:System.Net.Sockets.Socket.Connect%2A> w metodzie lub <xref:System.Net.Sockets.Socket.Accept%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Jeśli używasz bezpołączeniowego protokołu, możesz również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>pozwoli Ci odbierać dane przychodzące z dowolnego hosta.  
  
 Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie Zablokowani do momentu udostępnienia danych, chyba że wartość limitu czasu została ustawiona <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>przy użyciu. W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Receive%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość. Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w buforze stosu protokołu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie zakończona natychmiast i <xref:System.Net.Sockets.SocketException>zostanie wyświetlona. Możesz użyć właściwości, <xref:System.Net.Sockets.Socket.Available%2A> aby określić, czy dane są dostępne do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.  
  
 Jeśli używasz zorientowanej <xref:System.Net.Sockets.Socket>na połączenie <xref:System.Net.Sockets.Socket.Receive%2A> , Metoda odczytaje tyle danych, ile jest dostępnych, aż do rozmiaru buforu. Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.  
  
 Jeśli używasz bezpołączeniowego <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> Odczytaj pierwszy z kolejki w kolejce na <xref:System.Net.Sockets.Socket.Connect%2A> adres docelowy określony w metodzie. Jeśli odbierany datagram jest większy niż rozmiar `buffers` parametru, `buffers` jest wypełniany pierwszą częścią komunikatu, nadmiarowe <xref:System.Net.Sockets.SocketException> dane są tracone i zostaje zgłoszone.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
 **Uwaga** Ten element członkowski wyprowadza informacje o śledzeniu po włączeniu śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="buffer" /></exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <summary>Odbiera dane ze powiązanego <see cref="T:System.Net.Sockets.Socket" /> buforu odbioru przy użyciu określonej <see cref="T:System.Net.Sockets.SocketFlags" />wartości.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczytuje dane do parametru buforu i zwraca liczbę pomyślnie odczytywanych bajtów. Można wywoływać <xref:System.Net.Sockets.Socket.Receive%2A> zarówno gniazda zorientowane na połączenia, jak i bezpołączeni.  
  
 To Przeciążenie wymaga jedynie podania buforu odbioru i niezbędne <xref:System.Net.Sockets.SocketFlags>. Wartość domyślna przesunięcia buforu to 0, a wartość domyślna to długość parametru Byte.  
  
 W przypadku korzystania z protokołu zorientowanego na połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym lub <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenie przychodzące przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. Metoda będzie odczytywać tylko dane przychodzące z hosta zdalnego ustanowione <xref:System.Net.Sockets.Socket.Connect%2A> w lub <xref:System.Net.Sockets.Socket.Accept%2A> w metodzie. <xref:System.Net.Sockets.Socket.Receive%2A> Jeśli używasz bezpołączeniowego protokołu, możesz również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>pozwoli Ci odbierać dane przychodzące z dowolnego hosta.  
  
 Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie zablokowana do momentu udostępnienia danych. Jeśli jesteś w trybie bez blokowania i w buforze stosu protokołu nie ma dostępnych danych, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie zakończona natychmiast i <xref:System.Net.Sockets.SocketException>zostanie wyświetlona. Możesz użyć właściwości, <xref:System.Net.Sockets.Socket.Available%2A> aby określić, czy dane są dostępne do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.  
  
 Jeśli używasz zorientowanej <xref:System.Net.Sockets.Socket>na połączenie <xref:System.Net.Sockets.Socket.Receive%2A> , Metoda odczyta tyle danych, ile jest dostępnych do rozmiaru buforu. Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.  
  
 Jeśli używasz bezpołączeniowego <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> Odczytaj pierwszy z kolejki w kolejce na <xref:System.Net.Sockets.Socket.Connect%2A> adres docelowy określony w metodzie. Jeśli odbierany datagram jest większy niż rozmiar `buffer` parametru, `buffer` jest wypełniany pierwszą częścią komunikatu, nadmiarowe <xref:System.Net.Sockets.SocketException> dane są tracone i zostaje zgłoszone.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu określa bufor danych i <xref:System.Net.Sockets.SocketFlags> do odbioru danych przy użyciu połączenia. <xref:System.Net.Sockets.Socket>  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z sieci. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Lista <see cref="T:System.ArraySegment`1" />s typu <see cref="T:System.Byte" /> , która zawiera odebrane dane.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <summary>Odbiera dane z powiązanego <see cref="T:System.Net.Sockets.Socket" /> z listą buforów odbioru przy użyciu określonej <see cref="T:System.Net.Sockets.SocketFlags" />wartości.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje dane do `buffers` parametru i zwraca liczbę pomyślnie odczytywanych bajtów. Można wywoływać zarówno gniazda zorientowane na połączenia, jak i bezpołączeni.  
  
 To Przeciążenie wymaga podania co najmniej jednego bufora odbierania. <xref:System.Net.Sockets.SocketFlags> Wartość Domyślna<xref:System.Net.Sockets.SocketFlags.None>to.  
  
 W przypadku korzystania z protokołu zorientowanego na połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym lub <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenie przychodzące przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. Metoda będzie odczytywać tylko dane przychodzące z połączenia hosta zdalnego ustanowione <xref:System.Net.Sockets.Socket.Connect%2A> w metodzie lub <xref:System.Net.Sockets.Socket.Accept%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Jeśli używasz bezpołączeniowego protokołu, możesz również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>pozwoli Ci odbierać dane przychodzące z dowolnego hosta.  
  
 Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie Zablokowani do momentu udostępnienia danych, chyba że wartość limitu czasu została ustawiona <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>przy użyciu. W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Receive%2A> limitu czasu wywołanie <xref:System.Net.Sockets.SocketException>wygeneruje. Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w buforze stosu protokołu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie zakończona natychmiast i <xref:System.Net.Sockets.SocketException>zostanie wyświetlona. Możesz użyć właściwości, <xref:System.Net.Sockets.Socket.Available%2A> aby określić, czy dane są dostępne do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.  
  
 Jeśli używasz zorientowanej <xref:System.Net.Sockets.Socket>na połączenie <xref:System.Net.Sockets.Socket.Receive%2A> , Metoda odczytaje tyle danych, ile jest dostępnych, aż do rozmiaru buforu. Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.  
  
 Jeśli używasz bezpołączeniowego <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> Odczytaj pierwszy z kolejki w kolejce na <xref:System.Net.Sockets.Socket.Connect%2A> adres docelowy określony w metodzie. Jeśli odbierany datagram jest większy niż rozmiar `buffers` parametru, `buffers` jest wypełniany pierwszą częścią komunikatu, nadmiarowe <xref:System.Net.Sockets.SocketException> dane są tracone i zostaje zgłoszone.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak odbierać dane połączone <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="buffers" />. Liczba jest równa zero.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z sieci. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</param>
        <param name="size">Liczba bajtów do odebrania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <summary>Odbiera określoną liczbę bajtów danych z <see cref="T:System.Net.Sockets.Socket" /> podanego w buforze odbioru przy użyciu określonego. <see cref="T:System.Net.Sockets.SocketFlags" /></summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda odczytuje dane `buffer` do parametru i zwraca liczbę pomyślnie odczytywanych bajtów. <xref:System.Net.Sockets.Socket.Receive%2A> Można wywoływać <xref:System.Net.Sockets.Socket.Receive%2A> zarówno gniazda zorientowane na połączenia, jak i bezpołączeni.  
  
 To Przeciążenie wymaga tylko podania buforu odbioru, liczby bajtów, które mają być odbierane, oraz potrzeb <xref:System.Net.Sockets.SocketFlags>.  
  
 W przypadku korzystania z protokołu zorientowanego na połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym lub <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenie przychodzące przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. Metoda będzie odczytywać tylko dane przychodzące z hosta zdalnego ustanowione <xref:System.Net.Sockets.Socket.Connect%2A> w lub <xref:System.Net.Sockets.Socket.Accept%2A> w metodzie. <xref:System.Net.Sockets.Socket.Receive%2A> Jeśli używasz bezpołączeniowego protokołu, możesz również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>pozwoli Ci odbierać dane przychodzące z dowolnego hosta.  
  
 Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie Zablokowani do momentu udostępnienia danych, chyba że wartość limitu czasu została ustawiona <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>przy użyciu. W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Receive%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość. Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w buforze stosu protokołu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie zakończona natychmiast i <xref:System.Net.Sockets.SocketException>zostanie wyświetlona. Możesz użyć właściwości, <xref:System.Net.Sockets.Socket.Available%2A> aby określić, czy dane są dostępne do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.  
  
 Jeśli używasz zorientowanym <xref:System.Net.Sockets.Socket>na połączenie <xref:System.Net.Sockets.Socket.Receive%2A> , Metoda odczytaje tyle danych, ile jest dostępnych, do liczby bajtów określonej przez `size` parametr. Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.  
  
 Jeśli używasz bezpołączeniowego <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> program odczytaje pierwszy datagram umieszczony w kolejce na <xref:System.Net.Sockets.Socket.Connect%2A> adres docelowy określony w metodzie. Jeśli odbierany datagram jest większy niż rozmiar `buffer` parametru, `buffer` jest wypełniany pierwszą częścią komunikatu, nadmiarowe <xref:System.Net.Sockets.SocketException> dane są tracone i zostaje zgłoszone.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniżej odbiera dane Znalezione w `buffer`i określa <xref:System.Net.Sockets.SocketFlags.None> dla <xref:System.Net.Sockets.SocketFlags>.  
  
 [!code-cpp[Socket_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" />przekracza rozmiar <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z sieci. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Lista <see cref="T:System.ArraySegment`1" />s typu <see cref="T:System.Byte" /> , która zawiera odebrane dane.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="errorCode"><see cref="T:System.Net.Sockets.SocketError" /> Obiekt, który przechowuje błąd gniazda.</param>
        <summary>Odbiera dane z powiązanego <see cref="T:System.Net.Sockets.Socket" /> z listą buforów odbioru przy użyciu określonej <see cref="T:System.Net.Sockets.SocketFlags" />wartości.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje dane do `buffers` parametru i zwraca liczbę pomyślnie odczytywanych bajtów. Można wywoływać zarówno gniazda zorientowane na połączenia, jak i bezpołączeni.  
  
 To Przeciążenie wymaga podania co najmniej jednego bufora odbierania. <xref:System.Net.Sockets.SocketFlags> Wartość Domyślna<xref:System.Net.Sockets.SocketFlags.None>to.  
  
 W przypadku korzystania z protokołu zorientowanego na połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym lub <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenie przychodzące przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. Metoda będzie odczytywać tylko dane przychodzące z połączenia hosta zdalnego ustanowione <xref:System.Net.Sockets.Socket.Connect%2A> w metodzie lub <xref:System.Net.Sockets.Socket.Accept%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Jeśli używasz bezpołączeniowego protokołu, możesz również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>pozwoli Ci odbierać dane przychodzące z dowolnego hosta.  
  
 Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie Zablokowani do momentu udostępnienia danych, chyba że wartość limitu czasu została ustawiona <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>przy użyciu. W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Receive%2A> limitu czasu wywołanie <xref:System.Net.Sockets.SocketException>wygeneruje. Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w buforze stosu protokołu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie zakończona natychmiast i <xref:System.Net.Sockets.SocketException>zostanie wyświetlona. Możesz użyć właściwości, <xref:System.Net.Sockets.Socket.Available%2A> aby określić, czy dane są dostępne do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.  
  
 Jeśli używasz zorientowanej <xref:System.Net.Sockets.Socket>na połączenie <xref:System.Net.Sockets.Socket.Receive%2A> , Metoda odczytaje tyle danych, ile jest dostępnych, aż do rozmiaru buforu. Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.  
  
 Jeśli używasz bezpołączeniowego <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> program odczytaje pierwszy datagram umieszczony w kolejce na <xref:System.Net.Sockets.Socket.Connect%2A> adres docelowy określony w metodzie. Jeśli odbierany datagram jest większy niż rozmiar `buffers` parametru, `buffers` jest wypełniany pierwszą częścią komunikatu, nadmiarowe <xref:System.Net.Sockets.SocketException> dane są tracone i zostaje zgłoszone.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="buffers" />. Liczba jest równa zero.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z sieci. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</param>
        <param name="offset">Lokalizacja w programie <paramref name="buffer" /> do przechowywania odebranych danych.</param>
        <param name="size">Liczba bajtów do odebrania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <summary>Odbiera określoną liczbę bajtów od powiązanej <see cref="T:System.Net.Sockets.Socket" /> do określonej pozycji przesunięcia buforu odbioru, używając określonej <see cref="T:System.Net.Sockets.SocketFlags" />wartości.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczytuje dane do parametru buforu i zwraca liczbę pomyślnie odczytywanych bajtów. Można wywoływać <xref:System.Net.Sockets.Socket.Receive%2A> zarówno gniazda zorientowane na połączenia, jak i bezpołączeni.  
  
 W przypadku korzystania z protokołu zorientowanego na połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym lub <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenie przychodzące przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. Metoda będzie odczytywać tylko dane przychodzące z hosta zdalnego ustanowione <xref:System.Net.Sockets.Socket.Connect%2A> w lub <xref:System.Net.Sockets.Socket.Accept%2A> w metodzie. <xref:System.Net.Sockets.Socket.Receive%2A> Jeśli używasz bezpołączeniowego protokołu, możesz również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>pozwoli Ci odbierać dane przychodzące z dowolnego hosta.  
  
 Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie Zablokowani do momentu udostępnienia danych, chyba że wartość limitu czasu została ustawiona <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>przy użyciu. W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Receive%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość. Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w buforze stosu protokołu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie zakończona natychmiast i <xref:System.Net.Sockets.SocketException>zostanie wyświetlona. Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej. Możesz użyć właściwości, <xref:System.Net.Sockets.Socket.Available%2A> aby określić, czy dane są dostępne do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.  
  
 Jeśli używasz zorientowanej <xref:System.Net.Sockets.Socket>na połączenie <xref:System.Net.Sockets.Socket.Receive%2A> , Metoda odczytaje tyle danych, ile jest dostępnych, do liczby bajtów określonej przez parametr size. Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.  
  
 Jeśli używasz bezpołączeniowego <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> program odczytaje pierwszy datagram umieszczony w kolejce na <xref:System.Net.Sockets.Socket.Connect%2A> adres docelowy określony w metodzie. Jeśli odbierany datagram jest większy niż rozmiar `buffer` parametru, `buffer` jest wypełniany pierwszą częścią komunikatu, nadmiarowe <xref:System.Net.Sockets.SocketException> dane są tracone i zostaje zgłoszone.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu określa bufor danych, przesunięcie, rozmiar i flagę gniazda przed odebraniem danych w połączonym <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" />jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" />nie jest prawidłową kombinacją wartości.  
  
—lub— 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> Właściwość nie została ustawiona.  
  
—lub— 
Wystąpił błąd systemu operacyjnego podczas uzyskiwania dostępu <see cref="T:System.Net.Sockets.Socket" />do programu.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z sieci. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</param>
        <param name="offset">Pozycja w <paramref name="buffer" /> parametrze do przechowywania odebranych danych.</param>
        <param name="size">Liczba bajtów do odebrania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="errorCode"><see cref="T:System.Net.Sockets.SocketError" /> Obiekt, który przechowuje błąd gniazda.</param>
        <summary>Odbiera dane ze powiązanego <see cref="T:System.Net.Sockets.Socket" /> buforu odbioru przy użyciu określonej <see cref="T:System.Net.Sockets.SocketFlags" />wartości.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczytuje dane do parametru buforu i zwraca liczbę pomyślnie odczytywanych bajtów. Można wywoływać <xref:System.Net.Sockets.Socket.Receive%2A> zarówno gniazda zorientowane na połączenia, jak i bezpołączeni.  
  
 W przypadku korzystania z protokołu zorientowanego na połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym lub <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenie przychodzące przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. Metoda będzie odczytywać tylko dane przychodzące z hosta zdalnego ustanowione <xref:System.Net.Sockets.Socket.Connect%2A> w lub <xref:System.Net.Sockets.Socket.Accept%2A> w metodzie. <xref:System.Net.Sockets.Socket.Receive%2A> Jeśli używasz bezpołączeniowego protokołu, możesz również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>pozwoli Ci odbierać dane przychodzące z dowolnego hosta.  
  
 Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie Zablokowani do momentu udostępnienia danych, chyba że wartość limitu czasu została ustawiona <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>przy użyciu. W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Receive%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość. Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w buforze stosu protokołu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie zakończona natychmiast i <xref:System.Net.Sockets.SocketException>zostanie wyświetlona. Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej. Możesz użyć właściwości, <xref:System.Net.Sockets.Socket.Available%2A> aby określić, czy dane są dostępne do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.  
  
 Jeśli używasz zorientowanej <xref:System.Net.Sockets.Socket>na połączenie <xref:System.Net.Sockets.Socket.Receive%2A> , Metoda odczytaje tyle danych, ile jest dostępnych, do liczby bajtów określonej przez parametr size. Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.  
  
 Jeśli używasz bezpołączeniowego <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> program odczytaje pierwszy datagram umieszczony w kolejce na <xref:System.Net.Sockets.Socket.Connect%2A> adres docelowy określony w metodzie. Jeśli odbierany datagram jest większy niż rozmiar `buffer` parametru, `buffer` jest wypełniany pierwszą częścią komunikatu, nadmiarowe <xref:System.Net.Sockets.SocketException> dane są tracone i zostaje zgłoszone.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" />jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" />nie jest prawidłową kombinacją wartości.  
  
—lub— 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> Właściwość nie jest ustawiona.  
  
—lub— 
Wystąpił błąd systemu operacyjnego podczas uzyskiwania dostępu <see cref="T:System.Net.Sockets.Socket" />do programu.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z sieci. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Obiekt <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> , który ma być używany dla tej asynchronicznej operacji gniazda.</param>
        <summary>Rozpoczyna asynchroniczne żądanie odbierania danych z połączonego <see cref="T:System.Net.Sockets.Socket" /> obiektu.</summary>
        <returns><see langword="true" />Jeśli operacja we/wy jest w stanie oczekiwania. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie<paramref name="e" /> na parametrze zostanie wywołane po zakończeniu operacji.  
  
 <see langword="false" />Jeśli operacja we/wy została ukończona synchronicznie. W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie <paramref name="e" /> na parametrze <paramref name="e" /> nie zostanie zgłoszone i obiekt przenoszony jako parametr może zostać zbadany natychmiast po wywołaniu metody, aby pobrać wynik operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> Metoda jest używana w podłączonych gniazdach lub powiązanych gniazdach bezpołączeni i służy do odczytywania danych przychodzących. Adres lokalny gniazda musi być znany.  
  
 W przypadku powiązanych bezpołączeniowych gniazd ta funkcja ogranicza adresy, z których odebrane komunikaty są akceptowane. Funkcja zwraca tylko komunikaty z adresu zdalnego określonego w połączeniu. Komunikaty z innych adresów są dyskretnie odrzucane.  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> Właściwość`e` parametru udostępnia dostawcy usługi okna Sockets z dodatkowymi informacjami na temat żądania odczytu. Aby uzyskać więcej informacji na temat korzystania z tego parametru, <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>Zobacz.  
  
 Następujące właściwości i zdarzenia w <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiekcie są wymagane do pomyślnego wywołania tej metody:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> lub <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>Jeśli <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> jest ustawiona  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>Jeśli <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> jest ustawiona  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość na dowolny obiekt stanu użytkownika przed <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> wywołaniem metody, tak aby informacje były możliwe do pobierania w metodzie wywołania zwrotnego. Jeśli wywołanie zwrotne wymaga więcej informacji niż pojedynczy obiekt, można utworzyć małą klasę w celu przechowywania innych wymaganych informacji o stanie jako członków.  
  
 W przypadku gniazd typu Byte-styl strumień dane przychodzące są umieszczane w buforze do momentu wypełnienia buforu, połączenie jest zamknięte lub wyczerpanie wewnętrznie dane buforowane.  
  
 W przypadku gniazd zorientowanych na komunikaty przychodzący komunikat jest umieszczany w buforze do całkowitego rozmiaru buforu skojarzonego z `e` parametrem. Jeśli komunikat jest większy niż bufor, bufor zostanie wypełniony pierwszą częścią komunikatu.  
  
 W przypadku gniazd <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> zorientowanych na połączenia Metoda może wskazywać łagodne zakończenie obwodu wirtualnego w jednym z dwóch sposobów, które zależą od tego, czy gniazdo jest strumieniem typu Byte lub zorientowanym na komunikaty. W przypadku strumieni bajtowych zero bajty, które zostały odczytane, wskazuje na bezpieczne zamknięcie i nie będzie można odczytać więcej bajtów. W przypadku gniazd zorientowanych na komunikaty, gdzie komunikat o wartości zero jest często dozwolony, a <xref:System.Net.Sockets.SocketException> <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> z zestawem dla natywnego kodu błędu Winsock WSAEDISCON (10101) jest używany do wskazania bezpiecznego zamknięcia. W każdym przypadku a <xref:System.Net.Sockets.SocketException> <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> z zestawem dla natywnego kodu błędu Winsock WSAECONNRESET (10054) wskazuje, że wystąpiło zamknięcie przerwania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nieprawidłowy argument. Właściwości <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> <paramref name="e" /> lub <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> parametru muszą odwoływać się do prawidłowych buforów. Można ustawić jedną lub drugą z tych właściwości, ale nie oba jednocześnie.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja gniazda była już w toku przy użyciu <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiektu określonego <paramref name="e" /> w parametrze.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda wymaga systemu Windows XP lub nowszego.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą rozmiar buforu <see cref="T:System.Net.Sockets.Socket" />odbioru.</summary>
        <value>, <see cref="T:System.Int32" /> Który zawiera rozmiar (w bajtach) bufora odbierania. Wartość domyślna to 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Większy rozmiar buforu może spowodować zmniejszenie liczby pustych potwierdzeń (pakietów TCP bez części danych), ale także opóźnić Rozpoznawanie problemów z połączeniem. Należy rozważyć zwiększenie rozmiaru buforu w przypadku transferu dużych plików lub korzystania z dużej przepustowości i połączenia o dużej opóźnieniu (na przykład satelitarnego dostawcy sieci szerokopasmowej).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona dla operacji zestawu jest mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odbiera datagram i przechowuje źródłowy punkt końcowy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] *  -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</param>
        <param name="remoteEP">Element <see cref="T:System.Net.EndPoint" />, który został przesłany przez odwołanie, reprezentujący serwer zdalny.</param>
        <summary>Odbiera datagram w buforze danych i przechowuje punkt końcowy.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda odczytuje dane `buffer` do parametru, zwraca liczbę pomyślnie odczytywanych bajtów i przechwytuje punkt końcowy hosta, z którego dane zostały wysłane. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Ta metoda jest przydatna, jeśli zamierzasz otrzymywać bezpołączeni datagramy z nieznanego hosta lub wielu hostów.  
  
 To Przeciążenie wymaga jedynie podania odbioru `buffer` <xref:System.Net.EndPoint> i reprezentuje hosta zdalnego. Wartość domyślna przesunięcia buforu równa 0. Wartością domyślną jest długość `buffer` parametru `socketFlags` i wartość domyślna <xref:System.Net.Sockets.SocketFlags.None>to.  
  
> [!NOTE]
>  Przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>należy jawnie <xref:System.Net.Sockets.Socket> powiązać do lokalnego punktu końcowego przy użyciu <xref:System.Net.Sockets.Socket.Bind%2A> metody. Jeśli tego nie zrobisz, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> zostanie <xref:System.Net.Sockets.SocketException>zgłoszony.  
  
 W przypadku protokołów bez <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> połączenia program odczyta pierwszy zakolejce datagram otrzymany do buforu sieci lokalnej. Jeśli odbierany datagram jest większy `buffer`niż rozmiar <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> , Metoda wypełni `buffer` tyle <xref:System.Net.Sockets.SocketException>wiadomości jak to możliwe, i wygeneruje. Jeśli korzystasz z wiarygodnego protokołu, nadmiarowe dane zostaną utracone. Jeśli używasz niezawodnego protokołu, nadwyżkowe dane będą przechowywane przez dostawcę usługi i można je pobrać, wywołując <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodę z wystarczającą ilością buforu.  
  
 Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda zostanie zablokowana do momentu udostępnienia danych. Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w buforze stosu protokołu, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda zostanie zakończona natychmiast i <xref:System.Net.Sockets.SocketException>zostanie wyświetlona. Możesz użyć właściwości, <xref:System.Net.Sockets.Socket.Available%2A> aby określić, czy dane są dostępne do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.  
  
 Chociaż <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> jest przeznaczony dla protokołów bezpołączeniowych, można również użyć protokołu z zorientowanymi połączeniami. Jeśli zdecydujesz się to zrobić, musisz najpierw nawiązać połączenie z hostem zdalnym, wywołując <xref:System.Net.Sockets.Socket.Connect%2A> metodę lub akceptując przychodzące połączenie hosta zdalnego przez <xref:System.Net.Sockets.Socket.Accept%2A> wywołanie metody. Jeśli połączenie nie zostanie nawiązane przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody, <xref:System.Net.Sockets.SocketException>otrzymasz. Przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody można również ustanowić domyślnego hosta zdalnego dla bezpołączeniowego protokołu. W każdym z tych przypadków <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda `remoteEP` zignoruje parametr i będzie odbierać tylko dane z podłączonego lub domyślnego hosta zdalnego.  
  
 W przypadku gniazd zorientowanych na połączenia <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> program odczyta tyle danych, ile jest dostępnych do `buffer`rozmiaru. Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> Używanywprogramie<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> musi być zgodny zużytym<xref:System.Net.Sockets.Socket.SendTo%2A>w. <xref:System.Net.EndPoint> <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu odbiera bezpołączeniowy datagram z hosta zdalnego.  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="remoteEP" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z sieci. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP">Element <see cref="T:System.Net.EndPoint" />, który został przesłany przez odwołanie, reprezentujący serwer zdalny.</param>
        <summary>Odbiera datagram do buforu danych przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />i przechowuje punkt końcowy.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda odczytuje dane `buffer` do parametru, zwraca liczbę pomyślnie odczytywanych bajtów i przechwytuje punkt końcowy hosta, z którego dane zostały wysłane. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Ta metoda jest przydatna, jeśli zamierzasz otrzymywać bezpołączeni datagramy z nieznanego hosta lub wielu hostów.  
  
 To Przeciążenie wymaga jedynie podania buforu odbioru, niezbędnego <xref:System.Net.Sockets.SocketFlags> <xref:System.Net.EndPoint> i reprezentującego hosta zdalnego. Wartość domyślna przesunięcia to 0, a rozmiar domyślny to długość parametru buforu.  
  
> [!NOTE]
>  Przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>należy jawnie <xref:System.Net.Sockets.Socket> powiązać do lokalnego punktu końcowego przy użyciu <xref:System.Net.Sockets.Socket.Bind%2A> metody. Jeśli tego nie zrobisz, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> zostanie <xref:System.Net.Sockets.SocketException>zgłoszony.  
  
 W przypadku protokołów bez <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> połączenia program odczyta pierwszy zakolejce datagram otrzymany do buforu sieci lokalnej. Jeśli odbierany datagram jest większy `buffer`niż rozmiar <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> , Metoda wypełni `buffer` tyle <xref:System.Net.Sockets.SocketException>wiadomości jak to możliwe, i wygeneruje. Jeśli korzystasz z wiarygodnego protokołu, nadmiarowe dane zostaną utracone. Jeśli używasz niezawodnego protokołu, nadwyżkowe dane będą przechowywane przez dostawcę usługi i można je pobrać, wywołując <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodę z wystarczającą ilością buforu.  
  
 Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda zostanie zablokowana do momentu udostępnienia danych. Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w buforze stosu protokołu, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda zostanie zakończona natychmiast i <xref:System.Net.Sockets.SocketException>zostanie wyświetlona. Możesz użyć właściwości, <xref:System.Net.Sockets.Socket.Available%2A> aby określić, czy dane są dostępne do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.  
  
 Chociaż <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> jest przeznaczony dla protokołów bezpołączeniowych, można również użyć protokołu z zorientowanymi połączeniami. Jeśli zdecydujesz się to zrobić, musisz najpierw nawiązać połączenie z hostem zdalnym, wywołując <xref:System.Net.Sockets.Socket.Connect%2A> metodę lub akceptując przychodzące połączenie hosta zdalnego przez <xref:System.Net.Sockets.Socket.Accept%2A> wywołanie metody. Jeśli połączenie nie zostanie nawiązane przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody, <xref:System.Net.Sockets.SocketException>otrzymasz. Przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody można również ustanowić domyślnego hosta zdalnego dla bezpołączeniowego protokołu. W każdym z tych przypadków <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda `remoteEP` zignoruje parametr i będzie odbierać tylko dane z podłączonego lub domyślnego hosta zdalnego.  
  
 W przypadku gniazd zorientowanych na połączenia <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> program odczyta tyle danych, ile jest dostępnych do `buffer`rozmiaru. Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> Używanywprogramie<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> musi być zgodny zużytym<xref:System.Net.Sockets.Socket.SendTo%2A>w. <xref:System.Net.EndPoint> <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu odbiera bezpołączeniowy datagram z hosta zdalnego. <xref:System.Net.Sockets.SocketFlags>są przesyłane do <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody.  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="remoteEP" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z sieci. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</param>
        <param name="size">Liczba bajtów do odebrania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP">Element <see cref="T:System.Net.EndPoint" />, który został przesłany przez odwołanie, reprezentujący serwer zdalny.</param>
        <summary>Odbiera określoną liczbę bajtów w buforze danych przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />i przechowuje punkt końcowy.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda odczytuje dane `buffer` do parametru, zwraca liczbę pomyślnie odczytywanych bajtów i przechwytuje punkt końcowy hosta, z którego dane zostały wysłane. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Ta metoda jest przydatna, jeśli zamierzasz otrzymywać bezpołączeni datagramy z nieznanego hosta lub wielu hostów.  
  
 To Przeciążenie wymaga jedynie podania buforu odbioru, liczby bajtów, które mają być odbierane, niezbędne <xref:System.Net.Sockets.SocketFlags> <xref:System.Net.EndPoint> i reprezentujących hosta zdalnego. Wartość domyślna przesunięcia buforu równa 0.  
  
 W przypadku protokołów bez <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> połączenia program odczyta pierwszy zakolejce datagram otrzymany do buforu sieci lokalnej. Jeśli odbierany datagram jest większy `buffer`niż rozmiar <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> , Metoda wypełni `buffer` tyle <xref:System.Net.Sockets.SocketException>wiadomości jak to możliwe, i wygeneruje. Jeśli korzystasz z wiarygodnego protokołu, nadmiarowe dane zostaną utracone. Jeśli używasz niezawodnego protokołu, nadwyżkowe dane będą przechowywane przez dostawcę usługi i można je pobrać, wywołując <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodę z wystarczającą ilością buforu.  
  
 Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda zostanie zablokowana do momentu udostępnienia danych. Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w buforze stosu protokołu, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda zostanie zakończona natychmiast i <xref:System.Net.Sockets.SocketException>zostanie wyświetlona. Możesz użyć właściwości, <xref:System.Net.Sockets.Socket.Available%2A> aby określić, czy dane są dostępne do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.  
  
 Chociaż <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> jest przeznaczony dla protokołów bezpołączeniowych, można również użyć protokołu z zorientowanymi połączeniami. Jeśli zdecydujesz się to zrobić, musisz najpierw nawiązać połączenie z hostem zdalnym, wywołując <xref:System.Net.Sockets.Socket.Connect%2A> metodę lub akceptując przychodzące połączenie hosta zdalnego przez <xref:System.Net.Sockets.Socket.Accept%2A> wywołanie metody. Jeśli połączenie nie zostanie nawiązane przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody, <xref:System.Net.Sockets.SocketException>otrzymasz. Przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody można również ustanowić domyślnego hosta zdalnego dla bezpołączeniowego protokołu. W każdym z tych przypadków <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda `remoteEP` zignoruje parametr i będzie odbierać tylko dane z podłączonego lub domyślnego hosta zdalnego.  
  
 W przypadku gniazd zorientowanych na połączenia <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> program odczyta tyle danych, ile jest dostępnych do liczby bajtów określonej `size` przez parametr. Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.  
  
> [!NOTE]
>  Przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>należy jawnie <xref:System.Net.Sockets.Socket> powiązać do lokalnego punktu końcowego przy użyciu <xref:System.Net.Sockets.Socket.Bind%2A> metody. Jeśli tego nie zrobisz, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> zostanie <xref:System.Net.Sockets.SocketException>zgłoszony. Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> Używanywprogramie<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> musi być zgodny zużytym<xref:System.Net.Sockets.Socket.SendTo%2A>w. <xref:System.Net.EndPoint> <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu odbiera bezpołączeniowy datagram z hosta zdalnego. Rozmiar buforu i <xref:System.Net.Sockets.SocketFlags> są przesyłane <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> do metody.  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="remoteEP" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" />jest większa niż długość <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" />nie jest prawidłową kombinacją wartości.  
  
—lub— 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> Właściwość nie została ustawiona.  
  
—lub— 
Wystąpił błąd systemu operacyjnego podczas uzyskiwania dostępu <see cref="T:System.Net.Sockets.Socket" />do programu.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z sieci. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</param>
        <param name="offset">Pozycja w <paramref name="buffer" /> parametrze do przechowywania odebranych danych.</param>
        <param name="size">Liczba bajtów do odebrania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP">Element <see cref="T:System.Net.EndPoint" />, który został przesłany przez odwołanie, reprezentujący serwer zdalny.</param>
        <summary>Odbiera określoną liczbę bajtów danych w określonej lokalizacji w buforze danych, używając określonego <see cref="T:System.Net.Sockets.SocketFlags" />i zapisuje punkt końcowy.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda odczytuje dane `buffer` do parametru, zwraca liczbę pomyślnie odczytywanych bajtów i przechwytuje punkt końcowy hosta, z którego dane zostały wysłane. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Ta metoda jest przydatna, jeśli zamierzasz otrzymywać bezpołączeni datagramy z nieznanego hosta lub wielu hostów.  
  
 W przypadku protokołów bez <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> połączenia program odczyta pierwszy zakolejce datagram otrzymany do buforu sieci lokalnej. Jeśli odbierany datagram jest większy `buffer`niż rozmiar <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> , Metoda wypełni `buffer` tyle <xref:System.Net.Sockets.SocketException>wiadomości jak to możliwe, i wygeneruje. Jeśli korzystasz z wiarygodnego protokołu, nadmiarowe dane zostaną utracone. Jeśli używasz niezawodnego protokołu, nadwyżkowe dane będą przechowywane przez dostawcę usługi i można je pobrać, wywołując <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodę z wystarczającą ilością buforu.  
  
 Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda zostanie zablokowana do momentu udostępnienia danych. Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w buforze stosu protokołu, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda zostanie zakończona natychmiast i <xref:System.Net.Sockets.SocketException>zostanie wyświetlona. Możesz użyć właściwości, <xref:System.Net.Sockets.Socket.Available%2A> aby określić, czy dane są dostępne do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.  
  
 Chociaż <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> jest przeznaczony dla protokołów bezpołączeniowych, można również użyć protokołu z zorientowanymi połączeniami. Jeśli zdecydujesz się to zrobić, musisz najpierw nawiązać połączenie z hostem zdalnym, wywołując <xref:System.Net.Sockets.Socket.Connect%2A> metodę lub akceptując przychodzące połączenie hosta zdalnego przez <xref:System.Net.Sockets.Socket.Accept%2A> wywołanie metody. Jeśli połączenie nie zostanie nawiązane przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody, <xref:System.Net.Sockets.SocketException>otrzymasz. Przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody można również ustanowić domyślnego hosta zdalnego dla bezpołączeniowego protokołu. W każdym z tych przypadków <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda `remoteEP` zignoruje parametr i będzie odbierać tylko dane z podłączonego lub domyślnego hosta zdalnego.  
  
 W przypadku gniazd zorientowanych na połączenia <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> program będzie odczytywać tyle danych, ile jest dostępnych do wielkości bajtów określonych `size` przez parametr. Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.  
  
> [!NOTE]
>  Przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>należy jawnie <xref:System.Net.Sockets.Socket> powiązać do lokalnego punktu końcowego przy użyciu <xref:System.Net.Sockets.Socket.Bind%2A> metody. Jeśli tego nie zrobisz, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> zostanie <xref:System.Net.Sockets.SocketException>zgłoszony. Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> Używanywprogramie<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> musi być zgodny zużytym<xref:System.Net.Sockets.Socket.SendTo%2A>w. <xref:System.Net.EndPoint> <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu odbiera bezpołączeniowy datagram z hosta zdalnego. Przesunięcie, rozmiar buforu i <xref:System.Net.Sockets.SocketFlags> są przesyłane <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> do metody.  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="remoteEP" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" />jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości parametru przesunięcia.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" />nie jest prawidłową kombinacją wartości.  
  
—lub— 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> Właściwość nie została ustawiona.  
  
—lub— 
Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z sieci. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Obiekt <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> , który ma być używany dla tej asynchronicznej operacji gniazda.</param>
        <summary>Rozpoczyna asynchroniczne odbieranie danych z określonego urządzenia sieciowego.</summary>
        <returns><see langword="true" />Jeśli operacja we/wy jest w stanie oczekiwania. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie<paramref name="e" /> na parametrze zostanie wywołane po zakończeniu operacji.  
  
 <see langword="false" />Jeśli operacja we/wy została ukończona synchronicznie. W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie <paramref name="e" /> na parametrze <paramref name="e" /> nie zostanie zgłoszone i obiekt przenoszony jako parametr może zostać zbadany natychmiast po wywołaniu metody, aby pobrać wynik operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> Metoda jest używana głównie do odbierania danych w bezpołączeniowym gnieździe. Adres lokalny gniazda musi być znany.  
  
 Obiekt wywołujący musi ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Właściwość <xref:System.Net.IPEndPoint> na hoście zdalnym, z którego mają zostać odebrane dane.  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> Właściwość`e` parametru udostępnia dostawcy usługi okna Sockets z dodatkowymi informacjami na temat żądania odczytu. Aby uzyskać więcej informacji na temat korzystania z tego parametru, <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>Zobacz.  
  
 Następujące właściwości i zdarzenia w <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiekcie są wymagane do pomyślnego wywołania tej metody:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość na dowolny obiekt stanu użytkownika przed <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> wywołaniem metody, tak aby informacje były możliwe do pobierania w metodzie wywołania zwrotnego. Jeśli wywołanie zwrotne wymaga więcej informacji niż pojedynczy obiekt, można utworzyć małą klasę w celu przechowywania innych wymaganych informacji o stanie jako członków.  
  
 W przypadku gniazd zorientowanych na komunikaty przychodzący komunikat jest umieszczany w buforze do całkowitego rozmiaru buforu. Właściwości <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> i<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> określają, gdzie w buforze umieszczane są dane oraz ilość danych.  
  
 W przypadku gniazd typu Byte-styl strumień dane przychodzące są umieszczane w buforze do momentu wypełnienia buforu, połączenie jest zamknięte lub wyczerpanie wewnętrznie dane buforowane. Właściwości <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> i<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> określają, gdzie w buforze umieszczane są dane oraz ilość danych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> Nie może mieć wartości null.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja gniazda była już w toku przy użyciu <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiektu określonego <paramref name="e" /> w parametrze.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda wymaga systemu Windows XP lub nowszego.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int *  *  *  -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</param>
        <param name="offset">Pozycja w <paramref name="buffer" /> parametrze do przechowywania odebranych danych.</param>
        <param name="size">Liczba bajtów do odebrania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP">Element <see cref="T:System.Net.EndPoint" />, który został przesłany przez odwołanie, reprezentujący serwer zdalny.</param>
        <param name="ipPacketInformation"><see cref="T:System.Net.Sockets.IPPacketInformation" /> Adres i informacje o interfejsie.</param>
        <summary>Odbiera określoną liczbę bajtów danych w określonej lokalizacji w buforze danych, używając określonego <see cref="T:System.Net.Sockets.SocketFlags" />i zapisuje punkt końcowy oraz informacje o pakiecie.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda odczytuje dane `buffer` do parametru, zwraca liczbę pomyślnie odczytywanych bajtów i przechwytuje zdalny punkt końcowy hosta, z którego dane zostały wysłane, a także informacje o odebranym pakiecie. <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Metoda jest używana głównie do odbierania danych komunikatów w bezpołączeniowym gnieździe. Adres lokalny gniazda musi być znany. Tej metody można używać tylko z datagramami i gniazdami nieprzetworzonymi. Gniazdo musi być zainicjowane z typem gniazda ustawionym na <xref:System.Net.Sockets.SocketType.Dgram> lub <xref:System.Net.Sockets.SocketType.Raw> przed wywołaniem tej metody. Można to zrobić, gdy gniazdo jest zbudowane przy użyciu <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 W przypadku gniazd zorientowanych na komunikaty przychodzący komunikat jest umieszczany `buffer` w parametrze do całkowitego rozmiaru określonego `size` w parametrze. Parametr określa miejsce `buffer` , w którym znajdują się dane. `offset` Rzeczywista ilość danych umieszczonych w polu `buffer` jest zwracana <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> przez metodę.  
  
 Metoda automatycznie <xref:System.Net.Sockets.Socket>ustawia opcję `true` gniazda przy pierwszym wywołaniu dla danego elementu. <xref:System.Net.Sockets.SocketOptionName.PacketInformation> <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Jednak zwracany <xref:System.Net.Sockets.IPPacketInformation> obiekt będzie prawidłowy tylko dla pakietów, które docierają do komputera lokalnego po ustawieniu opcji gniazda. Jeśli gniazdo jest wysyłane <xref:System.Net.Sockets.Socket.Bind%2A> pakiety między <xref:System.Net.Sockets.Socket.Connect%2A>, gdy jest ono powiązane z lokalnym punktem końcowym (jawnie przez metodę lub niejawnie przez jedną z metod <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, lub <xref:System.Net.Sockets.Socket.SendToAsync%2A> ) i pierwsze wywołanie <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> elementu Metoda wywołania <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metody zwróci nieprawidłowe <xref:System.Net.Sockets.IPPacketInformation> obiekty dla tych pakietów.  
  
 Aby upewnić się <xref:System.Net.Sockets.IPPacketInformation> , że wszystkie obiekty są prawidłowe, aplikacja powinna <xref:System.Net.Sockets.SocketOptionName.PacketInformation> ustawić opcję gniazda `true` na przed powiązaniem z lokalnym punktem końcowym przy <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> użyciu metody.  
  
 Aplikacja może sprawdzić parametr, `ipPacketInformation` Jeśli musi wiedzieć, czy datagram został wysłany przy użyciu adresu emisji pojedynczej, multiemisji lub emisji.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> Używanywprogramie<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> musi być zgodny zużytym<xref:System.Net.Sockets.Socket.SendTo%2A>w. <xref:System.Net.EndPoint> <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.  
  
\-oraz 
 <paramref name="remoteEP" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" />jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości parametru przesunięcia.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" />nie jest prawidłową kombinacją wartości.  
  
—lub— 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> Właściwość nie została ustawiona.  
  
—lub— 
.NET Framework jest uruchomiona na procesorze AMD 64-bitowym.  
  
—lub— 
Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">System operacyjny to Windows 2000 lub starszy, a ta metoda wymaga systemu Windows XP.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z sieci. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e">Obiekt <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> , który ma być używany dla tej asynchronicznej operacji gniazda.</param>
        <summary>Rozpoczyna asynchroniczne odbieranie określonej liczby bajtów danych w określonej lokalizacji w buforze danych przy użyciu określonego <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />i przechowywanie informacji o punkcie końcowym i pakiecie.</summary>
        <returns><see langword="true" />Jeśli operacja we/wy jest w stanie oczekiwania. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie<paramref name="e" /> na parametrze zostanie wywołane po zakończeniu operacji.  
  
 <see langword="false" />Jeśli operacja we/wy została ukończona synchronicznie. W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie <paramref name="e" /> na parametrze <paramref name="e" /> nie zostanie zgłoszone i obiekt przenoszony jako parametr może zostać zbadany natychmiast po wywołaniu metody, aby pobrać wynik operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> Metoda jest używana głównie do odbierania danych komunikatów w bezpołączeniowym gnieździe. Adres lokalny gniazda musi być znany. Tej metody można używać tylko z datagramami i gniazdami nieprzetworzonymi. Gniazdo musi być zainicjowane z typem gniazda ustawionym na <xref:System.Net.Sockets.SocketType.Dgram> lub <xref:System.Net.Sockets.SocketType.Raw> przed wywołaniem tej metody. Można to zrobić, gdy gniazdo jest zbudowane przy użyciu <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 Obiekt wywołujący musi ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Właściwość <xref:System.Net.IPEndPoint> na hoście zdalnym, z którego mają zostać odebrane dane.  
  
 Następujące właściwości i zdarzenia w <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiekcie są wymagane do pomyślnego wywołania tej metody:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość na dowolny obiekt stanu użytkownika przed <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> wywołaniem metody, tak aby informacje były możliwe do pobierania w metodzie wywołania zwrotnego. Jeśli wywołanie zwrotne wymaga więcej informacji niż pojedynczy obiekt, można utworzyć małą klasę w celu przechowywania innych wymaganych informacji o stanie jako członków.  
  
 W przypadku gniazd zorientowanych na komunikaty przychodzący komunikat jest umieszczany w buforze do całkowitego rozmiaru buforu. Właściwości <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> i<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> określają, gdzie w buforze umieszczane są dane oraz ilość danych.  
  
 Metoda automatycznie <xref:System.Net.Sockets.Socket>ustawia opcję `true` gniazda przy pierwszym wywołaniu dla danego elementu. <xref:System.Net.Sockets.SocketOptionName.PacketInformation> <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> <xref:System.Net.Sockets.IPPacketInformation> Jednak obiekt będzie prawidłowy tylko dla pakietów, które docierają do komputera lokalnego po ustawieniu opcji gniazda. Jeśli gniazdo jest wysyłane <xref:System.Net.Sockets.Socket.Bind%2A> pakiety między <xref:System.Net.Sockets.Socket.Connect%2A>, gdy gniazdo jest powiązane z lokalnym punktem końcowym (jawnie przez metodę lub niejawnie przez jedną z metod, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>lub <xref:System.Net.Sockets.Socket.SendToAsync%2A> ) i pierwsze wywołanie elementu <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>Metoda, wywołania <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> metody powodują nieprawidłowe <xref:System.Net.Sockets.IPPacketInformation> obiekty dla tych pakietów.  
  
 Aby upewnić się <xref:System.Net.Sockets.IPPacketInformation> , że wszystkie obiekty są prawidłowe, aplikacja powinna <xref:System.Net.Sockets.SocketOptionName.PacketInformation> ustawić opcję gniazda`true` na przed powiązaniem z lokalnym punktem końcowym przy <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> użyciu metody.  
  
 Aplikacja może przeanalizować <xref:System.Net.Sockets.IPPacketInformation> obiekty, jeśli trzeba wiedzieć, czy datagram został wysłany przy użyciu adresu emisji pojedynczej, multiemisji lub emisji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> Nie może mieć wartości null.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda wymaga systemu Windows XP lub nowszego.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą czas, po upływie którego zostanie przekroczony <see cref="Overload:System.Net.Sockets.Socket.Receive" /> limit czasu wywołania synchronicznego.</summary>
        <value>Wartość limitu czasu (w milisekundach). Wartość domyślna to 0, co oznacza nieskończony limit czasu. Określenie-1 wskazuje także nieskończony limit czasu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta opcja dotyczy tylko wywołań <xref:System.Net.Sockets.Socket.Receive%2A> synchronicznych. W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Receive%2A> limitu czasu Metoda <xref:System.Net.Sockets.SocketException>wygeneruje.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona dla operacji zestawu jest mniejsza niż-1.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zdalny punkt końcowy.</summary>
        <value><see cref="T:System.Net.EndPoint" /> Z którym<see cref="T:System.Net.Sockets.Socket" /> komunikuje się.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz protokołu zorientowanego na połączenie, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> Właściwość <xref:System.Net.EndPoint> pobiera, który zawiera zdalny adres IP i numer <xref:System.Net.Sockets.Socket> portu, z którym jest połączony. Jeśli używasz protokołu bezpołączeniowego, zawiera <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> domyślny zdalny adres IP i numer portu, z <xref:System.Net.Sockets.Socket> którym będzie się komunikować. Należy rzutować to <xref:System.Net.EndPoint> <xref:System.Net.IPEndPoint> przed pobraniem jakichkolwiek informacji. Następnie można wywołać <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> metodę, aby pobrać zdalny <xref:System.Net.IPAddress>i <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> metodę pobierania numeru portu zdalnego.  
  
 Jest ustawiony po wywołaniu jednej <xref:System.Net.Sockets.Socket.Accept%2A> lub <xref:System.Net.Sockets.Socket.Connect%2A>. <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> Jeśli spróbujesz uzyskać dostęp do tej właściwości wcześniej <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> , spowoduje to <xref:System.Net.Sockets.SocketException>zgłoszenie. Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera i wyświetla lokalne i zdalne punkty końcowe.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SafeSocketHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.SafeSocketHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeSocketHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SafeSocketHandle ^ SafeHandle { System::Net::Sockets::SafeSocketHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : System.Net.Sockets.SafeSocketHandle" Usage="System.Net.Sockets.Socket.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SafeSocketHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera, który reprezentuje uchwyt gniazda, który jest hermetyzowany <see cref="T:System.Net.Sockets.Socket" /> bieżący obiekt. <see cref="T:System.Net.Sockets.SafeSocketHandle" /></summary>
        <value>Dojście gniazda uwidocznione w bezpieczny sposób dla gniazda, które jest hermetyzowane przez bieżący <see cref="T:System.Net.Sockets.Socket" /> obiekt.</value>
        <remarks>  
          <format type="text/markdown"><![CDATA[  

> [!IMPORTANT]
> Użycie funkcji <xref:System.Net.Sockets.SafeSocketHandle> do działania w gnieździe bezpośrednio może spowodować Nieudokumentowany stan. 

         ]]></format>
         </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="checkError" Type="System.Collections.IList" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="microSeconds" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="checkRead"><see cref="T:System.Collections.IList" /> Wystąpienia<see cref="T:System.Net.Sockets.Socket" /> umożliwiające sprawdzenie czytelności.</param>
        <param name="checkWrite"><see cref="T:System.Collections.IList" /> Wystąpienia<see cref="T:System.Net.Sockets.Socket" /> do sprawdzenia dla writability.</param>
        <param name="checkError"><see cref="T:System.Collections.IList" /> Wystąpieniado<see cref="T:System.Net.Sockets.Socket" /> sprawdzenia pod kątem błędów.</param>
        <param name="microSeconds">Wartość limitu czasu w mikrosekundach. Wartość-1 oznacza nieskończony limit czasu.</param>
        <summary>Określa stan co najmniej jednego gniazda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A>to metoda statyczna, która określa stan jednego lub większej liczby <xref:System.Net.Sockets.Socket> wystąpień. <xref:System.Collections.IList> Aby można było użyć metody, <xref:System.Net.Sockets.Socket.Select%2A> należy umieścić jeden lub więcej gniazd. Sprawdź dostępność, wywołując <xref:System.Net.Sockets.Socket.Select%2A> <xref:System.Collections.IList> metodę jako `checkRead` parametr. Aby sprawdzić gniazda dla writability, użyj `checkWrite` parametru. W celu wykrycia warunków błędów `checkError`Użyj. Po wywołaniu <xref:System.Net.Sockets.Socket.Select%2A> <xref:System.Collections.IList> , zostanie wypełnione tylko te gniazda, które spełniają warunki.  
  
 Jeśli jesteś w stanie nasłuchiwania, czytelność oznacza, że wywołanie <xref:System.Net.Sockets.Socket.Accept%2A> zakończy się pomyślnie bez blokowania. Jeśli połączenie zostało już zaakceptowane, czytelność oznacza, że dane są dostępne do odczytu. W takich przypadkach wszystkie operacje odbioru będą kończyły się powodzeniem bez blokowania. Czytelność może również wskazywać, czy <xref:System.Net.Sockets.Socket> obiekt zdalny zamknie połączenie; w takim przypadku <xref:System.Net.Sockets.Socket.Receive%2A> wywołanie metody zwróci wartość natychmiast, z zwróceniem zero bajtów.  
  
 <xref:System.Net.Sockets.Socket.Select%2A>zwraca, gdy co najmniej jedno z gniazd zainteresowania `checkRead`(gniazda na listach, `checkWrite`i `checkError` `microSeconds` ) spełnia określone kryteria lub parametr zostanie przekroczony, zależnie od tego, co nastąpi wcześniej. Ustawienie `microSeconds` wartość-1 określa nieskończony limit czasu.  
  
 W przypadku wywołania nieblokującego do <xref:System.Net.Sockets.Socket.Connect%2A>, writability oznacza, że połączenie zostało nawiązane pomyślnie. Jeśli nawiązano już połączenie, writability oznacza, że wszystkie operacje wysyłania będą kończyły się powodzeniem bez blokowania.  
  
 Jeśli wykonano wywołanie nieblokujące do <xref:System.Net.Sockets.Socket.Connect%2A> `checkerror` , parametr identyfikuje gniazda, które nie połączyły się pomyślnie.  
  
> [!NOTE]
>  Użyj metody <xref:System.Net.Sockets.Socket.Poll%2A> , jeśli chcesz tylko określić stan pojedynczej. <xref:System.Net.Sockets.Socket>  
  
> [!NOTE]
>  Ta metoda nie może wykryć niektórych rodzajów problemów z połączeniami, takich jak przerwany kabel sieciowy lub że host zdalny został zamknięty nieprawidłowo. Należy podjąć próbę wysłania lub odebrania danych w celu wykrycia tego rodzaju błędów.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Net.Sockets.Socket.Select%2A> do określenia, które gniazda nasłuchujące mają żądanie połączenia.  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="checkRead" /> Parametr jest<see langword="null" /> lub pusty.  
  
- i - 
<paramref name="checkWrite" /> Parametr jest<see langword="null" /> lub pusty 
- i - 
<paramref name="checkError" /> Parametr jest<see langword="null" /> lub pusty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wysyła dane do połączonej <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</param>
        <summary>Wysyła dane do połączonej <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>synchronicznie wysyła dane do hosta zdalnego określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metodzie lub <xref:System.Net.Sockets.Socket.Accept%2A> i zwraca liczbę pomyślnie wysłanych bajtów. <xref:System.Net.Sockets.Socket.Send%2A>może być używany zarówno dla protokołów zorientowanych na połączenia, jak i bezpołączeni.  
  
 To Przeciążenie wymaga buforu zawierającego dane, które mają zostać wysłane. <xref:System.Net.Sockets.SocketFlags> Wartość domyślna to 0, przesunięcie buforu domyślnie równa 0 i liczba bajtów, które mają zostać wysłane domyślnie do rozmiaru buforu.  
  
 Jeśli używasz bezpołączeniowego protokołu, musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosić <xref:System.Net.Sockets.SocketException>. W przypadku korzystania z protokołu zorientowanego na połączenia należy użyć polecenia <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym, lub użyć <xref:System.Net.Sockets.Socket.Accept%2A> do zaakceptowania połączenia przychodzącego.  
  
 Jeśli używasz bezpołączeniowego protokołu i planujesz wysyłać dane do kilku różnych hostów, użyj <xref:System.Net.Sockets.Socket.SendTo%2A> metody. Jeśli <xref:System.Net.Sockets.Socket.SendTo%2A> Metoda nie zostanie użyta, należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed każdym wywołaniem <xref:System.Net.Sockets.Socket.Send%2A>. Możesz użyć <xref:System.Net.Sockets.Socket.SendTo%2A> nawet po ustanowieniu domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>programu. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> , wykonując inne <xref:System.Net.Sockets.Socket.Connect%2A>wywołanie.  
  
 W przypadku korzystania z protokołu <xref:System.Net.Sockets.Socket.Send%2A> zorientowanego na połączenia program zablokuje do momentu wysłania wszystkich bajtów w buforze, chyba że limit czasu został ustawiony przy użyciu. <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość. W trybie nieblokującym może <xref:System.Net.Sockets.Socket.Send%2A> zakończyć się pomyślnie nawet wtedy, gdy wyśle on mniejszą liczbę bajtów w buforze. Jest to odpowiedzialność aplikacji do śledzenia liczby wysłanych bajtów i ponawiania operacji do momentu, gdy aplikacja wyśle bajty w buforze. Nie ma również gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci. Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie. Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wysyłanie danych w połączonym <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Lista <see cref="T:System.ArraySegment`1" />s typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</param>
        <summary>Wysyła zestaw buforów z listy do połączonej <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>może być używany zarówno dla protokołów zorientowanych na połączenia, jak i bezpołączeni.  
  
 To Przeciążenie wymaga co najmniej jednego buforu zawierającego dane, które mają zostać wysłane.  
  
 Jeśli używasz bezpołączeniowego protokołu, musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosić <xref:System.Net.Sockets.SocketException>. W przypadku korzystania z protokołu zorientowanego na połączenia należy użyć polecenia <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym, lub użyć <xref:System.Net.Sockets.Socket.Accept%2A> do zaakceptowania połączenia przychodzącego.  
  
 Jeśli używasz bezpołączeniowego protokołu i planujesz wysyłać dane do kilku różnych hostów, użyj <xref:System.Net.Sockets.Socket.SendTo%2A> metody. Jeśli <xref:System.Net.Sockets.Socket.SendTo%2A> Metoda nie zostanie użyta, należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed każdym wywołaniem <xref:System.Net.Sockets.Socket.Send%2A>. Możesz użyć <xref:System.Net.Sockets.Socket.SendTo%2A> nawet po ustanowieniu domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>programu. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> , wykonując inne <xref:System.Net.Sockets.Socket.Connect%2A>wywołanie.  
  
 W przypadku korzystania z protokołu <xref:System.Net.Sockets.Socket.Send%2A> zorientowanego na połączenia program zablokuje do momentu wysłania wszystkich bajtów w buforze, chyba że limit czasu został ustawiony przy użyciu. <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość. W trybie nieblokującym może <xref:System.Net.Sockets.Socket.Send%2A> zakończyć się pomyślnie nawet wtedy, gdy wyśle on mniejszą liczbę bajtów w buforze. Jest to odpowiedzialność aplikacji do śledzenia liczby wysłanych bajtów i ponawiania operacji do momentu, gdy aplikacja wyśle bajty w buforze. Nie ma również gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci. Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie. Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" />jest puste.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <summary>Wysyła dane do połączonego <see cref="T:System.Net.Sockets.Socket" /> przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>synchronicznie wysyła dane do hosta zdalnego ustanowionego w <xref:System.Net.Sockets.Socket.Connect%2A> metodzie lub <xref:System.Net.Sockets.Socket.Accept%2A> i zwraca liczbę pomyślnie wysłanych bajtów. Metoda <xref:System.Net.Sockets.Socket.Send%2A> ta może być używana zarówno dla protokołów zorientowanych na połączenia, jak i bezpołączeni.  
  
 To Przeciążenie wymaga bufora zawierającego dane, które mają zostać wysłane, oraz kombinacji <xref:System.Net.Sockets.SocketFlags>bitowe. Wartość domyślna przesunięcia buforu jest równa 0, a liczba bajtów do wysłania domyślnie do rozmiaru buforu. Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketflags` jako wartość parametru, wysyłane dane nie będą kierowane.  
  
 Jeśli używasz bezpołączeniowego protokołu, musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosić <xref:System.Net.Sockets.SocketException>. W przypadku korzystania z protokołu zorientowanego na połączenia należy użyć polecenia <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym, lub użyć <xref:System.Net.Sockets.Socket.Accept%2A> do zaakceptowania połączenia przychodzącego.  
  
 Jeśli używasz bezpołączeniowego protokołu i planujesz wysyłać dane do kilku różnych hostów, użyj <xref:System.Net.Sockets.Socket.SendTo%2A> metody. Jeśli <xref:System.Net.Sockets.Socket.SendTo%2A> Metoda nie zostanie użyta, należy <xref:System.Net.Sockets.Socket.Connect%2A> wywołać <xref:System.Net.Sockets.Socket.Send%2A>metodę przed każdym wywołaniem. Możesz użyć <xref:System.Net.Sockets.Socket.SendTo%2A> nawet po ustanowieniu domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>programu. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> , wykonując inne <xref:System.Net.Sockets.Socket.Connect%2A>wywołanie.  
  
 W przypadku korzystania z protokołu <xref:System.Net.Sockets.Socket.Send%2A> zorientowanego na połączenia program zablokuje do momentu wysłania wszystkich bajtów w buforze, chyba że limit czasu został ustawiony przy użyciu. <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość. W trybie nieblokującym może <xref:System.Net.Sockets.Socket.Send%2A> zakończyć się pomyślnie nawet wtedy, gdy wyśle on mniejszą liczbę bajtów w buforze. Jest to odpowiedzialność aplikacji do śledzenia liczby wysłanych bajtów i ponawiania operacji do momentu, gdy aplikacja wyśle żądaną liczbę bajtów. Nie ma również gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci. Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.  
  
> [!NOTE]
>  Należy upewnić się, że rozmiar buforu nie przekracza maksymalnego rozmiaru pakietu dostawcy usługi. Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.Send%2A> <xref:System.Net.Sockets.SocketException>wygeneruje. Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie. Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wysyłanie danych w połączonym <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Lista <see cref="T:System.ArraySegment`1" />s typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <summary>Wysyła zestaw buforów z listy do połączonego <see cref="T:System.Net.Sockets.Socket" />, przy użyciu określonego. <see cref="T:System.Net.Sockets.SocketFlags" /></summary>
        <returns>Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie wymaga co najmniej jednego buforu zawierającego dane, które mają zostać wysłane. <xref:System.Net.Sockets.SocketFlags> Wartość domyślna to 0. Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketFlags` jako parametr, wysyłane dane nie będą kierowane.  
  
 Jeśli używasz bezpołączeniowego protokołu, musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosić <xref:System.Net.Sockets.SocketException>. W przypadku korzystania z protokołu zorientowanego na połączenia należy użyć polecenia <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym, lub użyć <xref:System.Net.Sockets.Socket.Accept%2A> do zaakceptowania połączenia przychodzącego.  
  
 Jeśli używasz bezpołączeniowego protokołu i planujesz wysyłać dane do kilku różnych hostów, użyj <xref:System.Net.Sockets.Socket.SendTo%2A> metody. Jeśli <xref:System.Net.Sockets.Socket.SendTo%2A> Metoda nie zostanie użyta, należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed każdym wywołaniem <xref:System.Net.Sockets.Socket.Send%2A>. Możesz użyć <xref:System.Net.Sockets.Socket.SendTo%2A> nawet po ustanowieniu domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>programu. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> , wykonując inne <xref:System.Net.Sockets.Socket.Connect%2A>wywołanie.  
  
 W przypadku korzystania z protokołu <xref:System.Net.Sockets.Socket.Send%2A> zorientowanego na połączenia program zablokuje do momentu wysłania wszystkich bajtów w buforze, chyba że limit czasu został ustawiony przy użyciu. <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość. W trybie bez blokowania może zakończyć <xref:System.Net.Sockets.Socket.Send%2A> się pomyślnie nawet wtedy, gdy wysyła wartość mniejszą niż liczba bajtów w buforze. Jest to odpowiedzialność aplikacji do śledzenia liczby wysłanych bajtów i ponawiania operacji do momentu, gdy aplikacja wyśle bajty w buforze. Nie ma również gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci. Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie. Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" />jest puste.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</param>
        <param name="size">Liczba bajtów do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <summary>Wysyła określoną liczbę bajtów danych do połączonego <see cref="T:System.Net.Sockets.Socket" />, przy użyciu określonego. <see cref="T:System.Net.Sockets.SocketFlags" /></summary>
        <returns>Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>synchronicznie wysyła dane do hosta zdalnego ustanowionego w <xref:System.Net.Sockets.Socket.Connect%2A> metodzie lub <xref:System.Net.Sockets.Socket.Accept%2A> i zwraca liczbę pomyślnie wysłanych bajtów. <xref:System.Net.Sockets.Socket.Send%2A>może być używany zarówno dla protokołów zorientowanych na połączenia, jak i bezpołączeni.  
  
 To Przeciążenie wymaga bufora zawierającego dane, które mają zostać wysłane, liczbę bajtów do wysłania oraz bitową kombinację dowolnych <xref:System.Net.Sockets.SocketFlags>. Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketflags` jako parametr, wysyłane dane nie będą kierowane.  
  
 Jeśli używasz bezpołączeniowego protokołu, musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosić <xref:System.Net.Sockets.SocketException>. W przypadku korzystania z protokołu zorientowanego na połączenia należy użyć polecenia <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym, lub użyć <xref:System.Net.Sockets.Socket.Accept%2A> do zaakceptowania połączenia przychodzącego.  
  
 Jeśli używasz bezpołączeniowego protokołu i planujesz wysyłać dane do kilku różnych hostów, użyj <xref:System.Net.Sockets.Socket.SendTo%2A> metody. Jeśli <xref:System.Net.Sockets.Socket.SendTo%2A> Metoda nie zostanie użyta, należy <xref:System.Net.Sockets.Socket.Connect%2A> wywołać metodę <xref:System.Net.Sockets.Socket.Send%2A> przed każdym wywołaniem metody. Możesz użyć <xref:System.Net.Sockets.Socket.SendTo%2A> nawet po ustanowieniu domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>programu. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> , wykonując inne <xref:System.Net.Sockets.Socket.Connect%2A>wywołanie.  
  
 W przypadku protokołu <xref:System.Net.Sockets.Socket.Send%2A> zorientowanego na połączenia program zablokuje do momentu wysłania żądanej liczby bajtów, chyba że limit czasu został ustawiony przy <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>użyciu. W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość. W trybie niezablokowanym, <xref:System.Net.Sockets.Socket.Send%2A> może zakończyć się pomyślnie nawet wtedy, gdy wysyła mniej niż liczba żądanych bajtów. Jest to odpowiedzialność aplikacji do śledzenia liczby wysłanych bajtów i ponawiania operacji do momentu, gdy aplikacja wyśle żądaną liczbę bajtów. Nie ma również gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci. Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.  
  
> [!NOTE]
>  Należy upewnić się, że rozmiar nie przekracza maksymalnego rozmiaru pakietu dostawcy usługi. Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.Send%2A> <xref:System.Net.Sockets.SocketException>wygeneruje. Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie. Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła dane Znalezione w buforze i określa <xref:System.Net.Sockets.SocketFlags.None> dla. <xref:System.Net.Sockets.SocketFlags>  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" />jest mniejsza niż 0 lub przekracza rozmiar buforu.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" />nie jest prawidłową kombinacją wartości.  
  
—lub— 
Wystąpił błąd systemu operacyjnego podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Lista <see cref="T:System.ArraySegment`1" />s typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="errorCode"><see cref="T:System.Net.Sockets.SocketError" /> Obiekt, który przechowuje błąd gniazda.</param>
        <summary>Wysyła zestaw buforów z listy do połączonego <see cref="T:System.Net.Sockets.Socket" />, przy użyciu określonego. <see cref="T:System.Net.Sockets.SocketFlags" /></summary>
        <returns>Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie wymaga co najmniej jednego buforu zawierającego dane, które mają zostać wysłane. <xref:System.Net.Sockets.SocketFlags> Wartość domyślna to 0. Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketFlags` jako parametr, wysyłane dane nie będą kierowane.  
  
 Jeśli używasz bezpołączeniowego protokołu, musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosić <xref:System.Net.Sockets.SocketException>. W przypadku korzystania z protokołu zorientowanego na połączenia należy użyć polecenia <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym, lub użyć <xref:System.Net.Sockets.Socket.Accept%2A> do zaakceptowania połączenia przychodzącego.  
  
 Jeśli używasz bezpołączeniowego protokołu i planujesz wysyłać dane do kilku różnych hostów, użyj <xref:System.Net.Sockets.Socket.SendTo%2A> metody. Jeśli <xref:System.Net.Sockets.Socket.SendTo%2A> Metoda nie zostanie użyta, należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed każdym wywołaniem <xref:System.Net.Sockets.Socket.Send%2A>. Możesz użyć <xref:System.Net.Sockets.Socket.SendTo%2A> nawet po ustanowieniu domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>programu. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> , wykonując inne <xref:System.Net.Sockets.Socket.Connect%2A>wywołanie.  
  
 W przypadku korzystania z protokołu <xref:System.Net.Sockets.Socket.Send%2A> zorientowanego na połączenia program zablokuje do momentu wysłania wszystkich bajtów w buforze, chyba że limit czasu został ustawiony przy użyciu. <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość. W trybie bez blokowania może zakończyć <xref:System.Net.Sockets.Socket.Send%2A> się pomyślnie nawet wtedy, gdy wysyła wartość mniejszą niż liczba bajtów w buforze. Jest to odpowiedzialność aplikacji do śledzenia liczby wysłanych bajtów i ponawiania operacji do momentu, gdy aplikacja wyśle bajty w buforze. Nie ma również gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci. Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie. Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" />jest puste.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</param>
        <param name="offset">Pozycja w buforze danych, w której mają zostać rozpoczęte wysyłanie danych.</param>
        <param name="size">Liczba bajtów do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <summary>Wysyła określoną liczbę bajtów danych do połączonego <see cref="T:System.Net.Sockets.Socket" />, rozpoczynając od określonego przesunięcia i używając określonego. <see cref="T:System.Net.Sockets.SocketFlags" /></summary>
        <returns>Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>synchronicznie wysyła dane do hosta zdalnego określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metodzie lub <xref:System.Net.Sockets.Socket.Accept%2A> i zwraca liczbę pomyślnie wysłanych bajtów. <xref:System.Net.Sockets.Socket.Send%2A>może być używany zarówno dla protokołów zorientowanych na połączenia, jak i bezpołączeni.  
  
 W tym przeciążeniu, jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketflags` jako parametr, wysyłane dane nie będą kierowane.  
  
 Jeśli używasz bezpołączeniowego protokołu, musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosić <xref:System.Net.Sockets.SocketException>. W przypadku korzystania z protokołu zorientowanego na połączenia należy użyć polecenia <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym, lub użyć <xref:System.Net.Sockets.Socket.Accept%2A> do zaakceptowania połączenia przychodzącego.  
  
 Jeśli używasz bezpołączeniowego protokołu i planujesz wysyłać dane do kilku różnych hostów, użyj polecenia <xref:System.Net.Sockets.Socket.SendTo%2A>. Jeśli nie używasz <xref:System.Net.Sockets.Socket.SendTo%2A>, musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed każdym wywołaniem do <xref:System.Net.Sockets.Socket.Send%2A>. Nie można jej używać <xref:System.Net.Sockets.Socket.SendTo%2A> nawet po ustanowieniu domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>programu. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> , wykonując inne <xref:System.Net.Sockets.Socket.Connect%2A>wywołanie.  
  
 Należy również upewnić się, że rozmiar nie przekracza maksymalnego rozmiaru pakietu dostawcy usługi. Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.Send%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.  
  
 Jeśli używasz protokołu zorientowanego na połączenie, <xref:System.Net.Sockets.Socket.Send%2A> program zablokuje do momentu wysłania żądanej liczby bajtów, chyba że limit czasu został ustawiony przy użyciu. <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość. W trybie niezablokowanym, <xref:System.Net.Sockets.Socket.Send%2A> może zakończyć się pomyślnie nawet wtedy, gdy wysyła mniej niż liczba żądanych bajtów. Jest to odpowiedzialność aplikacji do śledzenia liczby wysłanych bajtów i ponawiania operacji do momentu, gdy aplikacja wyśle żądaną liczbę bajtów. Nie ma również gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci. Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie. Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu określa bufor danych, przesunięcie, rozmiar i <xref:System.Net.Sockets.SocketFlags> na potrzeby wysyłania danych do połączonej. <xref:System.Net.Sockets.Socket>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" />jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" />nie jest prawidłową kombinacją wartości.  
  
—lub— 
Wystąpił błąd systemu operacyjnego podczas uzyskiwania dostępu <see cref="T:System.Net.Sockets.Socket" />do programu.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</param>
        <param name="offset">Pozycja w buforze danych, w której mają zostać rozpoczęte wysyłanie danych.</param>
        <param name="size">Liczba bajtów do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="errorCode"><see cref="T:System.Net.Sockets.SocketError" /> Obiekt, który przechowuje błąd gniazda.</param>
        <summary>Wysyła określoną liczbę bajtów danych do połączonego <see cref="T:System.Net.Sockets.Socket" />, rozpoczynając od określonego przesunięcia i używając określonego<see cref="T:System.Net.Sockets.SocketFlags" /></summary>
        <returns>Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>synchronicznie wysyła dane do hosta zdalnego określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metodzie lub <xref:System.Net.Sockets.Socket.Accept%2A> i zwraca liczbę pomyślnie wysłanych bajtów. <xref:System.Net.Sockets.Socket.Send%2A>może być używany zarówno dla protokołów zorientowanych na połączenia, jak i bezpołączeni.  
  
 W tym przeciążeniu, jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketflags` jako parametr, wysyłane dane nie będą kierowane.  
  
 Jeśli używasz bezpołączeniowego protokołu, musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosić <xref:System.Net.Sockets.SocketException>. W przypadku korzystania z protokołu zorientowanego na połączenia należy użyć polecenia <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym, lub użyć <xref:System.Net.Sockets.Socket.Accept%2A> do zaakceptowania połączenia przychodzącego.  
  
 Jeśli używasz bezpołączeniowego protokołu i planujesz wysyłać dane do kilku różnych hostów, użyj polecenia <xref:System.Net.Sockets.Socket.SendTo%2A>. Jeśli nie używasz <xref:System.Net.Sockets.Socket.SendTo%2A>, musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed każdym wywołaniem do <xref:System.Net.Sockets.Socket.Send%2A>. Nie można jej używać <xref:System.Net.Sockets.Socket.SendTo%2A> nawet po ustanowieniu domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>programu. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> , wykonując inne <xref:System.Net.Sockets.Socket.Connect%2A>wywołanie.  
  
 Należy również upewnić się, że rozmiar nie przekracza maksymalnego rozmiaru pakietu dostawcy usługi. Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.Send%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.  
  
 Jeśli używasz protokołu zorientowanego na połączenie, <xref:System.Net.Sockets.Socket.Send%2A> program zablokuje do momentu wysłania żądanej liczby bajtów, chyba że limit czasu został ustawiony przy użyciu. <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość. W trybie niezablokowanym, <xref:System.Net.Sockets.Socket.Send%2A> może zakończyć się pomyślnie nawet wtedy, gdy wysyła mniej niż liczba żądanych bajtów. Jest to odpowiedzialność aplikacji do śledzenia liczby wysłanych bajtów i ponawiania operacji do momentu, gdy aplikacja wyśle żądaną liczbę bajtów. Nie ma również gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci. Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie. Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu określa bufor danych, przesunięcie, rozmiar i <xref:System.Net.Sockets.SocketFlags> na potrzeby wysyłania danych do połączonej. <xref:System.Net.Sockets.Socket>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" />jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" />nie jest prawidłową kombinacją wartości.  
  
—lub— 
Wystąpił błąd systemu operacyjnego podczas uzyskiwania dostępu <see cref="T:System.Net.Sockets.Socket" />do programu.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Obiekt <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> , który ma być używany dla tej asynchronicznej operacji gniazda.</param>
        <summary>Asynchronicznie wysyła dane do połączonego <see cref="T:System.Net.Sockets.Socket" /> obiektu.</summary>
        <returns><see langword="true" />Jeśli operacja we/wy jest w stanie oczekiwania. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie<paramref name="e" /> na parametrze zostanie wywołane po zakończeniu operacji.  
  
 <see langword="false" />Jeśli operacja we/wy została ukończona synchronicznie. W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie <paramref name="e" /> na parametrze <paramref name="e" /> nie zostanie zgłoszone i obiekt przenoszony jako parametr może zostać zbadany natychmiast po wywołaniu metody, aby pobrać wynik operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendAsync%2A> Metoda jest używana do zapisywania danych wychodzących z co najmniej jednego bufora w gnieździe zorientowanym na połączenie. Ta metoda może być również używana w gniazdach bez połączenia, które określiły host zdalny w operacji łączenia.  
  
 <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.ConnectAsync%2A> <xref:System.Net.Sockets.Socket.AcceptAsync%2A> <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.Connect%2A>Metoda uruchamia asynchroniczną operację wysyłania do hosta zdalnego, który został ustanowiony w metodzie <xref:System.Net.Sockets.Socket.BeginConnect%2A>,,,, lub. <xref:System.Net.Sockets.Socket.SendAsync%2A>  
  
 Następujące właściwości i zdarzenia w <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiekcie są wymagane do pomyślnego wywołania tej metody:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> lub <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>Jeśli <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> jest ustawiona  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>Jeśli <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> jest ustawiona  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość na dowolny obiekt stanu użytkownika przed <xref:System.Net.Sockets.Socket.SendAsync%2A> wywołaniem metody, tak aby informacje były możliwe do pobierania w metodzie wywołania zwrotnego. Jeśli wywołanie zwrotne wymaga więcej informacji niż pojedynczy obiekt, można utworzyć małą klasę w celu przechowywania innych wymaganych informacji o stanie jako członków.  
  
 <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.AcceptAsync%2A> <xref:System.Net.Sockets.Socket.Accept%2A>Metoda zgłosi wyjątek, jeśli nie zostanie najpierw wywołana,,,, lub <xref:System.Net.Sockets.Socket.ConnectAsync%2A>. <xref:System.Net.Sockets.Socket.SendAsync%2A>  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A> Wywołanie metody daje możliwość wysyłania danych w osobnym wątku wykonania.  
  
 W przypadku gniazd zorientowanych na komunikaty nie przekraczaj maksymalnego rozmiaru komunikatu dostawcy usługi Windows Sockets. Jeśli dane są zbyt długie do przekazania przez bazowego dostawcę usług, żadne dane nie są przesyłane, a <xref:System.Net.Sockets.Socket.SendAsync%2A> Metoda <xref:System.Net.Sockets.SocketException> zgłasza z <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> zestawem natywny kod błędu WSAEMSGSIZE Winsock (10040).  
  
 Należy zauważyć, że pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendAsync%2A> metody nie wskazuje, że dane zostały dostarczone pomyślnie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Właściwości <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> <paramref name="e" /> lub <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> parametru muszą odwoływać się do prawidłowych buforów. Można ustawić jedną lub drugą z tych właściwości, ale nie oba jednocześnie.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja gniazda była już w toku przy użyciu <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiektu określonego <paramref name="e" /> w parametrze.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda wymaga systemu Windows XP lub nowszego.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><see cref="M:System.Net.Sockets.Socket.Accept" /> <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />Program nie <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />jest jeszcze połączony lub nie został uzyskany za pośrednictwem metody,, lub. <see cref="T:System.Net.Sockets.Socket" /></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą rozmiar buforu <see cref="T:System.Net.Sockets.Socket" />wysyłania.</summary>
        <value>, <see cref="T:System.Int32" /> Który zawiera rozmiar (w bajtach) bufora wysyłania. Wartość domyślna to 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Większy rozmiar buforu może opóźnić rozpoznawanie trudności z połączeniem. Należy rozważyć zwiększenie rozmiaru buforu w przypadku transferu dużych plików lub korzystania z dużej przepustowości i połączenia o dużej opóźnieniu (na przykład satelitarnego dostawcy sieci szerokopasmowej).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.SendBufferSize%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona dla operacji zestawu jest mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wysyła synchronicznie do połączonego <see cref="T:System.Net.Sockets.Socket" />pliku i opcjonalne dane.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">A <see cref="T:System.String" /> , który zawiera ścieżkę i nazwę pliku do wysłania. Ten parametr może być <see langword="null" />.</param>
        <summary>Wysyła plik <paramref name="fileName" /> do połączonego <see cref="T:System.Net.Sockets.Socket" /> obiektu za pomocą <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> flagi wysyłania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie wysyła plik `fileName` do połączonego gniazda. `null` `preBuffer` `postBuffer` Parametr ma wartość domyślną (0), a parametry i są domyślne dla. <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> `flags` Jeśli `fileName` znajduje się w katalogu lokalnym, może być identyfikowana przy użyciu tylko nazwy pliku; w przeciwnym razie należy określić pełną ścieżkę i nazwę pliku. Symbole wieloznaczne (".. \\\\\\\\obsługiwane są \myfile.txt ") i nazwy udziałów UNC (" \shared Directory \myfile.txt "). \\ Jeśli plik nie zostanie znaleziony, zostanie zgłoszony wyjątek <xref:System.IO.FileNotFoundException> .  
  
 Ta metoda używa `TransmitFile` funkcji znalezionej w interfejsie API Windows Sockets 2. Aby uzyskać więcej informacji na `TransmitFile` temat funkcji i jej flag, zobacz dokumentację usługi [Windows Sockets](/windows/desktop/WinSock/) .  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A>synchronicznie wysyła plik do hosta zdalnego określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metodzie lub. <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.SendFile%2A>może być używany zarówno dla sieci zorientowanych na połączenia, jak i dla protokołów bezpołączeniowych.  
  
 Jeśli używasz bezpołączeniowego protokołu, musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody, w przeciwnym razie <xref:System.Net.Sockets.Socket.SendFile%2A> zgłasza <xref:System.Net.Sockets.SocketException> wyjątek. W przypadku korzystania z protokołu zorientowanego na połączenia należy użyć polecenia <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym lub użyć <xref:System.Net.Sockets.Socket.Accept%2A> do akceptowania połączenia przychodzącego.  
  
 Jeśli używasz protokołu zorientowanego na połączenia, <xref:System.Net.Sockets.Socket.SendFile%2A> bloki do momentu wysłania pliku. W trybie <xref:System.Net.Sockets.Socket.SendFile%2A> nieblokującym może zakończyć się pomyślnie przed wysłaniem całego pliku. Nie ma żadnej gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci. Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendFile%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy i łączy gniazdo, a następnie wysyła plik do hosta zdalnego. Plik "test. txt" znajduje się w katalogu głównym komputera lokalnego.  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Gniazdo nie jest połączone z hostem zdalnym.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> Obiekt nie jest w trybie blokowania i nie może zaakceptować tego wywołania synchronicznego.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono <paramref name="fileName" /> pliku.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">A <see cref="T:System.String" /> , który zawiera ścieżkę i nazwę pliku do wysłania. Ten parametr może być <see langword="null" />.</param>
        <param name="preBuffer"><see cref="T:System.Byte" /> Tablica zawierająca dane, które mają zostać wysłane przed wysłaniem pliku. Ten parametr może być <see langword="null" />.</param>
        <param name="postBuffer"><see cref="T:System.Byte" /> Tablica zawierająca dane, które mają zostać wysłane po wysłaniu pliku. Ten parametr może być <see langword="null" />.</param>
        <param name="flags">Co najmniej jedna wartość. <see cref="T:System.Net.Sockets.TransmitFileOptions" /></param>
        <summary>Wysyła plik <paramref name="fileName" /> i bufory danych do połączonego <see cref="T:System.Net.Sockets.Socket" /> obiektu przy użyciu określonej <see cref="T:System.Net.Sockets.TransmitFileOptions" /> wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie wymaga nazwy pliku, który chcesz wysłać, oraz bitowej kombinacji <xref:System.Net.Sockets.TransmitFileOptions> wartości. `preBuffer` Parametr zawiera wszystkie dane, które mają poprzedzać plik. `postBuffer`zawiera dane, które mają być zgodne z plikiem. Jeśli `fileName` znajduje się w bieżącym katalogu roboczym, może być zidentyfikowany przy użyciu tylko nazwy pliku; w przeciwnym razie należy określić pełną ścieżkę i nazwę pliku. Symbole wieloznaczne (".. \\\\\\\\obsługiwane są \myfile.txt ") i nazwy udziałów UNC (" \shared Directory \myfile.txt "). \\  
  
 `flags` Parametr udostępnia dostawcy usługi okna Sockets z dodatkowymi informacjami na temat transferu plików. Aby uzyskać więcej informacji na temat korzystania z tego parametru, <xref:System.Net.Sockets.TransmitFileOptions>Zobacz.  
  
 Ta metoda używa `TransmitFile` funkcji znalezionej w interfejsie API Windows Sockets 2. Aby uzyskać więcej informacji na `TransmitFile` temat funkcji i jej flag, zobacz dokumentację usługi [Windows Sockets](/windows/desktop/WinSock/) .  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A>synchronicznie wysyła plik do hosta zdalnego określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metodzie lub. <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.SendFile%2A>może być używany zarówno dla sieci zorientowanych na połączenia, jak i dla protokołów bezpołączeniowych.  
  
 Jeśli używasz bezpołączeniowego protokołu, musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody; w przeciwnym razie <xref:System.Net.Sockets.Socket.SendFile%2A> zgłasza <xref:System.Net.Sockets.SocketException>. W przypadku korzystania z protokołu zorientowanego na połączenia należy użyć polecenia <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym, lub użyć <xref:System.Net.Sockets.Socket.Accept%2A> do zaakceptowania połączenia przychodzącego.  
  
 Jeśli używasz protokołu zorientowanego na połączenia, <xref:System.Net.Sockets.Socket.SendFile%2A> bloki do momentu wysłania całego pliku. W trybie <xref:System.Net.Sockets.Socket.SendFile%2A> nieblokującym może zakończyć się pomyślnie przed wysłaniem całego pliku. Nie ma żadnej gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci. Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendFile%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy i łączy gniazdo. Plik "test. txt" znajduje się w katalogu głównym komputera lokalnego. W tym przykładzie utworzymy przedpostbufferę i dane, a następnie wyślesz je do zdalnego hosta z plikiem. Używane są <xref:System.Net.Sockets.TransmitFileOptions> ustawienia domyślne.  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">System operacyjny nie jest systemem Windows NT lub nowszym.  
  
—lub—
  
 Gniazdo nie jest połączone z hostem zdalnym.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> Obiekt nie jest w trybie blokowania i nie może zaakceptować tego wywołania synchronicznego.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono <paramref name="fileName" /> pliku.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e">Obiekt <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> , który ma być używany dla tej asynchronicznej operacji gniazda.</param>
        <summary>Wysyła kolekcję plików lub buforów danych pamięci asynchronicznie do połączonego <see cref="T:System.Net.Sockets.Socket" /> obiektu.</summary>
        <returns><see langword="true" />Jeśli operacja we/wy jest w stanie oczekiwania. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie<paramref name="e" /> na parametrze zostanie wywołane po zakończeniu operacji.  
  
 <see langword="false" />Jeśli operacja we/wy została ukończona synchronicznie. W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie <paramref name="e" /> na parametrze <paramref name="e" /> nie zostanie zgłoszone i obiekt przenoszony jako parametr może zostać zbadany natychmiast po wywołaniu metody, aby pobrać wynik operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Metoda jest używana do wysyłania kolekcji plików lub buforów danych pamięci do hosta zdalnego. Ta <xref:System.Net.Sockets.Socket> wartość musi być już połączona z hostem zdalnym.  
  
 <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> Jeśli odwołuje się do pliku w katalogu roboczym, można go zidentyfikować za pomocą tylko nazwy pliku; w przeciwnym razie należy określić pełną ścieżkę i nazwę pliku. Obsługiwane są symbole wieloznaczne i nazwy udziałów UNC. Jeśli plik nie zostanie znaleziony, <xref:System.IO.FileNotFoundException> zostanie zgłoszony.  
  
 Aby otrzymywać powiadomienia o zakończeniu, należy utworzyć metodę wywołania zwrotnego implementującą delegata\<EventHandler SocketAsyncEventArgs > i dołączyć wywołanie zwrotne <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> do zdarzenia.  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> Właściwość`e` na parametrze udostępnia dostawcy usługi Window Sockets z dodatkowymi informacjami na temat transferu plików. Aby uzyskać więcej informacji na temat korzystania z tego parametru, <xref:System.Net.Sockets.TransmitFileOptions>Zobacz.  
  
 Następujące właściwości i zdarzenia w <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiekcie są wymagane do pomyślnego wywołania tej metody:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość na dowolny obiekt stanu użytkownika przed <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> wywołaniem metody, tak aby informacje były możliwe do pobierania w metodzie wywołania zwrotnego. Jeśli wywołanie zwrotne wymaga więcej informacji niż pojedynczy obiekt, można utworzyć małą klasę w celu przechowywania innych wymaganych informacji o stanie jako członków.  
  
 Ta metoda używa funkcji TransmitPackets znajdującej się w interfejsie API Windows Sockets 2. Aby uzyskać więcej informacji na temat funkcji TransmitPackets i jej flag, zobacz dokumentację usługi [Windows Sockets](/windows/desktop/WinSock/) .  
  
 Chociaż są <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> przeznaczone dla protokołów zorientowanych na połączenia, Metoda również działa dla protokołów bezpołączeniowych, pod warunkiem, że <xref:System.Net.Sockets.Socket.Connect%2A>należy najpierw <xref:System.Net.Sockets.Socket.ConnectAsync%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>wywołać metodę, lub, aby określić domyślny host zdalny. W przypadku protokołów bez połączenia należy również upewnić się, że rozmiar pliku nie przekracza maksymalnego rozmiaru pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie jest wysyłany i <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> <xref:System.Net.Sockets.SocketException> zgłasza wyjątek.  
  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Metoda jest zoptymalizowana według systemu operacyjnego, w którym jest używana. W systemie Windows Server wersje <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Metoda jest zoptymalizowana pod kątem wysokiej wydajności.  
  
 W przypadku wersji <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> klienta systemu Windows Metoda jest zoptymalizowana pod kątem minimalnej ilości pamięci i wykorzystania zasobów.  
  
 <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> Użycie flagi<xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> we właściwości`e` parametru może zapewnić znaczne korzyści z wydajności. Jeśli wątek inicjujący <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> wywołanie metody jest używany w przypadku dużych obliczeń, istnieje prawdopodobieństwo, że jest to mało prawdopodobne, że APCs może być niemożliwe do uruchomienia. Należy zauważyć, że istnieje różnica między APCs jądra a trybem użytkownika. APCs jądra, gdy wątek jest w stanie oczekiwania. APCs trybu użytkownika, gdy wątek jest w stanie oczekiwania na alert  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku określonego we <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> właściwości.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja gniazda była już w toku przy użyciu <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiektu określonego <paramref name="e" /> w parametrze.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda wymaga systemu Windows XP lub nowszego. Ten wyjątek występuje również wtedy, <see cref="T:System.Net.Sockets.Socket" /> gdy nie jest podłączony do hosta zdalnego.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Jest używany <see cref="T:System.Net.Sockets.Socket" /> bezpołączeniowy i wysyłany plik przekracza maksymalny rozmiar pakietu podstawowego transportu.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą czas, po upływie którego zostanie przekroczony <see cref="Overload:System.Net.Sockets.Socket.Send" /> limit czasu wywołania synchronicznego.</summary>
        <value>Wartość limitu czasu (w milisekundach). Jeśli właściwość zostanie ustawiona z wartością z zakresu od 1 do 499, wartość zostanie zmieniona na 500. Wartość domyślna to 0, co oznacza nieskończony limit czasu. Określenie-1 wskazuje także nieskończony limit czasu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta opcja dotyczy tylko wywołań <xref:System.Net.Sockets.Socket.Send%2A> synchronicznych. W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu Metoda <xref:System.Net.Sockets.SocketException>wygeneruje.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.SendTimeout%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona dla operacji zestawu jest mniejsza niż-1.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wysyła dane do określonego punktu końcowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> Reprezentuje miejsce docelowe dla danych.</param>
        <summary>Wysyła dane do określonego punktu końcowego.</summary>
        <returns>Liczba wysłanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W tym przeciążeniu wartość domyślna przesunięcia bufora to 0, liczba bajtów wysyłanych domyślnie do rozmiaru `buffer` parametru, a wartością domyślną jest <xref:System.Net.Sockets.SocketFlags> 0.  
  
 Jeśli używasz bezpołączeniowego protokołu, nie musisz nawiązać domyślnego hosta zdalnego z <xref:System.Net.Sockets.Socket.Connect%2A> metodą przed wywołaniem. <xref:System.Net.Sockets.Socket.SendTo%2A> Wystarczy wykonać tę czynność tylko wtedy, gdy zamierzasz wywołać <xref:System.Net.Sockets.Socket.Send%2A> metodę. Jeśli wywołasz <xref:System.Net.Sockets.Socket.Connect%2A> metodę przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` parametr zastąpi określony domyślny host zdalny tylko dla tej operacji wysyłania. Nie jest również wymagane wywoływanie <xref:System.Net.Sockets.Socket.Bind%2A> metody, ponieważ dostawca usługi bazowej przypisze najbardziej odpowiedni adres sieci lokalnej i numer portu. Jeśli trzeba zidentyfikować przypisany adres sieci lokalnej i numer portu, można użyć <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwości <xref:System.Net.Sockets.Socket.SendTo%2A> po pomyślnym ukończeniu metody.  
  
 Chociaż są przeznaczone dla bezpołączeniych protokołów, <xref:System.Net.Sockets.Socket.SendTo%2A> działa również z protokołami zorientowanymi na połączenia. W przypadku korzystania z protokołu zorientowanego na połączenia należy najpierw ustanowić połączenie z hostem zdalnym, wywołując <xref:System.Net.Sockets.Socket.Connect%2A> metodę lub akceptując żądanie połączenia przychodzącego <xref:System.Net.Sockets.Socket.Accept%2A> za pomocą metody. Jeśli połączenie z hostem zdalnym nie zostanie nawiązane lub zaakceptowane, <xref:System.Net.Sockets.Socket.SendTo%2A> program zgłosi wartość. <xref:System.Net.Sockets.SocketException> Przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A> metody można również ustanowić domyślnego hosta zdalnego dla bezpołączeniowego protokołu. W każdym z tych przypadków <xref:System.Net.Sockets.Socket.SendTo%2A> program zignoruje ten `remoteEP` parametr i wyśle tylko dane do podłączonego lub domyślnego hosta zdalnego.  
  
 Blokowanie gniazd zostanie zablokowane do momentu wysłania wszystkich bajtów w buforze. Ponieważ nie jest <xref:System.Net.Sockets.Socket> wykonywane natychmiastowe zakończenie, może nie wysłać wszystkich bajtów `buffer`w. Jest to odpowiedzialność aplikacji do śledzenia liczby wysłanych bajtów i ponawiania operacji do momentu, gdy aplikacja wyśle wszystkie bajty w `buffer`. Nie ma również gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci. Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendTo%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.  
  
 Jeśli używasz protokołu bezpołączeni w trybie blokowania, <xref:System.Net.Sockets.Socket.SendTo%2A> program zablokuje do momentu wysłania datagramu. Jeśli chcesz wysłać dane do adresu emisji, musisz najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodę i ustawić opcję gniazda na. <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> Należy również upewnić się, że liczba wysłanych bajtów nie przekracza maksymalnego rozmiaru pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.SendTo%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła bezpołączeniowy datagram do określonego hosta zdalnego.  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="remoteEP" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> Reprezentuje lokalizację docelową dla danych.</param>
        <summary>Wysyła dane do określonego punktu końcowego przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba wysłanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W tym przeciążeniu bufor przesunięty domyślnie do wartości 0 i liczba bajtów, które mają zostać wysłane domyślnie do rozmiaru `buffer`. Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketflags` jako parametr, wysyłane dane nie będą kierowane.  
  
 Jeśli używasz bezpołączeniowego protokołu, nie musisz nawiązać domyślnego hosta zdalnego z <xref:System.Net.Sockets.Socket.Connect%2A> metodą przed wywołaniem. <xref:System.Net.Sockets.Socket.SendTo%2A> Wystarczy wykonać tę czynność tylko wtedy, gdy zamierzasz wywołać <xref:System.Net.Sockets.Socket.Send%2A> metodę. Jeśli wywołasz <xref:System.Net.Sockets.Socket.Connect%2A> metodę przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` parametr zastąpi określony domyślny host zdalny tylko dla tej operacji wysyłania. Nie jest również wymagane wywoływanie <xref:System.Net.Sockets.Socket.Bind%2A> metody, ponieważ dostawca usługi bazowej przypisze najbardziej odpowiedni adres sieci lokalnej i numer portu. Jeśli trzeba zidentyfikować przypisany adres sieci lokalnej i numer portu, można użyć <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwości <xref:System.Net.Sockets.Socket.SendTo%2A> po pomyślnym ukończeniu metody.  
  
 Chociaż są przeznaczone dla bezpołączeniych protokołów, <xref:System.Net.Sockets.Socket.SendTo%2A> działa również z protokołami zorientowanymi na połączenia. W przypadku korzystania z protokołu zorientowanego na połączenia należy najpierw ustanowić połączenie z hostem zdalnym, wywołując <xref:System.Net.Sockets.Socket.Connect%2A> metodę lub akceptując żądanie połączenia przychodzącego <xref:System.Net.Sockets.Socket.Accept%2A> za pomocą metody. Jeśli połączenie z hostem zdalnym nie zostanie nawiązane lub zaakceptowane, <xref:System.Net.Sockets.Socket.SendTo%2A> program zgłosi wartość. <xref:System.Net.Sockets.SocketException> Przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A> metody można również ustanowić domyślnego hosta zdalnego dla bezpołączeniowego protokołu. W każdym z tych przypadków <xref:System.Net.Sockets.Socket.SendTo%2A> program zignoruje ten `remoteEP` parametr i wyśle tylko dane do podłączonego lub domyślnego hosta zdalnego.  
  
 Blokowanie gniazd zostanie zablokowane do momentu wysłania żądanych wszystkich bajtów `buffer` w. Ponieważ nie jest <xref:System.Net.Sockets.Socket> wykonywane natychmiastowe zakończenie, może nie wysłać wszystkich bajtów `buffer`w. Jest to odpowiedzialność aplikacji do śledzenia liczby wysłanych bajtów i ponawiania operacji do momentu, gdy aplikacja wyśle wszystkie bajty w `buffer`. Nie ma również gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci. Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych, które zostaną zebrane. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendTo%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.  
  
 Jeśli używasz protokołu bezpołączeni w trybie blokowania, <xref:System.Net.Sockets.Socket.SendTo%2A> program zablokuje do momentu wysłania datagramu. Jeśli chcesz wysłać dane do adresu emisji, musisz najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodę i ustawić opcję gniazda na. <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> Należy również upewnić się, że liczba wysłanych bajtów nie przekracza maksymalnego rozmiaru pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.SendTo%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła bezpołączeniowy datagram do określonego hosta zdalnego. <xref:System.Net.Sockets.SocketFlags>są przesyłane do <xref:System.Net.Sockets.Socket.SendTo%2A> metody.  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="remoteEP" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</param>
        <param name="size">Liczba bajtów do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> Reprezentuje lokalizację docelową dla danych.</param>
        <summary>Wysyła określoną liczbę bajtów danych do określonego punktu końcowego przy użyciu określonej <see cref="T:System.Net.Sockets.SocketFlags" />wartości.</summary>
        <returns>Liczba wysłanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W tym przeciążeniu przesunięcie buforu domyślnie wynosi 0. Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketflags` jako parametr, wysyłane dane nie będą kierowane.  
  
 Jeśli używasz bezpołączeniowego protokołu, nie musisz nawiązać domyślnego hosta zdalnego z <xref:System.Net.Sockets.Socket.Connect%2A> metodą przed wywołaniem. <xref:System.Net.Sockets.Socket.SendTo%2A> Wystarczy wykonać tę czynność tylko wtedy, gdy zamierzasz wywołać <xref:System.Net.Sockets.Socket.Send%2A> metodę. Jeśli wywołasz <xref:System.Net.Sockets.Socket.Connect%2A> metodę przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` parametr zastąpi określony domyślny host zdalny tylko dla tej operacji wysyłania. Nie jest również wymagane wywoływanie <xref:System.Net.Sockets.Socket.Bind%2A> metody, ponieważ dostawca usługi bazowej przypisze najbardziej odpowiedni adres sieci lokalnej i numer portu. Jeśli trzeba zidentyfikować przypisany adres sieci lokalnej i numer portu, można użyć <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwości <xref:System.Net.Sockets.Socket.SendTo%2A> po pomyślnym ukończeniu metody.  
  
 Chociaż są przeznaczone dla bezpołączeniych protokołów, <xref:System.Net.Sockets.Socket.SendTo%2A> działa również z protokołami zorientowanymi na połączenia. W przypadku korzystania z protokołu zorientowanego na połączenia należy najpierw ustanowić połączenie z hostem zdalnym, wywołując <xref:System.Net.Sockets.Socket.Connect%2A> metodę lub akceptując żądanie połączenia przychodzącego <xref:System.Net.Sockets.Socket.Accept%2A> za pomocą metody. Jeśli połączenie z hostem zdalnym nie zostanie nawiązane lub zaakceptowane, <xref:System.Net.Sockets.Socket.SendTo%2A> program zgłosi wartość. <xref:System.Net.Sockets.SocketException> Przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A> metody można również ustanowić domyślnego hosta zdalnego dla bezpołączeniowego protokołu. W każdym z tych przypadków <xref:System.Net.Sockets.Socket.SendTo%2A> program zignoruje ten `remoteEP` parametr i wyśle tylko dane do podłączonego lub domyślnego hosta zdalnego.  
  
 Blokowanie gniazd zostanie zablokowane do momentu wysłania żądanej liczby bajtów. Ponieważ nie jest <xref:System.Net.Sockets.Socket> wykonywane natychmiastowe zakończenie, może nie wysłać wszystkich żądanych bajtów w ramach jednej operacji. Jest to odpowiedzialność aplikacji do śledzenia liczby wysłanych bajtów i ponawiania operacji do momentu, gdy aplikacja wyśle żądaną liczbę bajtów. Nie ma również gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci. Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych, które zostaną zebrane. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendTo%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.  
  
 Jeśli używasz protokołu bezpołączeni w trybie blokowania, <xref:System.Net.Sockets.Socket.SendTo%2A> program zablokuje do momentu wysłania datagramu. Jeśli chcesz wysłać dane do adresu emisji, musisz najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodę i ustawić opcję gniazda na. <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> Należy również upewnić się, że liczba wysłanych bajtów nie przekracza maksymalnego rozmiaru pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.SendTo%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła bezpołączeniowy datagram do określonego hosta zdalnego. Rozmiar i <xref:System.Net.Sockets.SocketFlags> są przesyłane <xref:System.Net.Sockets.Socket.SendTo%2A> do metody.  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="remoteEP" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Określona <paramref name="size" /> wartość przekracza <paramref name="buffer" />rozmiar.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</param>
        <param name="offset">Pozycja w buforze danych, w której mają zostać rozpoczęte wysyłanie danych.</param>
        <param name="size">Liczba bajtów do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> Reprezentuje lokalizację docelową dla danych.</param>
        <summary>Wysyła określoną liczbę bajtów danych do określonego punktu końcowego, rozpoczynając od określonej lokalizacji w buforze i używając określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba wysłanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W tym przeciążeniu, jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketflags` jako parametr, wysyłane dane nie będą kierowane.  
  
 Jeśli używasz bezpołączeniowego protokołu, nie musisz nawiązać domyślnego hosta zdalnego z <xref:System.Net.Sockets.Socket.Connect%2A> metodą przed wywołaniem. <xref:System.Net.Sockets.Socket.SendTo%2A> Wystarczy wykonać tę czynność tylko wtedy, gdy zamierzasz wywołać <xref:System.Net.Sockets.Socket.Send%2A> metodę. Jeśli wywołasz <xref:System.Net.Sockets.Socket.Connect%2A> metodę przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` parametr zastąpi określony domyślny host zdalny tylko dla tej operacji wysyłania. Nie jest również wymagane wywoływanie <xref:System.Net.Sockets.Socket.Bind%2A> metody, ponieważ dostawca usługi bazowej przypisze najbardziej odpowiedni adres sieci lokalnej i numer portu. Jeśli trzeba zidentyfikować przypisany adres sieci lokalnej i numer portu, można użyć <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwości <xref:System.Net.Sockets.Socket.SendTo%2A> po pomyślnym ukończeniu metody.  
  
 Chociaż są przeznaczone dla bezpołączeniych protokołów, <xref:System.Net.Sockets.Socket.SendTo%2A> działa również z protokołami zorientowanymi na połączenia. W przypadku korzystania z protokołu zorientowanego na połączenia należy najpierw ustanowić połączenie z hostem zdalnym, wywołując <xref:System.Net.Sockets.Socket.Connect%2A> metodę lub akceptując żądanie połączenia przychodzącego <xref:System.Net.Sockets.Socket.Accept%2A> za pomocą metody. Jeśli połączenie z hostem zdalnym nie zostanie nawiązane lub zaakceptowane, <xref:System.Net.Sockets.Socket.SendTo%2A> program zgłosi wartość. <xref:System.Net.Sockets.SocketException> Przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A> metody można również ustanowić domyślnego hosta zdalnego dla bezpołączeniowego protokołu. W każdym z tych przypadków <xref:System.Net.Sockets.Socket.SendTo%2A> program zignoruje ten `remoteEP` parametr i wyśle tylko dane do podłączonego lub domyślnego hosta zdalnego.  
  
 Blokowanie gniazd zostanie zablokowane do momentu wysłania żądanej liczby bajtów. Od momentu natychmiastowego <xref:System.Net.Sockets.Socket> zakończenia nie można wysłać wszystkich żądanych bajtów w ramach jednej operacji. Aplikacje są odpowiedzialne za śledzenie liczby wysłanych bajtów i ponawianie operacji do momentu wysłania przez aplikację żądanej liczby bajtów. Nie ma również gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci. Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych, które zostaną zebrane. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendTo%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.  
  
 Jeśli używasz protokołu bezpołączeni w trybie blokowania, <xref:System.Net.Sockets.Socket.SendTo%2A> program zablokuje do momentu wysłania datagramu. Jeśli chcesz wysłać dane do adresu emisji, musisz najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodę i ustawić opcję gniazda na. <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> Należy również upewnić się, że rozmiar nie przekracza maksymalnego rozmiaru pakietu dostawcy usługi. Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.SendTo%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła bezpołączeniowy datagram do określonego hosta zdalnego. Przesunięcie, rozmiar i <xref:System.Net.Sockets.SocketFlags> są przesyłane <xref:System.Net.Sockets.Socket.SendTo%2A> do metody.  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="remoteEP" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" />jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" />nie jest prawidłową kombinacją wartości.  
  
—lub— 
Wystąpił błąd systemu operacyjnego podczas uzyskiwania dostępu <see cref="T:System.Net.Sockets.Socket" />do programu.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w stosie wywołań nie ma wymaganych uprawnień.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Obiekt <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> , który ma być używany dla tej asynchronicznej operacji gniazda.</param>
        <summary>Wysyła dane asynchronicznie do określonego hosta zdalnego.</summary>
        <returns><see langword="true" />Jeśli operacja we/wy jest w stanie oczekiwania. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie<paramref name="e" /> na parametrze zostanie wywołane po zakończeniu operacji.  
  
 <see langword="false" />Jeśli operacja we/wy została ukończona synchronicznie. W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie <paramref name="e" /> na parametrze <paramref name="e" /> nie zostanie zgłoszone i obiekt przenoszony jako parametr może zostać zbadany natychmiast po wywołaniu metody, aby pobrać wynik operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda uruchamia asynchroniczną operację wysyłania do hosta zdalnego określonego <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> we właściwości `e` parametru. <xref:System.Net.Sockets.Socket.SendToAsync%2A> <xref:System.Net.Sockets.Socket.SendToAsync%2A> Wywołanie metody daje możliwość wysyłania danych w osobnym wątku wykonania. Mimo że ta metoda jest przeznaczona dla protokołów bezpołączeniowych, <xref:System.Net.Sockets.Socket.SendToAsync%2A> działa z protokołami bezpołączeniowymi i zorientowanymi na połączenia.  
  
 Aby otrzymywać powiadomienia o zakończeniu, należy utworzyć metodę wywołania zwrotnego implementującą delegata\<EventHandler SocketAsyncEventArgs > i dołączyć wywołanie zwrotne <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> do zdarzenia.  
  
 Następujące właściwości i zdarzenia w <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiekcie są wymagane do pomyślnego wywołania tej metody:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość na dowolny obiekt stanu użytkownika przed <xref:System.Net.Sockets.Socket.SendToAsync%2A> wywołaniem metody, tak aby informacje były możliwe do pobierania w metodzie wywołania zwrotnego. Jeśli wywołanie zwrotne wymaga więcej informacji niż pojedynczy obiekt, można utworzyć małą klasę w celu przechowywania innych wymaganych informacji o stanie jako członków.  
  
 W przypadku korzystania z <xref:System.Net.Sockets.Socket.Accept%2A>protokołu zorientowanego na połączenia należy najpierw wywołać metodę <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.AcceptAsync%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>,,, lub <xref:System.Net.Sockets.Socket.ConnectAsync%2A> . W <xref:System.Net.Sockets.Socket.SendToAsync%2A> przeciwnym razie <xref:System.Net.Sockets.SocketException>wygeneruje. <xref:System.Net.Sockets.Socket.SendToAsync%2A> W przypadku korzystania z protokołu zorientowanego na połączenia Metoda <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> zignoruje Właściwość <xref:System.Net.EndPoint?displayProperty=nameWithType> i wyśle dane <xref:System.Net.Sockets.Socket.Accept%2A>do ustanowionych w, <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.AcceptAsync%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A>,,, <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Metoda.  
  
 Jeśli używasz bezpołączeniowego protokołu, nie <xref:System.Net.Sockets.Socket.BeginConnect%2A>musisz nawiązać domyślnego hosta zdalnego z, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metody przed wywołaniem <xref:System.Net.Sockets.Socket.SendToAsync%2A>. Wystarczy wykonać tę czynność tylko wtedy, gdy zamierzasz wywołać <xref:System.Net.Sockets.Socket.BeginSend%2A> metody lub. <xref:System.Net.Sockets.Socket.SendAsync%2A> W przypadku <xref:System.Net.Sockets.Socket.BeginConnect%2A>wywołania metody, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> <xref:System.Net.Sockets.Socket.Connect%2A>, lub przed wywołaniem <xref:System.Net.Sockets.Socket.SendToAsync%2A> <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Właściwość zastąpi określony domyślny host zdalny tylko dla tej operacji wysyłania. Nie jest również wymagane wywoływanie <xref:System.Net.Sockets.Socket.Bind%2A> metody. W takim przypadku Dostawca usługi podstawowej będzie przypisywać najbardziej odpowiedni adres IP sieci lokalnej i numer portu. Użyj numeru portu równego zero, jeśli chcesz, aby Dostawca usługi podstawowej wybierał bezpłatny port. Jeśli musisz zidentyfikować przypisany adres IP sieci lokalnej i numer portu, możesz użyć <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwości <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> po zasygnalizowaniu zdarzenia i wywołaniu skojarzonych delegatów.  
  
 Aby wysłać dane do adresu emisji, należy najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodę i ustawić dla <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> opcji gniazda wartość true. Należy również upewnić się, że rozmiar buforu nie przekracza maksymalnego rozmiaru pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.SendToAsync%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.  
  
 Jeśli określisz flagę DontRoute we <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> właściwości, wysyłane dane nie będą kierowane.  
  
 W przypadku gniazd zorientowanych na komunikaty należy zachować ostrożność, aby nie przekroczyć maksymalnego rozmiaru komunikatu dotyczącego transportowego. Jeśli rozmiar buforu przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.SendToAsync%2A> <xref:System.Net.Sockets.SocketException>wygeneruje. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendToAsync%2A> metody nie wskazuje, że dane zostały dostarczone pomyślnie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> Nie może mieć wartości null.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja gniazda była już w toku przy użyciu <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiektu określonego <paramref name="e" /> w parametrze.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda wymaga systemu Windows XP lub nowszego.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Określony protokół jest zorientowany na połączenie, ale <see cref="T:System.Net.Sockets.Socket" /> nie jest jeszcze podłączony.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="level">Poziom ochrony adresów IP do ustawienia w tym gnieździe.</param>
        <summary>Ustaw poziom ochrony adresów IP w gnieździe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> Metoda umożliwia ograniczenie gniazda IPv6 lub IP do nasłuchiwania w określonym zakresie, takich jak adresy z tego samego linku lokalnego lub lokalnego prefiksu lokacji. Ta opcja gniazda umożliwia aplikacjom nakładanie ograniczeń dostępu w przypadku protokołu IPv6 lub IP Sockets. Takie ograniczenia umożliwiają aplikacji działającej w prywatnej sieci LAN, aby po prostu i niezawodnie zabezpieczyć się przed atakami zewnętrznymi. Tej opcji gniazda można także użyć w celu usunięcia ograniczeń dostępu, `level` Jeśli parametr jest ustawiony na. <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted> Ta opcja gniazda rozszerza lub zawęża zakres gniazda nasłuchiwania, umożliwiając nieograniczony dostęp z publicznych i prywatnych użytkowników, jeśli jest to konieczne, lub ograniczanie dostępu tylko do tej samej lokacji, zgodnie z wymaganiami.  
  
 Ta opcja gniazda ma zdefiniowane poziomy ochrony określone w <xref:System.Net.Sockets.IPProtectionLevel> wyliczeniu.  
  
 Metoda jest używana do włączania lub wyłączania przechodzenia między adresami sieciowymi (NAT) <xref:System.Net.Sockets.Socket> dla wystąpienia. <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> Przechodzenie NAT może być zapewnione przy użyciu protokołu Teredo, 6to4 lub tunelu ISATAP.  
  
 Gdy parametr jest ustawiony na <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted> <xref:System.Net.Sockets.IPProtectionLevel.Restricted> lub<xref:System.Net.Sockets.Socket> , jawnie wyłącza przechodzenie translatora adresów sieciowych dla wystąpienia. `level`  
  
 Gdy parametr jest ustawiony na <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, może to <xref:System.Net.Sockets.Socket> umożliwić Przechodzenie translatora adresów sieciowych w zależności od zasad zapory w miejscu systemu. `level`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Parametr nie może być <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />. <paramref name="level" /> Nie można ustawić wartości unnieokreślone dla poziomu ochrony adresów IP.</exception>
        <exception cref="T:System.NotSupportedException">Gniazdo musi mieć wartość <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />. <see cref="T:System.Net.Sockets.AddressFamily" /></exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> Ustawia opcję.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Jedna z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</param>
        <param name="optionName">Jedna z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</param>
        <param name="optionValue">Wartość opcji, reprezentowana jako <see cref="T:System.Boolean" />.</param>
        <summary>Ustawia określoną <see cref="T:System.Net.Sockets.Socket" /> opcję dla określonej <see cref="T:System.Boolean" /> wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>opcje określają zachowanie bieżącego <xref:System.Net.Sockets.Socket>elementu. Ustaw, aby włączyć opcję, lub `false` aby wyłączyć opcję. `optionValue` `true`  
  
 <xref:System.Net.Sockets.Socket>opcje są pogrupowane według poziomu obsługi protokołu.  
  
 Poniżej wymieniono różne <xref:System.Net.Sockets.Socket> opcje, które można ustawić za pomocą tego przeciążenia. Te opcje są pogrupowane według odpowiedniej <xref:System.Net.Sockets.SocketOptionLevel> wartości. Jeśli zamierzasz ustawić dowolną z tych opcji, pamiętaj, aby użyć odpowiedniej <xref:System.Net.Sockets.SocketOptionLevel> wartości `optionLevel` parametru. Opcja wybrana do ustawienia musi być określona w `optionName` parametrze. Jeśli chcesz uzyskać bieżącą wartość dowolnej z wymienionych opcji, użyj <xref:System.Net.Sockets.Socket.GetSocketOption%2A> metody.  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType>Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType>Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType>Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType>Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 Aby uzyskać więcej informacji na temat tych opcji, zapoznaj się z <xref:System.Net.Sockets.SocketOptionName> wyliczeniem.  
  
> [!NOTE]
>  Jeśli wystąpi <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> wyjątek, użyj właściwości, aby uzyskać określony kod błędu. <xref:System.Net.Sockets.SocketException> Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera gniazdo i włącza `DontLinger` opcje `OutOfBandInline` i gniazda.  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Jedna z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</param>
        <param name="optionName">Jedna z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</param>
        <param name="optionValue">Tablica typu <see cref="T:System.Byte" /> , która reprezentuje wartość opcji.</param>
        <summary>Ustawia określoną <see cref="T:System.Net.Sockets.Socket" /> opcję na określoną wartość, reprezentowane jako tablica bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>opcje określają zachowanie bieżącego <xref:System.Net.Sockets.Socket>elementu. Użyj tego przeciążenia, aby ustawić <xref:System.Net.Sockets.Socket> te opcje, które wymagają tablicy bajtowej jako wartości opcji.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia <xref:System.Net.Sockets.LingerOption> wartości i <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Jedna z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</param>
        <param name="optionName">Jedna z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</param>
        <param name="optionValue">Wartość opcji.</param>
        <summary>Ustawia określoną <see cref="T:System.Net.Sockets.Socket" /> opcję na określoną wartość całkowitą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>opcje określają zachowanie bieżącego <xref:System.Net.Sockets.Socket>elementu. Dla opcji z <xref:System.Boolean> typem danych określ wartość różną od zera, aby włączyć tę opcję, i wartość zerową, aby wyłączyć opcję. Dla opcji z typem danych Integer Określ odpowiednią wartość. <xref:System.Net.Sockets.Socket>opcje są pogrupowane według poziomu obsługi protokołu.  
  
 Poniżej wymieniono różne <xref:System.Net.Sockets.Socket> opcje, które można ustawić za pomocą tego przeciążenia. Te opcje są pogrupowane według odpowiednich <xref:System.Net.Sockets.SocketOptionLevel>. Jeśli zamierzasz ustawić dowolną z tych opcji, upewnij się, że użyto odpowiedniej <xref:System.Net.Sockets.SocketOptionLevel> `optionLevel` wartości parametru. Opcja wybrana do ustawienia musi być określona w `optionName` parametrze. Jeśli chcesz uzyskać bieżącą wartość dowolnej z wymienionych opcji, użyj <xref:System.Net.Sockets.Socket.GetSocketOption%2A> metody.  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType>Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType>Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType>Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType>Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType>Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 Aby uzyskać więcej informacji na temat tych opcji, zapoznaj się z <xref:System.Net.Sockets.SocketOptionName> wyliczeniem.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia <xref:System.Net.Sockets.LingerOption> wartości i <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Object" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Jedna z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</param>
        <param name="optionName">Jedna z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</param>
        <param name="optionValue"><see cref="T:System.Net.Sockets.LingerOption" /> Lub<see cref="T:System.Net.Sockets.MulticastOption" /> , który zawiera wartość opcji.</param>
        <summary>Ustawia określoną <see cref="T:System.Net.Sockets.Socket" /> opcję na określoną wartość, reprezentowane jako obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>opcje określają zachowanie bieżącego <xref:System.Net.Sockets.Socket>elementu. Użyj tego <xref:System.Net.Sockets.SocketOptionName.Linger>przeciążenia, aby ustawić opcje <xref:System.Net.Sockets.SocketOptionName.AddMembership>, i <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> . <xref:System.Net.Sockets.Socket> Dla opcji Użyj`optionLevel` parametru. <xref:System.Net.Sockets.SocketOptionName.Linger> Dla <xref:System.Net.Sockets.SocketOptionName.AddMembership> i <xref:System.Net.Sockets.SocketOptionName.DropMembership>, użyj <xref:System.Net.Sockets.SocketOptionLevel.IP>. Jeśli chcesz uzyskać bieżącą wartość dowolnej z wymienionych powyżej opcji, użyj <xref:System.Net.Sockets.Socket.GetSocketOption%2A> metody.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia <xref:System.Net.Sockets.LingerOption> wartości i <xref:System.Net.Sockets.Socket.Send%2A> limit czasu.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="optionValue" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">Jedna z <see cref="T:System.Net.Sockets.SocketShutdown" /> wartości, która określa operację, która nie będzie już dozwolona.</param>
        <summary>Wyłącza wysyłanie i odbiera w <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku korzystania z ukierunkowanych <xref:System.Net.Sockets.Socket>połączeń, zawsze <xref:System.Net.Sockets.Socket.Shutdown%2A> Wywołaj metodę przed zamknięciem <xref:System.Net.Sockets.Socket>. Gwarantuje to, że wszystkie dane zostaną wysłane i odebrane w podłączonym gnieździe przed jego zamknięciem.  
  
 Wywołaj <xref:System.Net.Sockets.Socket.Close%2A> metodę, aby zwolnić wszystkie zarządzane i niezarządzane zasoby skojarzone <xref:System.Net.Sockets.Socket>z. Nie próbuj ponownie używać <xref:System.Net.Sockets.Socket> po zamknięciu.  
  
 W poniższej tabeli przedstawiono <xref:System.Net.Sockets.SocketShutdown> wartości wyliczenia, które są prawidłowe `how` dla parametru.  
  
|Wartość|Opis|  
|-----------|-----------------|  
|Send|Wyłącz wysyłanie na ten <xref:System.Net.Sockets.Socket>temat.|  
|Receive|Wyłącz otrzymywanie na tym <xref:System.Net.Sockets.Socket>komputerze.|  
|Oba|Wyłącz wysyłanie i otrzymywanie na tym <xref:System.Net.Sockets.Socket>komputerze.|  
  
 Ustawienie `how` określa,żekolejnewywołaniametodysąniedozwolone.<xref:System.Net.Sockets.SocketShutdown.Send> <xref:System.Net.Sockets.Socket.Send%2A> Jeśli używasz bezpołączeniowego <xref:System.Net.Sockets.Socket>, określenie <xref:System.Net.Sockets.SocketShutdown.Send> nie będzie miało żadnego efektu.  
  
 Ustawienie `how` określa,żekolejnewywołaniametodysąniedozwolone.<xref:System.Net.Sockets.SocketShutdown.Receive> <xref:System.Net.Sockets.Socket.Receive%2A> Nie ma to wpływu na niższe warstwy protokołu. Jeśli używasz protokołu zorientowanego na połączenia, połączenie jest przerywane, jeśli jeden z następujących warunków istnieje po wywołaniu <xref:System.Net.Sockets.Socket.Shutdown%2A> :  
  
-   Dane znajdujące się w przychodzącym buforze sieciowym oczekują na odebranie.  
  
-   Osiągnięto więcej danych.  
  
 W przypadku korzystania z bezpołączeniowego protokołu datagramy są akceptowane i umieszczane w kolejce. Jeśli jednak żadne miejsce w buforze nie jest dostępne w przypadku dodatkowych datagramów przychodzących, zostaną odrzucone, a nadawca nie zwróci żadnego błędu. Nie <xref:System.Net.Sockets.Socket.Shutdown%2A> zaleca się używania <xref:System.Net.Sockets.Socket> w przypadku bezpołączeniowego.  
  
 Ustawienie `how` do <xref:System.Net.Sockets.SocketShutdown.Both> wyłączania wysyłanych i odbieranych danych zgodnie z powyższym opisem.  
  
> [!NOTE]
>  Jeśli podczas <xref:System.Net.Sockets.SocketException> <xref:System.Net.Sockets.Socket.Shutdown%2A> wywoływania metody zostanie wyświetlony komunikat o błędzie, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Net.Sockets.Socket.Shutdown%2A> do <xref:System.Net.Sockets.Socket>wyłączania.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Jedna z <see cref="T:System.Net.Sockets.SocketType" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SocketType%2A>jest tylko do odczytu i jest ustawiana podczas <xref:System.Net.Sockets.Socket> tworzenia.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, i <xref:System.Net.Sockets.ProtocolType> do konsoli programu.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy obsługa protokołu IPv4 jest dostępna i włączona na bieżącym hoście.</summary>
        <value><see langword="true" />Jeśli bieżący Host obsługuje protokół IPv4; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 System operacyjny może obsługiwać zarówno Protokoły IPv4, jak i IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy platforma obsługuje protokół IPv6 dla niektórych przestarzałych <see cref="T:System.Net.Dns" /> elementów członkowskich.</summary>
        <value><see langword="true" />Jeśli struktura obsługuje protokół IPv6 dla niektórych przestarzałych <see cref="T:System.Net.Dns" /> metod; <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 System operacyjny może obsługiwać zarówno Protokoły IPv4, jak i IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez <see cref="T:System.Net.Sockets.Socket" />program.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Wywołaj metodę IDisposable. Dispose po zakończeniu korzystania z <xref:System.Net.Sockets.Socket>. Metoda IDisposable. Dispose Pozostawia <xref:System.Net.Sockets.Socket> stan w stanie niezdatnym do użytku. Po wywołaniu metody IDisposable. Dispose należy wydać wszystkie odwołania do <xref:System.Net.Sockets.Socket> tak, aby moduł wyrzucania elementów bezużytecznych mógł odzyskiwać pamięć <xref:System.Net.Sockets.Socket> , która zajmuje. Aby uzyskać więcej informacji, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i implementowanie [metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).

> [!NOTE] 
> Zawsze Wywołaj metodę IDisposable. Dispose przed wydaniem ostatniego odwołania do <xref:System.Net.Sockets.Socket>. W przeciwnym razie używane zasoby nie zostaną zwolnione do momentu wywołania <xref:System.Net.Sockets.Socket> `Finalize` metody obiektu przez moduł zbierający elementy bezużyteczne.

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą wartość czasu wygaśnięcia (TTL) pakietów protokołu IP wysyłanych przez <see cref="T:System.Net.Sockets.Socket" />program.</summary>
        <value>Wartość TTL.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość TTL wskazuje maksymalną liczbę routerów, które może przekroczyć pakiet, zanim router odrzuci pakiet i komunikat o błędzie "czas wygaśnięcia protokołu ICMP (Internet Control Message Protocol)" zostanie zwrócony do nadawcy.  
  
 Wartość TTL może być ustawiona na wartość z przenoszącą od 0 do 255. Gdy ta właściwość nie jest ustawiona, domyślną wartością czasu wygaśnięcia dla gniazda jest 32.  
  
 Ustawienie tej właściwości w gnieździe Transmission Control Protocol (TCP) jest ignorowane przez stos TCP/IP, jeśli połączenie zostało nawiązane za pomocą gniazda.  
  
 Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.Ttl%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Nie można ustawić ujemnej wartości parametru TTL.</exception>
        <exception cref="T:System.NotSupportedException">Tę właściwość można ustawić tylko dla gniazd w <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> w rodzinach.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Ten błąd jest również zwracany, gdy podjęto próbę ustawienia czasu wygaśnięcia wartości większej niż 255.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy gniazdo ma korzystać tylko z nakładających się trybów we/wy.</summary>
        <value><see langword="true" />Jeśli używa <see cref="T:System.Net.Sockets.Socket" /> tylko nakładających się operacji we/wy; <see langword="false" />w przeciwnym razie. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw tę właściwość na `true` dla elementu <xref:System.Net.Sockets.Socket> , który ma być <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>wywoływany. W przeciwnym razie Struktura może przypisywać do gniazda port uzupełniania, co uniemożliwi korzystanie z programu <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Gniazdo zostało powiązane z portem ukończenia.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
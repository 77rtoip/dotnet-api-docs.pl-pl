<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata><Meta Name="ms.openlocfilehash" Value="66540fed16744abb368b7e3fa980a5643a9ba7e6" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69112370" /></Metadata><TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="0ed15-101">Implementuje interfejs Berkeley Sockets.</span><span class="sxs-lookup"><span data-stu-id="0ed15-101">Implements the Berkeley sockets interface.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-102"><xref:System.Net.Sockets.Socket> Klasa zawiera rozbudowany zestaw metod i właściwości komunikacji sieciowej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-102">The <xref:System.Net.Sockets.Socket> class provides a rich set of methods and properties for network communications.</span></span> <span data-ttu-id="0ed15-103">Klasa umożliwia przeprowadzenie synchronicznego i asynchronicznego transferu danych przy użyciu dowolnego protokołu komunikacyjnego wymienionego <xref:System.Net.Sockets.ProtocolType> w wyliczeniu. <xref:System.Net.Sockets.Socket></span><span class="sxs-lookup"><span data-stu-id="0ed15-103">The <xref:System.Net.Sockets.Socket> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <xref:System.Net.Sockets.ProtocolType> enumeration.</span></span>  
  
 <span data-ttu-id="0ed15-104">Klasa <xref:System.Net.Sockets.Socket> jest zgodna ze wzorcem nazewnictwa .NET Framework dla metod asynchronicznych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-104">The <xref:System.Net.Sockets.Socket> class follows the .NET Framework naming pattern for asynchronous methods.</span></span> <span data-ttu-id="0ed15-105">Na przykład metoda synchroniczna <xref:System.Net.Sockets.Socket.Receive%2A> odnosi się do metod asynchronicznych <xref:System.Net.Sockets.Socket.EndReceive%2A> <xref:System.Net.Sockets.Socket.BeginReceive%2A> i.</span><span class="sxs-lookup"><span data-stu-id="0ed15-105">For example, the synchronous <xref:System.Net.Sockets.Socket.Receive%2A> method corresponds to the asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods.</span></span>  
  
 <span data-ttu-id="0ed15-106">Jeśli aplikacja wymaga tylko jednego wątku podczas wykonywania, należy użyć następujących metod, które są przeznaczone do trybu operacji synchronicznej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-106">If your application only requires one thread during execution, use the following methods, which are designed for synchronous operation mode.</span></span>  
  
-   <span data-ttu-id="0ed15-107">Jeśli używasz protokołu opartego na połączeniu, takiego jak TCP, serwer może nasłuchiwać połączeń przy użyciu <xref:System.Net.Sockets.Socket.Listen%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-107">If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <xref:System.Net.Sockets.Socket.Listen%2A> method.</span></span> <span data-ttu-id="0ed15-108">Metoda przetwarza wszystkie przychodzące żądania połączenia i <xref:System.Net.Sockets.Socket> zwraca wartość, której można użyć do przekazywania danych z hosta zdalnego. <xref:System.Net.Sockets.Socket.Accept%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-108">The <xref:System.Net.Sockets.Socket.Accept%2A> method processes any incoming connection requests and returns a <xref:System.Net.Sockets.Socket> that you can use to communicate data with the remote host.</span></span> <span data-ttu-id="0ed15-109">Użyj tego zwrócenia <xref:System.Net.Sockets.Socket> do <xref:System.Net.Sockets.Socket.Send%2A> wywołania metody lub <xref:System.Net.Sockets.Socket.Receive%2A> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-109">Use this returned <xref:System.Net.Sockets.Socket> to call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span> <span data-ttu-id="0ed15-110">Wywołaj <xref:System.Net.Sockets.Socket.Listen%2A> metodę przed wywołaniem metody, jeśli chcesz określić lokalny adres IP i numer portu. <xref:System.Net.Sockets.Socket.Bind%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-110">Call the <xref:System.Net.Sockets.Socket.Bind%2A> method prior to calling the <xref:System.Net.Sockets.Socket.Listen%2A> method if you want to specify the local IP address and port number.</span></span> <span data-ttu-id="0ed15-111">Użyj numeru portu równego zero, jeśli chcesz, aby źródłowy Dostawca usługi przypisał dla Ciebie bezpłatny port.</span><span class="sxs-lookup"><span data-stu-id="0ed15-111">Use a port number of zero if you want the underlying service provider to assign a free port for you.</span></span> <span data-ttu-id="0ed15-112">Jeśli chcesz nawiązać połączenie z hostem nasłuchiwania, <xref:System.Net.Sockets.Socket.Connect%2A> Wywołaj metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-112">If you want to connect to a listening host, call the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="0ed15-113">Aby przekazać dane, wywołaj <xref:System.Net.Sockets.Socket.Send%2A> metodę <xref:System.Net.Sockets.Socket.Receive%2A> lub.</span><span class="sxs-lookup"><span data-stu-id="0ed15-113">To communicate data, call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
-   <span data-ttu-id="0ed15-114">Jeśli używasz protokołu bezpołączeniowego, takiego jak UDP, nie musisz nasłuchiwać połączeń w ogóle.</span><span class="sxs-lookup"><span data-stu-id="0ed15-114">If you are using a connectionless protocol such as UDP, you do not need to listen for connections at all.</span></span> <span data-ttu-id="0ed15-115">Wywołaj <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodę, aby zaakceptować wszystkie przychodzące datagramy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-115">Call the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method to accept any incoming datagrams.</span></span> <span data-ttu-id="0ed15-116">Użyj metody <xref:System.Net.Sockets.Socket.SendTo%2A> , aby wysłać datagramy do hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-116">Use the <xref:System.Net.Sockets.Socket.SendTo%2A> method to send datagrams to a remote host.</span></span>  
  
 <span data-ttu-id="0ed15-117">Aby przetwarzać komunikację przy użyciu oddzielnych wątków podczas wykonywania, należy użyć następujących metod, które są przeznaczone do trybu operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-117">To process communications using separate threads during execution, use the following methods, which are designed for asynchronous operation mode.</span></span>  
  
-   <span data-ttu-id="0ed15-118">Jeśli używasz protokołu opartego na połączeniu, takiego jak TCP, użyj <xref:System.Net.Sockets.Socket>metod, i <xref:System.Net.Sockets.Socket.EndConnect%2A> , <xref:System.Net.Sockets.Socket.BeginConnect%2A>aby nawiązać połączenie z hostem nasłuchiwania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-118">If you are using a connection-oriented protocol such as TCP, use the <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, and <xref:System.Net.Sockets.Socket.EndConnect%2A> methods to connect with a listening host.</span></span> <span data-ttu-id="0ed15-119">Użyj metod <xref:System.Net.Sockets.Socket.EndSend%2A> ilub<xref:System.Net.Sockets.Socket.BeginReceive%2A> ,<xref:System.Net.Sockets.Socket.EndReceive%2A> aby komunikować dane asynchronicznie. <xref:System.Net.Sockets.Socket.BeginSend%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-119">Use the <xref:System.Net.Sockets.Socket.BeginSend%2A> and <xref:System.Net.Sockets.Socket.EndSend%2A> or <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods to communicate data asynchronously.</span></span> <span data-ttu-id="0ed15-120">Przychodzące żądania połączeń mogą być przetwarzane przy <xref:System.Net.Sockets.Socket.BeginAccept%2A> użyciu <xref:System.Net.Sockets.Socket.EndAccept%2A>i.</span><span class="sxs-lookup"><span data-stu-id="0ed15-120">Incoming connection requests can be processed using <xref:System.Net.Sockets.Socket.BeginAccept%2A> and <xref:System.Net.Sockets.Socket.EndAccept%2A>.</span></span>  
  
-   <span data-ttu-id="0ed15-121">Jeśli używasz protokołu bezpołączeniowego, takiego jak UDP, możesz <xref:System.Net.Sockets.Socket.BeginSendTo%2A> użyć i <xref:System.Net.Sockets.Socket.EndSendTo%2A> do <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> wysyłania Datagrams <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> oraz do odbierania Datagrams.</span><span class="sxs-lookup"><span data-stu-id="0ed15-121">If you are using a connectionless protocol such as UDP, you can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.EndSendTo%2A> to send datagrams, and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> and <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> to receive datagrams.</span></span>  
  
 <span data-ttu-id="0ed15-122">W przypadku wykonywania wielu operacji asynchronicznych w gnieździe nie są one koniecznie wykonywane w kolejności, w której zostały uruchomione.</span><span class="sxs-lookup"><span data-stu-id="0ed15-122">If you perform multiple asynchronous operations on a socket, they do not necessarily complete in the order in which they are started.</span></span>  
  
 <span data-ttu-id="0ed15-123">Gdy skończysz wysyłać i odbierać dane, użyj <xref:System.Net.Sockets.Socket.Shutdown%2A> metody, aby <xref:System.Net.Sockets.Socket>wyłączyć.</span><span class="sxs-lookup"><span data-stu-id="0ed15-123">When you are finished sending and receiving data, use the <xref:System.Net.Sockets.Socket.Shutdown%2A> method to disable the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-124">Po wywołaniu <xref:System.Net.Sockets.Socket.Shutdown%2A>należy <xref:System.Net.Sockets.Socket.Close%2A> wywołać metodę, aby zwolnić <xref:System.Net.Sockets.Socket>wszystkie zasoby skojarzone z.</span><span class="sxs-lookup"><span data-stu-id="0ed15-124">After calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method to release all resources associated with the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 <span data-ttu-id="0ed15-125">Klasa umożliwia konfigurowanie przy użyciu <xref:System.Net.Sockets.Socket.SetSocketOption%2A>metody. <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket></span><span class="sxs-lookup"><span data-stu-id="0ed15-125">The <xref:System.Net.Sockets.Socket> class allows you to configure your <xref:System.Net.Sockets.Socket> using the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span> <span data-ttu-id="0ed15-126">Pobierz te ustawienia przy użyciu <xref:System.Net.Sockets.Socket.GetSocketOption%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-126">Retrieve these settings using the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-127">Jeśli piszesz stosunkowo prostą aplikację i nie potrzebujesz maksymalnej wydajności, rozważ użycie <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, i <xref:System.Net.Sockets.UdpClient>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-127">If you are writing a relatively simple application and do not require maximum performance, consider using <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, and <xref:System.Net.Sockets.UdpClient>.</span></span> <span data-ttu-id="0ed15-128">Te klasy zapewniają prostsze i bardziej przyjazny dla użytkownika interfejs do <xref:System.Net.Sockets.Socket> komunikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-128">These classes provide a simpler and more user-friendly interface to <xref:System.Net.Sockets.Socket> communications.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-129">Poniższy przykład kodu pokazuje, <xref:System.Net.Sockets.Socket> jak można użyć klasy do wysyłania danych do serwera http i odbierania odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="0ed15-129">The following code example shows how the <xref:System.Net.Sockets.Socket> class can be used to send data to an HTTP server and receive the response.</span></span> <span data-ttu-id="0ed15-130">Ten przykład blokuje do momentu otrzymania całej strony.</span><span class="sxs-lookup"><span data-stu-id="0ed15-130">This example blocks until the entire page is received.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="0ed15-131">Aby nawiązać połączenie wychodzące lub zaakceptować żądanie przychodzące.</span><span class="sxs-lookup"><span data-stu-id="0ed15-131">To establish an outgoing connection or accept an incoming request.</span></span></permission>
    <threadsafe><span data-ttu-id="0ed15-132">Wystąpienia tej klasy są bezpieczne wątkowo.</span><span class="sxs-lookup"><span data-stu-id="0ed15-132">Instances of this class are thread safe.</span></span></threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
    <related type="Article" href="~/docs/framework/network-programming/index.md"><span data-ttu-id="0ed15-133">Programowanie dla sieci w .NET Framework</span><span class="sxs-lookup"><span data-stu-id="0ed15-133">Network Programming in the .NET Framework</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/best-practices-for-system-net-classes.md"><span data-ttu-id="0ed15-134">Najlepsze rozwiązania dotyczące klas System.Net</span><span class="sxs-lookup"><span data-stu-id="0ed15-134">Best Practices for System.Net Classes</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/cache-management-for-network-applications.md"><span data-ttu-id="0ed15-135">Zarządzanie pamięcią podręczną dla aplikacji sieciowych</span><span class="sxs-lookup"><span data-stu-id="0ed15-135">Cache Management for Network Applications</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/internet-protocol-version-6.md"><span data-ttu-id="0ed15-136">Protokół IPv6</span><span class="sxs-lookup"><span data-stu-id="0ed15-136">Internet Protocol Version 6</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/network-programming-samples.md"><span data-ttu-id="0ed15-137">Przykłady programowania sieciowego</span><span class="sxs-lookup"><span data-stu-id="0ed15-137">Network Programming Samples</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/network-tracing.md"><span data-ttu-id="0ed15-138">Śledzenie sieci w .NET Framework</span><span class="sxs-lookup"><span data-stu-id="0ed15-138">Network Tracing in the .NET Framework</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/security-in-network-programming.md"><span data-ttu-id="0ed15-139">Zabezpieczenia w programowaniu sieciowym</span><span class="sxs-lookup"><span data-stu-id="0ed15-139">Security in Network Programming</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/socket-performance-enhancements-in-version-3-5.md"><span data-ttu-id="0ed15-140">Ulepszenia wydajności gniazda w wersji 3.5</span><span class="sxs-lookup"><span data-stu-id="0ed15-140">Socket Performance Enhancements in Version 3.5</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ed15-141">Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.Socket" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-141">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="socketInformation"><span data-ttu-id="0ed15-142">Informacje o gnieździe zwrócone <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />przez.</span><span class="sxs-lookup"><span data-stu-id="0ed15-142">The socket information returned by <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span></span></param>
        <summary><span data-ttu-id="0ed15-143">Inicjuje nowe wystąpienie <see cref="T:System.Net.Sockets.Socket" /> klasy przy użyciu określonej wartości zwróconej z <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-143">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified value returned from <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-144">W przypadku wywołania <xref:System.Net.Sockets.Socket.%23ctor%2A> konstruktora wiele razy z tą samą tablicą bajtową co argument dla każdego wywołania, utworzysz wiele zarządzanych <xref:System.Net.Sockets.Socket>s z tym samym gniazdem podstawowym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-144">If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket>s with the same underlying socket.</span></span> <span data-ttu-id="0ed15-145">Jest to zdecydowanie odradzane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-145">This practice is strongly discouraged.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType"><span data-ttu-id="0ed15-146">Jedna z <see cref="T:System.Net.Sockets.SocketType" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-146">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></param>
        <param name="protocolType"><span data-ttu-id="0ed15-147">Jedna z <see cref="T:System.Net.Sockets.ProtocolType" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-147">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></param>
        <summary><span data-ttu-id="0ed15-148">Inicjuje nowe wystąpienie <see cref="T:System.Net.Sockets.Socket" /> klasy przy użyciu określonego typu gniazda i protokołu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-148">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified socket type and protocol.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-149">Parametr określa typ <xref:System.Net.Sockets.Socket> klasy, a `protocolType` parametr określa protokół używany przez <xref:System.Net.Sockets.Socket>. `socketType`</span><span class="sxs-lookup"><span data-stu-id="0ed15-149">The `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-150">Dwa parametry nie są niezależne.</span><span class="sxs-lookup"><span data-stu-id="0ed15-150">The two parameters are not independent.</span></span> <span data-ttu-id="0ed15-151"><xref:System.Net.Sockets.Socket> Często typ jest niejawny w protokole.</span><span class="sxs-lookup"><span data-stu-id="0ed15-151">Often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol.</span></span> <span data-ttu-id="0ed15-152">Jeśli kombinacja <xref:System.Net.Sockets.Socket> typu i typu protokołu powoduje nieprawidłowy <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.SocketException>, ten konstruktor zgłasza.</span><span class="sxs-lookup"><span data-stu-id="0ed15-152">If the combination of <xref:System.Net.Sockets.Socket> type and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-153">Jeśli ten konstruktor zgłosi <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-153">If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-154">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-154">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-155">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-155">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-156">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-156">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-157">Kombinacja <paramref name="socketType" /> i<paramref name="protocolType" /> skutkuje nieprawidłowym gniazdem.</span><span class="sxs-lookup"><span data-stu-id="0ed15-157">The combination of  <paramref name="socketType" /> and <paramref name="protocolType" /> results in an invalid socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily"><span data-ttu-id="0ed15-158">Jedna z <see cref="T:System.Net.Sockets.AddressFamily" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-158">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</span></span></param>
        <param name="socketType"><span data-ttu-id="0ed15-159">Jedna z <see cref="T:System.Net.Sockets.SocketType" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-159">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></param>
        <param name="protocolType"><span data-ttu-id="0ed15-160">Jedna z <see cref="T:System.Net.Sockets.ProtocolType" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-160">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></param>
        <summary><span data-ttu-id="0ed15-161">Inicjuje nowe wystąpienie <see cref="T:System.Net.Sockets.Socket" /> klasy przy użyciu określonej rodziny adresów, typu gniazda i protokołu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-161">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified address family, socket type and protocol.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-162"><xref:System.Net.Sockets.Socket> `socketType` <xref:System.Net.Sockets.Socket> `protocolType` Parametr określa schemat adresowania używany przez klasę, parametr określa typ klasy, a parametr określa protokół używany przez <xref:System.Net.Sockets.Socket>. `addressFamily`</span><span class="sxs-lookup"><span data-stu-id="0ed15-162">The `addressFamily` parameter specifies the addressing scheme that the <xref:System.Net.Sockets.Socket> class uses, the `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class, and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-163">Trzy parametry nie są niezależne.</span><span class="sxs-lookup"><span data-stu-id="0ed15-163">The three parameters are not independent.</span></span> <span data-ttu-id="0ed15-164">Niektóre rodziny adresów ograniczają, które protokoły mogą być używane z nimi i często <xref:System.Net.Sockets.Socket> typ jest niejawny w protokole.</span><span class="sxs-lookup"><span data-stu-id="0ed15-164">Some address families restrict which protocols can be used with them, and often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol.</span></span> <span data-ttu-id="0ed15-165">Jeśli kombinacja rodziny adresów, <xref:System.Net.Sockets.Socket> typu i typu protokołu powoduje nieprawidłowy <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.SocketException>, ten konstruktor zgłasza.</span><span class="sxs-lookup"><span data-stu-id="0ed15-165">If the combination of address family, <xref:System.Net.Sockets.Socket> type, and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-166">Jeśli ten konstruktor zgłosi <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-166">If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-167">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-167">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-168">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-168">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-169">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-169">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-170">Poniższy przykład kodu demonstruje sposób tworzenia wystąpienia <xref:System.Net.Sockets.Socket> klasy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-170">The following code example demonstrates how to create an instance of the <xref:System.Net.Sockets.Socket> class.</span></span>  
  
 [!code-cpp[Socket_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-171">Kombinacja <paramref name="addressFamily" />, <paramref name="socketType" />i skutkujenieprawidłowymgniazdem.<paramref name="protocolType" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-171">The combination of <paramref name="addressFamily" />, <paramref name="socketType" />, and <paramref name="protocolType" /> results in an invalid socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0ed15-172">Tworzy nowy <see cref="T:System.Net.Sockets.Socket" /> dla nowo utworzonego połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-172">Creates a new <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</span></span></summary>
        <returns><span data-ttu-id="0ed15-173">A <see cref="T:System.Net.Sockets.Socket" /> dla nowo utworzonego połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-173">A <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-174"><xref:System.Net.Sockets.Socket.Accept%2A>synchronicznie wyodrębnia pierwsze oczekujące żądanie połączenia z kolejki żądań połączeń gniazda nasłuchiwania, a następnie tworzy i zwraca nowy <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-174"><xref:System.Net.Sockets.Socket.Accept%2A> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-175">Nie można użyć tej zwracanej <xref:System.Net.Sockets.Socket> w celu zaakceptowania wszelkich dodatkowych połączeń z kolejki połączeń.</span><span class="sxs-lookup"><span data-stu-id="0ed15-175">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="0ed15-176">Można jednak wywołać <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> metodę zwracaną <xref:System.Net.Sockets.Socket> , aby zidentyfikować adres sieciowy i numer portu hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-176">However, you can call the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> method of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.</span></span>  
  
 <span data-ttu-id="0ed15-177">W bloku tryb blokowania <xref:System.Net.Sockets.Socket.Accept%2A> do momentu, gdy zostanie umieszczona próba połączenia przychodzącego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-177">In blocking mode, <xref:System.Net.Sockets.Socket.Accept%2A> blocks until an incoming connection attempt is queued.</span></span> <span data-ttu-id="0ed15-178">Po zaakceptowaniu połączenia oryginalna <xref:System.Net.Sockets.Socket> Usługa kontynuuje przychodzące żądania połączenia do momentu jego zamknięcia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-178">Once a connection is accepted, the original <xref:System.Net.Sockets.Socket> continues queuing incoming connection requests until you close it.</span></span>  
  
 <span data-ttu-id="0ed15-179">W przypadku wywołania tej metody przy użyciu funkcji nieblokującej <xref:System.Net.Sockets.Socket>, a żadne żądania połączenia nie są umieszczane w kolejce, <xref:System.Net.Sockets.Socket.Accept%2A> zgłasza <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-179">If you call this method using a non-blocking <xref:System.Net.Sockets.Socket>, and no connection requests are queued, <xref:System.Net.Sockets.Socket.Accept%2A> throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-180">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-180">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-181">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-181">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-182">Przed wywołaniem <xref:System.Net.Sockets.Socket.Accept%2A> metody należy najpierw <xref:System.Net.Sockets.Socket.Listen%2A> wywołać metodę w celu nasłuchiwania przychodzących żądań połączeń i ich kolejki.</span><span class="sxs-lookup"><span data-stu-id="0ed15-182">Before calling the <xref:System.Net.Sockets.Socket.Accept%2A> method, you must first call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-183">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-183">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-184">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-184">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-185">Poniższy przykład kodu akceptuje proste <xref:System.Net.Sockets.Socket> połączenie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-185">The following code example accepts a simple <xref:System.Net.Sockets.Socket> connection.</span></span>  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-186">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-186">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-187"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-187">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-188">Gniazdo akceptujące nie nasłuchuje połączeń.</span><span class="sxs-lookup"><span data-stu-id="0ed15-188">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="0ed15-189">Musisz wywołać metodę <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> i <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> przed wywołaniem metody <see cref="M:System.Net.Sockets.Socket.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-189">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.Accept" />.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="0ed15-190">Obiekt <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> , który ma być używany dla tej asynchronicznej operacji gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-190">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="0ed15-191">Rozpoczyna operację asynchroniczną w celu zaakceptowania próby połączenia przychodzącego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-191">Begins an asynchronous operation to accept an incoming connection attempt.</span></span></summary>
        <returns><span data-ttu-id="0ed15-192"><see langword="true" />Jeśli operacja we/wy jest w stanie oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-192"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="0ed15-193"><see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie<paramref name="e" /> na parametrze zostanie wywołane po zakończeniu operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-193">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="0ed15-194"><see langword="false" />Jeśli operacja we/wy została ukończona synchronicznie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-194"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="0ed15-195">Zdarzenie na parametrze nie zostanie zgłoszone, a obiektprzesuniętyjakoparametrmożezostaćzbadanynatychmiastpowywołaniumetody,abypobraćwynikoperacji.<paramref name="e" /> <paramref name="e" /> <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-195">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-196">Protokoły zorientowane na połączenia mogą używać <xref:System.Net.Sockets.Socket.AcceptAsync%2A> metody do asynchronicznego przetwarzania przychodzących prób połączeń.</span><span class="sxs-lookup"><span data-stu-id="0ed15-196">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="0ed15-197">Akceptowanie połączeń asynchronicznie daje możliwość wysyłania i odbierania danych w osobnym wątku wykonania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-197">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="0ed15-198">Przed wywołaniem <xref:System.Net.Sockets.Socket.AcceptAsync%2A> metody należy <xref:System.Net.Sockets.Socket.Listen%2A> wywołać metodę, aby nasłuchiwać przychodzących żądań połączeń i kolejkować je.</span><span class="sxs-lookup"><span data-stu-id="0ed15-198">Before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="0ed15-199">Aby otrzymywać powiadomienia o zakończeniu, należy utworzyć metodę wywołania zwrotnego, która implementuje delegata EventHandler\<SocketAsyncEventArgs > i przechwytuje go <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> do zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-199">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and hook it to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="0ed15-200">Wymagane są następujące właściwości i zdarzenia dotyczące <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiektu:</span><span class="sxs-lookup"><span data-stu-id="0ed15-200">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="0ed15-201">Obiekt wywołujący może opcjonalnie określić istniejący <xref:System.Net.Sockets.Socket> do użycia dla połączenia przychodzącego, <xref:System.Net.Sockets.Socket> określając element do użycia z <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> właściwością.</span><span class="sxs-lookup"><span data-stu-id="0ed15-201">The caller can optionally specify an existing <xref:System.Net.Sockets.Socket> to use for the incoming connection by specifying the <xref:System.Net.Sockets.Socket> to use with the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="0ed15-202"><xref:System.Net.Sockets.Socket.ProtocolType%2A> <xref:System.Net.Sockets.Socket.SocketType%2A> <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.AddressFamily%2A> <xref:System.Net.Sockets.Socket> Jeśli właściwość ma wartość null, Nowa jest zbudowana z tą samą, i jako bieżącą i ustawioną jako <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> właściwość. <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0ed15-202">If the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property is null, a new <xref:System.Net.Sockets.Socket> is constructed with the same <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, and <xref:System.Net.Sockets.Socket.ProtocolType%2A> as the current <xref:System.Net.Sockets.Socket> and set as the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="0ed15-203">Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość na dowolny obiekt stanu użytkownika przed <xref:System.Net.Sockets.Socket.AcceptAsync%2A> wywołaniem metody, tak aby informacje były możliwe do pobierania w metodzie wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-203">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="0ed15-204">Jeśli wywołanie zwrotne wymaga więcej informacji niż pojedynczy obiekt, można utworzyć małą klasę w celu przechowywania innych wymaganych informacji o stanie jako członków.</span><span class="sxs-lookup"><span data-stu-id="0ed15-204">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="0ed15-205">Opcjonalnie można określić bufor, który ma otrzymać początkowy blok danych w gnieździe po pomyślnym zakończeniu <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-205">Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="0ed15-206">W tym przypadku <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> właściwość musi być ustawiona na bufor zawierający dane do odebrania, <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> a właściwość musi być ustawiona na maksymalną liczbę bajtów danych do odebrania w buforze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-206">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to receive and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the maximum number of bytes of data to receive in the buffer.</span></span> <span data-ttu-id="0ed15-207">Te właściwości można ustawić za pomocą <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-207">These properties can be set using the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0ed15-208">Część przenoszonego buforu zostanie użyta wewnętrznie do użycia przez bazowe wywołanie AcceptEx.</span><span class="sxs-lookup"><span data-stu-id="0ed15-208">Part of the buffer passed in will be consumed internally for use by the underlying Winsock AcceptEx call.</span></span> <span data-ttu-id="0ed15-209">Oznacza to, że ilość zwracanych danych będzie zawsze mniejsza niż wartość <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> właściwości <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> w podanym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-209">This means that the amount of data returned will always be less than the value of the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> instance provided.</span></span> <span data-ttu-id="0ed15-210">Ilość bufora używana wewnętrznie zależy od rodziny adresów gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-210">The amount of the buffer used internally varies based on the address family of the socket.</span></span> <span data-ttu-id="0ed15-211">Minimalny wymagany rozmiar buforu to 288 bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-211">The minimum buffer size required is 288 bytes.</span></span> <span data-ttu-id="0ed15-212">Jeśli zostanie określony większy rozmiar buforu, <xref:System.Net.Sockets.Socket> będzie on oczekiwać pewnej ilości dodatkowych danych niż dane adresowe odbierane przez wywołanie Winsock AcceptEx i będą oczekiwać na odebranie tych dodatkowych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-212">If a larger buffer size is specified, then the <xref:System.Net.Sockets.Socket> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received.</span></span> <span data-ttu-id="0ed15-213">W przypadku wystąpienia limitu czasu połączenie zostanie zresetowane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-213">If a timeout occurs, the connection is reset.</span></span> <span data-ttu-id="0ed15-214">Tak więc jeśli w przypadku danych dodatkowych jest oczekiwana określona ilość, rozmiar buforu powinien być ustawiony na minimalny rozmiar buforu Plus ta kwota.</span><span class="sxs-lookup"><span data-stu-id="0ed15-214">So if extra data is expected of  a specific amount, then the buffer size should be set to the minimum buffer size plus this amount.</span></span>  
  
 <span data-ttu-id="0ed15-215">Metoda wywołania zwrotnego ukończenia powinna sprawdzić <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> właściwość, aby określić, <xref:System.Net.Sockets.Socket.AcceptAsync%2A> czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-215">The completion callback method should examine the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> property to determine if the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> operation was successful.</span></span>  
  
 <span data-ttu-id="0ed15-216">Zdarzenie może wystąpić w niektórych przypadkach, gdy żadne połączenie nie zostało zaakceptowane i spowoduje <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> , że właściwość jest ustawiona <xref:System.Net.Sockets.SocketError.ConnectionReset>na. <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0ed15-216">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event can occur in some cases when no connection has been accepted and cause the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> property to be set to <xref:System.Net.Sockets.SocketError.ConnectionReset>.</span></span> <span data-ttu-id="0ed15-217">Może się to zdarzyć w wyniku skanowania portów przy użyciu pół-otwartego skanowania typu SYN (syn-> SYN-ACK-> RST).</span><span class="sxs-lookup"><span data-stu-id="0ed15-217">This can occur as a result of port scanning using a half-open SYN type scan (a SYN -> SYN-ACK -> RST sequence).</span></span> <span data-ttu-id="0ed15-218">Aplikacje korzystające <xref:System.Net.Sockets.Socket.AcceptAsync%2A> z metody powinny być przygotowane do obsługi tego warunku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-218">Applications using the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method should be prepared to handle this condition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-219">Argument jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-219">An argument is not valid.</span></span> <span data-ttu-id="0ed15-220">Ten wyjątek występuje, jeśli podany bufor nie jest wystarczająco duży.</span><span class="sxs-lookup"><span data-stu-id="0ed15-220">This exception occurs if the buffer provided is not large enough.</span></span> <span data-ttu-id="0ed15-221">Bufor musi mieć co najmniej 2 \* (sizeof (SOCKADDR_STORAGE + 16) b.</span><span class="sxs-lookup"><span data-stu-id="0ed15-221">The buffer must be at least 2 \* (sizeof(SOCKADDR_STORAGE + 16) bytes.</span></span>  
  
<span data-ttu-id="0ed15-222">Ten wyjątek występuje również wtedy, gdy określono wiele buforów <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> , właściwość nie ma wartości null.</span><span class="sxs-lookup"><span data-stu-id="0ed15-222">This exception also occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-223">Argument jest poza zakresem.</span><span class="sxs-lookup"><span data-stu-id="0ed15-223">An argument is out of range.</span></span> <span data-ttu-id="0ed15-224">Wyjątek występuje, jeśli wartość <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> jest mniejsza od 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-224">The exception occurs if the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-225">Zażądano nieprawidłowej operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-225">An invalid operation was requested.</span></span> <span data-ttu-id="0ed15-226">Ten wyjątek występuje, jeśli akceptowanie <see cref="T:System.Net.Sockets.Socket" /> nie nasłuchuje połączeń lub zaakceptowano gniazdo jest powiązane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-226">This exception occurs if the accepting <see cref="T:System.Net.Sockets.Socket" /> is not listening for connections or the accepted socket is bound.</span></span>  
  
<span data-ttu-id="0ed15-227">Przed wywołaniem <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> metodynależy<see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> wywołać metodę i.</span><span class="sxs-lookup"><span data-stu-id="0ed15-227">You must call the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> method before calling the <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method.</span></span>  
  
<span data-ttu-id="0ed15-228">Ten wyjątek występuje również wtedy, gdy gniazdo jest już połączone lub operacja gniazda była już w toku przy użyciu podanego <paramref name="e" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-228">This exception also occurs if the socket is already connected or a socket operation was already in progress using the specified <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-229">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-229">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-230">Ta metoda wymaga systemu Windows XP lub nowszego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-230">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-231"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-231">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-232">Pobiera rodzinę <see cref="T:System.Net.Sockets.Socket" />adresów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-232">Gets the address family of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="0ed15-233">Jedna z <see cref="T:System.Net.Sockets.AddressFamily" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-233">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-234">Określa schemat adresowania, którego może używać wystąpienie <xref:System.Net.Sockets.Socket> klasy. <xref:System.Net.Sockets.AddressFamily></span><span class="sxs-lookup"><span data-stu-id="0ed15-234">The <xref:System.Net.Sockets.AddressFamily> specifies the addressing scheme that an instance of the <xref:System.Net.Sockets.Socket> class can use.</span></span> <span data-ttu-id="0ed15-235">Ta właściwość jest tylko do odczytu i jest ustawiana podczas <xref:System.Net.Sockets.Socket> tworzenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-235">This property is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-236">Poniższy przykład kodu wyświetla <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, i <xref:System.Net.Sockets.ProtocolType> do konsoli programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-236">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-237">Pobiera ilość danych odebranych z sieci i jest dostępna do odczytu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-237">Gets the amount of data that has been received from the network and is available to be read.</span></span></summary>
        <value><span data-ttu-id="0ed15-238">Liczba bajtów danych odebranych z sieci i dostępnych do odczytu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-238">The number of bytes of data received from the network and available to be read.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-239">Jeśli używasz nieblokującego <xref:System.Net.Sockets.Socket>, to dobry sposób <xref:System.Net.Sockets.Socket.Available%2A> , aby określić, czy dane są umieszczane w kolejce do odczytu, przed <xref:System.Net.Sockets.Socket.Receive%2A>wywołaniem.</span><span class="sxs-lookup"><span data-stu-id="0ed15-239">If you are using a non-blocking <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> is a good way to determine whether data is queued for reading, before calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="0ed15-240">Dostępne dane to całkowita ilość danych znajdujących się w kolejce w buforze sieciowym na potrzeby odczytu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-240">The available data is the total amount of data queued in the network buffer for reading.</span></span> <span data-ttu-id="0ed15-241">Jeśli żadne dane nie są umieszczane w buforze <xref:System.Net.Sockets.Socket.Available%2A> sieciowym, zwraca wartość 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-241">If no data is queued in the network buffer, <xref:System.Net.Sockets.Socket.Available%2A> returns 0.</span></span>  
  
 <span data-ttu-id="0ed15-242">Jeśli host zdalny zamknie lub zamknie połączenie, <xref:System.Net.Sockets.Socket.Available%2A> może <xref:System.Net.Sockets.SocketException>zgłosić.</span><span class="sxs-lookup"><span data-stu-id="0ed15-242">If the remote host shuts down or closes the connection, <xref:System.Net.Sockets.Socket.Available%2A> can throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-243">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-243">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-244">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-244">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-245">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-245">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-246">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-246">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-247">Poniższy przykład kodu porównuje wyniki wywołania IOControl z FIONREAD i dostępne właściwości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-247">The following code example compares the results of calling IOControl with FIONREAD and the Available property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-248">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-248">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-249"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-249">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ed15-250">Rozpoczyna operację asynchroniczną w celu zaakceptowania próby połączenia przychodzącego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-250">Begins an asynchronous operation to accept an incoming connection attempt.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="callback"><span data-ttu-id="0ed15-251"><see cref="T:System.AsyncCallback" /> Delegat.</span><span class="sxs-lookup"><span data-stu-id="0ed15-251">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="0ed15-252">Obiekt, który zawiera informacje o stanie dla tego żądania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-252">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="0ed15-253">Rozpoczyna operację asynchroniczną w celu zaakceptowania próby połączenia przychodzącego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-253">Begins an asynchronous operation to accept an incoming connection attempt.</span></span></summary>
        <returns><span data-ttu-id="0ed15-254">, Który odwołuje się <see cref="T:System.Net.Sockets.Socket" /> do asynchronicznego tworzenia. <see cref="T:System.IAsyncResult" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-254">An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-255">Protokoły zorientowane na połączenia mogą używać <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody do asynchronicznego przetwarzania przychodzących prób połączeń.</span><span class="sxs-lookup"><span data-stu-id="0ed15-255">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="0ed15-256">Akceptowanie połączeń asynchronicznie daje możliwość wysyłania i odbierania danych w osobnym wątku wykonania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-256">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="0ed15-257">Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody należy <xref:System.Net.Sockets.Socket.Listen%2A> wywołać metodę, aby nasłuchiwać przychodzących żądań połączeń i kolejkować je.</span><span class="sxs-lookup"><span data-stu-id="0ed15-257">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="0ed15-258">Należy utworzyć metodę wywołania zwrotnego implementującą <xref:System.AsyncCallback> delegata i przekazać jej nazwę <xref:System.Net.Sockets.Socket.BeginAccept%2A> do metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-258">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="0ed15-259">Aby to zrobić, w bardzo minimalnym czasie należy przekazać obiekt nasłuchujący <xref:System.Net.Sockets.Socket> do <xref:System.Net.Sockets.Socket.BeginAccept%2A> za pomocą `state` parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-259">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="0ed15-260">Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małą klasę do przechowywania <xref:System.Net.Sockets.Socket> i innych wymaganych informacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-260">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="0ed15-261">Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody `state` za pomocą parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-261">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="0ed15-262">Metoda wywołania zwrotnego powinna wywołać <xref:System.Net.Sockets.Socket.EndAccept%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-262">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="0ed15-263">Gdy aplikacja jest wywoływana <xref:System.Net.Sockets.Socket.BeginAccept%2A>, system zazwyczaj używa oddzielnego wątku do wykonywania określonej metody wywołania zwrotnego i <xref:System.Net.Sockets.Socket.EndAccept%2A> blokuje się do momentu pobrania oczekującego połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-263">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span> <span data-ttu-id="0ed15-264"><xref:System.Net.Sockets.Socket.EndAccept%2A>zwróci nowy <xref:System.Net.Sockets.Socket> obiekt, za pomocą którego można wysyłać i odbierać dane przy użyciu hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-264"><xref:System.Net.Sockets.Socket.EndAccept%2A> will return a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="0ed15-265">Nie można użyć tej zwracanej <xref:System.Net.Sockets.Socket> w celu zaakceptowania wszelkich dodatkowych połączeń z kolejki połączeń.</span><span class="sxs-lookup"><span data-stu-id="0ed15-265">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="0ed15-266">Jeśli chcesz, aby oryginalny wątek blokował po wywołaniu <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, użyj. <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0ed15-266">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0ed15-267">Wywołaj metodę <xref:System.Threading.ManualResetEvent> Set w metodzie wywołania zwrotnego, jeśli chcesz, aby oryginalny wątek kontynuował wykonywanie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-267">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="0ed15-268">System może również użyć wątku wywołującego do wywołania metody wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-268">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="0ed15-269">W takim przypadku <xref:System.IAsyncResult.CompletedSynchronously%2A> Właściwość zwracanej <xref:System.IAsyncResult> wartości zostanie <xref:System.Net.Sockets.Socket.BeginAccept%2A> ustawiona, aby wskazać, że metoda została ukończona synchronicznie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-269">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="0ed15-270">Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego [, zobacz kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-270">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="0ed15-271">Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, <xref:System.Net.Sockets.Socket>Zamknij.</span><span class="sxs-lookup"><span data-stu-id="0ed15-271">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-272">Gdy metoda jest wywoływana w trakcie trwającej operacji asynchronicznej, wywołanie zwrotne dostarczone <xref:System.Net.Sockets.Socket.BeginAccept%2A> do metody jest wywoływana. <xref:System.Net.Sockets.Socket.Close%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-272">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="0ed15-273">Kolejne wywołanie <xref:System.Net.Sockets.Socket.EndAccept%2A> metody spowoduje <xref:System.ObjectDisposedException> zgłoszenie do wskazania, że operacja została anulowana.</span><span class="sxs-lookup"><span data-stu-id="0ed15-273">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-274">Możesz użyć <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> właściwości zwracanej <xref:System.Net.Sockets.Socket> , aby zidentyfikować adres sieciowy i numer portu hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-274">You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-275">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-275">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-276">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-276">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-277">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-277">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-278">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-278">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-279">Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-279">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="0ed15-280">Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="0ed15-280">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-281">Poniższy przykład kodu próbuje odebrać połączenie przychodzące asynchronicznie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-281">The following code example attempts to receive an incoming connection asynchronously.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-282"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-282">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-283">Dla tej metody wymagany jest system Windows NT.</span><span class="sxs-lookup"><span data-stu-id="0ed15-283">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-284">Gniazdo akceptujące nie nasłuchuje połączeń.</span><span class="sxs-lookup"><span data-stu-id="0ed15-284">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="0ed15-285">Musisz wywołać metodę <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> i <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> przed wywołaniem metody <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-285">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span>  
  
<span data-ttu-id="0ed15-286">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-286">-or-</span></span> 
<span data-ttu-id="0ed15-287">Zaakceptowane gniazdo jest powiązane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-287">The accepted socket is bound.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-288"><paramref name="receiveSize" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-288"><paramref name="receiveSize" /> is less than 0.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-289">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-289">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="0ed15-290">Przykład asynchronicznego gniazda klienta</span><span class="sxs-lookup"><span data-stu-id="0ed15-290">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="0ed15-291">Przykład asynchronicznego gniazda serwera</span><span class="sxs-lookup"><span data-stu-id="0ed15-291">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="receiveSize"><span data-ttu-id="0ed15-292">Liczba bajtów, które mają zostać zaakceptowane od nadawcy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-292">The number of bytes to accept from the sender.</span></span></param>
        <param name="callback"><span data-ttu-id="0ed15-293"><see cref="T:System.AsyncCallback" /> Delegat.</span><span class="sxs-lookup"><span data-stu-id="0ed15-293">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="0ed15-294">Obiekt, który zawiera informacje o stanie dla tego żądania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-294">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="0ed15-295">Rozpoczyna operację asynchroniczną w celu zaakceptowania próby połączenia przychodzącego i odebrania pierwszego bloku danych wysyłanych przez aplikację kliencką.</span><span class="sxs-lookup"><span data-stu-id="0ed15-295">Begins an asynchronous operation to accept an incoming connection attempt and receives the first block of data sent by the client application.</span></span></summary>
        <returns><span data-ttu-id="0ed15-296">, Który odwołuje się <see cref="T:System.Net.Sockets.Socket" /> do asynchronicznego tworzenia. <see cref="T:System.IAsyncResult" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-296">An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-297">Protokoły zorientowane na połączenia mogą używać <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody do asynchronicznego przetwarzania przychodzących prób połączeń.</span><span class="sxs-lookup"><span data-stu-id="0ed15-297">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="0ed15-298">Akceptowanie połączeń asynchronicznie umożliwia wysyłanie i odbieranie danych w osobnym wątku wykonania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-298">Accepting connections asynchronously enables you to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="0ed15-299">To Przeciążenie pozwala określić liczbę bajtów do zaakceptowania w początkowym transferze w `receiveSize` parametrze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-299">This overload allows you to specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.</span></span>  
  
 <span data-ttu-id="0ed15-300">Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody należy <xref:System.Net.Sockets.Socket.Listen%2A> wywołać metodę, aby nasłuchiwać przychodzących żądań połączeń i kolejkować je.</span><span class="sxs-lookup"><span data-stu-id="0ed15-300">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="0ed15-301">Należy utworzyć metodę wywołania zwrotnego implementującą <xref:System.AsyncCallback> delegata i przekazać jej nazwę <xref:System.Net.Sockets.Socket.BeginAccept%2A> do metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-301">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="0ed15-302">Aby to zrobić, w bardzo minimalnym czasie należy przekazać obiekt nasłuchujący <xref:System.Net.Sockets.Socket> do <xref:System.Net.Sockets.Socket.BeginAccept%2A> za pomocą `state` parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-302">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="0ed15-303">Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małą klasę do przechowywania <xref:System.Net.Sockets.Socket> i innych wymaganych informacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-303">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="0ed15-304">Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody `state` za pomocą parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-304">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="0ed15-305">Metoda wywołania zwrotnego powinna wywołać <xref:System.Net.Sockets.Socket.EndAccept%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-305">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="0ed15-306">Gdy aplikacja jest wywoływana <xref:System.Net.Sockets.Socket.BeginAccept%2A>, system zazwyczaj używa oddzielnego wątku do wykonywania określonej metody wywołania zwrotnego i <xref:System.Net.Sockets.Socket.EndAccept%2A> blokuje się do momentu pobrania oczekującego połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-306">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span>  
  
 <span data-ttu-id="0ed15-307"><xref:System.Net.Sockets.Socket.EndAccept%2A>zwraca nowy <xref:System.Net.Sockets.Socket> , którego można użyć do wysyłania i odbierania danych za pomocą hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-307"><xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="0ed15-308">Nie można użyć tej zwracanej <xref:System.Net.Sockets.Socket> w celu zaakceptowania wszelkich dodatkowych połączeń z kolejki połączeń.</span><span class="sxs-lookup"><span data-stu-id="0ed15-308">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="0ed15-309">Jeśli chcesz, aby oryginalny wątek blokował po wywołaniu <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, użyj. <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0ed15-309">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0ed15-310">Wywołaj metodę <xref:System.Threading.ManualResetEvent> Set w metodzie wywołania zwrotnego, jeśli chcesz, aby oryginalny wątek kontynuował wykonywanie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-310">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="0ed15-311">System może również użyć wątku wywołującego do wywołania metody wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-311">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="0ed15-312">W takim przypadku <xref:System.IAsyncResult.CompletedSynchronously%2A> Właściwość zwracanej <xref:System.IAsyncResult> wartości zostanie <xref:System.Net.Sockets.Socket.BeginAccept%2A> ustawiona, aby wskazać, że metoda została ukończona synchronicznie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-312">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="0ed15-313">Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego [, zobacz kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-313">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="0ed15-314">Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, <xref:System.Net.Sockets.Socket>Zamknij.</span><span class="sxs-lookup"><span data-stu-id="0ed15-314">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span>  <span data-ttu-id="0ed15-315">Gdy metoda jest wywoływana w trakcie trwającej operacji asynchronicznej, wywołanie zwrotne dostarczone <xref:System.Net.Sockets.Socket.BeginAccept%2A> do metody jest wywoływana. <xref:System.Net.Sockets.Socket.Close%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-315">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="0ed15-316">Kolejne wywołanie <xref:System.Net.Sockets.Socket.EndAccept%2A> metody spowoduje <xref:System.ObjectDisposedException> zgłoszenie do wskazania, że operacja została anulowana.</span><span class="sxs-lookup"><span data-stu-id="0ed15-316">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-317">Możesz wywołać użycie <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> właściwości zwracanego <xref:System.Net.Sockets.Socket> obiektu, aby zidentyfikować adres sieciowy i numer portu hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-317">You can call use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-318">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-318">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-319">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-319">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-320">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-320">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-321">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-321">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-322">Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-322">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="0ed15-323">Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="0ed15-323">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-324">Poniższy przykład kodu otwiera gniazdo i akceptuje połączenie asynchroniczne.</span><span class="sxs-lookup"><span data-stu-id="0ed15-324">The following code example opens a socket and accepts an asynchronous connection.</span></span> <span data-ttu-id="0ed15-325">W tym przykładzie gniazdo akceptuje pierwsze 10 bajtów danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-325">In this example, the socket accepts the initial 10 bytes of data.</span></span> <span data-ttu-id="0ed15-326">Liczba odebranych bajtów i dane są wyświetlane w konsoli przez delegata wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-326">The number of bytes received and the data are displayed on the console by the callback delegate.</span></span> <span data-ttu-id="0ed15-327">Zobacz <xref:System.Net.Sockets.Socket.BeginReceive%2A> , aby dowiedzieć się, jak są otrzymywane pozostałe dane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-327">See <xref:System.Net.Sockets.Socket.BeginReceive%2A> for a description of how the remaining data is received.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-328"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-328">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-329">Dla tej metody wymagany jest system Windows NT.</span><span class="sxs-lookup"><span data-stu-id="0ed15-329">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-330">Gniazdo akceptujące nie nasłuchuje połączeń.</span><span class="sxs-lookup"><span data-stu-id="0ed15-330">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="0ed15-331">Musisz wywołać metodę <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> i <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> przed wywołaniem metody <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-331">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span>  
  
<span data-ttu-id="0ed15-332">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-332">-or-</span></span> 
<span data-ttu-id="0ed15-333">Zaakceptowane gniazdo jest powiązane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-333">The accepted socket is bound.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-334"><paramref name="receiveSize" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-334"><paramref name="receiveSize" /> is less than 0.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-335">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-335">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="0ed15-336">Przykład asynchronicznego gniazda klienta</span><span class="sxs-lookup"><span data-stu-id="0ed15-336">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="0ed15-337">Przykład asynchronicznego gniazda serwera</span><span class="sxs-lookup"><span data-stu-id="0ed15-337">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="receiveSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="acceptSocket"><span data-ttu-id="0ed15-338">Zaakceptowany <see cref="T:System.Net.Sockets.Socket" /> obiekt.</span><span class="sxs-lookup"><span data-stu-id="0ed15-338">The accepted <see cref="T:System.Net.Sockets.Socket" /> object.</span></span> <span data-ttu-id="0ed15-339">Ta wartość może być <see langword="null" />równa.</span><span class="sxs-lookup"><span data-stu-id="0ed15-339">This value may be <see langword="null" />.</span></span></param>
        <param name="receiveSize"><span data-ttu-id="0ed15-340">Maksymalna liczba bajtów do odebrania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-340">The maximum number of bytes to receive.</span></span></param>
        <param name="callback"><span data-ttu-id="0ed15-341"><see cref="T:System.AsyncCallback" /> Delegat.</span><span class="sxs-lookup"><span data-stu-id="0ed15-341">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="0ed15-342">Obiekt, który zawiera informacje o stanie dla tego żądania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-342">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="0ed15-343">Rozpoczyna operację asynchroniczną w celu zaakceptowania próby połączenia przychodzącego z określonego gniazda i odbioru pierwszego bloku danych wysłanych przez aplikację kliencką.</span><span class="sxs-lookup"><span data-stu-id="0ed15-343">Begins an asynchronous operation to accept an incoming connection attempt from a specified socket and receives the first block of data sent by the client application.</span></span></summary>
        <returns><span data-ttu-id="0ed15-344">Obiekt, który odwołuje się <see cref="T:System.Net.Sockets.Socket" /> do asynchronicznego tworzenia obiektów. <see cref="T:System.IAsyncResult" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-344">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> object creation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-345">Protokoły zorientowane na połączenia mogą używać <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody do asynchronicznego przetwarzania przychodzących prób połączeń.</span><span class="sxs-lookup"><span data-stu-id="0ed15-345">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="0ed15-346">Akceptowanie połączeń asynchronicznie daje możliwość wysyłania i odbierania danych w osobnym wątku wykonania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-346">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="0ed15-347">To przeciążenie umożliwia określenie zaakceptowanego gniazda w `acceptSocket` parametrze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-347">This overload allows you to specify the accepted socket in the `acceptSocket` parameter.</span></span> <span data-ttu-id="0ed15-348">Jeśli ten parametr to `null`, zaakceptowane gniazdo jest tworzone <xref:System.Net.Sockets.Socket.BeginAccept%2A> przez metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-348">If this parameter is `null`, the accepted socket is created by the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="0ed15-349">Możesz określić liczbę bajtów, które mają być akceptowane w początkowym transferze w `receiveSize` parametrze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-349">You can specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.</span></span>  
  
 <span data-ttu-id="0ed15-350">Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody należy <xref:System.Net.Sockets.Socket.Listen%2A> wywołać metodę, aby nasłuchiwać przychodzących żądań połączeń i kolejkować je.</span><span class="sxs-lookup"><span data-stu-id="0ed15-350">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="0ed15-351">Należy utworzyć metodę wywołania zwrotnego implementującą <xref:System.AsyncCallback> delegata i przekazać jej nazwę <xref:System.Net.Sockets.Socket.BeginAccept%2A> do metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-351">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="0ed15-352">Aby to zrobić, w bardzo minimalnym czasie należy przekazać obiekt nasłuchujący <xref:System.Net.Sockets.Socket> do <xref:System.Net.Sockets.Socket.BeginAccept%2A> za pomocą `state` parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-352">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="0ed15-353">Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małą klasę do przechowywania <xref:System.Net.Sockets.Socket> i innych wymaganych informacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-353">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="0ed15-354">Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody `state` za pomocą parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-354">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="0ed15-355">Metoda wywołania zwrotnego powinna wywołać <xref:System.Net.Sockets.Socket.EndAccept%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-355">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="0ed15-356">Gdy aplikacja jest wywoływana <xref:System.Net.Sockets.Socket.BeginAccept%2A>, system zazwyczaj używa oddzielnego wątku do wykonywania określonej metody wywołania zwrotnego i <xref:System.Net.Sockets.Socket.EndAccept%2A> blokuje się do momentu pobrania oczekującego połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-356">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span>  
  
 <span data-ttu-id="0ed15-357"><xref:System.Net.Sockets.Socket.EndAccept%2A>zwraca nowy <xref:System.Net.Sockets.Socket> obiekt, za pomocą którego można wysyłać i odbierać dane przy użyciu hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-357"><xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="0ed15-358">Nie można użyć tej zwracanej <xref:System.Net.Sockets.Socket> w celu zaakceptowania wszelkich dodatkowych połączeń z kolejki połączeń.</span><span class="sxs-lookup"><span data-stu-id="0ed15-358">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="0ed15-359">Jeśli chcesz, aby oryginalny wątek blokował po wywołaniu <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, użyj. <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0ed15-359">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0ed15-360">Wywołaj metodę <xref:System.Threading.ManualResetEvent> Set w metodzie wywołania zwrotnego, jeśli chcesz, aby oryginalny wątek kontynuował wykonywanie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-360">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="0ed15-361">System może również użyć wątku wywołującego do wywołania metody wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-361">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="0ed15-362">W takim przypadku <xref:System.IAsyncResult.CompletedSynchronously%2A> Właściwość zwracanej <xref:System.IAsyncResult> wartości zostanie <xref:System.Net.Sockets.Socket.BeginAccept%2A> ustawiona, aby wskazać, że metoda została ukończona synchronicznie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-362">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="0ed15-363">Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego, zobacz [kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-363">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="0ed15-364">Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, <xref:System.Net.Sockets.Socket>Zamknij.</span><span class="sxs-lookup"><span data-stu-id="0ed15-364">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-365">Gdy metoda jest wywoływana w trakcie trwającej operacji asynchronicznej, wywołanie zwrotne dostarczone <xref:System.Net.Sockets.Socket.BeginAccept%2A> do metody jest wywoływana. <xref:System.Net.Sockets.Socket.Close%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-365">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="0ed15-366">Kolejne wywołanie <xref:System.Net.Sockets.Socket.EndAccept%2A> metody spowoduje <xref:System.ObjectDisposedException> zgłoszenie do wskazania, że operacja została anulowana.</span><span class="sxs-lookup"><span data-stu-id="0ed15-366">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-367">Aby zidentyfikować adres sieciowy <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> i numer portu hosta <xref:System.Net.Sockets.Socket> zdalnego, można użyć Właściwości zwróconego obiektu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-367">You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-368">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-368">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-369">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-369">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-370">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-370">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-371">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-371">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-372">Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-372">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="0ed15-373">Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="0ed15-373">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-374">Poniższy przykład kodu otwiera gniazdo i akceptuje połączenie asynchroniczne.</span><span class="sxs-lookup"><span data-stu-id="0ed15-374">The following code example opens a socket and accepts an asynchronous connection.</span></span> <span data-ttu-id="0ed15-375">W tym przykładzie gniazdo akceptuje pierwsze 10 bajtów danych, a `acceptSocket` parametr jest `null`, co wymusza <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody utworzenia zaakceptowanego gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-375">In this example, the socket accepts the initial 10 bytes of data and the `acceptSocket` parameter is `null`, which forces the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to create the accepted socket.</span></span> <span data-ttu-id="0ed15-376">Liczba odebranych bajtów i dane są wyświetlane w konsoli przez delegata wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-376">The number of bytes received and the data are displayed on the console by the callback delegate.</span></span> <span data-ttu-id="0ed15-377">Zobacz <xref:System.Net.Sockets.Socket.BeginReceive%2A> , aby dowiedzieć się, jak są otrzymywane pozostałe dane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-377">See <xref:System.Net.Sockets.Socket.BeginReceive%2A> for a description of how the remaining data is received.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-378"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-378">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-379">Dla tej metody wymagany jest system Windows NT.</span><span class="sxs-lookup"><span data-stu-id="0ed15-379">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-380">Gniazdo akceptujące nie nasłuchuje połączeń.</span><span class="sxs-lookup"><span data-stu-id="0ed15-380">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="0ed15-381">Musisz wywołać metodę <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> i <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> przed wywołaniem metody <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-381">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span>  
  
<span data-ttu-id="0ed15-382">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-382">-or-</span></span> 
<span data-ttu-id="0ed15-383">Zaakceptowane gniazdo jest powiązane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-383">The accepted socket is bound.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-384"><paramref name="receiveSize" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-384"><paramref name="receiveSize" /> is less than 0.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-385">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-385">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="0ed15-386">Przykład asynchronicznego gniazda klienta</span><span class="sxs-lookup"><span data-stu-id="0ed15-386">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="0ed15-387">Przykład asynchronicznego gniazda serwera</span><span class="sxs-lookup"><span data-stu-id="0ed15-387">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ed15-388">Rozpoczyna asynchroniczne żądanie połączenia z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-388">Begins an asynchronous request for a remote host connection.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP"><span data-ttu-id="0ed15-389"><see cref="T:System.Net.EndPoint" /> Reprezentuje hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-389">An <see cref="T:System.Net.EndPoint" /> that represents the remote host.</span></span></param>
        <param name="end_point"><span data-ttu-id="0ed15-390"><see cref="T:System.Net.EndPoint" /> Reprezentuje hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-390">An <see cref="T:System.Net.EndPoint" /> that represents the remote host.</span></span></param>
        <param name="callback"><span data-ttu-id="0ed15-391"><see cref="T:System.AsyncCallback" /> Delegat.</span><span class="sxs-lookup"><span data-stu-id="0ed15-391">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="0ed15-392">Obiekt, który zawiera informacje o stanie dla tego żądania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-392">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="0ed15-393">Rozpoczyna asynchroniczne żądanie połączenia z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-393">Begins an asynchronous request for a remote host connection.</span></span></summary>
        <returns><span data-ttu-id="0ed15-394"><see cref="T:System.IAsyncResult" /> Odwołujący się do połączenia asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-394">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-395">Jeśli używasz protokołu zorientowanego na połączenie, <xref:System.Net.Sockets.Socket.BeginConnect%2A> Metoda uruchamia asynchroniczne żądanie dla połączenia `remoteEP` z parametrem.</span><span class="sxs-lookup"><span data-stu-id="0ed15-395">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method starts an asynchronous request for a connection to the `remoteEP` parameter.</span></span> <span data-ttu-id="0ed15-396">Jeśli używasz protokołu bezpołączeniowego, program <xref:System.Net.Sockets.Socket.BeginConnect%2A> ustanowi domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-396">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.BeginConnect%2A> establishes a default remote host.</span></span> <span data-ttu-id="0ed15-397">Połączenie lub ustawienie domyślnego hosta zdalnego asynchronicznie umożliwia wysyłanie i odbieranie danych w osobnym wątku wykonania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-397">Connecting or setting the default remote host asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="0ed15-398">Można utworzyć metodę wywołania zwrotnego implementującą <xref:System.AsyncCallback> delegata i przekazać jej nazwę <xref:System.Net.Sockets.Socket.BeginConnect%2A> do metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-398">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.</span></span> <span data-ttu-id="0ed15-399">W bardzo minimalnym czasie należy przekazać <xref:System.Net.Sockets.Socket> do <xref:System.Net.Sockets.Socket.BeginConnect%2A> za pomocą `state` parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-399">At the very minimum, you must pass the <xref:System.Net.Sockets.Socket> to <xref:System.Net.Sockets.Socket.BeginConnect%2A> through the `state` parameter.</span></span> <span data-ttu-id="0ed15-400">Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małą klasę do przechowywania <xref:System.Net.Sockets.Socket>i innych wymaganych informacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-400">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information.</span></span> <span data-ttu-id="0ed15-401">Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody `state` za pomocą parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-401">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="0ed15-402">Metoda wywołania zwrotnego powinna wywołać <xref:System.Net.Sockets.Socket.EndConnect%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-402">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="0ed15-403">Gdy aplikacja jest wywoływana <xref:System.Net.Sockets.Socket.BeginConnect%2A>, system użyje oddzielnego wątku do wykonania określonej metody wywołania zwrotnego i <xref:System.Net.Sockets.Socket.EndConnect%2A> zablokuje się do momentu <xref:System.Net.Sockets.Socket> pomyślnego nawiązania połączenia lub wyrzuca wyjątek.</span><span class="sxs-lookup"><span data-stu-id="0ed15-403">When your application calls <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndConnect%2A> until the <xref:System.Net.Sockets.Socket> connects successfully or throws an exception.</span></span> <span data-ttu-id="0ed15-404">Jeśli chcesz, aby oryginalny wątek blokował po wywołaniu <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody, użyj. <xref:System.Threading.WaitHandle.WaitOne%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-404">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="0ed15-405">Wywołaj metodę <xref:System.Threading.ManualResetEvent> Set w metodzie wywołania zwrotnego, jeśli chcesz, aby oryginalny wątek kontynuował wykonywanie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-405">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="0ed15-406">Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego [, zobacz kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-406">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="0ed15-407">Jeśli używasz protokołu bezpołączeniowego, takiego jak UDP, nie musisz wywoływać <xref:System.Net.Sockets.Socket.BeginConnect%2A> przed wysłaniem i odebraniem danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-407">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.BeginConnect%2A> before sending and receiving data.</span></span> <span data-ttu-id="0ed15-408">Za pomocą <xref:System.Net.Sockets.Socket.BeginSendTo%2A> programu i <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> można komunikować się z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-408">You can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> to communicate with a remote host.</span></span> <span data-ttu-id="0ed15-409">Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.BeginConnect%2A>, wszelkie datagramy, które dotarły do adresu innego niż określona wartość domyślna zostaną odrzucone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-409">If you do call <xref:System.Net.Sockets.Socket.BeginConnect%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="0ed15-410">Jeśli chcesz ustawić domyślny host zdalny na adres emisji, musisz najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> i ustawić emisję do. `true`</span><span class="sxs-lookup"><span data-stu-id="0ed15-410">If you wish to set your default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="0ed15-411">Jeśli nie jest to <xref:System.Net.Sockets.Socket.BeginConnect%2A> możliwe, program <xref:System.Net.Sockets.SocketException>zgłosi.</span><span class="sxs-lookup"><span data-stu-id="0ed15-411">If you cannot, <xref:System.Net.Sockets.Socket.BeginConnect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="0ed15-412">Jeśli używasz protokołu zorientowanego na połączenia i nie wywołuj <xref:System.Net.Sockets.Socket.Bind%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.BeginConnect%2A>, Dostawca usługi bazowej przypisze najbardziej odpowiedni lokalny adres sieciowy i numer portu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-412">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="0ed15-413">Jeśli używasz bezpołączeniowego protokołu, dostawca usług nie przypisze lokalnego adresu sieciowego i numeru portu do momentu wywołania <xref:System.Net.Sockets.Socket.BeginSend%2A> metody lub. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-413">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="0ed15-414">Jeśli chcesz zmienić domyślnego hosta zdalnego, wywołaj <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodę ponownie z żądanym punktem końcowym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-414">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="0ed15-415">Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody, <xref:System.Net.Sockets.Socket>Zamknij.</span><span class="sxs-lookup"><span data-stu-id="0ed15-415">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-416">Gdy metoda jest wywoływana w trakcie trwającej operacji asynchronicznej, wywołanie zwrotne dostarczone <xref:System.Net.Sockets.Socket.BeginConnect%2A> do metody jest wywoływana. <xref:System.Net.Sockets.Socket.Close%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-416">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="0ed15-417">Kolejne wywołanie <xref:System.Net.Sockets.Socket.EndConnect%2A> metody spowoduje <xref:System.ObjectDisposedException> zgłoszenie do wskazania, że operacja została anulowana.</span><span class="sxs-lookup"><span data-stu-id="0ed15-417">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-418">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-418">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-419">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-419">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-420">Jeśli gniazdo zostało wcześniej odłączone, <xref:System.Net.Sockets.Socket.BeginConnect%2A> należy wywołać go w wątku, który nie zostanie zakończony do momentu zakończenia operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-420">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="0ed15-421">Jest to ograniczenie podstawowego dostawcy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-421">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-422">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-422">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-423">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-423">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-424">Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-424">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="0ed15-425">Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="0ed15-425">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-426">Poniższy przykład kodu inicjuje próbę połączenia asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-426">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-427"><paramref name="remoteEP" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-427"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-428">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-428">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-429"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-429">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0ed15-430">Obiekt wywołujący znajdujący się wyżej w stosie wywołań nie ma uprawnienia do żądanej operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-430">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-431">Został umieszczony w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />lub asynchroniczna operacja jest już w toku. <see cref="T:System.Net.Sockets.Socket" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-431">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="0ed15-432">Marshaling delegata jako metoda wywołania zwrotnego</span><span class="sxs-lookup"><span data-stu-id="0ed15-432">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="0ed15-433">Przykład asynchronicznego gniazda klienta</span><span class="sxs-lookup"><span data-stu-id="0ed15-433">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="0ed15-434">Przykład asynchronicznego gniazda serwera</span><span class="sxs-lookup"><span data-stu-id="0ed15-434">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="0ed15-435"><see cref="T:System.Net.IPAddress" /> Hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-435">The <see cref="T:System.Net.IPAddress" /> of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="0ed15-436">Numer portu hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-436">The port number of the remote host.</span></span></param>
        <param name="requestCallback"><span data-ttu-id="0ed15-437"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po ukończeniu operacji łączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-437">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="callback"><span data-ttu-id="0ed15-438"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po ukończeniu operacji łączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-438">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="0ed15-439">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji łączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-439">A user-defined object that contains information about the connect operation.</span></span> <span data-ttu-id="0ed15-440">Ten obiekt jest przesyłany do <paramref name="requestCallback" /> delegata po zakończeniu operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-440">This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="0ed15-441">Rozpoczyna asynchroniczne żądanie połączenia z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-441">Begins an asynchronous request for a remote host connection.</span></span> <span data-ttu-id="0ed15-442">Host jest określony przez <see cref="T:System.Net.IPAddress" /> i numer portu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-442">The host is specified by an <see cref="T:System.Net.IPAddress" /> and a port number.</span></span></summary>
        <returns><span data-ttu-id="0ed15-443"><see cref="T:System.IAsyncResult" /> Odwołujący się do połączenia asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-443">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-444">Operacja asynchroniczna <xref:System.Net.Sockets.Socket.BeginConnect%2A> musi być zakończona przez <xref:System.Net.Sockets.Socket.EndConnect%2A> wywołanie metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-444">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="0ed15-445">Zazwyczaj Metoda jest wywoływana przez `requestCallback` delegata.</span><span class="sxs-lookup"><span data-stu-id="0ed15-445">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="0ed15-446">Ta metoda nie jest blokowana do momentu ukończenia operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-446">This method does not block until the operation is complete.</span></span> <span data-ttu-id="0ed15-447">Aby zablokować do momentu ukończenia operacji, użyj jednego z <xref:System.Net.Sockets.Socket.Connect%2A> przeciążeń metody lub. <xref:System.Net.Sockets.Socket.EndConnect%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-447">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads, or <xref:System.Net.Sockets.Socket.EndConnect%2A>.</span></span>  
  
 <span data-ttu-id="0ed15-448">Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody, <xref:System.Net.Sockets.Socket>Zamknij.</span><span class="sxs-lookup"><span data-stu-id="0ed15-448">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-449">Gdy metoda jest wywoływana w trakcie trwającej operacji asynchronicznej, wywołanie zwrotne dostarczone <xref:System.Net.Sockets.Socket.BeginConnect%2A> do metody jest wywoływana. <xref:System.Net.Sockets.Socket.Close%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-449">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="0ed15-450">Kolejne wywołanie <xref:System.Net.Sockets.Socket.EndConnect%2A> metody spowoduje <xref:System.ObjectDisposedException> zgłoszenie do wskazania, że operacja została anulowana.</span><span class="sxs-lookup"><span data-stu-id="0ed15-450">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="0ed15-451">Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [wywoływanie metod synchronicznych asynchronicznie](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="0ed15-451">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-452">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-452">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-453">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-453">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-454">Jeśli gniazdo zostało wcześniej odłączone, <xref:System.Net.Sockets.Socket.BeginConnect%2A> należy wywołać go w wątku, który nie zostanie zakończony do momentu zakończenia operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-454">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="0ed15-455">Jest to ograniczenie podstawowego dostawcy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-455">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="0ed15-456"><xref:System.Net.EndPoint> Również, który jest używany, musi być inny.</span><span class="sxs-lookup"><span data-stu-id="0ed15-456">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-457">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-457">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-458">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-458">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-459">Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-459">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="0ed15-460">Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="0ed15-460">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-461">Poniższy przykład kodu inicjuje próbę połączenia asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-461">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-462"><paramref name="address" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-462"><paramref name="address" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-463">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-463">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-464"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-464">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-465">Nie <see cref="T:System.Net.Sockets.Socket" /> znajduje się w rodzinie gniazd.</span><span class="sxs-lookup"><span data-stu-id="0ed15-465">The <see cref="T:System.Net.Sockets.Socket" /> is not in the socket family.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-466">Numer portu jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-466">The port number is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-467">Długość <paramref name="address" /> wynosi zero.</span><span class="sxs-lookup"><span data-stu-id="0ed15-467">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-468">Został umieszczony w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />lub asynchroniczna operacja jest już w toku. <see cref="T:System.Net.Sockets.Socket" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-468">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="0ed15-469">Marshaling delegata jako metoda wywołania zwrotnego</span><span class="sxs-lookup"><span data-stu-id="0ed15-469">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="0ed15-470">Przykład asynchronicznego gniazda klienta</span><span class="sxs-lookup"><span data-stu-id="0ed15-470">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="0ed15-471">Przykład asynchronicznego gniazda serwera</span><span class="sxs-lookup"><span data-stu-id="0ed15-471">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="addresses"><span data-ttu-id="0ed15-472">Co najmniej jeden <see cref="T:System.Net.IPAddress" />, wyznaczający hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-472">At least one <see cref="T:System.Net.IPAddress" />, designating the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="0ed15-473">Numer portu hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-473">The port number of the remote host.</span></span></param>
        <param name="requestCallback"><span data-ttu-id="0ed15-474"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po ukończeniu operacji łączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-474">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="callback"><span data-ttu-id="0ed15-475"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po ukończeniu operacji łączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-475">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="0ed15-476">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji łączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-476">A user-defined object that contains information about the connect operation.</span></span> <span data-ttu-id="0ed15-477">Ten obiekt jest przesyłany do <paramref name="requestCallback" /> delegata po zakończeniu operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-477">This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="0ed15-478">Rozpoczyna asynchroniczne żądanie połączenia z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-478">Begins an asynchronous request for a remote host connection.</span></span> <span data-ttu-id="0ed15-479">Host jest określony przez <see cref="T:System.Net.IPAddress" /> tablicę i numer portu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-479">The host is specified by an <see cref="T:System.Net.IPAddress" /> array and a port number.</span></span></summary>
        <returns><span data-ttu-id="0ed15-480"><see cref="T:System.IAsyncResult" /> Odwołujący się do połączeń asynchronicznych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-480">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connections.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-481">Operacja asynchroniczna <xref:System.Net.Sockets.Socket.BeginConnect%2A> musi być zakończona przez <xref:System.Net.Sockets.Socket.EndConnect%2A> wywołanie metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-481">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="0ed15-482">Zazwyczaj Metoda jest wywoływana przez `requestCallback` delegata.</span><span class="sxs-lookup"><span data-stu-id="0ed15-482">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="0ed15-483">Ta metoda nie jest blokowana do momentu ukończenia operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-483">This method does not block until the operation is complete.</span></span> <span data-ttu-id="0ed15-484">Aby zablokować do momentu ukończenia operacji, użyj jednego z <xref:System.Net.Sockets.Socket.Connect%2A> przeciążeń metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-484">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.</span></span>  
  
 <span data-ttu-id="0ed15-485">Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody, <xref:System.Net.Sockets.Socket>Zamknij.</span><span class="sxs-lookup"><span data-stu-id="0ed15-485">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-486">Gdy metoda jest wywoływana w trakcie trwającej operacji asynchronicznej, wywołanie zwrotne dostarczone <xref:System.Net.Sockets.Socket.BeginConnect%2A> do metody jest wywoływana. <xref:System.Net.Sockets.Socket.Close%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-486">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="0ed15-487">Kolejne wywołanie <xref:System.Net.Sockets.Socket.EndConnect%2A> metody spowoduje <xref:System.ObjectDisposedException> zgłoszenie do wskazania, że operacja została anulowana.</span><span class="sxs-lookup"><span data-stu-id="0ed15-487">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="0ed15-488">Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [Asynchroniczne wywoływanie metod synchronicznych](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-488">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-489">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-489">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-490">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-490">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-491">Jeśli gniazdo zostało wcześniej odłączone, <xref:System.Net.Sockets.Socket.BeginConnect%2A> należy wywołać go w wątku, który nie zostanie zakończony do momentu zakończenia operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-491">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="0ed15-492">Jest to ograniczenie podstawowego dostawcy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-492">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="0ed15-493"><xref:System.Net.EndPoint> Również, który jest używany, musi być inny.</span><span class="sxs-lookup"><span data-stu-id="0ed15-493">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-494">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-494">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-495">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-495">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-496">Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-496">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="0ed15-497">Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="0ed15-497">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-498">Poniższy przykład kodu inicjuje próbę połączenia asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-498">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-499"><paramref name="addresses" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-499"><paramref name="addresses" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-500">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-500">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-501"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-501">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-502">Ta metoda jest prawidłowa dla gniazd korzystających <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> z <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />lub.</span><span class="sxs-lookup"><span data-stu-id="0ed15-502">This method is valid for sockets that use <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-503">Numer portu jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-503">The port number is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-504">Długość <paramref name="address" /> wynosi zero.</span><span class="sxs-lookup"><span data-stu-id="0ed15-504">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-505">Został umieszczony w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />lub asynchroniczna operacja jest już w toku. <see cref="T:System.Net.Sockets.Socket" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-505">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="0ed15-506">Marshaling delegata jako metoda wywołania zwrotnego</span><span class="sxs-lookup"><span data-stu-id="0ed15-506">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="0ed15-507">Przykład asynchronicznego gniazda klienta</span><span class="sxs-lookup"><span data-stu-id="0ed15-507">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="0ed15-508">Przykład asynchronicznego gniazda serwera</span><span class="sxs-lookup"><span data-stu-id="0ed15-508">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="0ed15-509">Nazwa hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-509">The name of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="0ed15-510">Numer portu hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-510">The port number of the remote host.</span></span></param>
        <param name="requestCallback"><span data-ttu-id="0ed15-511"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po ukończeniu operacji łączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-511">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="callback"><span data-ttu-id="0ed15-512"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po ukończeniu operacji łączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-512">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="0ed15-513">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji łączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-513">A user-defined object that contains information about the connect operation.</span></span> <span data-ttu-id="0ed15-514">Ten obiekt jest przesyłany do <paramref name="requestCallback" /> delegata po zakończeniu operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-514">This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="0ed15-515">Rozpoczyna asynchroniczne żądanie połączenia z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-515">Begins an asynchronous request for a remote host connection.</span></span> <span data-ttu-id="0ed15-516">Host jest określony przez nazwę hosta i numer portu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-516">The host is specified by a host name and a port number.</span></span></summary>
        <returns><span data-ttu-id="0ed15-517"><see cref="T:System.IAsyncResult" /> Odwołujący się do połączenia asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-517">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-518">Operacja asynchroniczna <xref:System.Net.Sockets.Socket.BeginConnect%2A> musi być zakończona przez <xref:System.Net.Sockets.Socket.EndConnect%2A> wywołanie metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-518">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="0ed15-519">Zazwyczaj Metoda jest wywoływana przez `requestCallback` delegata.</span><span class="sxs-lookup"><span data-stu-id="0ed15-519">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="0ed15-520">Ta metoda nie jest blokowana do momentu ukończenia operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-520">This method does not block until the operation is complete.</span></span> <span data-ttu-id="0ed15-521">Aby zablokować do momentu ukończenia operacji, użyj jednego z <xref:System.Net.Sockets.Socket.Connect%2A> przeciążeń metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-521">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.</span></span>  
  
 <span data-ttu-id="0ed15-522">Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody, <xref:System.Net.Sockets.Socket>Zamknij.</span><span class="sxs-lookup"><span data-stu-id="0ed15-522">To cancel a pending call to the  <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-523">Gdy metoda jest wywoływana w trakcie trwającej operacji asynchronicznej, wywołanie zwrotne dostarczone <xref:System.Net.Sockets.Socket.BeginConnect%2A> do metody jest wywoływana. <xref:System.Net.Sockets.Socket.Close%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-523">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="0ed15-524">Kolejne wywołanie <xref:System.Net.Sockets.Socket.EndConnect%2A> metody spowoduje <xref:System.ObjectDisposedException> zgłoszenie do wskazania, że operacja została anulowana.</span><span class="sxs-lookup"><span data-stu-id="0ed15-524">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="0ed15-525">Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [wywoływanie metod synchronicznych asynchronicznie](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="0ed15-525">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-526">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-526">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-527">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-527">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-528">Jeśli gniazdo zostało wcześniej odłączone, <xref:System.Net.Sockets.Socket.BeginConnect%2A> należy wywołać go w wątku, który nie zostanie zakończony do momentu zakończenia operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-528">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="0ed15-529">Jest to ograniczenie podstawowego dostawcy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-529">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="0ed15-530"><xref:System.Net.EndPoint> Również, który jest używany, musi być inny.</span><span class="sxs-lookup"><span data-stu-id="0ed15-530">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-531">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-531">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-532">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-532">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-533">Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-533">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="0ed15-534">Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="0ed15-534">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-535">Poniższy przykład kodu inicjuje próbę połączenia asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-535">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-536"><paramref name="host" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-536"><paramref name="host" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-537"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-537">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-538">Ta metoda jest prawidłowa dla gniazd w <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> w rodzinach.</span><span class="sxs-lookup"><span data-stu-id="0ed15-538">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-539">Numer portu jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-539">The port number is not valid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-540">Został umieszczony w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />lub asynchroniczna operacja jest już w toku. <see cref="T:System.Net.Sockets.Socket" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-540">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="0ed15-541">Marshaling delegata jako metoda wywołania zwrotnego</span><span class="sxs-lookup"><span data-stu-id="0ed15-541">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="0ed15-542">Przykład asynchronicznego gniazda klienta</span><span class="sxs-lookup"><span data-stu-id="0ed15-542">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="0ed15-543">Przykład asynchronicznego gniazda serwera</span><span class="sxs-lookup"><span data-stu-id="0ed15-543">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="reuseSocket"><span data-ttu-id="0ed15-544"><see langword="true" />Jeśli tego gniazda można użyć ponownie po zamknięciu połączenia; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-544"><see langword="true" /> if this socket can be reused after the connection is closed; otherwise, <see langword="false" />.</span></span></param>
        <param name="callback"><span data-ttu-id="0ed15-545"><see cref="T:System.AsyncCallback" /> Delegat.</span><span class="sxs-lookup"><span data-stu-id="0ed15-545">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="0ed15-546">Obiekt, który zawiera informacje o stanie dla tego żądania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-546">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="0ed15-547">Rozpoczyna asynchroniczne żądanie rozłączenia ze zdalnego punktu końcowego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-547">Begins an asynchronous request to disconnect from a remote endpoint.</span></span></summary>
        <returns><span data-ttu-id="0ed15-548"><see cref="T:System.IAsyncResult" /> Obiekt, który odwołuje się do operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-548">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-549">Jeśli używasz protokołu zorientowanego na połączenie, możesz wywołać <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> metodę, aby zażądać rozłączenia ze zdalnego punktu końcowego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-549">If you are using a connection-oriented protocol, you can call the <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method to request a disconnect from a remote endpoint.</span></span> <span data-ttu-id="0ed15-550">Jeśli `reuseSocket` jest`true`, możesz ponownie użyć gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-550">If `reuseSocket` is `true`, you can reuse the socket.</span></span>  
  
 <span data-ttu-id="0ed15-551"><xref:System.Net.Sockets.Socket.BeginDisconnect%2A> Metoda używa oddzielnego wątku do wywołania określonej metody wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-551">The <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method uses a separate thread to invoke the specified callback method.</span></span> <span data-ttu-id="0ed15-552"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> Metoda blokuje się do momentu ukończenia oczekującego rozłączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-552">The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the pending disconnect is complete.</span></span> <span data-ttu-id="0ed15-553">Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego, zobacz [kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-553">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-554">Jeśli wystąpi <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> wyjątek, użyj właściwości, aby uzyskać określony kod błędu. <xref:System.Net.Sockets.SocketException></span><span class="sxs-lookup"><span data-stu-id="0ed15-554">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-555">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-555">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-556">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-556">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-557">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-557">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-558">Poniższy przykład kodu tworzy gniazdo do komunikacji asynchronicznej i wysyła niektóre dane do hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-558">The following code example creates a socket for asynchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="0ed15-559">Po wysłaniu dane są wywoływane, <xref:System.Net.Sockets.Socket.Shutdown%2A> aby zatrzymać działanie wysyłania i odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-559">When the data has been sent, <xref:System.Net.Sockets.Socket.Shutdown%2A> is called to stop the send and receive activity.</span></span> <span data-ttu-id="0ed15-560">Następnie <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> jest wywoływana w celu rozpoczęcia żądania rozłączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-560">Then <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> is called to begin a disconnect request.</span></span> <span data-ttu-id="0ed15-561">Po zakończeniu żądania <xref:System.Net.Sockets.Socket.Connected%2A> właściwość zostanie zbadana, aby sprawdzić, czy gniazdo jest odłączone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-561">When the request completes, the <xref:System.Net.Sockets.Socket.Connected%2A> property is queried to test whether the socket is disconnected.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-562">System operacyjny to Windows 2000 lub starszy, a ta metoda wymaga systemu Windows XP.</span><span class="sxs-lookup"><span data-stu-id="0ed15-562">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-563"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-563">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-564">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-564">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ed15-565">Rozpoczyna asynchroniczne odbieranie danych z połączonej <see cref="T:System.Net.Sockets.Socket" />usługi.</span><span class="sxs-lookup"><span data-stu-id="0ed15-565">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="0ed15-566">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-566">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-567">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-567">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="0ed15-568"><see cref="T:System.AsyncCallback" /> Delegat, który odwołuje się do metody do wywołania po zakończeniu operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-568">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="0ed15-569">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-569">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="0ed15-570">Ten obiekt jest przesyłany do <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegata po zakończeniu operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-570">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="0ed15-571">Rozpoczyna asynchroniczne odbieranie danych z połączonej <see cref="T:System.Net.Sockets.Socket" />usługi.</span><span class="sxs-lookup"><span data-stu-id="0ed15-571">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-572"><see cref="T:System.IAsyncResult" /> Odwołuje się do odczytu asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-572">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-573">Operacja asynchroniczna <xref:System.Net.Sockets.Socket.BeginReceive%2A> musi być zakończona przez <xref:System.Net.Sockets.Socket.EndReceive%2A> wywołanie metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-573">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="0ed15-574">Zazwyczaj Metoda jest wywoływana przez `callback` delegata.</span><span class="sxs-lookup"><span data-stu-id="0ed15-574">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="0ed15-575">Ta metoda nie jest blokowana do momentu ukończenia operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-575">This method does not block until the operation is complete.</span></span> <span data-ttu-id="0ed15-576">Aby zablokować do momentu ukończenia operacji, użyj jednego z <xref:System.Net.Sockets.Socket.Receive%2A> przeciążeń metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-576">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="0ed15-577">Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceive%2A>, <xref:System.Net.Sockets.Socket.Close%2A> Wywołaj metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-577">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-578">Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [Asynchroniczne wywoływanie metod synchronicznych](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-578">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-579">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-579">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-580">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-580">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-581">Wszystkie we/wy zainicjowane przez dany wątek zostało anulowane po zakończeniu tego wątku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-581">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="0ed15-582">Oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek zostanie zakończony przed ukończeniem operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-582">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-583">`state`jest wystąpieniem klasy zdefiniowanej przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="0ed15-583">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-584">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-584">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-585">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-585">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-586">Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-586">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="0ed15-587">Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="0ed15-587">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-588"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-588"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-589">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-589">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-590"><see cref="T:System.Net.Sockets.Socket" />został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-590"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="0ed15-591">Marshaling delegata jako metoda wywołania zwrotnego</span><span class="sxs-lookup"><span data-stu-id="0ed15-591">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="0ed15-592">Przykład asynchronicznego gniazda klienta</span><span class="sxs-lookup"><span data-stu-id="0ed15-592">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="0ed15-593">Przykład asynchronicznego gniazda serwera</span><span class="sxs-lookup"><span data-stu-id="0ed15-593">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="0ed15-594">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-594">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-595">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-595">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="0ed15-596"><see cref="T:System.Net.Sockets.SocketError" /> Obiekt, który przechowuje błąd gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-596">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="0ed15-597"><see cref="T:System.AsyncCallback" /> Delegat, który odwołuje się do metody do wywołania po zakończeniu operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-597">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="0ed15-598">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-598">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="0ed15-599">Ten obiekt jest przesyłany do <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegata po zakończeniu operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-599">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="0ed15-600">Rozpoczyna asynchroniczne odbieranie danych z połączonej <see cref="T:System.Net.Sockets.Socket" />usługi.</span><span class="sxs-lookup"><span data-stu-id="0ed15-600">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-601"><see cref="T:System.IAsyncResult" /> Odwołuje się do odczytu asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-601">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-602">Operacja asynchroniczna <xref:System.Net.Sockets.Socket.BeginReceive%2A> musi być zakończona przez <xref:System.Net.Sockets.Socket.EndReceive%2A> wywołanie metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-602">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="0ed15-603">Zazwyczaj Metoda jest wywoływana przez `callback` delegata.</span><span class="sxs-lookup"><span data-stu-id="0ed15-603">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="0ed15-604">Ta metoda nie jest blokowana do momentu ukończenia operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-604">This method does not block until the operation is complete.</span></span> <span data-ttu-id="0ed15-605">Aby zablokować do momentu ukończenia operacji, użyj jednego z <xref:System.Net.Sockets.Socket.Receive%2A> przeciążeń metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-605">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="0ed15-606">Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceive%2A>, <xref:System.Net.Sockets.Socket.Close%2A> Wywołaj metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-606">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-607">Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [Asynchroniczne wywoływanie metod synchronicznych](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-607">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-608">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-608">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-609">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-609">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-610">Wszystkie we/wy zainicjowane przez dany wątek zostało anulowane po zakończeniu tego wątku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-610">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="0ed15-611">Oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek zostanie zakończony przed ukończeniem operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-611">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-612">`state`jest wystąpieniem klasy zdefiniowanej przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="0ed15-612">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-613">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-613">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-614">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-614">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-615">Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-615">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="0ed15-616">Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="0ed15-616">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-617"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-617"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-618">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-618">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-619"><see cref="T:System.Net.Sockets.Socket" />został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-619"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="0ed15-620">Marshaling delegata jako metoda wywołania zwrotnego</span><span class="sxs-lookup"><span data-stu-id="0ed15-620">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="0ed15-621">Przykład asynchronicznego gniazda klienta</span><span class="sxs-lookup"><span data-stu-id="0ed15-621">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="0ed15-622">Przykład asynchronicznego gniazda serwera</span><span class="sxs-lookup"><span data-stu-id="0ed15-622">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-623">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-623">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="0ed15-624">Pozycja od zera w <paramref name="buffer" /> parametrze, w którym mają być przechowywane odebrane dane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-624">The zero-based position in the <paramref name="buffer" /> parameter at which to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="0ed15-625">Liczba bajtów do odebrania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-625">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-626">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-626">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="socket_flags"><span data-ttu-id="0ed15-627">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-627">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="0ed15-628"><see cref="T:System.AsyncCallback" /> Delegat, który odwołuje się do metody do wywołania po zakończeniu operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-628">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="0ed15-629">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-629">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="0ed15-630">Ten obiekt jest przesyłany do <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegata po zakończeniu operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-630">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="0ed15-631">Rozpoczyna asynchroniczne odbieranie danych z połączonej <see cref="T:System.Net.Sockets.Socket" />usługi.</span><span class="sxs-lookup"><span data-stu-id="0ed15-631">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-632"><see cref="T:System.IAsyncResult" /> Odwołuje się do odczytu asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-632">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-633">Operacja asynchroniczna <xref:System.Net.Sockets.Socket.BeginReceive%2A> musi być zakończona przez <xref:System.Net.Sockets.Socket.EndReceive%2A> wywołanie metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-633">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="0ed15-634">Zazwyczaj Metoda jest wywoływana przez `callback` delegata.</span><span class="sxs-lookup"><span data-stu-id="0ed15-634">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="0ed15-635">Ta metoda nie jest blokowana do momentu ukończenia operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-635">This method does not block until the operation is complete.</span></span> <span data-ttu-id="0ed15-636">Aby zablokować do momentu ukończenia operacji, użyj jednego z <xref:System.Net.Sockets.Socket.Receive%2A> przeciążeń metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-636">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="0ed15-637">Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceive%2A>, <xref:System.Net.Sockets.Socket.Close%2A> Wywołaj metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-637">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-638">Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [Asynchroniczne wywoływanie metod synchronicznych](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-638">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-639">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-639">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-640">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-640">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-641">Wszystkie we/wy zainicjowane przez dany wątek zostało anulowane po zakończeniu tego wątku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-641">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="0ed15-642">Oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek zostanie zakończony przed ukończeniem operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-642">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-643">`state`jest wystąpieniem klasy zdefiniowanej przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="0ed15-643">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-644">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-644">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-645">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-645">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-646">Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-646">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="0ed15-647">Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="0ed15-647">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-648">Poniższy przykład kodu rozpoczyna asynchroniczne odbieranie danych z połączenia <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-648">The following code example begins to asynchronously receive data from a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-649"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-649"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-650">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-650">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-651"><see cref="T:System.Net.Sockets.Socket" />został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-651"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-652"><paramref name="offset" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-652"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-653">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-653">-or-</span></span> 
 <span data-ttu-id="0ed15-654"><paramref name="offset" />jest większa niż długość <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-654"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="0ed15-655">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-655">-or-</span></span> 
 <span data-ttu-id="0ed15-656"><paramref name="size" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-656"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-657">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-657">-or-</span></span> 
 <span data-ttu-id="0ed15-658"><paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości <paramref name="offset" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-658"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="0ed15-659">Marshaling delegata jako metoda wywołania zwrotnego</span><span class="sxs-lookup"><span data-stu-id="0ed15-659">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="0ed15-660">Przykład asynchronicznego gniazda klienta</span><span class="sxs-lookup"><span data-stu-id="0ed15-660">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="0ed15-661">Przykład asynchronicznego gniazda serwera</span><span class="sxs-lookup"><span data-stu-id="0ed15-661">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-662">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-662">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="0ed15-663">Lokalizacja w programie <paramref name="buffer" /> do przechowywania odebranych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-663">The location in <paramref name="buffer" /> to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="0ed15-664">Liczba bajtów do odebrania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-664">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-665">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-665">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="flags"><span data-ttu-id="0ed15-666">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-666">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="0ed15-667"><see cref="T:System.Net.Sockets.SocketError" /> Obiekt, który przechowuje błąd gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-667">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="error"><span data-ttu-id="0ed15-668"><see cref="T:System.Net.Sockets.SocketError" /> Obiekt, który przechowuje błąd gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-668">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="0ed15-669"><see cref="T:System.AsyncCallback" /> Delegat, który odwołuje się do metody do wywołania po zakończeniu operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-669">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="0ed15-670">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-670">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="0ed15-671">Ten obiekt jest przesyłany do <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegata po zakończeniu operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-671">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="0ed15-672">Rozpoczyna asynchroniczne odbieranie danych z połączonej <see cref="T:System.Net.Sockets.Socket" />usługi.</span><span class="sxs-lookup"><span data-stu-id="0ed15-672">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-673"><see cref="T:System.IAsyncResult" /> Odwołuje się do odczytu asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-673">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-674">Operacja asynchroniczna <xref:System.Net.Sockets.Socket.BeginReceive%2A> musi być zakończona przez <xref:System.Net.Sockets.Socket.EndReceive%2A> wywołanie metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-674">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="0ed15-675">Zazwyczaj Metoda jest wywoływana przez `callback` delegata.</span><span class="sxs-lookup"><span data-stu-id="0ed15-675">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="0ed15-676">Ta metoda nie jest blokowana do momentu ukończenia operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-676">This method does not block until the operation is complete.</span></span> <span data-ttu-id="0ed15-677">Aby zablokować do momentu ukończenia operacji, użyj jednego z <xref:System.Net.Sockets.Socket.Receive%2A> przeciążeń metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-677">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="0ed15-678">Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceive%2A>, <xref:System.Net.Sockets.Socket.Close%2A> Wywołaj metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-678">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-679">Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [Asynchroniczne wywoływanie metod synchronicznych](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-679">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-680">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-680">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-681">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-681">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-682">Wszystkie we/wy zainicjowane przez dany wątek zostało anulowane po zakończeniu tego wątku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-682">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="0ed15-683">Oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek zostanie zakończony przed ukończeniem operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-683">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-684">`state`jest wystąpieniem klasy zdefiniowanej przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="0ed15-684">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-685">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-685">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-686">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-686">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-687">Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-687">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="0ed15-688">Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="0ed15-688">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-689"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-689"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-690">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-690">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-691"><see cref="T:System.Net.Sockets.Socket" />został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-691"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-692"><paramref name="offset" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-692"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-693">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-693">-or-</span></span> 
 <span data-ttu-id="0ed15-694"><paramref name="offset" />jest większa niż długość <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-694"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="0ed15-695">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-695">-or-</span></span> 
 <span data-ttu-id="0ed15-696"><paramref name="size" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-696"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-697">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-697">-or-</span></span> 
 <span data-ttu-id="0ed15-698"><paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości <paramref name="offset" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-698"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="0ed15-699">Marshaling delegata jako metoda wywołania zwrotnego</span><span class="sxs-lookup"><span data-stu-id="0ed15-699">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="0ed15-700">Przykład asynchronicznego gniazda klienta</span><span class="sxs-lookup"><span data-stu-id="0ed15-700">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="0ed15-701">Przykład asynchronicznego gniazda serwera</span><span class="sxs-lookup"><span data-stu-id="0ed15-701">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-702">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-702">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="0ed15-703">Pozycja od zera w <paramref name="buffer" /> parametrze, w którym mają być przechowywane dane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-703">The zero-based position in the <paramref name="buffer" /> parameter at which to store the data.</span></span></param>
        <param name="size"><span data-ttu-id="0ed15-704">Liczba bajtów do odebrania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-704">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-705">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-705">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="socket_flags"><span data-ttu-id="0ed15-706">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-706">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="0ed15-707"><see cref="T:System.Net.EndPoint" /> Reprezentuje źródło danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-707">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span></span></param>
        <param name="remote_end"><span data-ttu-id="0ed15-708"><see cref="T:System.Net.EndPoint" /> Reprezentuje źródło danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-708">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span></span></param>
        <param name="callback"><span data-ttu-id="0ed15-709"><see cref="T:System.AsyncCallback" /> Delegat.</span><span class="sxs-lookup"><span data-stu-id="0ed15-709">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="0ed15-710">Obiekt, który zawiera informacje o stanie dla tego żądania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-710">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="0ed15-711">Rozpoczyna asynchroniczne odbieranie danych z określonego urządzenia sieciowego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-711">Begins to asynchronously receive data from a specified network device.</span></span></summary>
        <returns><span data-ttu-id="0ed15-712"><see cref="T:System.IAsyncResult" /> Odwołuje się do odczytu asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-712">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-713"><xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Metoda uruchamia asynchroniczne odczytywanie bezpołączeniowych datagramów z hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-713">The <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method starts asynchronously reading connectionless datagrams from a remote host.</span></span> <span data-ttu-id="0ed15-714"><xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Wywołanie metody daje możliwość odbierania danych w osobnym wątku wykonania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-714">Calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method gives you the ability to receive data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="0ed15-715">Można utworzyć metodę wywołania zwrotnego implementującą <xref:System.AsyncCallback> delegata i przekazać jej nazwę <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> do metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-715">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="0ed15-716">Aby to zrobić, w bardzo minimalnym `state` czasie parametr musi zawierać połączony lub domyślny <xref:System.Net.Sockets.Socket> używany do komunikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-716">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="0ed15-717">Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małą klasę do przechowywania <xref:System.Net.Sockets.Socket> i innych wymaganych informacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-717">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="0ed15-718">Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody `state` za pomocą parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-718">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="0ed15-719">Metoda wywołania zwrotnego powinna wywołać <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-719">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method.</span></span> <span data-ttu-id="0ed15-720">Gdy aplikacja jest wywoływana <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, system użyje oddzielnego wątku do wykonania określonej metody wywołania zwrotnego i będzie <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> blokować się do momentu, <xref:System.Net.Sockets.Socket> aż odczytuje dane lub zgłosi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="0ed15-720">When your application calls <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, the system will use a separate thread to execute the specified callback method, and it will block on <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> until the <xref:System.Net.Sockets.Socket> reads data or throws an exception.</span></span> <span data-ttu-id="0ed15-721">Jeśli chcesz, aby oryginalny wątek blokował po wywołaniu <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody, użyj. <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0ed15-721">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0ed15-722">Wywołaj metodę Set na T:System.Threading.ManualResetEvent w metodzie wywołania zwrotnego, jeśli chcesz, aby oryginalny wątek kontynuował wykonywanie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-722">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="0ed15-723">Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego, zobacz [kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-723">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-724">Przed <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>wywołaniem należy jawnie <xref:System.Net.Sockets.Socket.Bind%2A> <xref:System.Net.Sockets.Socket> powiązać z lokalnym punktem końcowym za pomocą metody lub <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> zgłosić <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-724">Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method, or <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="0ed15-725">Ta metoda odczytuje dane do `buffer` parametru i przechwytuje punkt końcowy hosta zdalnego, z którego są wysyłane dane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-725">This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent.</span></span> <span data-ttu-id="0ed15-726">Aby uzyskać informacje na temat pobierania tego punktu końcowego, zapoznaj się z <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>tematem.</span><span class="sxs-lookup"><span data-stu-id="0ed15-726">For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span></span> <span data-ttu-id="0ed15-727">Ta metoda jest najbardziej przydatna, jeśli zamierzasz asynchronicznie odbierać bezpołączeniowe datagramy z nieznanego hosta lub wielu hostów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-727">This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</span></span> <span data-ttu-id="0ed15-728">W takich przypadkach <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> program odczyta pierwszy zakolejce datagram otrzymany do buforu sieci lokalnej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-728">In these cases, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="0ed15-729">Jeśli odbierany datagram jest większy `buffer`niż rozmiar <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> , Metoda wypełni `buffer` tyle <xref:System.Net.Sockets.SocketException>wiadomości jak to możliwe, i wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-729">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-730">Jeśli korzystasz z wiarygodnego protokołu, nadmiarowe dane zostaną utracone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-730">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="0ed15-731">Jeśli używasz niezawodnego protokołu, nadwyżkowe dane będą przechowywane przez dostawcę usługi i można je pobrać, wywołując <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodę z wystarczającą ilością buforu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-731">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="0ed15-732">Aby zagwarantować, że punkt końcowy hosta zdalnego jest zawsze zwracany, aplikacja powinna jawnie <xref:System.Net.Sockets.Socket> powiązać do lokalnego punktu końcowego <xref:System.Net.Sockets.Socket.Bind%2A> przy użyciu <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody, a następnie `optionLevel` wywołać metodę z parametrem ustawionym na <xref:System.Net.Sockets.SocketOptionLevel.IP> <xref:System.Net.Sockets.SocketOptionName.PacketInformation>lub `optionName` ,w`optionValue` zależności od tego, parametru, aby włączyć tę opcję przed wywołaniem <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody. <xref:System.Net.Sockets.SocketOptionLevel.IPv6></span><span class="sxs-lookup"><span data-stu-id="0ed15-732">To guarantee that the remote host endpoint is always returned, an application should explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method and then call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method with the `optionLevel` parameter set to <xref:System.Net.Sockets.SocketOptionLevel.IP> or <xref:System.Net.Sockets.SocketOptionLevel.IPv6> as appropriate, the `optionName` parameter set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation>, and the `optionValue` parameter to enable this option before calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="0ed15-733">W przeciwnym razie możliwe jest, aby punkt końcowy hosta zdalnego nie był zwracany, gdy nadawca wysłał liczbę datagramów, zanim odbiornik wywołał <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-733">Otherwise, it is possible for the remote host endpoint to not be returned when the sender has sent a number of datagrams before the receiver has called the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-734">Chociaż <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> jest przeznaczony dla protokołów bezpołączeniowych, można również użyć protokołu z zorientowanymi połączeniami.</span><span class="sxs-lookup"><span data-stu-id="0ed15-734">Although <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="0ed15-735">Jeśli zdecydujesz się to zrobić, musisz <xref:System.Net.Sockets.Socket.Connect%2A> najpierw nawiązać połączenie z hostem zdalnym, wywołując  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodę lub <xref:System.Net.Sockets.Socket.Accept%2A> akceptując żądanie połączenia przychodzącego przez wywołanie metody lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-735">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> / <xref:System.Net.Sockets.Socket.BeginConnect%2A> method or accept an incoming connection request by calling the <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="0ed15-736">Jeśli wywołasz <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodę przed nawiązaniem lub zaakceptowaniem połączenia, <xref:System.Net.Sockets.SocketException>otrzymasz.</span><span class="sxs-lookup"><span data-stu-id="0ed15-736">If you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method before establishing or accepting a connection, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-737">Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody można również ustanowić domyślnego hosta zdalnego dla bezpołączeniowego protokołu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-737">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="0ed15-738">W każdym z tych przypadków <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Metoda `remoteEP` zignoruje parametr i będzie odbierać tylko dane z podłączonego lub domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-738">In either of these cases, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="0ed15-739">W przypadku gniazd zorientowanych na połączenia <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> program odczyta tyle danych, ile jest dostępnych do liczby bajtów określonej `size` przez parametr.</span><span class="sxs-lookup"><span data-stu-id="0ed15-739">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter.</span></span>  
  
 <span data-ttu-id="0ed15-740">Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, <xref:System.Net.Sockets.Socket.Close%2A> Wywołaj metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-740">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-741">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-741">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-742">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-742">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-743">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-743">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-744">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-744">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-745">Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-745">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="0ed15-746">Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="0ed15-746">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-747">Poniższy przykład kodu asynchronicznie odbiera bezpołączeniowe datagramy z hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-747">The following code example asynchronously receives connectionless datagrams from a remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-748"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-748"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ed15-749">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-749">-or-</span></span> 
 <span data-ttu-id="0ed15-750"><paramref name="remoteEP" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-750"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-751">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-751">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-752"><paramref name="offset" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-752"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-753">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-753">-or-</span></span> 
 <span data-ttu-id="0ed15-754"><paramref name="offset" />jest większa niż długość <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-754"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="0ed15-755">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-755">-or-</span></span> 
 <span data-ttu-id="0ed15-756"><paramref name="size" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-756"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-757">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-757">-or-</span></span> 
 <span data-ttu-id="0ed15-758"><paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości <paramref name="offset" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-758"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-759"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-759">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0ed15-760">Obiekt wywołujący znajdujący się wyżej w stosie wywołań nie ma uprawnienia do żądanej operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-760">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="0ed15-761">Marshaling delegata jako metoda wywołania zwrotnego</span><span class="sxs-lookup"><span data-stu-id="0ed15-761">Marshaling a Delegate as a Callback Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-762">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-762">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="0ed15-763">Pozycja od zera w <paramref name="buffer" /> parametrze, w którym mają być przechowywane dane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-763">The zero-based position in the <paramref name="buffer" /> parameter at which to store the data.</span></span></param>
        <param name="size"><span data-ttu-id="0ed15-764">Liczba bajtów do odebrania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-764">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-765">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-765">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="0ed15-766"><see cref="T:System.Net.EndPoint" /> Reprezentuje źródło danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-766">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span></span></param>
        <param name="callback"><span data-ttu-id="0ed15-767"><see cref="T:System.AsyncCallback" /> Delegat.</span><span class="sxs-lookup"><span data-stu-id="0ed15-767">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="0ed15-768">Obiekt, który zawiera informacje o stanie dla tego żądania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-768">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="0ed15-769">Rozpoczyna asynchroniczne odbieranie określonej liczby bajtów danych w określonej lokalizacji buforu danych przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />i przechowywanie informacji o punkcie końcowym i pakiecie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-769">Begins to asynchronously receive the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint and packet information.</span></span></summary>
        <returns><span data-ttu-id="0ed15-770"><see cref="T:System.IAsyncResult" /> Odwołuje się do odczytu asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-770">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-771">Asynchroniczne odbieranie operacji musi zostać zakończone przez wywołanie <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-771">The asynchronous receive operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> method.</span></span> <span data-ttu-id="0ed15-772">Zazwyczaj Metoda jest wywoływana przez `asyncCallback` delegata.</span><span class="sxs-lookup"><span data-stu-id="0ed15-772">Typically, the method is invoked by the `asyncCallback` delegate.</span></span>  
  
 <span data-ttu-id="0ed15-773">Ta metoda nie jest blokowana do momentu zakończenia operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-773">This method does not block until the operation completes.</span></span> <span data-ttu-id="0ed15-774">Aby zablokować do momentu zakończenia operacji, użyj <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-774">To block until the operation completes, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-775">Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, <xref:System.Net.Sockets.Socket.Close%2A> Wywołaj metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-775">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-776">Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [wywoływanie metod synchronicznych asynchronicznie](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="0ed15-776">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
 <span data-ttu-id="0ed15-777">Ta metoda odczytuje dane do `buffer` parametru i przechwytuje punkt końcowy hosta zdalnego, z którego są wysyłane dane, a także informacje o odebranym pakiecie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-777">This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent, as well as information about the received packet.</span></span> <span data-ttu-id="0ed15-778">Aby uzyskać informacje na temat pobierania tego punktu końcowego, zapoznaj się z <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>tematem.</span><span class="sxs-lookup"><span data-stu-id="0ed15-778">For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span></span> <span data-ttu-id="0ed15-779">Ta metoda jest najbardziej przydatna, jeśli zamierzasz asynchronicznie odbierać bezpołączeniowe datagramy z nieznanego hosta lub wielu hostów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-779">This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-780">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-780">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-781">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-781">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-782">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-782">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-783">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-783">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-784">Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-784">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="0ed15-785">Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="0ed15-785">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-786"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-786"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ed15-787">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-787">-or-</span></span> 
 <span data-ttu-id="0ed15-788"><paramref name="remoteEP" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-788"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-789">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-789">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-790"><paramref name="offset" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-790"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-791">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-791">-or-</span></span> 
 <span data-ttu-id="0ed15-792"><paramref name="offset" />jest większa niż długość <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-792"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="0ed15-793">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-793">-or-</span></span> 
 <span data-ttu-id="0ed15-794"><paramref name="size" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-794"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-795">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-795">-or-</span></span> 
 <span data-ttu-id="0ed15-796"><paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości <paramref name="offset" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-796"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-797"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-797">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-798">System operacyjny to Windows 2000 lub starszy, a ta metoda wymaga systemu Windows XP.</span><span class="sxs-lookup"><span data-stu-id="0ed15-798">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ed15-799">Wysyła dane asynchronicznie do połączonej <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-799">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="0ed15-800">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-800">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-801">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-801">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="0ed15-802"><see cref="T:System.AsyncCallback" /> Delegat.</span><span class="sxs-lookup"><span data-stu-id="0ed15-802">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="0ed15-803">Obiekt, który zawiera informacje o stanie dla tego żądania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-803">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="0ed15-804">Wysyła dane asynchronicznie do połączonej <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-804">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-805"><see cref="T:System.IAsyncResult" /> , Który odwołuje się do wysyłania asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-805">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-806"><xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Accept%2A>Metoda uruchamia asynchroniczną operację wysyłania do hosta zdalnego, który został ustanowiony w metodzie,, lub. <xref:System.Net.Sockets.Socket.BeginSend%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-806">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="0ed15-807"><xref:System.Net.Sockets.Socket.BeginSend%2A>zgłosi wyjątek, jeśli nie zostanie najpierw <xref:System.Net.Sockets.Socket.Accept%2A>wywołana, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-807"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="0ed15-808"><xref:System.Net.Sockets.Socket.BeginSend%2A> Wywołanie metody daje możliwość wysyłania danych w osobnym wątku wykonania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-808">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="0ed15-809">Można utworzyć metodę wywołania zwrotnego implementującą <xref:System.AsyncCallback> delegata i przekazać jej nazwę <xref:System.Net.Sockets.Socket.BeginSend%2A> do metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-809">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="0ed15-810">Aby to zrobić, w bardzo minimalnym `state` czasie parametr musi zawierać połączony lub domyślny <xref:System.Net.Sockets.Socket> używany do komunikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-810">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="0ed15-811">Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małą klasę lub strukturę w celu przechowywania <xref:System.Net.Sockets.Socket> i innych wymaganych informacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-811">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="0ed15-812">Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginSend%2A> metody `state` za pomocą parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-812">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="0ed15-813">Metoda wywołania zwrotnego powinna wywołać <xref:System.Net.Sockets.Socket.EndSend%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-813">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="0ed15-814">Gdy aplikacja wywołuje <xref:System.Net.Sockets.Socket.BeginSend%2A>program, system użyje oddzielnego wątku do wykonania określonej metody wywołania zwrotnego i <xref:System.Net.Sockets.Socket.EndSend%2A> zablokuje się do momentu <xref:System.Net.Sockets.Socket> wysłania żądania, gdy liczba bajtów lub zgłosi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="0ed15-814">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="0ed15-815">Jeśli chcesz, aby oryginalny wątek blokował po wywołaniu <xref:System.Net.Sockets.Socket.BeginSend%2A> metody, <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Użyj metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-815">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0ed15-816">Wywołaj metodę Set na T:System.Threading.ManualResetEvent w metodzie wywołania zwrotnego, jeśli chcesz, aby oryginalny wątek kontynuował wykonywanie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-816">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="0ed15-817">Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego [, zobacz kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-817">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="0ed15-818">Chociaż przeznaczone dla protokołów zorientowanych na połączenia, <xref:System.Net.Sockets.Socket.BeginSend%2A> działa również dla protokołów bezpołączeniowych, pod warunkiem, <xref:System.Net.Sockets.Socket.Connect%2A> że <xref:System.Net.Sockets.Socket.BeginConnect%2A> najpierw wywołanie metody lub do ustanowienia domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-818">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="0ed15-819">Jeśli używasz bezpołączeniowego protokołu i planujesz wysyłać dane do kilku różnych hostów, użyj polecenia <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-819">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="0ed15-820">Nie można jej używać <xref:System.Net.Sockets.Socket.BeginSendTo%2A> nawet po ustanowieniu domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-820">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="0ed15-821">Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSend%2A> , wykonując inne <xref:System.Net.Sockets.Socket.Connect%2A> wywołanie lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-821">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="0ed15-822">W przypadku protokołów bez połączenia należy również upewnić się, że rozmiar buforu nie przekracza maksymalnego rozmiaru pakietu podstawowego dostawcy usług.</span><span class="sxs-lookup"><span data-stu-id="0ed15-822">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="0ed15-823">Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-823">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="0ed15-824">Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketflags` jako parametr, wysyłane dane nie będą kierowane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-824">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-825">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-825">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-826">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-826">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-827">Wszystkie we/wy zainicjowane przez dany wątek zostało anulowane po zakończeniu tego wątku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-827">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="0ed15-828">Oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek zostanie zakończony przed ukończeniem operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-828">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-829">`state`jest wystąpieniem klasy zdefiniowanej przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="0ed15-829">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-830">Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-830">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="0ed15-831">Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-831">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-832">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-832">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-833">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-833">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-834">Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-834">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="0ed15-835">Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="0ed15-835">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-836"><paramref name="buffers" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-836"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-837"><paramref name="buffers" />jest puste.</span><span class="sxs-lookup"><span data-stu-id="0ed15-837"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-838">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-838">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="0ed15-839">Zobacz uwagi poniżej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-839">See remarks section below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-840"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-840">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="0ed15-841">Marshaling delegata jako metoda wywołania zwrotnego</span><span class="sxs-lookup"><span data-stu-id="0ed15-841">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="0ed15-842">Przykład asynchronicznego gniazda klienta</span><span class="sxs-lookup"><span data-stu-id="0ed15-842">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="0ed15-843">Przykład asynchronicznego gniazda serwera</span><span class="sxs-lookup"><span data-stu-id="0ed15-843">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="0ed15-844">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-844">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-845">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-845">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="0ed15-846"><see cref="T:System.Net.Sockets.SocketError" /> Obiekt, który przechowuje błąd gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-846">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="0ed15-847"><see cref="T:System.AsyncCallback" /> Delegat.</span><span class="sxs-lookup"><span data-stu-id="0ed15-847">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="0ed15-848">Obiekt, który zawiera informacje o stanie dla tego żądania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-848">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="0ed15-849">Wysyła dane asynchronicznie do połączonej <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-849">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-850"><see cref="T:System.IAsyncResult" /> , Który odwołuje się do wysyłania asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-850">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-851"><xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Accept%2A>Metoda uruchamia asynchroniczną operację wysyłania do hosta zdalnego, który został ustanowiony w metodzie,, lub. <xref:System.Net.Sockets.Socket.BeginSend%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-851">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="0ed15-852"><xref:System.Net.Sockets.Socket.BeginSend%2A>zgłosi wyjątek, jeśli nie zostanie najpierw <xref:System.Net.Sockets.Socket.Accept%2A>wywołana, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-852"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="0ed15-853"><xref:System.Net.Sockets.Socket.BeginSend%2A> Wywołanie metody daje możliwość wysyłania danych w osobnym wątku wykonania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-853">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="0ed15-854">Można utworzyć metodę wywołania zwrotnego implementującą <xref:System.AsyncCallback> delegata i przekazać jej nazwę <xref:System.Net.Sockets.Socket.BeginSend%2A> do metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-854">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="0ed15-855">Aby to zrobić, w bardzo minimalnym `state` czasie parametr musi zawierać połączony lub domyślny <xref:System.Net.Sockets.Socket> używany do komunikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-855">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="0ed15-856">Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małą klasę lub strukturę w celu przechowywania <xref:System.Net.Sockets.Socket> i innych wymaganych informacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-856">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="0ed15-857">Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginSend%2A> metody `state` za pomocą parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-857">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="0ed15-858">Metoda wywołania zwrotnego powinna wywołać <xref:System.Net.Sockets.Socket.EndSend%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-858">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="0ed15-859">Gdy aplikacja wywołuje <xref:System.Net.Sockets.Socket.BeginSend%2A>program, system użyje oddzielnego wątku do wykonania określonej metody wywołania zwrotnego i <xref:System.Net.Sockets.Socket.EndSend%2A> zablokuje się do momentu <xref:System.Net.Sockets.Socket> wysłania żądania, gdy liczba bajtów lub zgłosi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="0ed15-859">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="0ed15-860">Jeśli chcesz, aby oryginalny wątek blokował po wywołaniu <xref:System.Net.Sockets.Socket.BeginSend%2A> metody, <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Użyj metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-860">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0ed15-861">Wywołaj metodę <xref:System.Threading.ManualResetEvent> Set w metodzie wywołania zwrotnego, jeśli chcesz, aby oryginalny wątek kontynuował wykonywanie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-861">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="0ed15-862">Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego [, zobacz kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-862">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="0ed15-863">Chociaż przeznaczone dla protokołów zorientowanych na połączenia, <xref:System.Net.Sockets.Socket.BeginSend%2A> działa również dla protokołów bezpołączeniowych, pod warunkiem, <xref:System.Net.Sockets.Socket.Connect%2A> że <xref:System.Net.Sockets.Socket.BeginConnect%2A> najpierw wywołanie metody lub do ustanowienia domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-863">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="0ed15-864">Jeśli używasz bezpołączeniowego protokołu i planujesz wysyłać dane do kilku różnych hostów, użyj polecenia <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-864">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="0ed15-865">Nie można jej używać <xref:System.Net.Sockets.Socket.BeginSendTo%2A> nawet po ustanowieniu domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-865">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="0ed15-866">Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSend%2A> , wykonując inne <xref:System.Net.Sockets.Socket.Connect%2A> wywołanie lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-866">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="0ed15-867">W przypadku protokołów bez połączenia należy również upewnić się, że rozmiar buforu nie przekracza maksymalnego rozmiaru pakietu podstawowego dostawcy usług.</span><span class="sxs-lookup"><span data-stu-id="0ed15-867">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="0ed15-868">Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-868">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="0ed15-869">Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketflags` jako parametr, wysyłane dane nie będą kierowane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-869">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-870">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-870">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-871">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-871">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-872">Wszystkie we/wy zainicjowane przez dany wątek zostało anulowane po zakończeniu tego wątku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-872">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="0ed15-873">Oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek zostanie zakończony przed ukończeniem operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-873">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-874">`state`jest wystąpieniem klasy zdefiniowanej przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="0ed15-874">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-875">Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-875">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="0ed15-876">Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-876">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-877">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-877">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-878">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-878">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-879">Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-879">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="0ed15-880">Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="0ed15-880">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-881"><paramref name="buffers" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-881"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-882"><paramref name="buffers" />jest puste.</span><span class="sxs-lookup"><span data-stu-id="0ed15-882"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-883">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-883">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="0ed15-884">Zobacz uwagi poniżej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-884">See remarks section below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-885"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-885">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="0ed15-886">Marshaling delegata jako metoda wywołania zwrotnego</span><span class="sxs-lookup"><span data-stu-id="0ed15-886">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="0ed15-887">Przykład asynchronicznego gniazda klienta</span><span class="sxs-lookup"><span data-stu-id="0ed15-887">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="0ed15-888">Przykład asynchronicznego gniazda serwera</span><span class="sxs-lookup"><span data-stu-id="0ed15-888">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-889">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-889">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="offset"><span data-ttu-id="0ed15-890">Pozycja od zera w <paramref name="buffer" /> parametrze, od którego należy rozpocząć wysyłanie danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-890">The zero-based position in the <paramref name="buffer" /> parameter at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="0ed15-891">Liczba bajtów do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-891">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-892">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-892">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="0ed15-893"><see cref="T:System.Net.Sockets.SocketError" /> Obiekt, który przechowuje błąd gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-893">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="0ed15-894"><see cref="T:System.AsyncCallback" /> Delegat.</span><span class="sxs-lookup"><span data-stu-id="0ed15-894">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="0ed15-895">Obiekt, który zawiera informacje o stanie dla tego żądania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-895">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="0ed15-896">Wysyła dane asynchronicznie do połączonej <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-896">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-897"><see cref="T:System.IAsyncResult" /> , Który odwołuje się do wysyłania asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-897">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-898"><xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Accept%2A>Metoda uruchamia asynchroniczną operację wysyłania do hosta zdalnego, który został ustanowiony w metodzie,, lub. <xref:System.Net.Sockets.Socket.BeginSend%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-898">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="0ed15-899"><xref:System.Net.Sockets.Socket.BeginSend%2A>zgłosi wyjątek, jeśli nie zostanie najpierw <xref:System.Net.Sockets.Socket.Accept%2A>wywołana, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-899"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="0ed15-900"><xref:System.Net.Sockets.Socket.BeginSend%2A> Wywołanie metody daje możliwość wysyłania danych w osobnym wątku wykonania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-900">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="0ed15-901">Można utworzyć metodę wywołania zwrotnego implementującą <xref:System.AsyncCallback> delegata i przekazać jej nazwę <xref:System.Net.Sockets.Socket.BeginSend%2A> do metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-901">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="0ed15-902">Aby to zrobić, w bardzo minimalnym `state` czasie parametr musi zawierać połączony lub domyślny <xref:System.Net.Sockets.Socket> używany do komunikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-902">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="0ed15-903">Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małą klasę lub strukturę w celu przechowywania <xref:System.Net.Sockets.Socket> i innych wymaganych informacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-903">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="0ed15-904">Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginSend%2A> metody `state` za pomocą parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-904">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="0ed15-905">Metoda wywołania zwrotnego powinna wywołać <xref:System.Net.Sockets.Socket.EndSend%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-905">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="0ed15-906">Gdy aplikacja wywołuje <xref:System.Net.Sockets.Socket.BeginSend%2A>program, system użyje oddzielnego wątku do wykonania określonej metody wywołania zwrotnego i <xref:System.Net.Sockets.Socket.EndSend%2A> zablokuje się do momentu <xref:System.Net.Sockets.Socket> wysłania żądania, gdy liczba bajtów lub zgłosi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="0ed15-906">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="0ed15-907">Jeśli chcesz, aby oryginalny wątek blokował po wywołaniu <xref:System.Net.Sockets.Socket.BeginSend%2A> metody, <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Użyj metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-907">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0ed15-908">Wywołaj metodę Set na T:System.Threading.ManualResetEvent w metodzie wywołania zwrotnego, jeśli chcesz, aby oryginalny wątek kontynuował wykonywanie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-908">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="0ed15-909">Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego [, zobacz kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-909">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="0ed15-910">Chociaż przeznaczone dla protokołów zorientowanych na połączenia, <xref:System.Net.Sockets.Socket.BeginSend%2A> działa również dla protokołów bezpołączeniowych, pod warunkiem, <xref:System.Net.Sockets.Socket.Connect%2A> że <xref:System.Net.Sockets.Socket.BeginConnect%2A> najpierw wywołanie metody lub do ustanowienia domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-910">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="0ed15-911">Jeśli używasz bezpołączeniowego protokołu i planujesz wysyłać dane do kilku różnych hostów, użyj polecenia <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-911">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="0ed15-912">Nie można jej używać <xref:System.Net.Sockets.Socket.BeginSendTo%2A> nawet po ustanowieniu domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-912">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="0ed15-913">Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSend%2A> , wykonując inne <xref:System.Net.Sockets.Socket.Connect%2A> wywołanie lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-913">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="0ed15-914">W przypadku protokołów bez połączenia należy również upewnić się, że rozmiar buforu nie przekracza maksymalnego rozmiaru pakietu podstawowego dostawcy usług.</span><span class="sxs-lookup"><span data-stu-id="0ed15-914">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="0ed15-915">Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-915">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="0ed15-916">Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketflags` jako parametr, wysyłane dane nie będą kierowane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-916">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-917">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-917">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-918">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-918">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-919">Wszystkie we/wy zainicjowane przez dany wątek zostało anulowane po zakończeniu tego wątku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-919">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="0ed15-920">Oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek zostanie zakończony przed ukończeniem operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-920">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-921">`state`jest wystąpieniem klasy zdefiniowanej przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="0ed15-921">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-922">Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-922">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="0ed15-923">Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-923">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-924">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-924">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-925">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-925">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-926">Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-926">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="0ed15-927">Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="0ed15-927">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-928"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-928"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-929">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-929">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="0ed15-930">Zobacz uwagi poniżej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-930">See remarks section below.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-931"><paramref name="offset" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-931"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-932">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-932">-or-</span></span> 
 <span data-ttu-id="0ed15-933"><paramref name="offset" />jest mniejsza niż długość <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-933"><paramref name="offset" /> is less than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="0ed15-934">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-934">-or-</span></span> 
 <span data-ttu-id="0ed15-935"><paramref name="size" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-935"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-936">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-936">-or-</span></span> 
 <span data-ttu-id="0ed15-937"><paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości <paramref name="offset" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-937"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-938"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-938">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="0ed15-939">Marshaling delegata jako metoda wywołania zwrotnego</span><span class="sxs-lookup"><span data-stu-id="0ed15-939">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="0ed15-940">Przykład asynchronicznego gniazda klienta</span><span class="sxs-lookup"><span data-stu-id="0ed15-940">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="0ed15-941">Przykład asynchronicznego gniazda serwera</span><span class="sxs-lookup"><span data-stu-id="0ed15-941">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-942">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-942">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="offset"><span data-ttu-id="0ed15-943">Pozycja od zera w <paramref name="buffer" /> parametrze, od którego należy rozpocząć wysyłanie danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-943">The zero-based position in the <paramref name="buffer" /> parameter at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="0ed15-944">Liczba bajtów do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-944">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-945">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-945">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="socket_flags"><span data-ttu-id="0ed15-946">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-946">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="0ed15-947"><see cref="T:System.AsyncCallback" /> Delegat.</span><span class="sxs-lookup"><span data-stu-id="0ed15-947">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="0ed15-948">Obiekt, który zawiera informacje o stanie dla tego żądania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-948">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="0ed15-949">Wysyła dane asynchronicznie do połączonej <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-949">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-950"><see cref="T:System.IAsyncResult" /> , Który odwołuje się do wysyłania asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-950">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-951"><xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Accept%2A>Metoda uruchamia asynchroniczną operację wysyłania do hosta zdalnego, który został ustanowiony w metodzie,, lub. <xref:System.Net.Sockets.Socket.BeginSend%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-951">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="0ed15-952"><xref:System.Net.Sockets.Socket.BeginSend%2A>zgłosi wyjątek, jeśli nie zostanie najpierw <xref:System.Net.Sockets.Socket.Accept%2A>wywołana, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-952"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="0ed15-953"><xref:System.Net.Sockets.Socket.BeginSend%2A> Wywołanie metody daje możliwość wysyłania danych w osobnym wątku wykonania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-953">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="0ed15-954">Można utworzyć metodę wywołania zwrotnego implementującą <xref:System.AsyncCallback> delegata i przekazać jej nazwę <xref:System.Net.Sockets.Socket.BeginSend%2A> do metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-954">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="0ed15-955">Aby to zrobić, w bardzo minimalnym `state` czasie parametr musi zawierać połączony lub domyślny <xref:System.Net.Sockets.Socket> używany do komunikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-955">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="0ed15-956">Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małą klasę lub strukturę w celu przechowywania <xref:System.Net.Sockets.Socket> i innych wymaganych informacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-956">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="0ed15-957">Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginSend%2A> metody `state` za pomocą parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-957">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="0ed15-958">Metoda wywołania zwrotnego powinna wywołać <xref:System.Net.Sockets.Socket.EndSend%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-958">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="0ed15-959">Gdy aplikacja wywołuje <xref:System.Net.Sockets.Socket.BeginSend%2A>program, system użyje oddzielnego wątku do wykonania określonej metody wywołania zwrotnego i <xref:System.Net.Sockets.Socket.EndSend%2A> zablokuje się do momentu <xref:System.Net.Sockets.Socket> wysłania żądania, gdy liczba bajtów lub zgłosi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="0ed15-959">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="0ed15-960">Jeśli chcesz, aby oryginalny wątek blokował po wywołaniu <xref:System.Net.Sockets.Socket.BeginSend%2A> metody, <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Użyj metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-960">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0ed15-961">Wywołaj metodę Set na T:System.Threading.ManualResetEvent w metodzie wywołania zwrotnego, jeśli chcesz, aby oryginalny wątek kontynuował wykonywanie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-961">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="0ed15-962">Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego [, zobacz kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-962">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="0ed15-963">Chociaż przeznaczone dla protokołów zorientowanych na połączenia, <xref:System.Net.Sockets.Socket.BeginSend%2A> działa również dla protokołów bezpołączeniowych, pod warunkiem, <xref:System.Net.Sockets.Socket.Connect%2A> że <xref:System.Net.Sockets.Socket.BeginConnect%2A> najpierw wywołanie metody lub do ustanowienia domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-963">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="0ed15-964">Jeśli używasz bezpołączeniowego protokołu i planujesz wysyłać dane do kilku różnych hostów, użyj polecenia <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-964">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="0ed15-965">Nie można jej używać <xref:System.Net.Sockets.Socket.BeginSendTo%2A> nawet po ustanowieniu domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-965">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="0ed15-966">Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSend%2A> , wykonując inne <xref:System.Net.Sockets.Socket.Connect%2A> wywołanie lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-966">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="0ed15-967">W przypadku protokołów bez połączenia należy również upewnić się, że rozmiar buforu nie przekracza maksymalnego rozmiaru pakietu podstawowego dostawcy usług.</span><span class="sxs-lookup"><span data-stu-id="0ed15-967">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="0ed15-968">Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-968">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="0ed15-969">Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketflags` jako parametr, wysyłane dane nie będą kierowane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-969">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-970">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-970">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-971">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-971">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-972">Wszystkie we/wy zainicjowane przez dany wątek zostało anulowane po zakończeniu tego wątku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-972">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="0ed15-973">Oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek zostanie zakończony przed ukończeniem operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-973">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-974">`state`jest wystąpieniem klasy zdefiniowanej przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="0ed15-974">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-975">Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-975">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="0ed15-976">Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-976">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-977">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-977">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-978">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-978">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-979">Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-979">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="0ed15-980">Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="0ed15-980">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-981">Poniższy przykład kodu rozpoczyna asynchroniczne wysyłanie danych do hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-981">The following code example begins asynchronously sending data to a remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-982"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-982"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-983">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-983">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="0ed15-984">Zobacz uwagi poniżej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-984">See remarks section below.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-985"><paramref name="offset" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-985"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-986">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-986">-or-</span></span> 
 <span data-ttu-id="0ed15-987"><paramref name="offset" />jest mniejsza niż długość <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-987"><paramref name="offset" /> is less than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="0ed15-988">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-988">-or-</span></span> 
 <span data-ttu-id="0ed15-989"><paramref name="size" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-989"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-990">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-990">-or-</span></span> 
 <span data-ttu-id="0ed15-991"><paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości <paramref name="offset" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-991"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-992"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-992">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="0ed15-993">Marshaling delegata jako metoda wywołania zwrotnego</span><span class="sxs-lookup"><span data-stu-id="0ed15-993">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="0ed15-994">Przykład asynchronicznego gniazda klienta</span><span class="sxs-lookup"><span data-stu-id="0ed15-994">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="0ed15-995">Przykład asynchronicznego gniazda serwera</span><span class="sxs-lookup"><span data-stu-id="0ed15-995">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ed15-996">Wysyła plik asynchronicznie do połączonego <see cref="T:System.Net.Sockets.Socket" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-996">Sends a file asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="0ed15-997">Ciąg, który zawiera ścieżkę i nazwę pliku do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-997">A string that contains the path and name of the file to send.</span></span> <span data-ttu-id="0ed15-998">Ten parametr może być <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-998">This parameter can be <see langword="null" />.</span></span></param>
        <param name="callback"><span data-ttu-id="0ed15-999"><see cref="T:System.AsyncCallback" /> Delegat.</span><span class="sxs-lookup"><span data-stu-id="0ed15-999">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="0ed15-1000">Obiekt, który zawiera informacje o stanie dla tego żądania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1000">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="0ed15-1001">Wysyła plik <paramref name="fileName" /> do obiektu połączonego <see cref="T:System.Net.Sockets.Socket" /> przy użyciu <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> flagi.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1001">Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> flag.</span></span></summary>
        <returns><span data-ttu-id="0ed15-1002"><see cref="T:System.IAsyncResult" /> Obiekt, który reprezentuje wysyłanie asynchroniczne.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1002">An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1003">To Przeciążenie wysyła plik `fileName` do połączonego gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1003">This overload sends the file `fileName` to the connected socket.</span></span> <span data-ttu-id="0ed15-1004">Jeśli `fileName` znajduje się w katalogu lokalnym, może być identyfikowana przy użyciu tylko nazwy pliku; w przeciwnym razie należy określić pełną ścieżkę i nazwę pliku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1004">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="0ed15-1005">Symbole wieloznaczne (".. \\\\\\\\obsługiwane są \myfile.txt ") i nazwy udziałów UNC (" \shared Directory \myfile.txt "). \\</span><span class="sxs-lookup"><span data-stu-id="0ed15-1005">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="0ed15-1006">Jeśli plik nie zostanie znaleziony, zostanie zgłoszony wyjątek <xref:System.IO.FileNotFoundException> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-1006">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="0ed15-1007">Ta metoda używa `TransmitFile` funkcji znalezionej w interfejsie API Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1007">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="0ed15-1008">Aby uzyskać więcej informacji na `TransmitFile` temat funkcji i jej flag, zobacz dokumentację usługi [Windows Sockets](/windows/desktop/WinSock/) .</span><span class="sxs-lookup"><span data-stu-id="0ed15-1008">For more information about the `TransmitFile` function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="0ed15-1009"><xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Accept%2A>Metoda uruchamia asynchroniczną operację wysyłania do hosta zdalnego ustanowionego w metodach,, lub. <xref:System.Net.Sockets.Socket.BeginSendFile%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-1009">The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods.</span></span> <span data-ttu-id="0ed15-1010"><xref:System.Net.Sockets.Socket.BeginSendFile%2A>zgłasza wyjątek, jeśli nie używasz pierwszego <xref:System.Net.Sockets.Socket.Accept%2A>wywołania, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1010"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="0ed15-1011"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> Wywołanie metody umożliwia wysłanie pliku w osobnym wątku wykonania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1011">Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method enables you to send a file within a separate execution thread.</span></span>  
  
 <span data-ttu-id="0ed15-1012">Aby ukończyć operację, można utworzyć metodę wywołania zwrotnego, która jest wywoływana przez <xref:System.AsyncCallback> parametr delegata.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1012">To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter.</span></span> <span data-ttu-id="0ed15-1013">Aby to zrobić, w bardzo minimalnym `state` czasie parametr musi <xref:System.Net.Sockets.Socket> zawierać obiekt używany do komunikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1013">To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication.</span></span> <span data-ttu-id="0ed15-1014">Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć klasę lub strukturę do przechowywania <xref:System.Net.Sockets.Socket> i innych wymaganych informacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1014">If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="0ed15-1015">Przekaż wystąpienie tego obiektu niestandardowego do <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metody `state` za pomocą parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1015">Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="0ed15-1016">Metoda wywołania zwrotnego musi wywoływać <xref:System.Net.Sockets.Socket.EndSendFile%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1016">Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method.</span></span> <span data-ttu-id="0ed15-1017">Gdy aplikacja jest wywoływana <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, system używa oddzielnego wątku do wykonywania określonej metody wywołania zwrotnego i <xref:System.Net.Sockets.Socket.EndSendFile%2A> blokuje się do momentu <xref:System.Net.Sockets.Socket> wysłania całego pliku lub wyrzuca wyjątek.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1017">When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception.</span></span> <span data-ttu-id="0ed15-1018">Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego [, zobacz kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1018">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="0ed15-1019">Chociaż przeznaczone dla protokołów zorientowanych na połączenia, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> działa również dla protokołów bezpołączeniowych, pod warunkiem, <xref:System.Net.Sockets.Socket.Connect%2A> że <xref:System.Net.Sockets.Socket.BeginConnect%2A> najpierw wywołanie metody lub do ustanowienia domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1019">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="0ed15-1020">W przypadku protokołów bez połączenia należy upewnić się, że rozmiar pliku nie przekracza maksymalnego rozmiaru pakietu dostawcy usługi.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1020">With connectionless protocols, you must be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="0ed15-1021">Jeśli tak, datagram nie jest wysyłany i <xref:System.Net.Sockets.Socket.BeginSendFile%2A> <xref:System.Net.Sockets.SocketException> zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1021">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1022">Jeśli wystąpi <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> wyjątek, użyj właściwości, aby uzyskać określony kod błędu. <xref:System.Net.Sockets.SocketException></span><span class="sxs-lookup"><span data-stu-id="0ed15-1022">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1023">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1023">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1024">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1024">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1025">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1025">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1026">Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-1026">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="0ed15-1027">Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1027">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1028">Poniższy przykład kodu tworzy i łączy gniazdo do komunikacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1028">The following code example creates and connects a socket for asynchronous communication.</span></span> <span data-ttu-id="0ed15-1029">Najpierw plik "text. txt" jest wysyłany asynchronicznie do hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1029">First, the file "text.txt" is sent asynchronously to the remote host.</span></span> <span data-ttu-id="0ed15-1030">Delegat wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndSendFile%2A> do ukończenia transmisji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1030">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1031"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1031">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-1032">Gniazdo nie jest połączone z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1032">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="0ed15-1033">Nie znaleziono <paramref name="fileName" /> pliku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1033">The file <paramref name="fileName" /> was not found.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1034">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1034">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="0ed15-1035">Zobacz uwagi poniżej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1035">See remarks section below.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="0ed15-1036">Ciąg, który zawiera ścieżkę i nazwę pliku do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1036">A string that contains the path and name of the file to be sent.</span></span> <span data-ttu-id="0ed15-1037">Ten parametr może być <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1037">This parameter can be <see langword="null" />.</span></span></param>
        <param name="preBuffer"><span data-ttu-id="0ed15-1038"><see cref="T:System.Byte" /> Tablica zawierająca dane, które mają zostać wysłane przed wysłaniem pliku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1038">A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent.</span></span> <span data-ttu-id="0ed15-1039">Ten parametr może być <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1039">This parameter can be <see langword="null" />.</span></span></param>
        <param name="postBuffer"><span data-ttu-id="0ed15-1040"><see cref="T:System.Byte" /> Tablica zawierająca dane, które mają zostać wysłane po wysłaniu pliku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1040">A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent.</span></span> <span data-ttu-id="0ed15-1041">Ten parametr może być <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1041">This parameter can be <see langword="null" />.</span></span></param>
        <param name="flags"><span data-ttu-id="0ed15-1042">Bitowa kombinacja <see cref="T:System.Net.Sockets.TransmitFileOptions" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1042">A bitwise combination of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="0ed15-1043"><see cref="T:System.AsyncCallback" /> Delegat do wywołania po zakończeniu tej operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1043">An <see cref="T:System.AsyncCallback" /> delegate to be invoked when this operation completes.</span></span> <span data-ttu-id="0ed15-1044">Ten parametr może być <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1044">This parameter can be <see langword="null" />.</span></span></param>
        <param name="state"><span data-ttu-id="0ed15-1045">Zdefiniowany przez użytkownika obiekt zawierający informacje o stanie dla tego żądania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1045">A user-defined object that contains state information for this request.</span></span> <span data-ttu-id="0ed15-1046">Ten parametr może być <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1046">This parameter can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="0ed15-1047">Wysyła plik i bufory danych asynchronicznie do połączonego <see cref="T:System.Net.Sockets.Socket" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1047">Sends a file and buffers of data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="0ed15-1048"><see cref="T:System.IAsyncResult" /> Obiekt, który reprezentuje operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1048">An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1049">To Przeciążenie wymaga nazwy pliku, który chcesz wysłać, oraz bitowej kombinacji <xref:System.Net.Sockets.TransmitFileOptions> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1049">This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values.</span></span> <span data-ttu-id="0ed15-1050">`preBuffer` Parametr zawiera wszystkie dane, które mają poprzedzać plik.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1050">The `preBuffer` parameter contains any data you want to precede the file.</span></span> <span data-ttu-id="0ed15-1051">`postBuffer`zawiera dane, które mają być zgodne z plikiem.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1051">`postBuffer` contains data you want to follow the file.</span></span> <span data-ttu-id="0ed15-1052">Jeśli `fileName` znajduje się w katalogu lokalnym, może być identyfikowana przy użyciu tylko nazwy pliku; w przeciwnym razie należy określić pełną ścieżkę i nazwę pliku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1052">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="0ed15-1053">Symbole wieloznaczne (".. \\\\\\\\obsługiwane są \myfile.txt ") i nazwy udziałów UNC (" \shared Directory \myfile.txt "). \\</span><span class="sxs-lookup"><span data-stu-id="0ed15-1053">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="0ed15-1054">Jeśli plik nie zostanie znaleziony, zostanie zgłoszony wyjątek <xref:System.IO.FileNotFoundException> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-1054">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="0ed15-1055">`flags` Parametr udostępnia dostawcy usługi okna Sockets z dodatkowymi informacjami na temat transferu plików.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1055">The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="0ed15-1056">Aby uzyskać więcej informacji na temat korzystania z tego parametru, <xref:System.Net.Sockets.TransmitFileOptions>Zobacz.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1056">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="0ed15-1057">Ta metoda używa `TransmitFile` funkcji znalezionej w interfejsie API Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1057">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="0ed15-1058">Aby uzyskać więcej informacji na `TransmitFile` temat funkcji i jej flag, zobacz dokumentację usługi [Windows Sockets](/windows/desktop/WinSock/) .</span><span class="sxs-lookup"><span data-stu-id="0ed15-1058">For more information about the `TransmitFile` function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="0ed15-1059"><xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Accept%2A>Metoda uruchamia asynchroniczną operację wysyłania do hosta zdalnego ustanowionego w metodach,, lub. <xref:System.Net.Sockets.Socket.BeginSendFile%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-1059">The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods.</span></span> <span data-ttu-id="0ed15-1060"><xref:System.Net.Sockets.Socket.BeginSendFile%2A>zgłasza wyjątek, jeśli nie używasz pierwszego <xref:System.Net.Sockets.Socket.Accept%2A>wywołania, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1060"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="0ed15-1061"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> Wywołanie metody daje możliwość wysyłania pliku w osobnym wątku wykonania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1061">Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method gives you the ability to send a file within a separate execution thread.</span></span>  
  
 <span data-ttu-id="0ed15-1062">Aby ukończyć operację, można utworzyć metodę wywołania zwrotnego, która jest wywoływana przez <xref:System.AsyncCallback> parametr delegata.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1062">To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter.</span></span> <span data-ttu-id="0ed15-1063">Aby to zrobić, w bardzo minimalnym `state` czasie parametr musi <xref:System.Net.Sockets.Socket> zawierać obiekt używany do komunikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1063">To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication.</span></span> <span data-ttu-id="0ed15-1064">Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć klasę lub strukturę do przechowywania <xref:System.Net.Sockets.Socket> i innych wymaganych informacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1064">If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="0ed15-1065">Przekaż wystąpienie tego obiektu niestandardowego do <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metody `state` za pomocą parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1065">Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="0ed15-1066">Metoda wywołania zwrotnego musi wywoływać <xref:System.Net.Sockets.Socket.EndSendFile%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1066">Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method.</span></span> <span data-ttu-id="0ed15-1067">Gdy aplikacja jest wywoływana <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, system używa oddzielnego wątku do wykonywania określonej metody wywołania zwrotnego i <xref:System.Net.Sockets.Socket.EndSendFile%2A> blokuje się do momentu <xref:System.Net.Sockets.Socket> wysłania całego pliku lub wyrzuca wyjątek.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1067">When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception.</span></span> <span data-ttu-id="0ed15-1068">Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego [, zobacz kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1068">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="0ed15-1069">Chociaż przeznaczone dla protokołów zorientowanych na połączenia, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> działa również dla protokołów bezpołączeniowych, pod warunkiem, <xref:System.Net.Sockets.Socket.Connect%2A> że <xref:System.Net.Sockets.Socket.BeginConnect%2A> najpierw wywołanie metody lub do ustanowienia domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1069">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="0ed15-1070">W przypadku protokołów bez połączenia należy również upewnić się, że rozmiar pliku nie przekracza maksymalnego rozmiaru pakietu podstawowego dostawcy usług.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1070">With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="0ed15-1071">Jeśli tak, datagram nie jest wysyłany i <xref:System.Net.Sockets.Socket.BeginSendFile%2A> <xref:System.Net.Sockets.SocketException> zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1071">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1072">Jeśli wystąpi <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> wyjątek, użyj właściwości, aby uzyskać określony kod błędu. <xref:System.Net.Sockets.SocketException></span><span class="sxs-lookup"><span data-stu-id="0ed15-1072">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1073">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1073">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1074">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1074">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1075">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1075">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1076">Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-1076">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="0ed15-1077">Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1077">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1078">Poniższy przykład kodu tworzy i łączy gniazdo do komunikacji asynchronicznej i zaczyna wysyłać plik "text. txt" asynchronicznie do hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1078">The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</span></span> <span data-ttu-id="0ed15-1079">W tym przykładzie `preBuffer` jest tworzone `postBuffer` i a danych do wysłania z plikiem, a wartość domyślna <xref:System.Net.Sockets.TransmitFileOptions> jest używana.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1079">In this example, a `preBuffer` and a `postBuffer` of data is created to send with the file and the default <xref:System.Net.Sockets.TransmitFileOptions> value is used.</span></span> <span data-ttu-id="0ed15-1080">Delegat wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndSendFile%2A> do ukończenia transmisji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1080">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1081"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1081">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1082">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1082">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="0ed15-1083">Zobacz uwagi poniżej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1083">See remarks section below.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-1084">System operacyjny nie jest systemem Windows NT lub nowszym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1084">The operating system is not Windows NT or later.</span></span>  
  
<span data-ttu-id="0ed15-1085">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-1085">-or-</span></span>
  
 <span data-ttu-id="0ed15-1086">Gniazdo nie jest połączone z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1086">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="0ed15-1087">Nie znaleziono <paramref name="fileName" /> pliku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1087">The file <paramref name="fileName" /> was not found.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-1088">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1088">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="offset"><span data-ttu-id="0ed15-1089">Pozycja od zera, w <paramref name="buffer" /> której rozpoczyna się wysyłanie danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1089">The zero-based position in <paramref name="buffer" /> at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="0ed15-1090">Liczba bajtów do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1090">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-1091">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1091">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="socket_flags"><span data-ttu-id="0ed15-1092">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1092">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="0ed15-1093"><see cref="T:System.Net.EndPoint" /> Reprezentuje urządzenie zdalne.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1093">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span></span></param>
        <param name="remote_end"><span data-ttu-id="0ed15-1094"><see cref="T:System.Net.EndPoint" /> Reprezentuje urządzenie zdalne.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1094">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span></span></param>
        <param name="callback"><span data-ttu-id="0ed15-1095"><see cref="T:System.AsyncCallback" /> Delegat.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1095">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="0ed15-1096">Obiekt, który zawiera informacje o stanie dla tego żądania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1096">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="0ed15-1097">Wysyła dane asynchronicznie do określonego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1097">Sends data asynchronously to a specific remote host.</span></span></summary>
        <returns><span data-ttu-id="0ed15-1098"><see cref="T:System.IAsyncResult" /> , Który odwołuje się do wysyłania asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1098">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1099">Metoda uruchamia asynchroniczną operację wysyłania do hosta zdalnego określonego `remoteEP` w parametrze. <xref:System.Net.Sockets.Socket.BeginSendTo%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-1099">The <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method starts an asynchronous send operation to the remote host specified in the `remoteEP` parameter.</span></span> <span data-ttu-id="0ed15-1100"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> Wywołanie metody daje możliwość wysyłania danych w osobnym wątku wykonania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1100">Calling the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method gives you the ability to send data within a separate execution thread.</span></span> <span data-ttu-id="0ed15-1101">Chociaż przeznaczone dla protokołów bezpołączeniowych, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> działa z protokołami bezpołączeniowymi i zorientowanymi na połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1101">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> works with both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="0ed15-1102">Można utworzyć metodę wywołania zwrotnego implementującą <xref:System.AsyncCallback> delegata i przekazać jej nazwę <xref:System.Net.Sockets.Socket.BeginSendTo%2A> do metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1102">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method.</span></span> <span data-ttu-id="0ed15-1103">Aby to zrobić, w bardzo minimalnym `state` czasie parametr musi zawierać połączony lub domyślny <xref:System.Net.Sockets.Socket> używany do komunikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1103">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="0ed15-1104">Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małą klasę do przechowywania <xref:System.Net.Sockets.Socket>i innych wymaganych informacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1104">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information.</span></span> <span data-ttu-id="0ed15-1105">Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metody `state` za pomocą parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1105">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="0ed15-1106">Metoda wywołania zwrotnego powinna wywołać <xref:System.Net.Sockets.Socket.EndSendTo%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1106">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method.</span></span> <span data-ttu-id="0ed15-1107">Gdy aplikacja wywołuje <xref:System.Net.Sockets.Socket.BeginSendTo%2A>program, system użyje oddzielnego wątku do wykonania określonej metody wywołania zwrotnego i <xref:System.Net.Sockets.Socket.EndSendTo%2A> zablokuje się do momentu <xref:System.Net.Sockets.Socket> wysłania żądania, gdy liczba bajtów lub zgłosi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1107">When your application calls <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSendTo%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="0ed15-1108">Jeśli chcesz, aby oryginalny wątek blokował po wywołaniu <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metody, <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Użyj metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1108">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0ed15-1109">Wywołaj metodę Set na T:System.Threading.ManualResetEvent w metodzie wywołania zwrotnego, jeśli chcesz, aby oryginalny wątek kontynuował wykonywanie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1109">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="0ed15-1110">Aby uzyskać dodatkowe informacje na temat pisania metod wywołania zwrotnego [, zobacz kierowanie delegata jako metody wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1110">For additional information about writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="0ed15-1111">W przypadku korzystania z protokołu zorientowanego na połączenia należy najpierw wywołać <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>metodę,, <xref:System.Net.Sockets.SocketException> <xref:System.Net.Sockets.Socket.Accept%2A>, lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> , lub <xref:System.Net.Sockets.Socket.BeginSendTo%2A> zgłosić.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1111">If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, or <xref:System.Net.Sockets.Socket.BeginSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-1112"><xref:System.Net.Sockets.Socket.BeginSendTo%2A>program zignoruje `remoteEP` parametr i wyśle dane <xref:System.Net.EndPoint> do ustalonej <xref:System.Net.Sockets.Socket.Connect%2A>metody, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-1112"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> will ignore the `remoteEP` parameter and send data to the <xref:System.Net.EndPoint> established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-1113">Jeśli używasz bezpołączeniowego protokołu, nie musisz nawiązać domyślnego hosta zdalnego z <xref:System.Net.Sockets.Socket.Connect%2A> metodą lub <xref:System.Net.Sockets.Socket.BeginConnect%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1113">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="0ed15-1114">Wystarczy wykonać tę czynność tylko wtedy, gdy zamierzasz wywołać <xref:System.Net.Sockets.Socket.BeginSend%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1114">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="0ed15-1115">Jeśli wywołaniu <xref:System.Net.Sockets.Socket.Connect%2A> metody lub <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.SendTo%2A>przed wywołaniem, parametrzastąpiokreślonydomyślnyhostzdalnydlatejoperacjiwysyłania.`remoteEP`</span><span class="sxs-lookup"><span data-stu-id="0ed15-1115">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="0ed15-1116">Nie jest również wymagane wywoływanie <xref:System.Net.Sockets.Socket.Bind%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1116">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="0ed15-1117">W takim przypadku Dostawca usługi podstawowej będzie przypisywać najbardziej odpowiedni lokalny adres sieciowy i numer portu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1117">In this case, the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="0ed15-1118">Użyj numeru portu równego zero, jeśli chcesz, aby Dostawca usługi podstawowej wybierał bezpłatny port.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1118">Use a port number of zero if you want the underlying service provider to select a free port.</span></span> <span data-ttu-id="0ed15-1119">Jeśli trzeba zidentyfikować przypisany adres sieci lokalnej i numer portu, można użyć <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwości <xref:System.Net.Sockets.Socket.EndSendTo%2A> po pomyślnym ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1119">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="0ed15-1120">Jeśli chcesz wysłać dane do adresu emisji, musisz najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodę i ustawić opcję gniazda na. <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0ed15-1120">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0ed15-1121">— Należy również upewnić się, że rozmiar buforu nie przekracza maksymalnego rozmiaru pakietu podstawowego dostawcy usług.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1121">-You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="0ed15-1122">Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.EndSendTo%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1122">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.EndSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="0ed15-1123">Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketflags` jako parametr, wysyłane dane nie będą kierowane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1123">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1124">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1124">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1125">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1125">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1126">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1126">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1127">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1127">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1128">Kontekst wykonywania (kontekst zabezpieczeń, personifikowany użytkownik i kontekst wywołujący) jest buforowany dla metod asynchronicznych <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-1128">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="0ed15-1129">Po pierwszym użyciu określonego kontekstu (określonej metodzie asynchronicznej <xref:System.Net.Sockets.Socket> , konkretnemu <xref:System.Net.Sockets.Socket> wystąpieniu i określonym wywołaniu zwrotnym) kolejne zastosowania tego kontekstu zobaczą zwiększenie wydajności.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1129">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1130">Poniższy przykład kodu asynchronicznie wysyła dane do określonego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1130">The following code example asynchronously sends data to the specified remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-1131"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1131"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ed15-1132">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-1132">-or-</span></span> 
 <span data-ttu-id="0ed15-1133"><paramref name="remoteEP" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1133"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1134">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1134">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-1135"><paramref name="offset" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1135"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-1136">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-1136">-or-</span></span> 
 <span data-ttu-id="0ed15-1137"><paramref name="offset" />jest większa niż długość <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1137"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="0ed15-1138">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-1138">-or-</span></span> 
 <span data-ttu-id="0ed15-1139"><paramref name="size" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1139"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-1140">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-1140">-or-</span></span> 
 <span data-ttu-id="0ed15-1141"><paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości <paramref name="offset" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1141"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1142"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1142">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0ed15-1143">Obiekt wywołujący znajdujący się wyżej w stosie wywołań nie ma uprawnienia do żądanej operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1143">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="0ed15-1144">Marshaling delegata jako metoda wywołania zwrotnego</span><span class="sxs-lookup"><span data-stu-id="0ed15-1144">Marshaling a Delegate as a Callback Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP"><span data-ttu-id="0ed15-1145">Lokalna <see cref="T:System.Net.EndPoint" /> do skojarzenia <see cref="T:System.Net.Sockets.Socket" />z.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1145">The local <see cref="T:System.Net.EndPoint" /> to associate with the <see cref="T:System.Net.Sockets.Socket" />.</span></span></param>
        <summary><span data-ttu-id="0ed15-1146">Kojarzy <see cref="T:System.Net.Sockets.Socket" /> a z lokalnym punktem końcowym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1146">Associates a <see cref="T:System.Net.Sockets.Socket" /> with a local endpoint.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1147">Użyj metody <xref:System.Net.Sockets.Socket.Bind%2A> , jeśli musisz użyć określonego lokalnego punktu końcowego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1147">Use the <xref:System.Net.Sockets.Socket.Bind%2A> method if you need to use a specific local endpoint.</span></span> <span data-ttu-id="0ed15-1148">Musisz wywołać <xref:System.Net.Sockets.Socket.Bind%2A> , <xref:System.Net.Sockets.Socket.Listen%2A> aby można było wywołać metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1148">You must call <xref:System.Net.Sockets.Socket.Bind%2A> before you can call the <xref:System.Net.Sockets.Socket.Listen%2A> method.</span></span> <span data-ttu-id="0ed15-1149">Nie trzeba wywoływać <xref:System.Net.Sockets.Socket.Bind%2A> przed użyciem metody, <xref:System.Net.Sockets.Socket.Connect%2A> chyba że trzeba użyć określonego lokalnego punktu końcowego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1149">You do not need to call <xref:System.Net.Sockets.Socket.Bind%2A> before using the <xref:System.Net.Sockets.Socket.Connect%2A> method unless you need to use a specific local endpoint.</span></span> <span data-ttu-id="0ed15-1150"><xref:System.Net.Sockets.Socket.Bind%2A> Metody można użyć zarówno w przypadku połączeń bezpołączeniowych, jak i dla protokołów zorientowanych na połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1150">You can use the <xref:System.Net.Sockets.Socket.Bind%2A> method on both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="0ed15-1151">Przed wywołaniem <xref:System.Net.Sockets.Socket.Bind%2A>należy najpierw utworzyć lokalne <xref:System.Net.IPEndPoint> , z którego mają być przekazywane dane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1151">Before calling <xref:System.Net.Sockets.Socket.Bind%2A>, you must first create the local <xref:System.Net.IPEndPoint> from which you intend to communicate data.</span></span> <span data-ttu-id="0ed15-1152">Jeśli nie wiesz, który adres lokalny jest przypisany, możesz utworzyć <xref:System.Net.IPEndPoint> parametr używany <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> jako adres, a usługodawca źródłowy przypisze najbardziej odpowiedni adres sieciowy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1152">If you do not care which local address is assigned, you can create an <xref:System.Net.IPEndPoint> using <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> as the address parameter, and the underlying service provider will assign the most appropriate network address.</span></span> <span data-ttu-id="0ed15-1153">Może to pomóc uprościć aplikację, jeśli masz wiele interfejsów sieciowych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1153">This might help simplify your application if you have multiple network interfaces.</span></span> <span data-ttu-id="0ed15-1154">Jeśli nie wiesz, który port lokalny jest używany, możesz utworzyć <xref:System.Net.IPEndPoint> numer portu za pomocą wartości 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1154">If you do not care which local port is used, you can create an <xref:System.Net.IPEndPoint> using 0 for the port number.</span></span> <span data-ttu-id="0ed15-1155">W takim przypadku dostawca usług przypisze dostępny numer portu z zakresu od 1024 do 5000.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1155">In this case, the service provider will assign an available port number between 1024 and 5000.</span></span>  
  
 <span data-ttu-id="0ed15-1156">W przypadku korzystania z powyższego podejścia można ustalić, który adres sieci lokalnej i numer portu zostały przypisane przez wywołanie <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1156">If you use the above approach, you can discover what local network address and port number has been assigned by calling the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>.</span></span> <span data-ttu-id="0ed15-1157">W przypadku korzystania z protokołu <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> zorientowanego na połączenia program nie zwróci lokalnie przypisanego adresu sieciowego do momentu wywołania <xref:System.Net.Sockets.Socket.Connect%2A> metody lub <xref:System.Net.Sockets.Socket.EndConnect%2A> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-1157">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> will not return the locally assigned network address until after you have made a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="0ed15-1158">Jeśli używasz bezpołączeniowego protokołu, nie będziesz mieć dostępu do tych informacji, dopóki nie zakończy się wysyłanie ani odbieranie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1158">If you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.</span></span>  
  
 <span data-ttu-id="0ed15-1159">Jeśli gniazdo UDP chce otrzymywać informacje o interfejsie dla odebranych pakietów, <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Metoda powinna być jawnie wywołana z opcją gniazda ustawioną na <xref:System.Net.Sockets.SocketOptionName.PacketInformation> natychmiast po wywołaniu <xref:System.Net.Sockets.Socket.Bind%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1159">If a UDP socket wants to receive interface information on received packets,  the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method should be explicitly called with the socket option set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation> immediately after calling the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1160">Jeśli zamierzasz odbierać datagramy multiemisji, należy wywołać <xref:System.Net.Sockets.Socket.Bind%2A> metodę z numerem portu multiemisji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1160">If you intend to receive multicast datagrams, you must call the <xref:System.Net.Sockets.Socket.Bind%2A> method with a multicast port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1161">Należy wywołać metodę, <xref:System.Net.Sockets.Socket.Bind%2A> Jeśli zamierzasz odbierać bezpołączeniowe datagramy <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> przy użyciu metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1161">You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method if you intend to receive connectionless datagrams using the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1162">Jeśli podczas <xref:System.Net.Sockets.SocketException> <xref:System.Net.Sockets.Socket.Bind%2A> wywoływania metody zostanie wyświetlony komunikat o błędzie, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1162">If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1163">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1163">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1164">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1164">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1165">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1165">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1166">Poniższy przykład kodu wiąże się z <xref:System.Net.Sockets.Socket> przy użyciu określonego lokalnego punktu końcowego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1166">The following code example binds a <xref:System.Net.Sockets.Socket> using the specified local endpoint.</span></span>  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-1167"><paramref name="localEP" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1167"><paramref name="localEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1168">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1168">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1169"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1169">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0ed15-1170">Obiekt wywołujący znajdujący się wyżej w stosie wywołań nie ma uprawnienia do żądanej operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1170">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="0ed15-1171">do akceptowania połączeń z hosta zdefiniowanego <paramref name="localEP" />przez program.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1171">for accepting connections from the host defined by <paramref name="localEP" />.</span></span> <span data-ttu-id="0ed15-1172">Skojarzone Wyliczenie:<see cref="F:System.Net.NetworkAccess.Accept" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-1172">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></span></span></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-1173">Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Net.Sockets.Socket" /> jest w trybie blokowania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1173">Gets or sets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is in blocking mode.</span></span></summary>
        <value><span data-ttu-id="0ed15-1174"><see langword="true" />Jeśli zostanie zablokowanie; w przeciwnym razie, <see langword="false" />. <see cref="T:System.Net.Sockets.Socket" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-1174"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> will block; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="0ed15-1175">Wartość domyślna to <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1175">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1176">Właściwość <xref:System.Net.Sockets.Socket.Blocking%2A> wskazuje, <xref:System.Net.Sockets.Socket> czy jest w trybie blokowania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1176">The <xref:System.Net.Sockets.Socket.Blocking%2A> property indicates whether a <xref:System.Net.Sockets.Socket> is in blocking mode.</span></span>  
  
 <span data-ttu-id="0ed15-1177">Jeśli jesteś w trybie blokowania i utworzysz wywołanie metody, które nie zostanie natychmiast zakończone, aplikacja będzie blokować wykonywanie do momentu ukończenia żądanej operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1177">If you are in blocking mode, and you make a method call which does not complete immediately, your application will block execution until the requested operation completes.</span></span> <span data-ttu-id="0ed15-1178">Jeśli chcesz kontynuować wykonywanie, mimo że żądana operacja nie została ukończona, Zmień <xref:System.Net.Sockets.Socket.Blocking%2A> właściwość na. `false`</span><span class="sxs-lookup"><span data-stu-id="0ed15-1178">If you want execution to continue even though the requested operation is not complete, change the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false`.</span></span> <span data-ttu-id="0ed15-1179"><xref:System.Net.Sockets.Socket.Blocking%2A> Właściwość nie ma wpływu na metody asynchroniczne.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1179">The <xref:System.Net.Sockets.Socket.Blocking%2A> property has no effect on asynchronous methods.</span></span> <span data-ttu-id="0ed15-1180">Jeśli wysyłasz i otrzymujesz dane asynchronicznie i chcesz zablokować wykonywanie, użyj <xref:System.Threading.ManualResetEvent> klasy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1180">If you are sending and receiving data asynchronously and want to block execution, use the <xref:System.Threading.ManualResetEvent> class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1181">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1181">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1182">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1182">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1183">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1183">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1184">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1184">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1185">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1185">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1186"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1186">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="0ed15-1187">Obiekt używany do żądania połączenia z hostem zdalnym przez wywołanie jednej <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> z metod. <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-1187">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object used to request the connection to the remote host by calling one of the <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> methods.</span></span></param>
        <summary><span data-ttu-id="0ed15-1188">Anuluje asynchroniczne żądanie połączenia z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1188">Cancels an asynchronous request for a remote host connection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1189"><xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> Metoda anuluje asynchroniczne żądanie połączenia hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1189">The <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> method cancels an asynchronous request for a remote host connection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-1190">Parametr nie może mieć wartości null <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> i nie może mieć wartości null. <paramref name="e" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-1190">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1191">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1191">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1192"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1192">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0ed15-1193">Obiekt wywołujący znajdujący się wyżej w stosie wywołań nie ma uprawnienia do żądanej operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1193">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ed15-1194"><see cref="T:System.Net.Sockets.Socket" /> Zamyka połączenie i zwalnia wszystkie skojarzone z nim zasoby.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1194">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0ed15-1195"><see cref="T:System.Net.Sockets.Socket" /> Zamyka połączenie i zwalnia wszystkie skojarzone z nim zasoby.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1195">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1196">Metoda zamyka połączenie hosta zdalnego i zwalnia wszystkie zarządzane i niezarządzane zasoby skojarzone <xref:System.Net.Sockets.Socket>z. <xref:System.Net.Sockets.Socket.Close%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-1196">The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-1197">Po zamknięciu <xref:System.Net.Sockets.Socket.Connected%2A> właściwość jest ustawiona na `false`.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1197">Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.</span></span>  
  
 <span data-ttu-id="0ed15-1198">W przypadku protokołów zorientowanych na połączenia zaleca się wywołanie <xref:System.Net.Sockets.Socket.Shutdown%2A> przed <xref:System.Net.Sockets.Socket.Close%2A> wywołaniem metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1198">For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span> <span data-ttu-id="0ed15-1199">Gwarantuje to, że wszystkie dane zostaną wysłane i odebrane w podłączonym gnieździe przed jego zamknięciem.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1199">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="0ed15-1200">Jeśli zachodzi konieczność <xref:System.Net.Sockets.Socket.Close%2A> wywołania bez uprzedniego wywołania <xref:System.Net.Sockets.Socket.Shutdown%2A>, można upewnić się, że dane w kolejce do transmisji wychodzącej będą `false` wysyłane przez ustawienie <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> opcji i określanie interwału limitu czasu niezerowego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1200">If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specifying a non-zero time-out interval.</span></span> <span data-ttu-id="0ed15-1201"><xref:System.Net.Sockets.Socket.Close%2A>Program zablokuje do momentu wysłania tych danych lub aż do upływu określonego limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1201"><xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="0ed15-1202">Jeśli ustawisz <xref:System.Net.Sockets.SocketOptionName.DontLinger> `false` wartość i określisz interwał limitu czasu, program <xref:System.Net.Sockets.Socket.Close%2A> zwolni połączenie i automatycznie odrzuci wychodzące dane znajdujące się w kolejce.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1202">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1203">Aby <xref:System.Net.Sockets.SocketOptionName.DontLinger> ustawić opcję gniazda na <xref:System.Net.Sockets.LingerOption> `false`, Utwórz, ustaw właściwość Enabled na `true`, a następnie ustaw <xref:System.Net.Sockets.LingerOption.LingerTime%2A> właściwość na żądany limit czasu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1203">To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time out period.</span></span> <span data-ttu-id="0ed15-1204">Użyj tego <xref:System.Net.Sockets.LingerOption> programu wraz <xref:System.Net.Sockets.SocketOptionName.DontLinger> z opcją <xref:System.Net.Sockets.Socket.SetSocketOption%2A> gniazda, aby wywołać metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1204">Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1205">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1205">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1206">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1206">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1207">Poniższy przykład kodu zamyka a <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1207">The following code example closes a <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="0ed15-1208">Zaczekaj <paramref name="timeout" /> do sekund, aby wysłać wszystkie pozostałe dane, a następnie zamknij gniazdo.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1208">Wait up to <paramref name="timeout" /> seconds to send any remaining data, then close the socket.</span></span></param>
        <summary><span data-ttu-id="0ed15-1209"><see cref="T:System.Net.Sockets.Socket" /> Zamyka połączenie i zwalnia wszystkie skojarzone zasoby z określonym limitem czasu, aby umożliwić wysyłanie w kolejce danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1209">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources with a specified timeout to allow queued data to be sent.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1210">Metoda zamyka połączenie hosta zdalnego i zwalnia wszystkie zarządzane i niezarządzane zasoby skojarzone <xref:System.Net.Sockets.Socket>z. <xref:System.Net.Sockets.Socket.Close%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-1210">The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-1211">Po zamknięciu <xref:System.Net.Sockets.Socket.Connected%2A> właściwość jest ustawiona na `false`.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1211">Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.</span></span>  
  
 <span data-ttu-id="0ed15-1212">W przypadku protokołów zorientowanych na połączenia zaleca się wywołanie <xref:System.Net.Sockets.Socket.Shutdown%2A> przed wywołaniem metody. <xref:System.Net.Sockets.Socket.Close%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-1212">For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling <xref:System.Net.Sockets.Socket.Close%2A>.</span></span> <span data-ttu-id="0ed15-1213">Gwarantuje to, że wszystkie dane zostaną wysłane i odebrane w podłączonym gnieździe przed jego zamknięciem.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1213">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="0ed15-1214">Jeśli zachodzi konieczność <xref:System.Net.Sockets.Socket.Close%2A> wywołania bez uprzedniego wywołania <xref:System.Net.Sockets.Socket.Shutdown%2A>, można upewnić się, że dane w kolejce do transmisji wychodzącej będą `false` wysyłane przez ustawienie <xref:System.Net.Sockets.SocketOptionName.DontLinger> opcji i określanie interwału limitu czasu niezerowego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1214">If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger> option to `false` and specifying a non-zero time-out interval.</span></span> <span data-ttu-id="0ed15-1215"><xref:System.Net.Sockets.Socket.Close%2A>Program zablokuje do momentu wysłania tych danych lub aż do upływu określonego limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1215"><xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="0ed15-1216">Jeśli ustawisz <xref:System.Net.Sockets.SocketOptionName.DontLinger> `false` wartość i określisz interwał limitu czasu, program <xref:System.Net.Sockets.Socket.Close%2A> zwolni połączenie i automatycznie odrzuci wychodzące dane znajdujące się w kolejce.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1216">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1217">Aby <xref:System.Net.Sockets.SocketOptionName.DontLinger> ustawić opcję gniazda na <xref:System.Net.Sockets.LingerOption> `false`, Utwórz, ustaw właściwość Enabled na `true`wartość i ustaw <xref:System.Net.Sockets.LingerOption.LingerTime%2A> właściwość na żądany limit czasu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1217">To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time-out period.</span></span> <span data-ttu-id="0ed15-1218">Użyj tego <xref:System.Net.Sockets.LingerOption> programu wraz <xref:System.Net.Sockets.SocketOptionName.DontLinger> z opcją <xref:System.Net.Sockets.Socket.SetSocketOption%2A> gniazda, aby wywołać metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1218">Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1219">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1219">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1220">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1220">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1221">Poniższy przykład kodu demonstruje, <xref:System.Net.Sockets.Socket>jak zamknąć.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1221">The following code example demonstrates how to close a <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ed15-1222">Ustanawia połączenie z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1222">Establishes a connection to a remote host.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP"><span data-ttu-id="0ed15-1223"><see cref="T:System.Net.EndPoint" /> Reprezentuje urządzenie zdalne.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1223">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span></span></param>
        <summary><span data-ttu-id="0ed15-1224">Ustanawia połączenie z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1224">Establishes a connection to a remote host.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1225">Jeśli używasz protokołu opartego na połączeniu, takiego jak TCP, <xref:System.Net.Sockets.Socket.Connect%2A> Metoda synchronicznie ustanawia połączenie sieciowe między <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> i określonym zdalnym punktem końcowym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1225">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="0ed15-1226">Jeśli używasz protokołu bezpołączeniowego, program <xref:System.Net.Sockets.Socket.Connect%2A> ustanowi domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1226">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="0ed15-1227">Po wywołaniu <xref:System.Net.Sockets.Socket.Connect%2A>programu można wysłać dane do urządzenia zdalnego <xref:System.Net.Sockets.Socket.Send%2A> za pomocą metody lub odebrać dane z urządzenia zdalnego za pomocą <xref:System.Net.Sockets.Socket.Receive%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1227">After you call <xref:System.Net.Sockets.Socket.Connect%2A>, you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-1228">Jeśli używasz protokołu bezpołączeniowego, takiego jak UDP, nie musisz wywoływać <xref:System.Net.Sockets.Socket.Connect%2A> przed wysłaniem i odebraniem danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1228">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="0ed15-1229">Za pomocą <xref:System.Net.Sockets.Socket.SendTo%2A> programu i <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> można synchronicznie komunikować się z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1229">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="0ed15-1230">Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.Connect%2A>, wszelkie datagramy, które dotarły do adresu innego niż określona wartość domyślna zostaną odrzucone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1230">If you do call <xref:System.Net.Sockets.Socket.Connect%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="0ed15-1231">Jeśli chcesz ustawić domyślny host zdalny na adres emisji <xref:System.Net.Sockets.Socket.SetSocketOption%2A> , musisz najpierw wywołać metodę i ustawić opcję Socket na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>lub <xref:System.Net.Sockets.Socket.Connect%2A> zgłosić <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1231">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-1232">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1232">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1233">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1233">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="0ed15-1234">Metoda zostanie zablokowana, chyba `false` że przed wywołaniem <xref:System.Net.Sockets.Socket.Blocking%2A> <xref:System.Net.Sockets.Socket.Connect%2A>zostanie wybrana właściwość. <xref:System.Net.Sockets.Socket.Connect%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-1234">The <xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="0ed15-1235">Jeśli używasz protokołu opartego na połączeniu, takiego jak TCP, i wyłączyć blokowanie, program zgłosi plik <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.SocketException> , ponieważ potrzebuje czasu na nawiązanie połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1235">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="0ed15-1236">Protokoły bez połączenia nie zgłaszają wyjątku, ponieważ po prostu nawiązują domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1236">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="0ed15-1237">Można użyć <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1237">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1238">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1238">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="0ed15-1239">Jeśli błąd zwrócił WSAEWOULDBLOCK, połączenie hosta zdalnego zostało zainicjowane przez zorientowane <xref:System.Net.Sockets.Socket>na połączenie, ale jeszcze nie zostało zakończone pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1239">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="0ed15-1240">Użyj metody, aby określić, <xref:System.Net.Sockets.Socket> Kiedy zakończy się nawiązywanie połączenia. <xref:System.Net.Sockets.Socket.Poll%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-1240">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1241">Jeśli używasz protokołu zorientowanego na połączenia i nie wywołuje <xref:System.Net.Sockets.Socket.Bind%2A> się przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>, Dostawca usługi bazowej przypisze lokalny adres sieciowy i numer portu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1241">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="0ed15-1242">Jeśli używasz bezpołączeniowego protokołu, dostawca usług nie przypisze lokalnego adresu sieciowego i numeru portu do momentu ukończenia operacji wysyłania lub odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1242">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="0ed15-1243">Jeśli chcesz zmienić domyślnego hosta zdalnego, wywołaj <xref:System.Net.Sockets.Socket.Connect%2A> ponownie z żądanym punktem końcowym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1243">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1244">Jeśli gniazdo zostało wcześniej odłączone, nie można użyć tej metody do przywrócenia połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1244">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="0ed15-1245">Użyj jednej z metod asynchronicznych <xref:System.Net.Sockets.Socket.BeginConnect%2A> , aby ponownie nawiązać połączenie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1245">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="0ed15-1246">Jest to ograniczenie podstawowego dostawcy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1246">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1247">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1247">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1248">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1248">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1249">Poniższy przykład kodu łączy się ze zdalnym punktem końcowym, a następnie weryfikuje połączenie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1249">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-1250"><paramref name="remoteEP" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1250"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1251">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1251">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1252"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1252">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0ed15-1253">Obiekt wywołujący znajdujący się wyżej w stosie wywołań nie ma uprawnienia do żądanej operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1253">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-1254">Został umieszczony w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />. <see cref="T:System.Net.Sockets.Socket" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-1254">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="0ed15-1255">do nawiązania połączenia z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1255">for connecting to the remote host.</span></span> <span data-ttu-id="0ed15-1256">Skojarzone Wyliczenie:<see cref="F:System.Net.NetworkAccess.Connect" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-1256">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Connect" /></span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="0ed15-1257">Adres IP hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1257">The IP address of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="0ed15-1258">Numer portu hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1258">The port number of the remote host.</span></span></param>
        <summary><span data-ttu-id="0ed15-1259">Ustanawia połączenie z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1259">Establishes a connection to a remote host.</span></span> <span data-ttu-id="0ed15-1260">Host jest określony przez adres IP i numer portu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1260">The host is specified by an IP address and a port number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1261">Jeśli używasz protokołu opartego na połączeniu, takiego jak TCP, <xref:System.Net.Sockets.Socket.Connect%2A> Metoda synchronicznie ustanawia połączenie sieciowe między <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> i określonym zdalnym punktem końcowym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1261">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="0ed15-1262">Jeśli używasz protokołu bezpołączeniowego, program <xref:System.Net.Sockets.Socket.Connect%2A> ustanowi domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1262">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="0ed15-1263">Po wywołaniu <xref:System.Net.Sockets.Socket.Connect%2A> można wysłać dane do urządzenia zdalnego <xref:System.Net.Sockets.Socket.Send%2A> za pomocą metody lub odebrać dane z urządzenia zdalnego za pomocą <xref:System.Net.Sockets.Socket.Receive%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1263">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-1264">Jeśli używasz protokołu bezpołączeniowego, takiego jak UDP, nie musisz wywoływać <xref:System.Net.Sockets.Socket.Connect%2A> przed wysłaniem i odebraniem danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1264">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="0ed15-1265">Za pomocą <xref:System.Net.Sockets.Socket.SendTo%2A> programu i <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> można synchronicznie komunikować się z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1265">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="0ed15-1266">Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.Connect%2A> jakakolwiek datagramy, które dotarły do adresu innego niż określony, zostanie odrzucone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1266">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="0ed15-1267">Jeśli chcesz ustawić domyślny host zdalny na adres emisji <xref:System.Net.Sockets.Socket.SetSocketOption%2A> , musisz najpierw wywołać metodę i ustawić opcję Socket na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>lub <xref:System.Net.Sockets.Socket.Connect%2A> zgłosić <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1267">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-1268">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1268">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1269">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1269">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="0ed15-1270"><xref:System.Net.Sockets.Socket.Connect%2A>Metoda zostanie zablokowana, chyba że <xref:System.Net.Sockets.Socket.Blocking%2A> `false` przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>zostanie wybrana właściwość.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1270"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="0ed15-1271">Jeśli używasz protokołu opartego na połączeniu, takiego jak TCP, i wyłączyć blokowanie, program zgłosi plik <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.SocketException> , ponieważ potrzebuje czasu na nawiązanie połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1271">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="0ed15-1272">Protokoły bez połączenia nie zgłaszają wyjątku, ponieważ po prostu nawiązują domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1272">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="0ed15-1273">Można użyć <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1273">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1274">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1274">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="0ed15-1275">Jeśli błąd zwrócił WSAEWOULDBLOCK, połączenie hosta zdalnego zostało zainicjowane przez zorientowane <xref:System.Net.Sockets.Socket>na połączenie, ale jeszcze nie zostało zakończone pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1275">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="0ed15-1276">Użyj metody, aby określić, <xref:System.Net.Sockets.Socket> Kiedy zakończy się nawiązywanie połączenia. <xref:System.Net.Sockets.Socket.Poll%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-1276">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1277">Jeśli używasz protokołu zorientowanego na połączenia i nie wywołuje <xref:System.Net.Sockets.Socket.Bind%2A> się przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>, Dostawca usługi bazowej przypisze lokalny adres sieciowy i numer portu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1277">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="0ed15-1278">Jeśli używasz bezpołączeniowego protokołu, dostawca usług nie przypisze lokalnego adresu sieciowego i numeru portu do momentu ukończenia operacji wysyłania lub odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1278">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="0ed15-1279">Jeśli chcesz zmienić domyślnego hosta zdalnego, wywołaj <xref:System.Net.Sockets.Socket.Connect%2A> ponownie z żądanym punktem końcowym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1279">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1280">Jeśli gniazdo zostało wcześniej odłączone, nie można użyć tej metody do przywrócenia połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1280">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="0ed15-1281">Użyj jednej z metod asynchronicznych <xref:System.Net.Sockets.Socket.BeginConnect%2A> , aby ponownie nawiązać połączenie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1281">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="0ed15-1282">Jest to ograniczenie podstawowego dostawcy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1282">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1283">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1283">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1284">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1284">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1285">Poniższy przykład kodu łączy się ze zdalnym punktem końcowym, a następnie weryfikuje połączenie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1285">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-1286"><paramref name="address" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1286"><paramref name="address" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-1287">Numer portu jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1287">The port number is not valid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1288">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1288">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1289"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1289">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-1290">Ta metoda jest prawidłowa dla gniazd w <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> w rodzinach.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1290">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-1291">Długość <paramref name="address" /> wynosi zero.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1291">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-1292">Został umieszczony w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />. <see cref="T:System.Net.Sockets.Socket" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-1292">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="addresses"><span data-ttu-id="0ed15-1293">Adresy IP hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1293">The IP addresses of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="0ed15-1294">Numer portu hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1294">The port number of the remote host.</span></span></param>
        <summary><span data-ttu-id="0ed15-1295">Ustanawia połączenie z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1295">Establishes a connection to a remote host.</span></span> <span data-ttu-id="0ed15-1296">Host jest określony przez tablicę adresów IP i numer portu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1296">The host is specified by an array of IP addresses and a port number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1297">Ta metoda jest zwykle używana natychmiast po wywołaniu <xref:System.Net.Dns.GetHostAddresses%2A>metody, która może zwracać wiele adresów IP dla jednego hosta.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1297">This method is typically used immediately after a call to <xref:System.Net.Dns.GetHostAddresses%2A>, which can return multiple IP addresses for a single host.</span></span> <span data-ttu-id="0ed15-1298">Jeśli używasz protokołu opartego na połączeniu, takiego jak TCP, <xref:System.Net.Sockets.Socket.Connect%2A> Metoda synchronicznie ustanawia połączenie sieciowe między <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> i określonym zdalnym punktem końcowym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1298">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="0ed15-1299">Jeśli używasz protokołu bezpołączeniowego, program <xref:System.Net.Sockets.Socket.Connect%2A> ustanowi domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1299">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="0ed15-1300">Po wywołaniu <xref:System.Net.Sockets.Socket.Connect%2A> można wysłać dane do urządzenia zdalnego <xref:System.Net.Sockets.Socket.Send%2A> za pomocą metody lub odebrać dane z urządzenia zdalnego za pomocą <xref:System.Net.Sockets.Socket.Receive%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1300">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-1301">Jeśli używasz protokołu bezpołączeniowego, takiego jak UDP, nie musisz wywoływać <xref:System.Net.Sockets.Socket.Connect%2A> przed wysłaniem i odebraniem danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1301">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="0ed15-1302">Za pomocą <xref:System.Net.Sockets.Socket.SendTo%2A> programu i <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> można synchronicznie komunikować się z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1302">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="0ed15-1303">Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.Connect%2A> jakakolwiek datagramy, które dotarły do adresu innego niż określony, zostanie odrzucone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1303">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="0ed15-1304">Jeśli chcesz ustawić domyślny host zdalny na adres emisji <xref:System.Net.Sockets.Socket.SetSocketOption%2A> , musisz najpierw wywołać metodę i ustawić opcję Socket na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>lub <xref:System.Net.Sockets.Socket.Connect%2A> zgłosić <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1304">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-1305">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1305">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1306">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1306">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="0ed15-1307"><xref:System.Net.Sockets.Socket.Connect%2A>Metoda zostanie zablokowana, chyba że <xref:System.Net.Sockets.Socket.Blocking%2A> `false` przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>zostanie wybrana właściwość.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1307"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="0ed15-1308">Jeśli używasz protokołu opartego na połączeniu, takiego jak TCP, i wyłączyć blokowanie, program zgłosi plik <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.SocketException> , ponieważ potrzebuje czasu na nawiązanie połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1308">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="0ed15-1309">Protokoły bez połączenia nie zgłaszają wyjątku, ponieważ po prostu nawiązują domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1309">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="0ed15-1310">Można użyć <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1310">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1311">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1311">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="0ed15-1312">Jeśli błąd zwrócił WSAEWOULDBLOCK, połączenie hosta zdalnego zostało zainicjowane przez zorientowane <xref:System.Net.Sockets.Socket>na połączenie, ale jeszcze nie zostało zakończone pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1312">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="0ed15-1313">Użyj metody, aby określić, <xref:System.Net.Sockets.Socket> Kiedy zakończy się nawiązywanie połączenia. <xref:System.Net.Sockets.Socket.Poll%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-1313">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1314">Jeśli używasz protokołu zorientowanego na połączenia i nie wywołuje <xref:System.Net.Sockets.Socket.Bind%2A> się przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>, Dostawca usługi bazowej przypisze lokalny adres sieciowy i numer portu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1314">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="0ed15-1315">Jeśli używasz bezpołączeniowego protokołu, dostawca usług nie przypisze lokalnego adresu sieciowego i numeru portu do momentu ukończenia operacji wysyłania lub odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1315">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="0ed15-1316">Jeśli chcesz zmienić domyślnego hosta zdalnego, wywołaj <xref:System.Net.Sockets.Socket.Connect%2A> ponownie z żądanym punktem końcowym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1316">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1317">Jeśli gniazdo zostało wcześniej odłączone, nie można użyć tej metody do przywrócenia połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1317">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="0ed15-1318">Użyj jednej z metod asynchronicznych <xref:System.Net.Sockets.Socket.BeginConnect%2A> , aby ponownie nawiązać połączenie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1318">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="0ed15-1319">Jest to ograniczenie podstawowego dostawcy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1319">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1320">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1320">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1321">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1321">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1322">Poniższy przykład kodu łączy się ze zdalnym punktem końcowym, a następnie weryfikuje połączenie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1322">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-1323"><paramref name="addresses" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1323"><paramref name="addresses" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-1324">Numer portu jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1324">The port number is not valid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1325">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1325">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1326"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1326">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-1327">Ta metoda jest prawidłowa dla gniazd w <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> w rodzinach.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1327">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-1328">Długość <paramref name="address" /> wynosi zero.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1328">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-1329">Został umieszczony w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />. <see cref="T:System.Net.Sockets.Socket" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-1329">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="0ed15-1330">Nazwa hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1330">The name of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="0ed15-1331">Numer portu hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1331">The port number of the remote host.</span></span></param>
        <summary><span data-ttu-id="0ed15-1332">Ustanawia połączenie z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1332">Establishes a connection to a remote host.</span></span> <span data-ttu-id="0ed15-1333">Host jest określony przez nazwę hosta i numer portu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1333">The host is specified by a host name and a port number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1334">Jeśli używasz protokołu opartego na połączeniu, takiego jak TCP, <xref:System.Net.Sockets.Socket.Connect%2A> Metoda synchronicznie ustanawia połączenie sieciowe między <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> i określonym hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1334">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote host.</span></span> <span data-ttu-id="0ed15-1335">Jeśli używasz protokołu bezpołączeniowego, program <xref:System.Net.Sockets.Socket.Connect%2A> ustanowi domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1335">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="0ed15-1336">Po wywołaniu <xref:System.Net.Sockets.Socket.Connect%2A> można wysłać dane do urządzenia zdalnego <xref:System.Net.Sockets.Socket.Send%2A> za pomocą metody lub odebrać dane z urządzenia zdalnego za pomocą <xref:System.Net.Sockets.Socket.Receive%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1336">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-1337">Jeśli używasz protokołu bezpołączeniowego, takiego jak UDP, nie musisz wywoływać <xref:System.Net.Sockets.Socket.Connect%2A> przed wysłaniem i odebraniem danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1337">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="0ed15-1338">Za pomocą <xref:System.Net.Sockets.Socket.SendTo%2A> programu i <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> można synchronicznie komunikować się z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1338">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="0ed15-1339">Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.Connect%2A> jakakolwiek datagramy, które dotarły do adresu innego niż określony, zostanie odrzucone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1339">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="0ed15-1340">Jeśli chcesz ustawić domyślny host zdalny na adres emisji <xref:System.Net.Sockets.Socket.SetSocketOption%2A> , musisz najpierw wywołać metodę i ustawić opcję Socket na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>lub <xref:System.Net.Sockets.Socket.Connect%2A> zgłosić <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1340">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-1341">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1341">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1342">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1342">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="0ed15-1343"><xref:System.Net.Sockets.Socket.Connect%2A>Metoda zostanie zablokowana, chyba że <xref:System.Net.Sockets.Socket.Blocking%2A> `false` przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>zostanie wybrana właściwość.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1343"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="0ed15-1344">Jeśli używasz protokołu opartego na połączeniu, takiego jak TCP, i wyłączyć blokowanie, program zgłosi plik <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.SocketException> , ponieważ potrzebuje czasu na nawiązanie połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1344">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="0ed15-1345">Protokoły bez połączenia nie zgłaszają wyjątku, ponieważ po prostu nawiązują domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1345">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="0ed15-1346">Można użyć <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1346">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1347">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1347">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="0ed15-1348">Jeśli błąd zwrócił WSAEWOULDBLOCK, połączenie hosta zdalnego zostało zainicjowane przez zorientowane <xref:System.Net.Sockets.Socket>na połączenie, ale jeszcze nie zostało zakończone pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1348">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="0ed15-1349">Użyj metody, aby określić, <xref:System.Net.Sockets.Socket> Kiedy zakończy się nawiązywanie połączenia. <xref:System.Net.Sockets.Socket.Poll%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-1349">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
 <span data-ttu-id="0ed15-1350">Jeśli protokół IPv6 jest włączony i <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> wywoływana jest metoda w celu nawiązania połączenia z hostem, który jest rozpoznawany jako adres IPv6 i IPv4, połączenie z adresem IPv6 zostanie podjęte najpierw przed adresem IPv4.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1350">If IPv6 is enabled and the <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address.</span></span> <span data-ttu-id="0ed15-1351">Może to skutkować opóźnieniami czasu na nawiązanie połączenia, Jeśli host nie nasłuchuje na adresie IPv6.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1351">This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1352">Jeśli używasz protokołu zorientowanego na połączenia i nie wywołuje <xref:System.Net.Sockets.Socket.Bind%2A> się przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>, Dostawca usługi bazowej przypisze lokalny adres sieciowy i numer portu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1352">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="0ed15-1353">Jeśli używasz bezpołączeniowego protokołu, dostawca usług nie przypisze lokalnego adresu sieciowego i numeru portu do momentu ukończenia operacji wysyłania lub odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1353">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="0ed15-1354">Jeśli chcesz zmienić domyślnego hosta zdalnego, wywołaj <xref:System.Net.Sockets.Socket.Connect%2A> ponownie z żądanym punktem końcowym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1354">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1355">Jeśli gniazdo zostało wcześniej odłączone, nie można użyć tej metody do przywrócenia połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1355">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="0ed15-1356">Użyj jednej z metod asynchronicznych <xref:System.Net.Sockets.Socket.BeginConnect%2A> , aby ponownie nawiązać połączenie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1356">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="0ed15-1357">Jest to ograniczenie podstawowego dostawcy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1357">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1358">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1358">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1359">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1359">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1360">Poniższy przykład kodu łączy się ze zdalnym punktem końcowym, a następnie weryfikuje połączenie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1360">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-1361"><paramref name="host" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1361"><paramref name="host" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-1362">Numer portu jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1362">The port number is not valid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1363">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1363">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1364"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1364">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-1365">Ta metoda jest prawidłowa dla gniazd w <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> w rodzinach.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1365">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-1366">Został umieszczony w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />. <see cref="T:System.Net.Sockets.Socket" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-1366">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ed15-1367">Rozpoczyna asynchroniczne żądanie połączenia z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1367">Begins an asynchronous request for a connection to a remote host.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="0ed15-1368">Obiekt <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> , który ma być używany dla tej asynchronicznej operacji gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1368">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="0ed15-1369">Rozpoczyna asynchroniczne żądanie połączenia z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1369">Begins an asynchronous request for a connection to a remote host.</span></span></summary>
        <returns><span data-ttu-id="0ed15-1370"><see langword="true" />Jeśli operacja we/wy jest w stanie oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1370"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="0ed15-1371"><see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie<paramref name="e" /> na parametrze zostanie wywołane po zakończeniu operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1371">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="0ed15-1372"><see langword="false" />Jeśli operacja we/wy została ukończona synchronicznie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1372"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="0ed15-1373">W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie <paramref name="e" /> na parametrze <paramref name="e" /> nie zostanie zgłoszone i obiekt przenoszony jako parametr może zostać zbadany natychmiast po wywołaniu metody, aby pobrać wynik operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1373">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1374">W <xref:System.Net.Sockets.Socket.ConnectAsync%2A> przypadku korzystania z protokołu zorientowanego na połączenia Metoda uruchamia asynchroniczne żądanie dla połączenia z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1374">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method starts an asynchronous request for a connection to the remote host.</span></span> <span data-ttu-id="0ed15-1375">Jeśli używasz protokołu bezpołączeniowego, program <xref:System.Net.Sockets.Socket.ConnectAsync%2A> ustanowi domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1375">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host.</span></span>  
  
 <span data-ttu-id="0ed15-1376">Aby otrzymywać powiadomienia o zakończeniu, należy utworzyć metodę wywołania zwrotnego implementującą delegata\<EventHandler SocketAsyncEventArgs > i dołączyć wywołanie zwrotne <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> do zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1376">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="0ed15-1377">Obiekt wywołujący musi ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Właściwość <xref:System.Net.IPEndPoint> na hoście zdalnym, z którym ma zostać nawiązane połączenie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1377">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.</span></span>  
  
 <span data-ttu-id="0ed15-1378">Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość na dowolny obiekt stanu użytkownika przed <xref:System.Net.Sockets.Socket.ConnectAsync%2A> wywołaniem metody, tak aby informacje były możliwe do pobierania w metodzie wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1378">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="0ed15-1379">Jeśli wywołanie zwrotne wymaga więcej informacji niż pojedynczy obiekt, można utworzyć małą klasę w celu przechowywania innych wymaganych informacji o stanie jako członków.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1379">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="0ed15-1380">Jeśli używasz protokołu bezpołączeniowego, takiego jak UDP, nie musisz wywoływać <xref:System.Net.Sockets.Socket.ConnectAsync%2A> przed wysłaniem i odebraniem danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1380">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data.</span></span> <span data-ttu-id="0ed15-1381">Za pomocą <xref:System.Net.Sockets.Socket.SendToAsync%2A> programu i <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> można komunikować się z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1381">You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host.</span></span> <span data-ttu-id="0ed15-1382">Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, wszelkie datagramy, które dotarły do adresu innego niż określona wartość domyślna zostaną odrzucone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1382">If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="0ed15-1383">Jeśli chcesz zmienić domyślnego hosta zdalnego, wywołaj <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodę ponownie z żądanym punktem końcowym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1383">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="0ed15-1384">Jeśli chcesz ustawić domyślny host zdalny na adres emisji, musisz najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> i ustawić emisję do. `true`</span><span class="sxs-lookup"><span data-stu-id="0ed15-1384">If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="0ed15-1385">Jeśli to nie zrobisz, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Metoda <xref:System.Net.Sockets.SocketException>wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1385">If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="0ed15-1386">Wymagane są następujące właściwości i zdarzenia dotyczące <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiektu:</span><span class="sxs-lookup"><span data-stu-id="0ed15-1386">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="0ed15-1387">Opcjonalnie można dostarczyć bufor, który będzie niepodzielny w gnieździe po pomyślnym zakończeniu <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1387">Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="0ed15-1388">W tym przypadku <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> właściwość musi być ustawiona na bufor zawierający dane do wysłania, <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> a właściwość musi być ustawiona na liczbę bajtów danych do wysłania z bufora.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1388">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the number of bytes of data to send from the buffer.</span></span> <span data-ttu-id="0ed15-1389">Po nawiązaniu połączenia zostanie wysłany ten bufor danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1389">Once a connection is established, this buffer of data is sent.</span></span>  
  
 <span data-ttu-id="0ed15-1390">Jeśli używasz protokołu zorientowanego na połączenia i nie wywołuj <xref:System.Net.Sockets.Socket.Bind%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, Dostawca usługi bazowej przypisze najbardziej odpowiedni lokalny adres sieciowy i numer portu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1390">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span>  
  
 <span data-ttu-id="0ed15-1391">Jeśli używasz bezpołączeniowego protokołu, dostawca usług nie przypisze lokalnego adresu IP i numeru portu do momentu wywołania <xref:System.Net.Sockets.Socket.SendAsync%2A> metody lub. <xref:System.Net.Sockets.Socket.ReceiveAsync%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-1391">If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.</span></span>  
  
 <span data-ttu-id="0ed15-1392">Metoda zgłasza <xref:System.NotSupportedException> , czy <xref:System.Net.Sockets.Socket> Rodzinaadresówiniejesttąsamąrodzinąadresów.<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> <xref:System.Net.Sockets.Socket.ConnectAsync%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-1392">The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> are not the same address family.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1393">Jeśli podczas wywoływania tej <xref:System.Net.Sockets.SocketException> metody zostanie wyświetlony komunikat o błędzie, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1393">If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1394">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1394">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-1395">Argument jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1395">An argument is not valid.</span></span> <span data-ttu-id="0ed15-1396">Ten wyjątek występuje, jeśli określono wiele buforów, <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> właściwość nie ma wartości null.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1396">This exception occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-1397">Parametr nie może mieć wartości null <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> i nie może mieć wartości null. <paramref name="e" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-1397">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-1398">Operacja nasłuchuje lub gniazdo <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> <paramref name="e" /> <see cref="T:System.Net.Sockets.Socket" /> jest już w toku przy użyciu obiektu określonego w parametrze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1398">The <see cref="T:System.Net.Sockets.Socket" /> is listening or a socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1399">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1399">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-1400">Ta metoda wymaga systemu Windows XP lub nowszego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1400">Windows XP or later is required for this method.</span></span> <span data-ttu-id="0ed15-1401">Ten wyjątek występuje również wtedy, gdy lokalny punkt końcowy <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> i program nie mają tej samej rodziny adresów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1401">This exception also occurs if the local endpoint and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1402"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1402">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0ed15-1403">Obiekt wywołujący znajdujący się wyżej w stosie wywołań nie ma uprawnienia do żądanej operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1403">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType"><span data-ttu-id="0ed15-1404">Jedna z <see cref="T:System.Net.Sockets.SocketType" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1404">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></param>
        <param name="protocolType"><span data-ttu-id="0ed15-1405">Jedna z <see cref="T:System.Net.Sockets.ProtocolType" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1405">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></param>
        <param name="e"><span data-ttu-id="0ed15-1406">Obiekt <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> , który ma być używany dla tej asynchronicznej operacji gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1406">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="0ed15-1407">Rozpoczyna asynchroniczne żądanie połączenia z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1407">Begins an asynchronous request for a connection to a remote host.</span></span></summary>
        <returns><span data-ttu-id="0ed15-1408"><see langword="true" />Jeśli operacja we/wy jest w stanie oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1408"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="0ed15-1409"><see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie<paramref name="e" /> na parametrze zostanie wywołane po zakończeniu operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1409">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="0ed15-1410"><see langword="false" />Jeśli operacja we/wy została ukończona synchronicznie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1410"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="0ed15-1411">W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie <paramref name="e" /> na parametrze <paramref name="e" /> nie zostanie zgłoszone i obiekt przenoszony jako parametr może zostać zbadany natychmiast po wywołaniu metody, aby pobrać wynik operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1411">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1412">Jeśli używasz protokołu zorientowanego na połączenie, Metoda M:System.Net.Sockets.Socket.ConnectAsync (System .NET. Sockets. SocketType, system .NET. Sockets. ProtocolType, system .NET. Sockets. SocketAsyncEventArgs) uruchamia asynchroniczne żądanie dla połączenie z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1412">If you are using a connection-oriented protocol, the M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) method starts an asynchronous request for a connection to the remote host.</span></span> <span data-ttu-id="0ed15-1413">W przypadku korzystania z bezpołączeniowego protokołu <xref:System.Net.Sockets.Socket.ConnectAsync%2A> program ustanawia domyślny host zdalny określony `socketType` przez parametry i `protocolType` .</span><span class="sxs-lookup"><span data-stu-id="0ed15-1413">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host specified by the `socketType` and `protocolType` parameters.</span></span>  
  
 <span data-ttu-id="0ed15-1414">Aby otrzymywać powiadomienia o zakończeniu, należy utworzyć metodę wywołania zwrotnego implementującą delegata\<EventHandler SocketAsyncEventArgs > i dołączyć wywołanie zwrotne <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> do zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1414">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="0ed15-1415">Obiekt wywołujący musi ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Właściwość <xref:System.Net.IPEndPoint> na hoście zdalnym, z którym ma zostać nawiązane połączenie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1415">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.</span></span>  
  
 <span data-ttu-id="0ed15-1416">Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość na dowolny obiekt stanu użytkownika przed <xref:System.Net.Sockets.Socket.ConnectAsync%2A> wywołaniem metody, tak aby informacje były możliwe do pobierania w metodzie wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1416">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="0ed15-1417">Jeśli wywołanie zwrotne wymaga więcej informacji niż pojedynczy obiekt, można utworzyć małą klasę w celu przechowywania innych wymaganych informacji o stanie jako członków.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1417">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="0ed15-1418">Jeśli używasz protokołu bezpołączeniowego, takiego jak UDP, nie musisz wywoływać <xref:System.Net.Sockets.Socket.ConnectAsync%2A> przed wysłaniem i odebraniem danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1418">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data.</span></span> <span data-ttu-id="0ed15-1419">Za pomocą <xref:System.Net.Sockets.Socket.SendToAsync%2A> programu i <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> można komunikować się z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1419">You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host.</span></span> <span data-ttu-id="0ed15-1420">Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, wszelkie datagramy, które dotarły do adresu innego niż określona wartość domyślna zostaną odrzucone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1420">If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="0ed15-1421">Jeśli chcesz zmienić domyślnego hosta zdalnego, wywołaj <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodę ponownie z żądanym punktem końcowym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1421">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="0ed15-1422">Jeśli chcesz ustawić domyślny host zdalny na adres emisji, musisz najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> i ustawić emisję do. `true`</span><span class="sxs-lookup"><span data-stu-id="0ed15-1422">If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="0ed15-1423">Jeśli to nie zrobisz, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Metoda <xref:System.Net.Sockets.SocketException>wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1423">If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="0ed15-1424">Wymagane są następujące właściwości i zdarzenia dotyczące <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiektu:</span><span class="sxs-lookup"><span data-stu-id="0ed15-1424">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="0ed15-1425">Opcjonalnie można dostarczyć bufor, który będzie niepodzielny w gnieździe po pomyślnym zakończeniu <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1425">Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="0ed15-1426">W tym przypadku <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> właściwość musi być ustawiona na bufor zawierający dane do wysłania, <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> a właściwość musi być ustawiona na liczbę bajtów danych do wysłania z bufora.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1426">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the number of bytes of data to send from the buffer.</span></span> <span data-ttu-id="0ed15-1427">Po nawiązaniu połączenia zostanie wysłany ten bufor danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1427">Once a connection is established, this buffer of data is sent.</span></span>  
  
 <span data-ttu-id="0ed15-1428">Jeśli używasz protokołu zorientowanego na połączenia i nie wywołuj <xref:System.Net.Sockets.Socket.Bind%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, Dostawca usługi bazowej przypisze najbardziej odpowiedni lokalny adres sieciowy i numer portu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1428">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span>  
  
 <span data-ttu-id="0ed15-1429">Jeśli używasz bezpołączeniowego protokołu, dostawca usług nie przypisze lokalnego adresu IP i numeru portu do momentu wywołania <xref:System.Net.Sockets.Socket.SendAsync%2A> metody lub. <xref:System.Net.Sockets.Socket.ReceiveAsync%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-1429">If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.</span></span>  
  
 <span data-ttu-id="0ed15-1430">Metoda zgłasza <xref:System.NotSupportedException> , czy <xref:System.Net.Sockets.Socket> Rodzinaadresówiniejesttąsamąrodzinąadresów.<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> <xref:System.Net.Sockets.Socket.ConnectAsync%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-1430">The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> are not the same address family.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1431">Jeśli podczas wywoływania tej <xref:System.Net.Sockets.SocketException> metody zostanie wyświetlony komunikat o błędzie, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1431">If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1432">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1432">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-1433">Argument jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1433">An argument is not valid.</span></span> <span data-ttu-id="0ed15-1434">Ten wyjątek występuje, jeśli określono wiele buforów, <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> właściwość nie ma wartości null.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1434">This exception occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-1435">Parametr nie może mieć wartości null <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> i nie może mieć wartości null. <paramref name="e" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-1435">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-1436">Operacja nasłuchuje lub gniazdo <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> <paramref name="e" /> <see cref="T:System.Net.Sockets.Socket" /> jest już w toku przy użyciu obiektu określonego w parametrze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1436">The <see cref="T:System.Net.Sockets.Socket" /> is listening or a socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1437">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1437">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-1438">Ta metoda wymaga systemu Windows XP lub nowszego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1438">Windows XP or later is required for this method.</span></span> <span data-ttu-id="0ed15-1439">Ten wyjątek występuje również wtedy, gdy lokalny punkt końcowy <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> i program nie mają tej samej rodziny adresów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1439">This exception also occurs if the local endpoint and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1440"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1440">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0ed15-1441">Obiekt wywołujący znajdujący się wyżej w stosie wywołań nie ma uprawnienia do żądanej operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1441">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-1442">Pobiera wartość wskazującą, czy <see cref="T:System.Net.Sockets.Socket" /> jest połączony z hostem zdalnym w ramach ostatniej <see cref="Overload:System.Net.Sockets.Socket.Send" /> lub <see cref="Overload:System.Net.Sockets.Socket.Receive" /> operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1442">Gets a value that indicates whether a <see cref="T:System.Net.Sockets.Socket" /> is connected to a remote host as of the last <see cref="Overload:System.Net.Sockets.Socket.Send" /> or <see cref="Overload:System.Net.Sockets.Socket.Receive" /> operation.</span></span></summary>
        <value><span data-ttu-id="0ed15-1443"><see langword="true" />Jeśli został podłączony do zasobu zdalnego w ramach najnowszej operacji; <see langword="false" />w przeciwnym razie. <see cref="T:System.Net.Sockets.Socket" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-1443"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> was connected to a remote resource as of the most recent operation; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1444">Właściwość pobiera stan <xref:System.Net.Sockets.Socket> połączenia z ostatniej operacji we/wy. `Connected`</span><span class="sxs-lookup"><span data-stu-id="0ed15-1444">The `Connected` property gets the connection state of the <xref:System.Net.Sockets.Socket> as of the last I/O operation.</span></span> <span data-ttu-id="0ed15-1445">Gdy zwróci wartość `false` <xref:System.Net.Sockets.Socket> , nigdy nie nawiązano połączenia lub nie jest już połączony.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1445">When it returns `false`, the <xref:System.Net.Sockets.Socket> was either never connected, or is no longer connected.</span></span>  
  
 <span data-ttu-id="0ed15-1446">Wartość <xref:System.Net.Sockets.Socket.Connected%2A> właściwości odzwierciedla stan połączenia w ramach najnowszej operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1446">The value of the <xref:System.Net.Sockets.Socket.Connected%2A> property reflects the state of the connection as of the most recent operation.</span></span> <span data-ttu-id="0ed15-1447">Aby określić bieżący stan połączenia, należy wykonać nieblokujące wywołanie wysyłania bez bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1447">If you need to determine the current state of the connection, make a nonblocking, zero-byte Send call.</span></span> <span data-ttu-id="0ed15-1448">Jeśli wywołanie zwróci się pomyślnie lub zgłosi kod błędu WAEWOULDBLOCK (10035), gniazdo jest nadal połączone; w przeciwnym razie gniazdo nie jest już połączone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1448">If the call returns successfully or throws a WAEWOULDBLOCK error code (10035), then the socket is still connected; otherwise, the socket is no longer connected.</span></span>  
  
 <span data-ttu-id="0ed15-1449">Jeśli wywołasz <xref:System.Net.Sockets.Socket.Connect%2A> w gnieździe UDP (User Datagram Protocol) <xref:System.Net.Sockets.Socket.Connected%2A> , właściwość zawsze zwróci wartość `true`, jednak ta akcja nie powoduje zmiany bezpołączeniowego charakteru protokołu UDP.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1449">If you call <xref:System.Net.Sockets.Socket.Connect%2A> on a User Datagram Protocol (UDP) socket, the <xref:System.Net.Sockets.Socket.Connected%2A> property always returns `true`; however, this action does not change the inherent connectionless nature of UDP.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1450">Poniższy przykład kodu łączy się ze zdalnym punktem końcowym, sprawdza <xref:System.Net.Sockets.Socket.Connected%2A> Właściwość i sprawdza bieżący stan połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1450">The following code example connects to a remote endpoint, checks the <xref:System.Net.Sockets.Socket.Connected%2A> property, and checks the current state of the connection.</span></span>  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="reuseSocket"><span data-ttu-id="0ed15-1451"><see langword="true" />Jeśli tego gniazda można użyć ponownie po zamknięciu bieżącego połączenia; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-1451"><see langword="true" /> if this socket can be reused after the current connection is closed; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="0ed15-1452">Zamyka połączenie gniazda i umożliwia ponowne użycie gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1452">Closes the socket connection and allows reuse of the socket.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1453">Jeśli używasz protokołu zorientowanego na połączenie, możesz użyć tej metody, aby zamknąć gniazdo.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1453">If you are using a connection-oriented protocol, you can use this method to close the socket.</span></span> <span data-ttu-id="0ed15-1454">Ta metoda przerywa połączenie i ustawia <xref:System.Net.Sockets.Socket.Connected%2A> właściwość na. `false`</span><span class="sxs-lookup"><span data-stu-id="0ed15-1454">This method ends the connection and sets the <xref:System.Net.Sockets.Socket.Connected%2A> property to `false`.</span></span> <span data-ttu-id="0ed15-1455">Jeśli `reuseSocket` jednak jest to `true`możliwe, możesz ponownie użyć gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1455">However, if `reuseSocket` is `true`, you can reuse the socket.</span></span>  
  
 <span data-ttu-id="0ed15-1456">Aby upewnić się, że wszystkie dane są wysyłane i odbierane przed zamknięciem gniazda, <xref:System.Net.Sockets.Socket.Shutdown%2A> należy wywołać przed <xref:System.Net.Sockets.Socket.Disconnect%2A> wywołaniem metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1456">To ensure that all data is sent and received before the socket is closed, you should call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Disconnect%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-1457">Jeśli zachodzi konieczność <xref:System.Net.Sockets.Socket.Disconnect%2A> wywołania bez uprzedniego wywołania <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.Shutdown%2A> <xref:System.Net.Sockets.SocketOptionName.DontLinger> , można ustawić opcję na `false` i określić niezerowy limit czasu, aby upewnić się, że dane są wysyłane do kolejki transmisji wychodzącej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1457">If you need to call <xref:System.Net.Sockets.Socket.Disconnect%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can set the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specify a nonzero time-out interval to ensure that data queued for outgoing transmission is sent.</span></span> <span data-ttu-id="0ed15-1458"><xref:System.Net.Sockets.Socket.Disconnect%2A>następnie bloki do momentu wysłania danych lub aż do upływu określonego limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1458"><xref:System.Net.Sockets.Socket.Disconnect%2A> then blocks until the data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="0ed15-1459">Jeśli ustawisz <xref:System.Net.Sockets.SocketOptionName.DontLinger> `false` wartość i określisz interwał limitu czasu, program <xref:System.Net.Sockets.Socket.Close%2A> zwolni połączenie i automatycznie odrzuci wychodzące dane znajdujące się w kolejce.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1459">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1460">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1460">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1461">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1461">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1462">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1462">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1463">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1463">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1464">Poniższy przykład kodu tworzy gniazdo do komunikacji synchronicznej i wysyła niektóre dane do hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1464">The following code example creates a socket for synchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="0ed15-1465">Następnie wywołuje <xref:System.Net.Sockets.Socket.Shutdown%2A>, aby zatrzymać działanie wysyłania i odbierania, a <xref:System.Net.Sockets.Socket.Disconnect%2A>następnie zamknąć połączenie gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1465">It then calls <xref:System.Net.Sockets.Socket.Shutdown%2A>, to stop the send and receive activity, and <xref:System.Net.Sockets.Socket.Disconnect%2A>, to close the socket connection.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="0ed15-1466">Ta metoda wymaga systemu Windows 2000 lub starszego lub wyjątek zostanie wygenerowany.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1466">This method requires Windows 2000 or earlier, or the exception will be thrown.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1467"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1467">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1468">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1468">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="0ed15-1469">Obiekt <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> , który ma być używany dla tej asynchronicznej operacji gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1469">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="0ed15-1470">Rozpoczyna asynchroniczne żądanie rozłączenia ze zdalnego punktu końcowego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1470">Begins an asynchronous request to disconnect from a remote endpoint.</span></span></summary>
        <returns><span data-ttu-id="0ed15-1471"><see langword="true" />Jeśli operacja we/wy jest w stanie oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1471"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="0ed15-1472"><see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie<paramref name="e" /> na parametrze zostanie wywołane po zakończeniu operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1472">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="0ed15-1473"><see langword="false" />Jeśli operacja we/wy została ukończona synchronicznie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1473"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="0ed15-1474">W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie <paramref name="e" /> na parametrze <paramref name="e" /> nie zostanie zgłoszone i obiekt przenoszony jako parametr może zostać zbadany natychmiast po wywołaniu metody, aby pobrać wynik operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1474">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1475">W przypadku korzystania z protokołu zorientowanego na połączenia wywoływanie <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> metody powoduje odłączenie ze zdalnego punktu końcowego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1475">When using a connection-oriented protocol, calling the <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> method requests a disconnect from a remote endpoint.</span></span> <span data-ttu-id="0ed15-1476">Jeśli ustawisz <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> wartość `true` w `e` parametrze, gniazdo może być ponownie używane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1476">If you set <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> to `true` in the `e` parameter, the socket can be reused.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-1477"><paramref name="e" /> Parametr nie może mieć wartości null.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1477">The <paramref name="e" /> parameter cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-1478">Operacja gniazda była już w toku przy użyciu <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiektu określonego <paramref name="e" /> w parametrze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1478">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-1479">Ta metoda wymaga systemu Windows XP lub nowszego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1479">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1480"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1480">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1481">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1481">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ed15-1482">Zwalnia wszystkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Net.Sockets.Socket" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1482">Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0ed15-1483">Zwalnia wszystkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Net.Sockets.Socket" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1483">Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1484">Wywołaj `Dispose` po zakończeniu korzystania z <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1484">Call `Dispose` when you are finished using the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-1485">`Dispose` Metoda<xref:System.Net.Sockets.Socket> pozostawia w stanie niezdatnym do użytku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1485">The `Dispose` method leaves the <xref:System.Net.Sockets.Socket> in an unusable state.</span></span> <span data-ttu-id="0ed15-1486">Po wywołaniu `Dispose`należy wydać wszystkie odwołania <xref:System.Net.Sockets.Socket> do, aby moduł wyrzucania elementów bezużytecznych mógł odwoływać pamięć <xref:System.Net.Sockets.Socket> , którą zajmował.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1486">After calling `Dispose`, you must release all references to the <xref:System.Net.Sockets.Socket> so the garbage collector can reclaim the memory that the <xref:System.Net.Sockets.Socket> was occupying.</span></span>  
  
 <span data-ttu-id="0ed15-1487">Aby uzyskać więcej informacji, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i implementowanie [metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1487">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1488">Zawsze wywołuj `Dispose` przed wydaniem ostatniego odwołania <xref:System.Net.Sockets.Socket>do.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1488">Always call `Dispose` before you release your last reference to the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-1489">W przeciwnym razie używane zasoby nie zostaną zwolnione do momentu wywołania <xref:System.Net.Sockets.Socket> `Finalize` metody obiektu przez moduł zbierający elementy bezużyteczne.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1489">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Net.Sockets.Socket> object's `Finalize` method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="0ed15-1490"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> zwalnia tylko niezarządzane zasoby.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1490"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to releases only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="0ed15-1491">Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Net.Sockets.Socket" />program i opcjonalnie usuwa zarządzane zasoby.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1491">Releases the unmanaged resources used by the <see cref="T:System.Net.Sockets.Socket" />, and optionally disposes of the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1492">Ta metoda jest wywoływana przez metodę publiczną `Dispose()` <xref:System.Object.Finalize%2A> i metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1492">This method is called by the public `Dispose()` method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="0ed15-1493">`Dispose()`wywołuje metodę chronioną `Dispose(Boolean)` `disposing` z parametrem ustawionym `true`na.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1493">`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="0ed15-1494"><xref:System.Object.Finalize%2A>wywołuje `Dispose` `false`z `disposing` ustawionym na.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1494"><xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="0ed15-1495">Gdy parametr ma wartość `true`, ta metoda zwalnia wszystkie zasoby przechowywane przez wszystkie obiekty zarządzane, do <xref:System.Net.Sockets.Socket> których odwołują się te odwołania. `disposing`</span><span class="sxs-lookup"><span data-stu-id="0ed15-1495">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Net.Sockets.Socket> references.</span></span> <span data-ttu-id="0ed15-1496">Ta metoda wywołuje `Dispose()` metodę każdego przywoływanego obiektu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1496">This method invokes the `Dispose()` method of each referenced object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1497">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1497">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1498">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1498">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="0ed15-1499">
            <see langword="Dispose" />może być wywoływana wiele razy przez inne obiekty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1499">
            <see langword="Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="0ed15-1500">Podczas zastępowania <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />należy zachować ostrożność, aby nie odwoływać się do obiektów, które zostały wcześniej usunięte <see langword="Dispose" />w ramach wcześniejszego wywołania do.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1500">When overriding <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />.</span></span> <span data-ttu-id="0ed15-1501">Aby uzyskać więcej informacji na temat sposobu <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />implementacji, zobacz [implementowanie metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1501">For more information about how to implement <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
<span data-ttu-id="0ed15-1502">Aby uzyskać więcej informacji <see langword="Dispose" /> na <see cref="M:System.Object.Finalize" />temat i, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [Zastępowanie metody Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1502">For more information about <see langword="Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-1503">Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określającą, <see cref="T:System.Net.Sockets.Socket" /> czy mają być pofragmentowane datagramy protokołu IP.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1503">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows Internet Protocol (IP) datagrams to be fragmented.</span></span></summary>
        <value><span data-ttu-id="0ed15-1504"><see langword="true" />Jeśli zezwala <see cref="T:System.Net.Sockets.Socket" /> na fragmentację datagramów; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1504"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows datagram fragmentation; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="0ed15-1505">Wartość domyślna to <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1505">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1506">Datagramy wymagają fragmentacji, gdy ich rozmiar przekracza maksymalną jednostkę transferu (MTU) nośnika transmisji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1506">Datagrams require fragmentation when their size exceeds the Maximum Transfer Unit (MTU) of the transmission medium.</span></span> <span data-ttu-id="0ed15-1507">Wszystkie datagramy mogą być pofragmentowane przez hosta wysyłającego (wszystkie wersje protokołu internetowego) lub do pośredniego routera (tylko protokół internetowy w wersji 4).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1507">Datagrams may be fragmented by the sending host (all Internet Protocol versions) or an intermediate router (Internet Protocol Version 4 only).</span></span> <span data-ttu-id="0ed15-1508">Jeśli datagram musi być pofragmentowany, a <xref:System.Net.Sockets.Socket.DontFragment%2A> opcja jest ustawiona, datagram zostaje odrzucony, a komunikat o błędzie protokołu ICMP (Internet Control Message Protocol) zostanie wysłany z powrotem do nadawcy datagramu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1508">If a datagram must be fragmented, and the <xref:System.Net.Sockets.Socket.DontFragment%2A> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram.</span></span>  
  
 <span data-ttu-id="0ed15-1509">Ustawienie tej właściwości w gnieździe Transmission Control Protocol (TCP) nie będzie miało żadnego efektu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1509">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1510">Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.DontFragment%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1510">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.DontFragment%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-1511">Tę właściwość można ustawić tylko dla gniazd w <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> w rodzinach.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1511">This property can be set only for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1512">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1512">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1513"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1513">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-1514">Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określającą, <see cref="T:System.Net.Sockets.Socket" /> czy jest to gniazdo dwukierunkowe używane dla protokołów IPv4 i IPv6.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1514">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> is a dual-mode socket used for both IPv4 and IPv6.</span></span></summary>
        <value><span data-ttu-id="0ed15-1515"><see langword="true" />Jeśli jest to gniazdo dwutrybowe, <see langword="false" />w przeciwnym razie. <see cref="T:System.Net.Sockets.Socket" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-1515"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> is a  dual-mode socket; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="0ed15-1516">Wartość domyślna to <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1516">The default is <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="targetProcessId"><span data-ttu-id="0ed15-1517">Identyfikator procesu docelowego, w którym jest tworzone duplikaty odwołania gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1517">The ID of the target process where a duplicate of the socket reference is created.</span></span></param>
        <summary><span data-ttu-id="0ed15-1518">Duplikuje odwołanie do gniazda dla procesu docelowego i zamyka gniazdo dla tego procesu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1518">Duplicates the socket reference for the target process, and closes the socket for this process.</span></span></summary>
        <returns><span data-ttu-id="0ed15-1519">Odwołanie do gniazda, które ma zostać przesłane do procesu docelowego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1519">The socket reference to be passed to the target process.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1520">Proces docelowy powinien użyć <xref:System.Net.Sockets.Socket.%23ctor%2A> do utworzenia zduplikowanego wystąpienia gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1520">The target process should use <xref:System.Net.Sockets.Socket.%23ctor%2A> to create the duplicate socket instance.</span></span>  
  
 <span data-ttu-id="0ed15-1521">W przypadku wywołania <xref:System.Net.Sockets.Socket.%23ctor%2A> konstruktora wiele razy z tą samą tablicą bajtową, co argument dla każdego wywołania, utworzysz wiele wystąpień zarządzanych <xref:System.Net.Sockets.Socket> z tym samym gniazdem podstawowym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1521">If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket> instances with the same underlying socket.</span></span> <span data-ttu-id="0ed15-1522">Jest to zdecydowanie odradzane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1522">This practice is strongly discouraged.</span></span>  
  
 <span data-ttu-id="0ed15-1523">Jeśli proces tworzenia gniazda używa metod asynchronicznych (<xref:System.Net.Sockets.Socket.BeginReceive%2A> lub <xref:System.Net.Sockets.Socket.BeginSend%2A>), <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> proces musi najpierw ustawić właściwość na true; w przeciwnym razie gniazdo jest powiązane z portem zakończenia procesu tworzenia, co może spowodować wystąpienie <xref:System.ArgumentNullException> do zgłoszenia w procesie docelowym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1523">If the process creating the socket uses asynchronous methods (<xref:System.Net.Sockets.Socket.BeginReceive%2A> or <xref:System.Net.Sockets.Socket.BeginSend%2A>), the process must first set the <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> property to true; otherwise, the socket is bound to the completion port of the creating process, which may cause an <xref:System.ArgumentNullException> to be thrown on the target process.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1524"><paramref name="targetProcessID" />nie jest prawidłowym identyfikatorem procesu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1524"><paramref name="targetProcessID" /> is not a valid process id.</span></span> 
<span data-ttu-id="0ed15-1525">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-1525">-or-</span></span> 
<span data-ttu-id="0ed15-1526">Duplikowanie odwołania gniazda nie powiodło się.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1526">Duplication of the socket reference failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-1527">Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określającą, <see cref="T:System.Net.Sockets.Socket" /> czy można wysyłać i odbierać pakiety emisji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1527">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> can send or receive broadcast packets.</span></span></summary>
        <value><span data-ttu-id="0ed15-1528"><see langword="true" />Jeśli zezwala <see cref="T:System.Net.Sockets.Socket" /> na pakiety emisji, <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1528"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows broadcast packets; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="0ed15-1529">Wartość domyślna to <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1529">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1530">Emisja jest ograniczona do określonej podsieci i musi korzystać z protokołu UDP (User Datagram Protocol). W przypadku protokołu internetowego w wersji 4 można emitować do podsieci lokalnej, wysyłając pakiet do wersji 255.255.255.255; można też użyć adresu emisji kierowanej, który jest częścią sieci adresu IP, ze wszystkimi bitami ustawionymi w części hosta.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1530">Broadcasting is limited to a specific subnet, and must use User Datagram Protocol (UDP.) For Internet Protocol version 4, you can broadcast to your local subnet by sending a packet to 255.255.255.255; or you can use the directed broadcast address, which is the network portion of an Internet Protocol (IP) address with all bits set in the host portion.</span></span> <span data-ttu-id="0ed15-1531">Na przykład, jeśli adres IP to 192.168.1.40 (adres klasy C, z maską sieci 255.255.255.0) — część sieciowa to pierwsze trzy oktety, a część hosta jest ostatnim oktetem), kierowany adres emisji to 192.168.1.255.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1531">For example, if your IP address is 192.168.1.40 (a Class C address, with a netmask of 255.255.255.0 -- the network portion is the first three octets, and the host portion is the last octet), your directed broadcast address is 192.168.1.255.</span></span>  
  
 <span data-ttu-id="0ed15-1532">Ustawienie tej właściwości w gnieździe Transmission Control Protocol (TCP) nie będzie miało żadnego efektu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1532">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1533">Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1533">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1534">Ta opcja jest prawidłowa tylko dla gniazda datagram.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1534">This option is valid for a datagram socket only.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1535"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1535">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ed15-1536">Asynchronicznie akceptuje próbę połączenia przychodzącego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1536">Asynchronously accepts an incoming connection attempt.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-1537">Tablica typu <see cref="T:System.Byte" /> zawierającego Bajty przesłane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1537">An array of type <see cref="T:System.Byte" /> that contains the bytes transferred.</span></span></param>
        <param name="asyncResult"><span data-ttu-id="0ed15-1538"><see cref="T:System.IAsyncResult" /> Obiekt, który przechowuje informacje o stanie dla tej operacji asynchronicznej, a także wszystkie dane zdefiniowane przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1538">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <summary><span data-ttu-id="0ed15-1539">Asynchronicznie akceptuje próbę połączenia przychodzącego i tworzy <see cref="T:System.Net.Sockets.Socket" /> nowy obiekt do obsługi komunikacji z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1539">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> object to handle remote host communication.</span></span> <span data-ttu-id="0ed15-1540">Ta metoda zwraca bufor zawierający dane wstępne przesłane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1540">This method returns a buffer that contains the initial data transferred.</span></span></summary>
        <returns><span data-ttu-id="0ed15-1541"><see cref="T:System.Net.Sockets.Socket" /> Obiekt obsługujący komunikację z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1541">A <see cref="T:System.Net.Sockets.Socket" /> object to handle communication with the remote host.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1542"><xref:System.Net.Sockets.Socket.EndAccept%2A>kończy wywołanie metody <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1542"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="0ed15-1543">Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginAccept%2A>należy utworzyć metodę wywołania zwrotnego, która jest wywoływana <xref:System.AsyncCallback> przez delegata.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1543">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="0ed15-1544">Ta metoda wywołania zwrotnego jest wykonywana w osobnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginAccept%2A> powrocie metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1544">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span>  
  
 <span data-ttu-id="0ed15-1545">W metodzie wywołania zwrotnego Wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę `asyncResult` parametru, aby uzyskać, <xref:System.Net.Sockets.Socket> na którym nastąpiło próba połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1545">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="0ed15-1546">Po uzyskaniu <xref:System.Net.Sockets.Socket>można <xref:System.Net.Sockets.Socket.EndAccept%2A> wywołać metodę, aby pomyślnie zakończyć próbę połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1546">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span> <span data-ttu-id="0ed15-1547">Parametr tego przeciążenia zawiera dane odebrane w <xref:System.Net.Sockets.Socket.BeginAccept%2A> wywołaniu metody, a `bytesTransferred` parametr zawiera liczbę bajtów przesłanych w wywołaniu. `buffer`</span><span class="sxs-lookup"><span data-stu-id="0ed15-1547">The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.</span></span>  
  
 <span data-ttu-id="0ed15-1548"><xref:System.Net.Sockets.Socket.EndAccept%2A> Metoda blokuje się do momentu oczekiwania połączenia w kolejce połączeń przychodzących.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1548">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="0ed15-1549">Metoda akceptuje połączenie przychodzące i zwraca nową <xref:System.Net.Sockets.Socket> , która może być używana do wysyłania danych do i odbierania danych z hosta zdalnego. <xref:System.Net.Sockets.Socket.EndAccept%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-1549">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1550">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1550">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1551">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1551">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1552">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1552">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1553">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1553">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1554">Poniższy przykład kodu używa <xref:System.Net.Sockets.Socket.BeginAccept%2A> do tworzenia i łączenia gniazda i akceptowania pierwszych 10 bajtów danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1554">The following code example uses <xref:System.Net.Sockets.Socket.BeginAccept%2A> to create and connect a socket and accept the initial 10 bytes of data.</span></span> <span data-ttu-id="0ed15-1555">Delegat <xref:System.Net.Sockets.Socket.EndAccept%2A> wywołania zwrotnego zakończył asynchroniczne żądanie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1555">The callback delegate calls <xref:System.Net.Sockets.Socket.EndAccept%2A> to end the asynchronous request.</span></span> <span data-ttu-id="0ed15-1556">Liczba przesłanych bajtów i dane są zwracane w `buffer` parametrach i `bytesTransferred` w tej metodzie i są wyświetlane w konsoli programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1556">The number of bytes transmitted and the data are returned in the `buffer` and `bytesTransferred` parameters of this method and are displayed on the console.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-1557">Dla tej metody wymagany jest system Windows NT.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1557">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1558"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1558">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-1559"><paramref name="asyncResult" />jest puste.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1559"><paramref name="asyncResult" /> is empty.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-1560"><paramref name="asyncResult" />nie został utworzony przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1560"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-1561"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />Metoda została wcześniej wywołana.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1561"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1562">Wystąpił błąd podczas próby uzyskania dostępu do<see cref="T:System.Net.Sockets.Socket" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-1562">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" /></span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="0ed15-1563"><see cref="T:System.IAsyncResult" /> Przechowuje informacje o stanie dla tej operacji asynchronicznej, a także wszystkie dane zdefiniowane przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1563">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <param name="result"><span data-ttu-id="0ed15-1564"><see cref="T:System.IAsyncResult" /> Przechowuje informacje o stanie dla tej operacji asynchronicznej, a także wszystkie dane zdefiniowane przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1564">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <summary><span data-ttu-id="0ed15-1565">Asynchronicznie akceptuje próbę połączenia przychodzącego i tworzy <see cref="T:System.Net.Sockets.Socket" /> nową do obsługi komunikacji z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1565">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> to handle remote host communication.</span></span></summary>
        <returns><span data-ttu-id="0ed15-1566">A <see cref="T:System.Net.Sockets.Socket" /> do obsługi komunikacji z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1566">A <see cref="T:System.Net.Sockets.Socket" /> to handle communication with the remote host.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1567"><xref:System.Net.Sockets.Socket.EndAccept%2A>kończy wywołanie metody <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1567"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="0ed15-1568">Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginAccept%2A>należy utworzyć metodę wywołania zwrotnego <xref:System.AsyncCallback> implementującą delegata.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1568">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="0ed15-1569">Ta metoda wywołania zwrotnego jest wykonywana w osobnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginAccept%2A> powrocie metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1569">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span> <span data-ttu-id="0ed15-1570">Musi akceptować `asyncResult` parametr zwracany <xref:System.Net.Sockets.Socket.BeginAccept%2A> przez metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1570">It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-1571">W metodzie wywołania zwrotnego Wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę `asyncResult` parametru, aby uzyskać, <xref:System.Net.Sockets.Socket> na którym nastąpiło próba połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1571">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="0ed15-1572">Po uzyskaniu <xref:System.Net.Sockets.Socket>można <xref:System.Net.Sockets.Socket.EndAccept%2A> wywołać metodę, aby pomyślnie zakończyć próbę połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1572">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span>  
  
 <span data-ttu-id="0ed15-1573"><xref:System.Net.Sockets.Socket.EndAccept%2A> Metoda blokuje się do momentu oczekiwania połączenia w kolejce połączeń przychodzących.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1573">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="0ed15-1574">Metoda akceptuje połączenie przychodzące i zwraca nową <xref:System.Net.Sockets.Socket> , która może być używana do wysyłania danych do i odbierania danych z hosta zdalnego. <xref:System.Net.Sockets.Socket.EndAccept%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-1574">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1575">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1575">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1576">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1576">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1577">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1577">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1578">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1578">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1579">Poniższy przykład kodu zamyka żądanie asynchroniczne i tworzy nowy <xref:System.Net.Sockets.Socket> , aby zaakceptować żądanie połączenia przychodzącego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1579">The following code example ends an asynchronous request and creates a new <xref:System.Net.Sockets.Socket> to accept an incoming connection request.</span></span> <span data-ttu-id="0ed15-1580">Aby zapoznać się z kompletnym przykładem, który pokazuje asynchroniczne komunikację z gniazdami, zobacz [przykłady kodu gniazda](~/docs/framework/network-programming/socket-code-examples.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1580">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-1581"><paramref name="asyncResult" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1581"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-1582"><paramref name="asyncResult" />nie został utworzony przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1582"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1583">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1583">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="0ed15-1584">Zobacz sekcję Spostrzeżenia, aby uzyskać więcej informacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1584">See the Remarks section for more information.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1585"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1585">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-1586"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />Metoda została wcześniej wywołana.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1586"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-1587">Dla tej metody wymagany jest system Windows NT.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1587">Windows NT is required for this method.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  *  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bytesTransferred" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-1588">Tablica typu <see cref="T:System.Byte" /> zawierającego Bajty przesłane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1588">An array of type <see cref="T:System.Byte" /> that contains the bytes transferred.</span></span></param>
        <param name="bytesTransferred"><span data-ttu-id="0ed15-1589">Liczba bajtów przesłanych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1589">The number of bytes transferred.</span></span></param>
        <param name="asyncResult"><span data-ttu-id="0ed15-1590"><see cref="T:System.IAsyncResult" /> Obiekt, który przechowuje informacje o stanie dla tej operacji asynchronicznej, a także wszystkie dane zdefiniowane przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1590">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <summary><span data-ttu-id="0ed15-1591">Asynchronicznie akceptuje próbę połączenia przychodzącego i tworzy <see cref="T:System.Net.Sockets.Socket" /> nowy obiekt do obsługi komunikacji z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1591">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> object to handle remote host communication.</span></span> <span data-ttu-id="0ed15-1592">Ta metoda zwraca bufor zawierający dane początkowe oraz liczbę przesłanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1592">This method returns a buffer that contains the initial data and the number of bytes transferred.</span></span></summary>
        <returns><span data-ttu-id="0ed15-1593"><see cref="T:System.Net.Sockets.Socket" /> Obiekt obsługujący komunikację z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1593">A <see cref="T:System.Net.Sockets.Socket" /> object to handle communication with the remote host.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1594"><xref:System.Net.Sockets.Socket.EndAccept%2A>kończy wywołanie metody <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1594"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="0ed15-1595">Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginAccept%2A>należy utworzyć metodę wywołania zwrotnego, która jest wywoływana <xref:System.AsyncCallback> przez delegata.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1595">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="0ed15-1596">Ta metoda wywołania zwrotnego jest wykonywana w osobnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginAccept%2A> powrocie metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1596">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span> <span data-ttu-id="0ed15-1597">Musi akceptować `asyncResult` parametr zwracany <xref:System.Net.Sockets.Socket.BeginAccept%2A> przez metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1597">It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-1598">W metodzie wywołania zwrotnego Wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę `asyncResult` parametru, aby uzyskać, <xref:System.Net.Sockets.Socket> na którym nastąpiło próba połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1598">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="0ed15-1599">Po uzyskaniu <xref:System.Net.Sockets.Socket>można <xref:System.Net.Sockets.Socket.EndAccept%2A> wywołać metodę, aby pomyślnie zakończyć próbę połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1599">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span> <span data-ttu-id="0ed15-1600">Parametr tego przeciążenia zawiera dane odebrane w <xref:System.Net.Sockets.Socket.BeginAccept%2A> wywołaniu metody, a `bytesTransferred` parametr zawiera liczbę bajtów przesłanych w wywołaniu. `buffer`</span><span class="sxs-lookup"><span data-stu-id="0ed15-1600">The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.</span></span>  
  
 <span data-ttu-id="0ed15-1601"><xref:System.Net.Sockets.Socket.EndAccept%2A> Metoda blokuje się do momentu oczekiwania połączenia w kolejce połączeń przychodzących.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1601">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="0ed15-1602">Metoda akceptuje połączenie przychodzące i zwraca nową <xref:System.Net.Sockets.Socket> , która może być używana do wysyłania danych do i odbierania danych z hosta zdalnego. <xref:System.Net.Sockets.Socket.EndAccept%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-1602">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1603">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1603">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1604">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1604">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1605">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1605">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1606">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1606">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1607">Poniższy przykład kodu używa <xref:System.Net.Sockets.Socket.BeginAccept%2A> do tworzenia i łączenia gniazda i akceptowania pierwszych 10 bajtów danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1607">The following code example uses <xref:System.Net.Sockets.Socket.BeginAccept%2A> to create and connect a socket and accept the initial 10 bytes of data.</span></span> <span data-ttu-id="0ed15-1608">Delegat <xref:System.Net.Sockets.Socket.EndAccept%2A> wywołania zwrotnego zakończył asynchroniczne żądanie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1608">The callback delegate calls <xref:System.Net.Sockets.Socket.EndAccept%2A> to end the asynchronous request.</span></span> <span data-ttu-id="0ed15-1609">Liczba przesłanych bajtów i dane są zwracane w `buffer` parametrach i `bytesTransferred` w tej metodzie i są wyświetlane w konsoli programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1609">The number of bytes transmitted and the data are returned in the `buffer` and `bytesTransferred` parameters of this method and are displayed on the console.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-1610">Dla tej metody wymagany jest system Windows NT.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1610">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1611"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1611">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-1612"><paramref name="asyncResult" />jest puste.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1612"><paramref name="asyncResult" /> is empty.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-1613"><paramref name="asyncResult" />nie został utworzony przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1613"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-1614"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />Metoda została wcześniej wywołana.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1614"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1615">Wystąpił błąd podczas próby uzyskania dostępu <see cref="T:System.Net.Sockets.Socket" />do elementu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1615">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="0ed15-1616"><see cref="T:System.IAsyncResult" /> Przechowujące informacje o stanie i wszystkie dane zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1616">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="0ed15-1617"><see cref="T:System.IAsyncResult" /> Przechowujące informacje o stanie i wszystkie dane zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1617">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="0ed15-1618">Zakończenie oczekiwania na asynchroniczne żądanie połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1618">Ends a pending asynchronous connection request.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1619"><xref:System.Net.Sockets.Socket.EndConnect%2A>to metoda blokująca, która kończy asynchroniczne żądanie połączenia zdalnego hosta uruchomione w <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodzie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1619"><xref:System.Net.Sockets.Socket.EndConnect%2A> is a blocking method that completes the asynchronous remote host connection request started in the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-1620">Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginConnect%2A>należy utworzyć metodę wywołania zwrotnego <xref:System.AsyncCallback> implementującą delegata.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1620">Before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="0ed15-1621">Ta metoda wywołania zwrotnego jest wykonywana w osobnym wątku i jest wywoływana przez system <xref:System.Net.Sockets.Socket.BeginConnect%2A> po powrocie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1621">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginConnect%2A> returns.</span></span> <span data-ttu-id="0ed15-1622">Metoda wywołania zwrotnego musi akceptować <xref:System.IAsyncResult> zwrócone <xref:System.Net.Sockets.Socket.BeginConnect%2A> przez metodę jako parametr.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1622">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="0ed15-1623">W metodzie wywołania zwrotnego Wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę <xref:System.IAsyncResult> parametru, aby uzyskać, <xref:System.Net.Sockets.Socket> na którym nastąpiło próba połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1623">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="0ed15-1624">Po uzyskaniu <xref:System.Net.Sockets.Socket>można <xref:System.Net.Sockets.Socket.EndConnect%2A> wywołać metodę, aby pomyślnie zakończyć próbę połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1624">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndConnect%2A> method to successfully complete the connection attempt.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1625">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1625">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1626">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1626">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1627">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1627">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1628">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1628">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1629">Poniższy przykład kodu przerywa próbę połączenia asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1629">The following code example ends the asynchronous connection attempt.</span></span> <span data-ttu-id="0ed15-1630">Aby zapoznać się z kompletnym przykładem, który pokazuje asynchroniczne komunikację z gniazdami, zobacz [przykłady kodu gniazda](~/docs/framework/network-programming/socket-code-examples.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1630">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-1631"><paramref name="asyncResult" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1631"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-1632"><paramref name="asyncResult" />nie został zwrócony przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1632"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-1633"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />zostało wcześniej wywołane dla połączenia asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1633"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> was previously called for the asynchronous connection.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1634">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1634">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1635"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1635">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="0ed15-1636"><see cref="T:System.IAsyncResult" /> Obiekt, który przechowuje informacje o stanie i wszystkie dane zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1636">An <see cref="T:System.IAsyncResult" /> object that stores state information and any user-defined data for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="0ed15-1637">Przerywa oczekujące asynchroniczne żądanie rozłączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1637">Ends a pending asynchronous disconnect request.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1638"><xref:System.Net.Sockets.Socket.EndDisconnect%2A>kończy wywołanie metody <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1638"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>.</span></span> <span data-ttu-id="0ed15-1639"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> Metoda blokuje się do momentu zakończenia rozłączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1639">The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the disconnect completes.</span></span> <span data-ttu-id="0ed15-1640">Aby uzyskać informacje o operacjach asynchronicznych, zobacz temat Omówienie programowania asynchronicznego w bibliotece MSDN.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1640">For information about asynchronous operations, see the Asynchronous Programming Overview topic in the MSDN library.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1641">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1641">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1642">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1642">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1643">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1643">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1644">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1644">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1645">Poniższy przykład kodu tworzy gniazdo do komunikacji asynchronicznej i wysyła niektóre dane do hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1645">The following code example creates a socket for asynchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="0ed15-1646">Po wysłaniu dane są wywoływane, <xref:System.Net.Sockets.Socket.Shutdown%2A> aby zatrzymać działanie wysyłania i odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1646">When the data has been sent, <xref:System.Net.Sockets.Socket.Shutdown%2A> is called to stop the send and receive activity.</span></span> <span data-ttu-id="0ed15-1647">Następnie <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> jest wywoływana w celu rozpoczęcia żądania rozłączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1647">Then <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> is called to begin a disconnect request.</span></span> <span data-ttu-id="0ed15-1648">Delegat <xref:System.Net.Sockets.Socket.EndDisconnect%2A> wywołania zwrotnego zakończył asynchroniczne żądanie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1648">The callback delegate calls <xref:System.Net.Sockets.Socket.EndDisconnect%2A> to end the asynchronous request.</span></span> <span data-ttu-id="0ed15-1649">Po zakończeniu żądania <xref:System.Net.Sockets.Socket.Connected%2A> właściwość zostanie zbadana, aby sprawdzić, czy gniazdo jest odłączone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1649">When the request completes, the <xref:System.Net.Sockets.Socket.Connected%2A> property is queried to test whether the socket is disconnected.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-1650">System operacyjny to Windows 2000 lub starszy, a ta metoda wymaga systemu Windows XP.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1650">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1651"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1651">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-1652"><paramref name="asyncResult" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1652"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-1653"><paramref name="asyncResult" />nie został zwrócony przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1653"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-1654"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />zostało wcześniej wywołane dla połączenia asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1654"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> was previously called for the asynchronous connection.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1655">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1655">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.Net.WebException"><span data-ttu-id="0ed15-1656">Upłynął limit czasu żądania rozłączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1656">The disconnect request has timed out.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ed15-1657">Zakończenie oczekiwania na odczyt asynchroniczny.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1657">Ends a pending asynchronous read.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="0ed15-1658"><see cref="T:System.IAsyncResult" /> Przechowujące informacje o stanie i wszystkie dane zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1658">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="0ed15-1659"><see cref="T:System.IAsyncResult" /> Przechowujące informacje o stanie i wszystkie dane zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1659">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="0ed15-1660">Zakończenie oczekiwania na odczyt asynchroniczny.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1660">Ends a pending asynchronous read.</span></span></summary>
        <returns><span data-ttu-id="0ed15-1661">Liczba odebranych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1661">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1662">Metoda kończy asynchroniczne operacje odczytu rozpoczęte <xref:System.Net.Sockets.Socket.BeginReceive%2A> w metodzie. <xref:System.Net.Sockets.Socket.EndReceive%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-1662">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-1663">Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginReceive%2A>należy utworzyć metodę wywołania zwrotnego <xref:System.AsyncCallback> implementującą delegata.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1663">Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="0ed15-1664">Ta metoda wywołania zwrotnego jest wykonywana w osobnym wątku i jest wywoływana przez system <xref:System.Net.Sockets.Socket.BeginReceive%2A> po powrocie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1664">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="0ed15-1665">Metoda wywołania zwrotnego musi akceptować <xref:System.IAsyncResult> zwrócone <xref:System.Net.Sockets.Socket.BeginReceive%2A> przez metodę jako parametr.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1665">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="0ed15-1666">W metodzie wywołania zwrotnego Wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę <xref:System.IAsyncResult> , aby uzyskać obiekt <xref:System.Net.Sockets.Socket.BeginReceive%2A> stanu przekazaną do metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1666">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="0ed15-1667">Wyodrębnij odebranie <xref:System.Net.Sockets.Socket> z tego obiektu stanu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1667">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="0ed15-1668">Po uzyskaniu <xref:System.Net.Sockets.Socket>można <xref:System.Net.Sockets.Socket.EndReceive%2A> wywołać metodę, aby pomyślnie zakończyć operację odczytu i zwrócić liczbę odczytanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1668">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="0ed15-1669"><xref:System.Net.Sockets.Socket.EndReceive%2A> Metoda zostanie zablokowana do momentu udostępnienia danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1669">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available.</span></span> <span data-ttu-id="0ed15-1670">W przypadku korzystania z bezpołączeniowego protokołu <xref:System.Net.Sockets.Socket.EndReceive%2A> program odczytaje pierwszy znajdujący się w kolejce datagram dostępny w buforze sieci przychodzącej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1670">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="0ed15-1671">Jeśli używasz protokołu zorientowanego na połączenie, <xref:System.Net.Sockets.Socket.EndReceive%2A> Metoda odczyta tyle danych, ile jest dostępnych do liczby bajtów określonych `size` w parametrze <xref:System.Net.Sockets.Socket.BeginReceive%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1671">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="0ed15-1672">Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.EndReceive%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1672">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="0ed15-1673">Aby uzyskać odebrane dane, wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę <xref:System.IAsyncResult>i Wyodrębnij bufor zawarty w obiekcie stanu wyników.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1673">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.</span></span>  
  
 <span data-ttu-id="0ed15-1674">Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceive%2A>, <xref:System.Net.Sockets.Socket.Close%2A> Wywołaj metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1674">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1675">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1675">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1676">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1676">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1677">Wszystkie we/wy zainicjowane przez dany wątek zostało anulowane po zakończeniu tego wątku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1677">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="0ed15-1678">Oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek zostanie zakończony przed ukończeniem operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1678">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1679">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1679">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1680">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1680">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1681">Poniższy przykład kodu kończący oczekujący odczyt asynchroniczny.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1681">The following code example ends a pending asynchronous read.</span></span> <span data-ttu-id="0ed15-1682">Aby zapoznać się z kompletnym przykładem, który pokazuje asynchroniczne komunikację z gniazdami, zobacz [przykłady kodu gniazda](~/docs/framework/network-programming/socket-code-examples.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1682">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-1683"><paramref name="asyncResult" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1683"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-1684"><paramref name="asyncResult" />nie został zwrócony przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1684"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-1685"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />zostało wcześniej wywołane dla odczytu asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1685"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1686">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1686">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1687"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1687">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult *  -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="0ed15-1688"><see cref="T:System.IAsyncResult" /> Przechowujące informacje o stanie i wszystkie dane zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1688">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="errorCode"><span data-ttu-id="0ed15-1689"><see cref="T:System.Net.Sockets.SocketError" /> Obiekt, który przechowuje błąd gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1689">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="0ed15-1690">Zakończenie oczekiwania na odczyt asynchroniczny.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1690">Ends a pending asynchronous read.</span></span></summary>
        <returns><span data-ttu-id="0ed15-1691">Liczba odebranych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1691">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1692">Metoda kończy asynchroniczne operacje odczytu rozpoczęte <xref:System.Net.Sockets.Socket.BeginReceive%2A> w metodzie. <xref:System.Net.Sockets.Socket.EndReceive%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-1692">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-1693">Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginReceive%2A>należy utworzyć metodę wywołania zwrotnego <xref:System.AsyncCallback> implementującą delegata.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1693">Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="0ed15-1694">Ta metoda wywołania zwrotnego jest wykonywana w osobnym wątku i jest wywoływana przez system <xref:System.Net.Sockets.Socket.BeginReceive%2A> po powrocie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1694">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="0ed15-1695">Metoda wywołania zwrotnego musi akceptować <xref:System.IAsyncResult> zwrócone <xref:System.Net.Sockets.Socket.BeginReceive%2A> przez metodę jako parametr.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1695">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="0ed15-1696">W metodzie wywołania zwrotnego Wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę <xref:System.IAsyncResult> , aby uzyskać obiekt <xref:System.Net.Sockets.Socket.BeginReceive%2A> stanu przekazaną do metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1696">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="0ed15-1697">Wyodrębnij odebranie <xref:System.Net.Sockets.Socket> z tego obiektu stanu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1697">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="0ed15-1698">Po uzyskaniu <xref:System.Net.Sockets.Socket>można <xref:System.Net.Sockets.Socket.EndReceive%2A> wywołać metodę, aby pomyślnie zakończyć operację odczytu i zwrócić liczbę odczytanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1698">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="0ed15-1699"><xref:System.Net.Sockets.Socket.EndReceive%2A> Metoda zostanie zablokowana do momentu udostępnienia danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1699">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available.</span></span> <span data-ttu-id="0ed15-1700">W przypadku korzystania z bezpołączeniowego protokołu <xref:System.Net.Sockets.Socket.EndReceive%2A> program odczytaje pierwszy znajdujący się w kolejce datagram dostępny w buforze sieci przychodzącej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1700">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="0ed15-1701">Jeśli używasz protokołu zorientowanego na połączenie, <xref:System.Net.Sockets.Socket.EndReceive%2A> Metoda odczyta tyle danych, ile jest dostępnych do liczby bajtów określonych `size` w parametrze <xref:System.Net.Sockets.Socket.BeginReceive%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1701">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="0ed15-1702">Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.EndReceive%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1702">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="0ed15-1703">Aby uzyskać odebrane dane, wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę <xref:System.IAsyncResult>i Wyodrębnij bufor zawarty w obiekcie stanu wyników.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1703">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1704">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1704">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1705">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1705">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1706">Wszystkie we/wy zainicjowane przez dany wątek zostało anulowane po zakończeniu tego wątku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1706">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="0ed15-1707">Oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek zostanie zakończony przed ukończeniem operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1707">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1708">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1708">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1709">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1709">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-1710"><paramref name="asyncResult" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1710"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-1711"><paramref name="asyncResult" />nie został zwrócony przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1711"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-1712"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />zostało wcześniej wywołane dla odczytu asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1712"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1713">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1713">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1714"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1714">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult *  -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="0ed15-1715"><see cref="T:System.IAsyncResult" /> Przechowujące informacje o stanie i wszystkie dane zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1715">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="0ed15-1716"><see cref="T:System.IAsyncResult" /> Przechowujące informacje o stanie i wszystkie dane zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1716">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="endPoint"><span data-ttu-id="0ed15-1717">Źródło <see cref="T:System.Net.EndPoint" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1717">The source <see cref="T:System.Net.EndPoint" />.</span></span></param>
        <param name="end_point"><span data-ttu-id="0ed15-1718">Źródło <see cref="T:System.Net.EndPoint" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1718">The source <see cref="T:System.Net.EndPoint" />.</span></span></param>
        <summary><span data-ttu-id="0ed15-1719">Zamyka oczekujące asynchroniczne odczyt z określonego punktu końcowego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1719">Ends a pending asynchronous read from a specific endpoint.</span></span></summary>
        <returns><span data-ttu-id="0ed15-1720">Jeśli to się powiedzie, liczba odebranych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1720">If successful, the number of bytes received.</span></span> <span data-ttu-id="0ed15-1721">Jeśli nie powiedzie się, zwraca wartość 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1721">If unsuccessful, returns 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1722">Metoda kończy asynchroniczne operacje odczytu rozpoczęte <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> w metodzie. <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-1722">The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-1723">Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>należy utworzyć metodę wywołania zwrotnego <xref:System.AsyncCallback> implementującą delegata.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1723">Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="0ed15-1724">Ta metoda wywołania zwrotnego jest wykonywana w osobnym wątku i jest wywoływana przez system <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> po powrocie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1724">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> returns.</span></span> <span data-ttu-id="0ed15-1725">Metoda wywołania zwrotnego musi akceptować <xref:System.IAsyncResult> zwrócone <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> przez metodę jako parametr.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1725">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="0ed15-1726">W metodzie wywołania zwrotnego Wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę <xref:System.IAsyncResult> , aby uzyskać obiekt <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> stanu przekazaną do metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1726">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="0ed15-1727">Wyodrębnij odebranie <xref:System.Net.Sockets.Socket> z tego obiektu stanu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1727">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="0ed15-1728">Po uzyskaniu <xref:System.Net.Sockets.Socket>można <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> wywołać metodę, aby pomyślnie zakończyć operację odczytu i zwrócić liczbę odczytanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1728">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="0ed15-1729"><xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Metoda zostanie zablokowana do momentu udostępnienia danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1729">The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="0ed15-1730">W przypadku korzystania z bezpołączeniowego protokołu <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> program odczytaje pierwszy znajdujący się w kolejce datagram dostępny w buforze sieci przychodzącej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1730">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="0ed15-1731">Jeśli używasz protokołu zorientowanego na połączenie, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Metoda odczyta tyle danych, ile jest dostępnych do liczby bajtów określonych `size` w parametrze <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1731">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="0ed15-1732">Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1732">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span> <span data-ttu-id="0ed15-1733">Aby uzyskać odebrane dane, wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę <xref:System.IAsyncResult> obiektu i Wyodrębnij bufor zawarty w obiekcie stanu wyników.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1733">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> object, and extract the buffer contained in the resulting state object.</span></span> <span data-ttu-id="0ed15-1734">Aby zidentyfikować hosta źródłowego, Wyodrębnij <xref:System.Net.EndPoint> go i przerzutj <xref:System.Net.IPEndPoint>na.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1734">To identify the originating host, extract the <xref:System.Net.EndPoint> and cast it to an <xref:System.Net.IPEndPoint>.</span></span> <span data-ttu-id="0ed15-1735">Użyj metody, aby uzyskać adres IP <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> i metodę w celu uzyskania numeru portu. <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0ed15-1735">Use the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to obtain the IP address and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to obtain the port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1736">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1736">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1737">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1737">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1738">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1738">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1739">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1739">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1740">Poniższy przykład kodu zamyka oczekujące asynchroniczne odczyt z określonego <xref:System.Net.EndPoint>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1740">The following code example ends a pending asynchronous read from a specific <xref:System.Net.EndPoint>.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-1741"><paramref name="asyncResult" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1741"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-1742"><paramref name="asyncResult" />nie został zwrócony przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1742"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-1743"><see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />zostało wcześniej wywołane dla odczytu asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1743"><see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1744">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1744">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1745"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1745">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult *  *  *  -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="0ed15-1746"><see cref="T:System.IAsyncResult" /> Przechowujące informacje o stanie i wszystkie dane zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1746">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-1747">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości dla odebranego pakietu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1747">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values for the received packet.</span></span></param>
        <param name="endPoint"><span data-ttu-id="0ed15-1748">Źródło <see cref="T:System.Net.EndPoint" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1748">The source <see cref="T:System.Net.EndPoint" />.</span></span></param>
        <param name="ipPacketInformation"><span data-ttu-id="0ed15-1749">Interfejs <see cref="T:System.Net.IPAddress" /> i odebrany pakiet.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1749">The <see cref="T:System.Net.IPAddress" /> and interface of the received packet.</span></span></param>
        <summary><span data-ttu-id="0ed15-1750">Zamyka oczekujące asynchroniczne odczyt z określonego punktu końcowego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1750">Ends a pending asynchronous read from a specific endpoint.</span></span> <span data-ttu-id="0ed15-1751">Ta metoda ujawnia również więcej informacji na temat pakietu niż <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1751">This method also reveals more information about the packet than <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-1752">Jeśli to się powiedzie, liczba odebranych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1752">If successful, the number of bytes received.</span></span> <span data-ttu-id="0ed15-1753">Jeśli nie powiedzie się, zwraca wartość 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1753">If unsuccessful, returns 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1754">Jeśli operacja nie została ukończona, ta metoda jest blokowana, dopóki nie zostanie wykonana.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1754">If the operation has not completed, this method blocks until it does.</span></span>  
  
 <span data-ttu-id="0ed15-1755">Aby wykonać tę operację synchronicznie, użyj <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1755">To perform this operation synchronously, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-1756">Sprawdź `ipPacketInformation` , czy musisz wiedzieć, czy datagram został wysłany przy użyciu adresu emisji pojedynczej, multiemisji lub emisji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1756">Examine `ipPacketInformation` if you need to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-1757"><paramref name="asyncResult" />była<see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-1757"><paramref name="asyncResult" /> is <see langword="null" /></span></span>  
  
<span data-ttu-id="0ed15-1758">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-1758">-or-</span></span> 
 <span data-ttu-id="0ed15-1759"><paramref name="endPoint" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1759"><paramref name="endPoint" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-1760"><paramref name="asyncResult" />nie został zwrócony przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1760"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-1761"><see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />zostało wcześniej wywołane dla odczytu asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1761"><see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1762">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1762">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1763"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1763">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ed15-1764">Zakończenie oczekiwania na wysłanie asynchroniczne.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1764">Ends a pending asynchronous send.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="0ed15-1765"><see cref="T:System.IAsyncResult" /> Przechowujący informacje o stanie dla tej operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1765">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="0ed15-1766"><see cref="T:System.IAsyncResult" /> Przechowujący informacje o stanie dla tej operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1766">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="0ed15-1767">Zakończenie oczekiwania na wysłanie asynchroniczne.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1767">Ends a pending asynchronous send.</span></span></summary>
        <returns><span data-ttu-id="0ed15-1768">Jeśli to się powiedzie, liczba bajtów wysłanych <see cref="T:System.Net.Sockets.Socket" />do; w przeciwnym razie <see cref="T:System.Net.Sockets.Socket" /> , nieprawidłowy błąd.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1768">If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1769"><xref:System.Net.Sockets.Socket.EndSend%2A>kończy asynchroniczne operacje wysyłania rozpoczęte w <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1769"><xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span></span>  
  
 <span data-ttu-id="0ed15-1770">Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSend%2A>należy utworzyć metodę wywołania zwrotnego <xref:System.AsyncCallback> implementującą delegata.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1770">Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="0ed15-1771">Ta metoda wywołania zwrotnego jest wykonywana w osobnym wątku i jest wywoływana przez system <xref:System.Net.Sockets.Socket.BeginSend%2A> po powrocie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1771">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns.</span></span> <span data-ttu-id="0ed15-1772">Metoda wywołania zwrotnego musi akceptować <xref:System.IAsyncResult> zwrócone <xref:System.Net.Sockets.Socket.BeginSend%2A> przez metodę jako parametr.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1772">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="0ed15-1773">W metodzie wywołania zwrotnego Wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę <xref:System.IAsyncResult> parametru, aby uzyskać wysyłanie <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1773">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-1774">Po uzyskaniu <xref:System.Net.Sockets.Socket>można <xref:System.Net.Sockets.Socket.EndSend%2A> wywołać metodę, aby pomyślnie zakończyć operację wysyłania i zwrócić liczbę wysłanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1774">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="0ed15-1775">Jeśli używasz bezpołączeniowego protokołu, <xref:System.Net.Sockets.Socket.EndSend%2A> program zablokuje do momentu wysłania datagramu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1775">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="0ed15-1776">Jeśli używasz protokołu zorientowanego na połączenie, <xref:System.Net.Sockets.Socket.EndSend%2A> program zablokuje do momentu wysłania niektórych buforów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1776">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent.</span></span> <span data-ttu-id="0ed15-1777">Jeśli wartość zwracana z <xref:System.Net.Sockets.Socket.EndSend%2A> wskazuje, że bufor nie został całkowicie wysłany, <xref:System.Net.Sockets.Socket.BeginSend%2A> Wywołaj metodę ponownie, modyfikując bufor do przechowywania niewysłanych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1777">If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.</span></span>  
  
 <span data-ttu-id="0ed15-1778">Nie ma żadnej gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1778">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="0ed15-1779">Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1779">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="0ed15-1780">Pomyślne zakończenie <xref:System.Net.Sockets.Socket.BeginSend%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1780">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1781">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1781">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1782">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1782">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1783">Wszystkie we/wy zainicjowane przez dany wątek zostało anulowane po zakończeniu tego wątku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1783">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="0ed15-1784">Oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek zostanie zakończony przed ukończeniem operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1784">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1785">Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1785">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="0ed15-1786">Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1786">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1787">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1787">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1788">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1788">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1789">Poniższy przykład kodu zamyka oczekujące asynchroniczne wysyłanie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1789">The following code example ends a pending asynchronous send.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-1790"><paramref name="asyncResult" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1790"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-1791"><paramref name="asyncResult" />nie został zwrócony przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1791"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-1792"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />została wcześniej wywołana dla wysyłania asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1792"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for the asynchronous send.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1793">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1793">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1794"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1794">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult *  -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="0ed15-1795"><see cref="T:System.IAsyncResult" /> Przechowujący informacje o stanie dla tej operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1795">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span></span></param>
        <param name="errorCode"><span data-ttu-id="0ed15-1796"><see cref="T:System.Net.Sockets.SocketError" /> Obiekt, który przechowuje błąd gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1796">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="0ed15-1797">Zakończenie oczekiwania na wysłanie asynchroniczne.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1797">Ends a pending asynchronous send.</span></span></summary>
        <returns><span data-ttu-id="0ed15-1798">Jeśli to się powiedzie, liczba bajtów wysłanych <see cref="T:System.Net.Sockets.Socket" />do; w przeciwnym razie <see cref="T:System.Net.Sockets.Socket" /> , nieprawidłowy błąd.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1798">If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1799"><xref:System.Net.Sockets.Socket.EndSend%2A>kończy asynchroniczne operacje wysyłania rozpoczęte w <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1799"><xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span></span>  
  
 <span data-ttu-id="0ed15-1800">Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSend%2A>należy utworzyć metodę wywołania zwrotnego <xref:System.AsyncCallback> implementującą delegata.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1800">Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="0ed15-1801">Ta metoda wywołania zwrotnego jest wykonywana w osobnym wątku i jest wywoływana przez system <xref:System.Net.Sockets.Socket.BeginSend%2A> po powrocie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1801">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns.</span></span> <span data-ttu-id="0ed15-1802">Metoda wywołania zwrotnego musi akceptować <xref:System.IAsyncResult> zwrócone <xref:System.Net.Sockets.Socket.BeginSend%2A> przez metodę jako parametr.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1802">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="0ed15-1803">W metodzie wywołania zwrotnego Wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę <xref:System.IAsyncResult> parametru, aby uzyskać wysyłanie <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1803">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-1804">Po uzyskaniu <xref:System.Net.Sockets.Socket>można <xref:System.Net.Sockets.Socket.EndSend%2A> wywołać metodę, aby pomyślnie zakończyć operację wysyłania i zwrócić liczbę wysłanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1804">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="0ed15-1805">Jeśli używasz bezpołączeniowego protokołu, <xref:System.Net.Sockets.Socket.EndSend%2A> program zablokuje do momentu wysłania datagramu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1805">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="0ed15-1806">Jeśli używasz protokołu zorientowanego na połączenie, <xref:System.Net.Sockets.Socket.EndSend%2A> program zablokuje do momentu wysłania niektórych buforów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1806">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent.</span></span> <span data-ttu-id="0ed15-1807">Jeśli wartość zwracana z <xref:System.Net.Sockets.Socket.EndSend%2A> wskazuje, że bufor nie został całkowicie wysłany, <xref:System.Net.Sockets.Socket.BeginSend%2A> Wywołaj metodę ponownie, modyfikując bufor do przechowywania niewysłanych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1807">If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.</span></span>  
  
 <span data-ttu-id="0ed15-1808">Nie ma żadnej gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1808">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="0ed15-1809">Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1809">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="0ed15-1810">Pomyślne zakończenie <xref:System.Net.Sockets.Socket.BeginSend%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1810">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1811">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1811">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1812">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1812">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1813">Wszystkie we/wy zainicjowane przez dany wątek zostało anulowane po zakończeniu tego wątku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1813">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="0ed15-1814">Oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek zostanie zakończony przed ukończeniem operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1814">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1815">Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1815">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="0ed15-1816">Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1816">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1817">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1817">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1818">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1818">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-1819"><paramref name="asyncResult" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1819"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-1820"><paramref name="asyncResult" />nie został zwrócony przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1820"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-1821"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />została wcześniej wywołana dla wysyłania asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1821"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for the asynchronous send.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1822">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1822">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1823"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1823">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="0ed15-1824"><see cref="T:System.IAsyncResult" /> Obiekt, który przechowuje informacje o stanie dla tej operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1824">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="0ed15-1825">Zamyka oczekujące asynchroniczne wysyłanie pliku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1825">Ends a pending asynchronous send of a file.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1826"><xref:System.Net.Sockets.Socket.EndSendFile%2A>kończy asynchroniczne operacje wysyłania rozpoczęte w <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1826"><xref:System.Net.Sockets.Socket.EndSendFile%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.</span></span>  
  
 <span data-ttu-id="0ed15-1827">Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSendFile%2A>należy utworzyć metodę wywołania zwrotnego <xref:System.AsyncCallback> implementującą delegata.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1827">Before calling <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, you must create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="0ed15-1828">Ta metoda wywołania zwrotnego jest wykonywana w osobnym wątku i jest wywoływana przez system <xref:System.Net.Sockets.Socket.BeginSendFile%2A> po powrocie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1828">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSendFile%2A> returns.</span></span> <span data-ttu-id="0ed15-1829">Metoda wywołania zwrotnego musi akceptować <xref:System.IAsyncResult> obiekt zwracany <xref:System.Net.Sockets.Socket.BeginSendFile%2A> przez metodę jako parametr.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1829">The callback method must accept the <xref:System.IAsyncResult> object returned by the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="0ed15-1830">W metodzie wywołania zwrotnego Wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę <xref:System.IAsyncResult> parametru, aby uzyskać wysyłanie <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1830">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-1831">Po uzyskaniu <xref:System.Net.Sockets.Socket>można <xref:System.Net.Sockets.Socket.EndSendFile%2A> wywołać metodę, aby pomyślnie zakończyć operację wysyłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1831">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method to successfully complete the send operation.</span></span>  
  
 <span data-ttu-id="0ed15-1832">Jeśli używasz bezpołączeniowego protokołu, <xref:System.Net.Sockets.Socket.EndSendFile%2A> bloki do momentu wysłania datagramu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1832">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the datagram is sent.</span></span> <span data-ttu-id="0ed15-1833">Jeśli używasz protokołu zorientowanego na połączenia, <xref:System.Net.Sockets.Socket.EndSendFile%2A> bloki do momentu wysłania całego pliku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1833">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the entire file is sent.</span></span> <span data-ttu-id="0ed15-1834">Nie ma żadnej gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1834">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="0ed15-1835">Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1835">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="0ed15-1836">Pomyślne zakończenie <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1836">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1837">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1837">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1838">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1838">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1839">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1839">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1840">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1840">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1841">Poniższy przykład kodu tworzy i łączy gniazdo do komunikacji asynchronicznej i zaczyna wysyłać plik "text. txt" asynchronicznie do hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1841">The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</span></span> <span data-ttu-id="0ed15-1842">Delegat wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndSendFile%2A> do ukończenia transmisji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1842">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-1843">Dla tej metody wymagany jest system Windows NT.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1843">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1844"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1844">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-1845"><paramref name="asyncResult" />jest puste.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1845"><paramref name="asyncResult" /> is empty.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-1846"><paramref name="asyncResult" />nie został zwrócony przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1846"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-1847"><see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />zostało wcześniej wywołane dla asynchronicznej <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1847"><see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> was previously called for the asynchronous <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1848">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1848">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="0ed15-1849">Zobacz uwagi poniżej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1849">See remarks section below.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="0ed15-1850"><see cref="T:System.IAsyncResult" /> Przechowujące informacje o stanie i wszystkie dane zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1850">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="0ed15-1851"><see cref="T:System.IAsyncResult" /> Przechowujące informacje o stanie i wszystkie dane zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1851">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="0ed15-1852">Zamyka oczekujące wysyłanie asynchroniczne do określonej lokalizacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1852">Ends a pending asynchronous send to a specific location.</span></span></summary>
        <returns><span data-ttu-id="0ed15-1853">W przypadku powodzenia — liczba wysłanych bajtów; w przeciwnym razie nieprawidłowy <see cref="T:System.Net.Sockets.Socket" /> błąd.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1853">If successful, the number of bytes sent; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1854"><xref:System.Net.Sockets.Socket.EndSendTo%2A>kończy asynchroniczne operacje wysyłania rozpoczęte w <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1854"><xref:System.Net.Sockets.Socket.EndSendTo%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span>  
  
 <span data-ttu-id="0ed15-1855">Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSendTo%2A>należy utworzyć metodę wywołania zwrotnego <xref:System.AsyncCallback> implementującą delegata.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1855">Before calling <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="0ed15-1856">Ta metoda wywołania zwrotnego jest wykonywana w osobnym wątku i jest wywoływana przez system <xref:System.Net.Sockets.Socket.BeginReceive%2A> po powrocie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1856">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="0ed15-1857">Metoda wywołania zwrotnego musi akceptować <xref:System.IAsyncResult> zwrócone <xref:System.Net.Sockets.Socket.BeginSendTo%2A> przez metodę jako parametr.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1857">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="0ed15-1858">W metodzie wywołania zwrotnego Wywołaj <xref:System.IAsyncResult.AsyncState%2A> metodę <xref:System.IAsyncResult> parametru, aby uzyskać wysyłanie <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1858">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-1859">Po uzyskaniu <xref:System.Net.Sockets.Socket>można <xref:System.Net.Sockets.Socket.EndSendTo%2A> wywołać metodę, aby pomyślnie zakończyć operację wysyłania i zwrócić liczbę wysłanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1859">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="0ed15-1860">Jeśli używasz bezpołączeniowego protokołu, <xref:System.Net.Sockets.Socket.EndSendTo%2A> program zablokuje do momentu wysłania datagramu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1860">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="0ed15-1861">Jeśli używasz protokołu zorientowanego na połączenie, <xref:System.Net.Sockets.Socket.EndSendTo%2A> program zablokuje do momentu wysłania żądanej liczby bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1861">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="0ed15-1862">Nie ma żadnej gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1862">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="0ed15-1863">Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1863">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="0ed15-1864">Pomyślne zakończenie <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1864">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1865">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1865">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1866">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1866">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1867">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1867">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1868">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1868">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1869">Poniższy przykład kodu przerywa wysyłanie asynchroniczne do określonej lokalizacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1869">The following code example ends an asynchronous send to a specific location.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-1870"><paramref name="asyncResult" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1870"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-1871"><paramref name="asyncResult" />nie został zwrócony przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1871"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-1872"><see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />została wcześniej wywołana dla wysyłania asynchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1872"><see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> was previously called for the asynchronous send.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1873">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1873">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1874"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1874">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-1875">Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określającą, <see cref="T:System.Net.Sockets.Socket" /> czy zezwala tylko jednemu procesowi na powiązanie z portem.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1875">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows only one process to bind to a port.</span></span></summary>
        <value><span data-ttu-id="0ed15-1876"><see langword="true" />Jeśli zezwala tylko jednemu gnieździi na powiązanie z określonym portem; w przeciwnym razie, <see langword="false" />. <see cref="T:System.Net.Sockets.Socket" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-1876"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows only one socket to bind to a specific port; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="0ed15-1877">Wartość domyślna to <see langword="true" /> Windows Server 2003 i Windows XP z dodatkiem Service Pack 2 <see langword="false" /> oraz dla wszystkich innych wersji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1877">The default is <see langword="true" /> for Windows Server 2003 and Windows XP Service Pack 2, and <see langword="false" /> for all other versions.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1878">Jeśli <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> jest `false` ,<xref:System.Net.Sockets.Socket.Bind%2A> wiele gniazd może używać metody do powiązania z określonym portem; jednak tylko jedno z gniazd może wykonywać operacje w ruchu sieciowym wysyłanym do portu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1878">If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `false`, multiple sockets can use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a specific port; however only one of the sockets can perform operations on the network traffic sent to the port.</span></span> <span data-ttu-id="0ed15-1879">Jeśli więcej niż jedno gniazdo próbuje użyć <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> metody do powiązania z określonym portem, to ten z bardziej szczegółowym adresem IP będzie obsługiwać ruch sieciowy wysyłany do tego portu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1879">If more than one socket attempts to use the <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> method to bind to a particular port, then the one with the more specific IP address will handle the network traffic sent to that port.</span></span>  
  
 <span data-ttu-id="0ed15-1880">Jeśli <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> <xref:System.Net.Sockets.Socket.Bind%2A> <xref:System.Net.Sockets.Socket.Bind%2A> jest `true`, pierwsze użycie metody w celu utworzenia powiązania z określonym portem, bez względu na adres protokołu internetowego (IP), powiedzie się; wszystkie kolejne zastosowania metody w celu utworzenia powiązania z tym portem będą nie powiodło się, dopóki oryginalne powiązane gniazdo nie zostanie zniszczone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1880">If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `true`, the first use of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to a particular port, regardless of Internet Protocol (IP) address, will succeed; all subsequent uses of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to that port will fail until the original bound socket is destroyed.</span></span>  
  
 <span data-ttu-id="0ed15-1881">Ta właściwość musi być ustawiona przed <xref:System.Net.Sockets.Socket.Bind%2A> wywołaniem metody; <xref:System.InvalidOperationException> w przeciwnym razie zostanie wygenerowany.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1881">This property must be set before <xref:System.Net.Sockets.Socket.Bind%2A> is called; otherwise an <xref:System.InvalidOperationException> will be thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1882">Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1882">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1883">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1883">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1884"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1884">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-1885"><see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />został wywołany dla tego <see cref="T:System.Net.Sockets.Socket" />elementu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1885"><see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> has been called for this <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0ed15-1886">Zwalnia zasoby używane przez <see cref="T:System.Net.Sockets.Socket" /> klasę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1886">Frees resources used by the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1887">Finalizator klasy wywołuje metodę w celu zamknięcia <xref:System.Net.Sockets.Socket> i zwolnienia zasobów skojarzonych z <xref:System.Net.Sockets.Socket>. <xref:System.Net.Sockets.Socket.Close%2A> <xref:System.Net.Sockets.Socket></span><span class="sxs-lookup"><span data-stu-id="0ed15-1887">The <xref:System.Net.Sockets.Socket> class finalizer calls the <xref:System.Net.Sockets.Socket.Close%2A> method to close the <xref:System.Net.Sockets.Socket> and free resources associated with the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0ed15-1888">Zwraca wartość skrótu dla <see cref="T:System.Net.Sockets.Socket" /> wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1888">Returns a hash value for a <see cref="T:System.Net.Sockets.Socket" /> instance.</span></span></summary>
        <returns><span data-ttu-id="0ed15-1889">Wartość skrótu liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1889">An integer hash value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="0ed15-1890">Metoda GetHashCode zwraca kod skrótu tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1890">The GetHashCode method returns a hash code of this instance.</span></span> <span data-ttu-id="0ed15-1891">Ta wartość może być używana jako klucz w tabelach skrótów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1891">This value can be used as a key in hash tables.</span></span>

]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ed15-1892">Zwraca wartość <see cref="T:System.Net.Sockets.Socket" /> opcji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1892">Returns the value of a <see cref="T:System.Net.Sockets.Socket" /> option.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="0ed15-1893">Jedna z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1893">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="0ed15-1894">Jedna z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1894">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <summary><span data-ttu-id="0ed15-1895">Zwraca wartość określonej <see cref="T:System.Net.Sockets.Socket" /> opcji reprezentowanej jako obiekt.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1895">Returns the value of a specified <see cref="T:System.Net.Sockets.Socket" /> option, represented as an object.</span></span></summary>
        <returns><span data-ttu-id="0ed15-1896">Obiekt, który reprezentuje wartość opcji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1896">An object that represents the value of the option.</span></span> <span data-ttu-id="0ed15-1897">Gdy parametr jest ustawiony na <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> wartość zwracaną, <see cref="T:System.Net.Sockets.LingerOption" /> jest wystąpieniem klasy. <paramref name="optionName" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-1897">When the <paramref name="optionName" /> parameter is set to <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> the return value is an instance of the <see cref="T:System.Net.Sockets.LingerOption" /> class.</span></span> <span data-ttu-id="0ed15-1898">Gdy <paramref name="optionName" /> jest ustawiona na <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> lub <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, wartość zwracana jest wystąpieniem <see cref="T:System.Net.Sockets.MulticastOption" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1898">When <paramref name="optionName" /> is set to <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> or <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, the return value is an instance of the <see cref="T:System.Net.Sockets.MulticastOption" /> class.</span></span> <span data-ttu-id="0ed15-1899">Gdy <paramref name="optionName" /> jest dowolną inną wartością, zwracana wartość jest liczbą całkowitą.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1899">When <paramref name="optionName" /> is any other value, the return value is an integer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1900"><xref:System.Net.Sockets.Socket>opcje określają zachowanie bieżącego <xref:System.Net.Sockets.Socket>elementu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1900"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-1901">Użyj tego <xref:System.Net.Sockets.SocketOptionName.Linger>przeciążenia, aby uzyskać opcje <xref:System.Net.Sockets.SocketOptionName.AddMembership>, i <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-1901">Use this overload to get the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options.</span></span> <span data-ttu-id="0ed15-1902"><xref:System.Net.Sockets.Socket> Dla opcji Użyj`optionLevel` parametru. <xref:System.Net.Sockets.SocketOptionName.Linger></span><span class="sxs-lookup"><span data-stu-id="0ed15-1902">For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter.</span></span> <span data-ttu-id="0ed15-1903">Dla <xref:System.Net.Sockets.SocketOptionName.AddMembership> i <xref:System.Net.Sockets.SocketOptionName.DropMembership>, użyj <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1903">For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span></span> <span data-ttu-id="0ed15-1904">Jeśli chcesz ustawić wartość dowolnej z wymienionych powyżej opcji, użyj <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1904">If you want to set the value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1905">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1905">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1906">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1906">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1907">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1907">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1908">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1908">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1909">Poniższy przykład kodu pobiera <xref:System.Net.Sockets.LingerOption> wartości i <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu i wyświetla je w konsoli programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1909">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1910">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1910">An error occurred when attempting to access the socket.</span></span>  
  
<span data-ttu-id="0ed15-1911">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-1911">-or-</span></span> 
 <span data-ttu-id="0ed15-1912"><paramref name="optionName" />ustawiono nieobsługiwaną wartość <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1912"><paramref name="optionName" /> was set to the unsupported value <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1913"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1913">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="0ed15-1914">Jedna z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1914">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="0ed15-1915">Jedna z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1915">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="0ed15-1916">Tablica typu <see cref="T:System.Byte" /> , który ma otrzymać ustawienie opcji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1916">An array of type <see cref="T:System.Byte" /> that is to receive the option setting.</span></span></param>
        <summary><span data-ttu-id="0ed15-1917">Zwraca określone <see cref="T:System.Net.Sockets.Socket" /> ustawienie opcji reprezentowane jako tablica bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1917">Returns the specified <see cref="T:System.Net.Sockets.Socket" /> option setting, represented as a byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1918"><xref:System.Net.Sockets.Socket>opcje określają zachowanie bieżącego <xref:System.Net.Sockets.Socket>elementu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1918"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-1919">Po pomyślnym zakończeniu tej metody tablica określona przez `optionValue` parametr zawiera wartość określonej <xref:System.Net.Sockets.Socket> opcji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1919">Upon successful completion of this method, the array specified by the `optionValue` parameter contains the value of the specified <xref:System.Net.Sockets.Socket> option.</span></span>  
  
 <span data-ttu-id="0ed15-1920">Gdy długość `optionValue` tablicy jest mniejsza niż liczba bajtów wymagana do przechowania wartości określonej <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.SocketException>opcji, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> program wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1920">When the length of the `optionValue` array is smaller than the number of bytes required to store the value of the specified <xref:System.Net.Sockets.Socket> option, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-1921">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1921">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1922">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1922">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="0ed15-1923">Użyj tego przeciążenia dla wszystkich gniazd, które są reprezentowane przez wartości logiczne lub liczby całkowite.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1923">Use this overload for any sockets that are represented by Boolean values or integers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1924">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1924">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1925">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1925">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1926">Poniższy przykład kodu pobiera <xref:System.Net.Sockets.LingerOption> wartości i <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu i wyświetla je w konsoli programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1926">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1927">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1927">An error occurred when attempting to access the socket.</span></span>  
  
<span data-ttu-id="0ed15-1928">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-1928">-or-</span></span> 
<span data-ttu-id="0ed15-1929">W .NET Compact Framework aplikacji Windows CE domyślna przestrzeń buforu jest ustawiona na 32768 bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1929">In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</span></span> <span data-ttu-id="0ed15-1930">Można zmienić miejsce w buforze na gniazdo, wywołując <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1930">You can change the per socket buffer space by calling <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1931"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1931">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionLength" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="0ed15-1932">Jedna z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1932">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="0ed15-1933">Jedna z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1933">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionLength"><span data-ttu-id="0ed15-1934">Długość (w bajtach) oczekiwanej wartości zwracanej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1934">The length, in bytes, of the expected return value.</span></span></param>
        <summary><span data-ttu-id="0ed15-1935">Zwraca wartość określonej <see cref="T:System.Net.Sockets.Socket" /> opcji w tablicy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1935">Returns the value of the specified <see cref="T:System.Net.Sockets.Socket" /> option in an array.</span></span></summary>
        <returns><span data-ttu-id="0ed15-1936">Tablica typu <see cref="T:System.Byte" /> , która zawiera wartość opcji gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1936">An array of type <see cref="T:System.Byte" /> that contains the value of the socket option.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1937">`optionLength` Parametr ustawia maksymalny rozmiar zwracanej tablicy bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1937">The `optionLength` parameter sets the maximum size of the returned byte array.</span></span> <span data-ttu-id="0ed15-1938">Jeśli wartość opcji wymaga mniejszej liczby bajtów, tablica będzie zawierać tylko liczbę bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1938">If the option value requires fewer bytes, the array will contain only that many bytes.</span></span> <span data-ttu-id="0ed15-1939">Jeśli wartość opcji wymaga większej liczby bajtów, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> program <xref:System.Net.Sockets.SocketException>wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1939">If the option value requires more bytes, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-1940">Użyj tego przeciążenia dla wszystkich gniazd, które są reprezentowane przez wartości logiczne lub liczby całkowite.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1940">Use this overload for any sockets that are represented by Boolean values or integers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1941">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1941">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1942">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1942">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1943">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1943">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1944">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1944">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1945">Poniższy przykład kodu pobiera <xref:System.Net.Sockets.LingerOption> wartości i <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu i wyświetla je w konsoli programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1945">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1946">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1946">An error occurred when attempting to access the socket.</span></span>  
  
<span data-ttu-id="0ed15-1947">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-1947">-or-</span></span> 
<span data-ttu-id="0ed15-1948">W .NET Compact Framework aplikacji Windows CE domyślna przestrzeń buforu jest ustawiona na 32768 bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1948">In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</span></span> <span data-ttu-id="0ed15-1949">Można zmienić miejsce w buforze na gniazdo, wywołując <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1949">You can change the per socket buffer space by calling <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1950"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1950">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-1951">Pobiera uchwyt systemu operacyjnego dla <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1951">Gets the operating system handle for the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="0ed15-1952">Reprezentuje dojście systemu operacyjnego <see cref="T:System.Net.Sockets.Socket" />dla. <see cref="T:System.IntPtr" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-1952">An <see cref="T:System.IntPtr" /> that represents the operating system handle for the <see cref="T:System.Net.Sockets.Socket" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ed15-1953">Ustawia Tryby operacyjne niskiego poziomu dla <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1953">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ioControlCode"><span data-ttu-id="0ed15-1954"><see cref="T:System.Int32" /> Wartość określająca kod sterujący operacji do wykonania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1954">An <see cref="T:System.Int32" /> value that specifies the control code of the operation to perform.</span></span></param>
        <param name="optionInValue"><span data-ttu-id="0ed15-1955"><see cref="T:System.Byte" /> Tablica zawierająca dane wejściowe wymagane przez operację.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1955">A <see cref="T:System.Byte" /> array that contains the input data required by the operation.</span></span></param>
        <param name="optionOutValue"><span data-ttu-id="0ed15-1956"><see cref="T:System.Byte" /> Tablica zawierająca dane wyjściowe zwrócone przez operację.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1956">A <see cref="T:System.Byte" /> array that contains the output data returned by the operation.</span></span></param>
        <summary><span data-ttu-id="0ed15-1957">Ustawia Tryby operacyjne niskiego poziomu dla <see cref="T:System.Net.Sockets.Socket" /> kodów kontroli liczbowej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1957">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using numerical control codes.</span></span></summary>
        <returns><span data-ttu-id="0ed15-1958">Liczba bajtów w <paramref name="optionOutValue" /> parametrze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1958">The number of bytes in the <paramref name="optionOutValue" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1959">Metoda zapewnia dostęp niskiego poziomu do systemu <xref:System.Net.Sockets.Socket> operacyjnego bazowego bieżącego wystąpienia <xref:System.Net.Sockets.Socket> klasy. <xref:System.Net.Sockets.Socket.IOControl%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-1959">The <xref:System.Net.Sockets.Socket.IOControl%2A> method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class.</span></span> <span data-ttu-id="0ed15-1960">Aby uzyskać więcej informacji, zapoznaj się z dokumentacją [WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) .</span><span class="sxs-lookup"><span data-stu-id="0ed15-1960">For more information, see the [WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) documentation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1961">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1961">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1962">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1962">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1963">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1963">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1964">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1964">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1965">Poniższy przykład kodu porównuje wyniki FIONREAD i dostępne właściwości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1965">The following code example compares the results of FIONREAD and the Available property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1966">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1966">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1967"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1967">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-1968">Podjęto próbę zmiany trybu blokowania bez użycia <see cref="P:System.Net.Sockets.Socket.Blocking" /> właściwości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1968">An attempt was made to change the blocking mode without using the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0ed15-1969">Obiekt wywołujący w stosie wywołań nie ma wymaganych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1969">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="0ed15-1970">Aby wykonać kod niezarządzany.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1970">to execute unmanaged code.</span></span> <span data-ttu-id="0ed15-1971">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1971">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ioControlCode"><span data-ttu-id="0ed15-1972"><see cref="T:System.Net.Sockets.IOControlCode" /> Wartość, która określa kod sterujący operacji do wykonania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1972">A <see cref="T:System.Net.Sockets.IOControlCode" /> value that specifies the control code of the operation to perform.</span></span></param>
        <param name="optionInValue"><span data-ttu-id="0ed15-1973">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane wejściowe wymagane przez operację.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1973">An array of type <see cref="T:System.Byte" /> that contains the input data required by the operation.</span></span></param>
        <param name="optionOutValue"><span data-ttu-id="0ed15-1974">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane wyjściowe zwrócone przez operację.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1974">An array of type <see cref="T:System.Byte" /> that contains the output data returned by the operation.</span></span></param>
        <summary><span data-ttu-id="0ed15-1975">Ustawia Tryby operacyjne niskiego poziomu dla <see cref="T:System.Net.Sockets.Socket" /> wyliczenia przy użyciu, <see cref="T:System.Net.Sockets.IOControlCode" /> aby określić kody kontroli.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1975">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using the <see cref="T:System.Net.Sockets.IOControlCode" /> enumeration to specify control codes.</span></span></summary>
        <returns><span data-ttu-id="0ed15-1976">Liczba bajtów w <paramref name="optionOutValue" /> parametrze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1976">The number of bytes in the <paramref name="optionOutValue" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1977">Ta metoda zapewnia dostęp niskiego poziomu do systemu <xref:System.Net.Sockets.Socket> operacyjnego odpowiadającego bieżącemu wystąpieniu <xref:System.Net.Sockets.Socket> klasy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1977">This method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class.</span></span> <span data-ttu-id="0ed15-1978">Aby uzyskać więcej informacji, zapoznaj się z dokumentacją [WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) .</span><span class="sxs-lookup"><span data-stu-id="0ed15-1978">For more, see the [WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) documentation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1979">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1979">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-1980">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1980">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-1981">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1981">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-1982">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-1982">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1983">Poniższy przykład kodu porównuje wyniki wywołania <xref:System.Net.Sockets.Socket.IOControl%2A> z <xref:System.Net.Sockets.IOControlCode.DataToRead> i <xref:System.Net.Sockets.Socket.Available%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1983">The following code example compares the results of calling <xref:System.Net.Sockets.Socket.IOControl%2A> with <xref:System.Net.Sockets.IOControlCode.DataToRead> and the <xref:System.Net.Sockets.Socket.Available%2A> property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-1984">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1984">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-1985"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1985">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-1986">Podjęto próbę zmiany trybu blokowania bez użycia <see cref="P:System.Net.Sockets.Socket.Blocking" /> właściwości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1986">An attempt was made to change the blocking mode without using the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="0ed15-1987">Aby wykonać kod niezarządzany.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1987">to execute unmanaged code.</span></span> <span data-ttu-id="0ed15-1988">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1988">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-1989">Pobiera wartość wskazującą, czy <see cref="T:System.Net.Sockets.Socket" /> jest powiązana z określonym portem lokalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1989">Gets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is bound to a specific local port.</span></span></summary>
        <value><span data-ttu-id="0ed15-1990"><see langword="true" />Jeśli jest powiązany z portem lokalnym; w przeciwnym razie <see langword="false" />,. <see cref="T:System.Net.Sockets.Socket" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-1990"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> is bound to a local port; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1991">Gniazdo jest uznawane za powiązane z portem lokalnym, jeśli jest ono jawnie powiązane przez <xref:System.Net.Sockets.Socket.Bind%2A> wywołanie metody lub niejawnie powiązanej przez wywołujących <xref:System.Net.Sockets.Socket.SendTo%2A>członków, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>takich jak <xref:System.Net.Sockets.Socket.Connect%2A>, lub, które używają portu lokalnego na czas dłuższy niż 1024 wybrana przez system operacyjny). Serwery używają <xref:System.Net.Sockets.Socket.Bind%2A> metody do powiązania z dobrze znanym portem, dzięki czemu klienci mogą się z nimi łączyć.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1991">A socket is considered bound to a local port if it is explicitly bound by calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, or implicitly bound by calling members like <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, which use an ephemeral local port (a free port greater than 1024, selected by the operating system.) Servers use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a well-known port so that clients may connect to them.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-1992">Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.IsBound%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1992">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.IsBound%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-1993">Pobiera lub ustawia wartość określającą, czy <see cref="T:System.Net.Sockets.Socket" /> opóźnienie zamknie gniazdo w trakcie próby wysłania wszystkich oczekujących danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1993">Gets or sets a value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> will delay closing a socket in an attempt to send all pending data.</span></span></summary>
        <value><span data-ttu-id="0ed15-1994">Obiekt <see cref="T:System.Net.Sockets.LingerOption" /> , który określa sposób pokutujący podczas zamykania gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1994">A <see cref="T:System.Net.Sockets.LingerOption" /> that specifies how to linger while closing a socket.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-1995">Właściwość zmienia sposób <xref:System.Net.Sockets.Socket.Close%2A> zachowania metody. <xref:System.Net.Sockets.Socket.LingerState%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-1995">The <xref:System.Net.Sockets.Socket.LingerState%2A> property changes the way <xref:System.Net.Sockets.Socket.Close%2A> method behaves.</span></span> <span data-ttu-id="0ed15-1996">Ta właściwość po ustawieniu modyfikuje warunki, w których połączenie może być resetowane przez usługę Winsock.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1996">This property when set modifies the conditions under which the connection can be reset by Winsock.</span></span> <span data-ttu-id="0ed15-1997">Resetowanie połączeń może nadal odbywać się w zależności od zachowania protokołu IP.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1997">Connection resets can still occur based on the IP protocol behavior.</span></span>  
  
 <span data-ttu-id="0ed15-1998">Ta właściwość określa czas, przez jaki połączenie zorientowane na połączenie pozostanie otwarte po wywołaniu <xref:System.Net.Sockets.Socket.Close%2A> , gdy dane zostaną wysłane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1998">This property controls the length of time that a connection-oriented connection will remain open after a call to <xref:System.Net.Sockets.Socket.Close%2A> when data remains to be sent.</span></span>  
  
 <span data-ttu-id="0ed15-1999">Gdy wywołujesz metody wysyłania danych do elementu równorzędnego, te dane są umieszczane w buforze sieci wychodzącej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-1999">When you call methods to send data to a peer, this data is placed in the outgoing network buffer.</span></span> <span data-ttu-id="0ed15-2000">Ta właściwość może służyć do upewnienia się, że te dane są wysyłane do hosta zdalnego przed <xref:System.Net.Sockets.TcpClient.Close%2A> odrzuceniem połączenia przez metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2000">This property can be used to ensure that this data is sent to the remote host before the <xref:System.Net.Sockets.TcpClient.Close%2A> method drops the connection.</span></span>  
  
 <span data-ttu-id="0ed15-2001">Aby włączyć pokutujący, Utwórz <xref:System.Net.Sockets.LingerOption> wystąpienie zawierające wymagane wartości, a następnie <xref:System.Net.Sockets.Socket.LingerState%2A> ustaw właściwość na to wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2001">To enable lingering, create a <xref:System.Net.Sockets.LingerOption> instance containing the desired values, and set the <xref:System.Net.Sockets.Socket.LingerState%2A> property to this instance.</span></span>  
  
 <span data-ttu-id="0ed15-2002">W poniższej tabeli opisano <xref:System.Net.Sockets.Socket.Close%2A> zachowanie metody dla możliwych wartości <xref:System.Net.Sockets.LingerOption.Enabled%2A> właściwości i <xref:System.Net.Sockets.LingerOption.LingerTime%2A> właściwości przechowywanej we <xref:System.Net.Sockets.Socket.LingerState%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2002">The following table describes the behavior of the <xref:System.Net.Sockets.Socket.Close%2A> method for the possible values of the <xref:System.Net.Sockets.LingerOption.Enabled%2A> property and the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property.</span></span>  
  
|<span data-ttu-id="0ed15-2003">LingerState.Enabled</span><span class="sxs-lookup"><span data-stu-id="0ed15-2003">LingerState.Enabled</span></span>|<span data-ttu-id="0ed15-2004">LingerState.LingerTime</span><span class="sxs-lookup"><span data-stu-id="0ed15-2004">LingerState.LingerTime</span></span>|<span data-ttu-id="0ed15-2005">Zachowanie</span><span class="sxs-lookup"><span data-stu-id="0ed15-2005">Behavior</span></span>|  
|-------------------------|----------------------------|--------------|  
|<span data-ttu-id="0ed15-2006">`false`(wyłączone), wartość domyślna</span><span class="sxs-lookup"><span data-stu-id="0ed15-2006">`false` (disabled), the default value</span></span>|<span data-ttu-id="0ed15-2007">Limit czasu nie ma zastosowania (wartość domyślna).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2007">The time-out is not applicable, (default).</span></span>|<span data-ttu-id="0ed15-2008">Próbuje wysłać oczekujące dane do momentu wygaśnięcia domyślnego limitu czasu protokołu IP.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2008">Attempts to send pending data until the default IP protocol time-out expires.</span></span>|  
|<span data-ttu-id="0ed15-2009">`true`dostępny</span><span class="sxs-lookup"><span data-stu-id="0ed15-2009">`true` (enabled)</span></span>|<span data-ttu-id="0ed15-2010">Limit czasu różny od zera</span><span class="sxs-lookup"><span data-stu-id="0ed15-2010">A nonzero time-out</span></span>|<span data-ttu-id="0ed15-2011">Próbuje wysłać oczekujące dane do czasu wygaśnięcia określonego limitu czasu, a jeśli próba nie powiedzie się, usługa Winsock resetuje połączenie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2011">Attempts to send pending data until the specified time-out expires, and if the attempt fails, then Winsock resets the connection.</span></span>|  
|<span data-ttu-id="0ed15-2012">`true`dostępny</span><span class="sxs-lookup"><span data-stu-id="0ed15-2012">`true` (enabled)</span></span>|<span data-ttu-id="0ed15-2013">Limit czasu równy zero.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2013">A zero timeout.</span></span>|<span data-ttu-id="0ed15-2014">Odrzuca wszystkie oczekujące dane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2014">Discards any pending data.</span></span> <span data-ttu-id="0ed15-2015">W przypadku gniazda zorientowanego na połączenia (na przykład TCP), Winsock resetuje połączenie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2015">For connection-oriented socket (TCP, for example), Winsock resets the connection.</span></span>|  
  
 <span data-ttu-id="0ed15-2016">Stos IP oblicza domyślny limit czasu protokołu IP do użycia na podstawie czasu błądzenia połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2016">The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection.</span></span> <span data-ttu-id="0ed15-2017">W większości przypadków limit czasu obliczony przez stos jest bardziej istotny niż jeden zdefiniowany przez aplikację.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2017">In most cases, the time-out computed by the stack is more relevant than one defined by an application.</span></span> <span data-ttu-id="0ed15-2018">Jest to domyślne zachowanie dla gniazda, gdy <xref:System.Net.Sockets.Socket.LingerState%2A> właściwość nie jest ustawiona.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2018">This is the default behavior for a socket when the <xref:System.Net.Sockets.Socket.LingerState%2A> property is not set.</span></span>  
  
 <span data-ttu-id="0ed15-2019">Gdy właściwość przechowywana <xref:System.Net.Sockets.Socket.LingerState%2A> we właściwości jest ustawiona na wartość większą niż domyślny limit czasu protokołu IP, domyślny limit czasu protokołu IP będzie nadal stosowany i przesłonięty. <xref:System.Net.Sockets.LingerOption.LingerTime%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-2019">When the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-2020">Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.LingerState%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2020">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.LingerState%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2021">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2021">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2022"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2022">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog"><span data-ttu-id="0ed15-2023">Maksymalna długość kolejki oczekujących połączeń.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2023">The maximum length of the pending connections queue.</span></span></param>
        <summary><span data-ttu-id="0ed15-2024"><see cref="T:System.Net.Sockets.Socket" /> Umieszcza w stanie nasłuchiwania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2024">Places a <see cref="T:System.Net.Sockets.Socket" /> in a listening state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2025"><xref:System.Net.Sockets.Socket.Listen%2A>powoduje nawiązanie <xref:System.Net.Sockets.Socket> połączenia w celu nasłuchiwania prób połączenia przychodzącego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2025"><xref:System.Net.Sockets.Socket.Listen%2A> causes a connection-oriented <xref:System.Net.Sockets.Socket> to listen for incoming connection attempts.</span></span> <span data-ttu-id="0ed15-2026">`backlog` Parametr określa liczbę połączeń przychodzących, które można umieścić w kolejce do akceptacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2026">The `backlog` parameter specifies the number of incoming connections that can be queued for acceptance.</span></span> <span data-ttu-id="0ed15-2027">Aby określić maksymalną liczbę połączeń, które można określić, należy pobrać <xref:System.Net.Sockets.SocketOptionName.MaxConnections> wartość.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2027">To determine the maximum number of connections you can specify, retrieve the <xref:System.Net.Sockets.SocketOptionName.MaxConnections> value.</span></span> <span data-ttu-id="0ed15-2028"><xref:System.Net.Sockets.Socket.Listen%2A>nie blokuje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2028"><xref:System.Net.Sockets.Socket.Listen%2A> does not block.</span></span>  
  
 <span data-ttu-id="0ed15-2029">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2029">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-2030">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2030">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="0ed15-2031">Użyj <xref:System.Net.Sockets.Socket.Accept%2A> lub<xref:System.Net.Sockets.Socket.BeginAccept%2A> , aby zaakceptować połączenie z kolejki.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2031">Use <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> to accept a connection from the queue.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2032">Należy wywołać <xref:System.Net.Sockets.Socket.Bind%2A> metodę przed wywołaniem <xref:System.Net.Sockets.Socket.Listen%2A>lub <xref:System.Net.Sockets.Socket.Listen%2A> zgłosić <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2032">You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method before calling <xref:System.Net.Sockets.Socket.Listen%2A>, or <xref:System.Net.Sockets.Socket.Listen%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2033">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2033">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-2034">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2034">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2035">Parametr zaległości jest ograniczony do różnych wartości w zależności od systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2035">The backlog parameter is limited to different values depending on the Operating System.</span></span> <span data-ttu-id="0ed15-2036">Możesz określić wyższą wartość, ale zaległości będą ograniczone w zależności od systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2036">You may specify a higher value, but the backlog will be limited based on the Operating System.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-2037">Poniższy przykład kodu używa <xref:System.Net.Sockets.Socket> do nasłuchiwania połączeń przychodzących.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2037">The following code example uses <xref:System.Net.Sockets.Socket> to listen for incoming connections.</span></span>  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2038">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2038">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2039"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2039">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-2040">Pobiera lokalny punkt końcowy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2040">Gets the local endpoint.</span></span></summary>
        <value><span data-ttu-id="0ed15-2041"><see cref="T:System.Net.EndPoint" /> Używany<see cref="T:System.Net.Sockets.Socket" /> do komunikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2041">The <see cref="T:System.Net.EndPoint" /> that the <see cref="T:System.Net.Sockets.Socket" /> is using for communications.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2042">Właściwość pobiera, który zawiera lokalny adres IP i numer <xref:System.Net.Sockets.Socket> portu, z którym jest powiązany. <xref:System.Net.EndPoint> <xref:System.Net.Sockets.Socket.LocalEndPoint%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-2042">The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property gets an <xref:System.Net.EndPoint> that contains the local IP address and port number to which your <xref:System.Net.Sockets.Socket> is bound.</span></span> <span data-ttu-id="0ed15-2043">Należy rzutować to <xref:System.Net.EndPoint> <xref:System.Net.IPEndPoint> przed pobraniem jakichkolwiek informacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2043">You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information.</span></span> <span data-ttu-id="0ed15-2044">Następnie można wywołać <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> metodę w celu pobrania lokalnego <xref:System.Net.IPAddress>i <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> metody pobrania numeru portu lokalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2044">You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to retrieve the local <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to retrieve the local port number.</span></span>  
  
 <span data-ttu-id="0ed15-2045">Właściwość jest zazwyczaj ustawiana po wywołaniu <xref:System.Net.Sockets.Socket.Bind%2A> metody. <xref:System.Net.Sockets.Socket.LocalEndPoint%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-2045">The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property is usually set after you make a call to the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="0ed15-2046">Jeśli zezwolisz systemowi na przypisanie lokalnego adresu IP i numeru portu gniazda, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwość zostanie ustawiona po pierwszej operacji we/wy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2046">If you allow the system to assign your socket's local IP address and port number, the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property will be set after the first I/O operation.</span></span> <span data-ttu-id="0ed15-2047">W przypadku protokołów zorientowanych na połączenia pierwszą operacją we/wy będzie wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> metody lub. <xref:System.Net.Sockets.Socket.Accept%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-2047">For connection-oriented protocols, the first I/O operation would be a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="0ed15-2048">W przypadku protokołów bezpołączeniowych Pierwsza operacja we/wy będzie dowolna z wywołań wysyłania lub odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2048">For connectionless protocols, the first I/O operation would be any of the send or receive calls.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2049">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2049">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-2050">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2050">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2051">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2051">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-2052">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2052">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-2053">Poniższy przykład kodu pobiera i wyświetla lokalne i zdalne punkty końcowe.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2053">The following code example retrieves and displays the local and remote endpoints.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2054">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2054">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2055"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2055">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-2056">Pobiera lub ustawia wartość określającą, czy wychodzące pakiety multiemisji są dostarczane do aplikacji wysyłającej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2056">Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.</span></span></summary>
        <value><span data-ttu-id="0ed15-2057"><see langword="true" />Jeśli odbiera wychodzące pakiety multiemisji; <see langword="false" />w przeciwnym razie. <see cref="T:System.Net.Sockets.Socket" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-2057"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> receives outgoing multicast packets; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2058">Multiemisja to skalowalna Metoda komunikacji wiele-do-wielu w Internecie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2058">Multicast is a scalable method for many-to-many communication on the Internet.</span></span> <span data-ttu-id="0ed15-2059">Proces subskrybuje adres multiemisji; następnie wszystkie pakiety wysyłane przez proces subskrybowany są odbierane przez każdy inny proces subskrybowany na adres multiemisji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2059">A process subscribes to a multicast address; then, any packets sent by a subscribed process are received by every other process subscribed to the multicast address.</span></span>  
  
 <span data-ttu-id="0ed15-2060">Ustawienie tej właściwości w gnieździe Transmission Control Protocol (TCP) nie będzie miało żadnego efektu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2060">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-2061">Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2061">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2062">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2062">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2063"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2063">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-2064">Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określającą, czy strumień <see cref="T:System.Net.Sockets.Socket" /> używa algorytmu nagle.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2064">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the stream <see cref="T:System.Net.Sockets.Socket" /> is using the Nagle algorithm.</span></span></summary>
        <value><span data-ttu-id="0ed15-2065"><see langword="false" />Jeśli używa algorytmu nagle; <see langword="true" />w przeciwnym razie. <see cref="T:System.Net.Sockets.Socket" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-2065"><see langword="false" /> if the <see cref="T:System.Net.Sockets.Socket" /> uses the Nagle algorithm; otherwise, <see langword="true" />.</span></span> <span data-ttu-id="0ed15-2066">Wartość domyślna to <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2066">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2067">Algorytm nagle został zaprojektowany w celu zmniejszenia ruchu sieciowego przez spowodowanie, że gniazdo buforuje małe pakiety, a następnie łączy i wysyła je w jednym pakiecie w pewnych okolicznościach.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2067">The Nagle algorithm is designed to reduce network traffic by causing the socket to buffer small packets and then combine and send them in one packet under certain circumstances.</span></span> <span data-ttu-id="0ed15-2068">Pakiet TCP składa się z 40 bajtów nagłówka i wysyłanych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2068">A TCP packet consists of 40 bytes of header plus the data being sent.</span></span> <span data-ttu-id="0ed15-2069">Gdy małe pakiety danych są wysyłane przy użyciu protokołu TCP, obciążenie wynikające z nagłówka TCP może stać się znaczną częścią ruchu sieciowego. W przypadku silnie załadowanej sieci Przeciążenie wynikające z tego obciążenia może spowodować utratę datagramów i retransmisji, a także nadmierny czas propagacji spowodowany przeciążeniem.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2069">When small packets of data are sent with TCP, the overhead resulting from the TCP header can become a significant part of the network traffic.On heavily loaded networks, the congestion resulting from this overhead can result in lost datagrams and retransmissions, as well as excessive propagation time caused by congestion.</span></span> <span data-ttu-id="0ed15-2070">Algorytm nagle hamuje wysłanie nowych wychodzących danych TCP segmentswhen przez użytkownika, jeśli jakiekolwiek dane previouslytransmitted połączenia nie zostaną potwierdzone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2070">The Nagle algorithm inhibits the sending of new TCP segmentswhen new outgoing data arrives from the user if any previouslytransmitted data on the connection remains unacknowledged.</span></span>  
  
 <span data-ttu-id="0ed15-2071">Większość aplikacji sieciowych powinna używać algorytmu nagle.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2071">The majority of network applications should use the Nagle algorithm.</span></span>  
  
 <span data-ttu-id="0ed15-2072">Ustawienie tej właściwości w gnieździe UDP (User Datagram Protocol) nie będzie miało żadnego efektu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2072">Setting this property on a User Datagram Protocol (UDP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-2073">Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.NoDelay%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2073">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.NoDelay%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2074">Wystąpił błąd podczas próby uzyskania dostępu <see cref="T:System.Net.Sockets.Socket" />do elementu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2074">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2075"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2075">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-2076">Wskazuje, czy podstawowy system operacyjny i karty sieciowe obsługują protokół internetowy w wersji 4 (IPv4).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2076">Indicates whether the underlying operating system and network adaptors support Internet Protocol version 4 (IPv4).</span></span></summary>
        <value><span data-ttu-id="0ed15-2077"><see langword="true" />Jeśli system operacyjny i adaptery sieciowe obsługują protokół IPv4; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-2077"><see langword="true" /> if the operating system and network adaptors support the IPv4 protocol; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2078">System operacyjny może obsługiwać zarówno Protokoły IPv4, jak i IPv6.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2078">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-2079">Wskazuje, czy podstawowy system operacyjny i karty sieciowe obsługują protokół internetowy w wersji 6 (IPv6).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2079">Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).</span></span></summary>
        <value><span data-ttu-id="0ed15-2080"><see langword="true" />Jeśli system operacyjny i karty sieciowe obsługują protokół IPv6; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-2080"><see langword="true" /> if the operating system and network adaptors support the IPv6 protocol; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2081">System operacyjny może obsługiwać zarówno Protokoły IPv4, jak i IPv6.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2081">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="microSeconds"><span data-ttu-id="0ed15-2082">Czas oczekiwania na odpowiedź w mikrosekundach.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2082">The time to wait for a response, in microseconds.</span></span></param>
        <param name="mode"><span data-ttu-id="0ed15-2083">Jedna z <see cref="T:System.Net.Sockets.SelectMode" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2083">One of the <see cref="T:System.Net.Sockets.SelectMode" /> values.</span></span></param>
        <summary><span data-ttu-id="0ed15-2084">Określa stan <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2084">Determines the status of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-2085">Stan <see cref="T:System.Net.Sockets.Socket" /> na podstawie wartości trybu sondowania przekazaną <paramref name="mode" /> w parametrze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2085">The status of the <see cref="T:System.Net.Sockets.Socket" /> based on the polling mode value passed in the <paramref name="mode" /> parameter.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="0ed15-2086">Tryb</span><span class="sxs-lookup"><span data-stu-id="0ed15-2086">Mode</span></span> 
 </term><description> <span data-ttu-id="0ed15-2087">Wartość zwracana</span><span class="sxs-lookup"><span data-stu-id="0ed15-2087">Return Value</span></span> 
 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><span data-ttu-id="0ed15-2088"><see langword="true" />Jeśli <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> został wywołany, a połączenie jest w stanie oczekiwania;</span><span class="sxs-lookup"><span data-stu-id="0ed15-2088"><see langword="true" /> if <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> has been called and a connection is pending;</span></span> 
<span data-ttu-id="0ed15-2089">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2089">-or-</span></span> 
 <span data-ttu-id="0ed15-2090"><see langword="true" />Jeśli dane są dostępne do odczytu;</span><span class="sxs-lookup"><span data-stu-id="0ed15-2090"><see langword="true" /> if data is available for reading;</span></span> 
<span data-ttu-id="0ed15-2091">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2091">-or-</span></span> 
 <span data-ttu-id="0ed15-2092"><see langword="true" />Jeśli połączenie zostało zamknięte, zresetowane lub przerwane;</span><span class="sxs-lookup"><span data-stu-id="0ed15-2092"><see langword="true" /> if the connection has been closed, reset, or terminated;</span></span> 
<span data-ttu-id="0ed15-2093">w przeciwnym razie <see langword="false" />zwraca.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2093">otherwise, returns <see langword="false" />.</span></span>  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><span data-ttu-id="0ed15-2094"><see langword="true" />, w przypadku przetwarzania <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />a, a połączenie zakończyło się pomyślnie;</span><span class="sxs-lookup"><span data-stu-id="0ed15-2094"><see langword="true" />, if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, and the connection has succeeded;</span></span> 
<span data-ttu-id="0ed15-2095">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2095">-or-</span></span> 
 <span data-ttu-id="0ed15-2096"><see langword="true" />Jeśli dane mogą być wysyłane;</span><span class="sxs-lookup"><span data-stu-id="0ed15-2096"><see langword="true" /> if data can be sent;</span></span> 
<span data-ttu-id="0ed15-2097">w przeciwnym razie <see langword="false" />zwraca.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2097">otherwise, returns <see langword="false" />.</span></span>  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description><span data-ttu-id="0ed15-2098"><see langword="true" />Jeśli przetwarzanie <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> , które nie jest blokowane, a połączenie nie powiodło się;</span><span class="sxs-lookup"><span data-stu-id="0ed15-2098"><see langword="true" /> if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> that does not block, and the connection has failed;</span></span> 
<span data-ttu-id="0ed15-2099">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2099">-or-</span></span> 
 <span data-ttu-id="0ed15-2100"><see langword="true" />Jeśli <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> nie jest ustawiona i dostępne są dane poza pasmem;</span><span class="sxs-lookup"><span data-stu-id="0ed15-2100"><see langword="true" /> if <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> is not set and out-of-band data is available;</span></span> 
<span data-ttu-id="0ed15-2101">w przeciwnym razie <see langword="false" />zwraca.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2101">otherwise, returns <see langword="false" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2102">Metoda sprawdzi stan <xref:System.Net.Sockets.Socket>. <xref:System.Net.Sockets.Socket.Poll%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-2102">The <xref:System.Net.Sockets.Socket.Poll%2A> method will check the state of the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-2103">Określ <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> parametr, aby określić, <xref:System.Net.Sockets.Socket> czy ma być możliwy do odczytu. `selectMode`</span><span class="sxs-lookup"><span data-stu-id="0ed15-2103">Specify <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> for the `selectMode` parameter to determine if the <xref:System.Net.Sockets.Socket> is readable.</span></span> <span data-ttu-id="0ed15-2104">Określ <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> , aby określić, <xref:System.Net.Sockets.Socket> czy ma być zapisywalny.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2104">Specify <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> to determine if the <xref:System.Net.Sockets.Socket> is writable.</span></span> <span data-ttu-id="0ed15-2105">Użyj <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> , aby wykryć warunek błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2105">Use <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> to detect an error condition.</span></span> <span data-ttu-id="0ed15-2106"><xref:System.Net.Sockets.Socket.Poll%2A>spowoduje zablokowanie wykonania do określonego przedziału czasu `microseconds`, mierzoną w, upłynie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2106"><xref:System.Net.Sockets.Socket.Poll%2A> will block execution until the specified time period, measured in `microseconds`, elapses.</span></span> <span data-ttu-id="0ed15-2107">`microSeconds` Ustaw parametr na ujemną liczbę całkowitą, jeśli chcesz czekać w nieskończoność na odpowiedź.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2107">Set the `microSeconds` parameter to a negative integer if you would like to wait indefinitely for a response.</span></span> <span data-ttu-id="0ed15-2108">Jeśli chcesz sprawdzić stan wielu gniazd, warto użyć <xref:System.Net.Sockets.Socket.Select%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2108">If you want to check the status of multiple sockets, you might prefer to use the <xref:System.Net.Sockets.Socket.Select%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2109">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2109">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-2110">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2110">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2111">Ta metoda nie może wykryć niektórych rodzajów problemów z połączeniami, takich jak przerwany kabel sieciowy lub że host zdalny został zamknięty nieprawidłowo.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2111">This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</span></span> <span data-ttu-id="0ed15-2112">Należy podjąć próbę wysłania lub odebrania danych w celu wykrycia tego rodzaju błędów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2112">You must attempt to send or receive data to detect these kinds of errors.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2113">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2113">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-2114">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2114">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-2115">Poniższy przykład kodu tworzy gniazdo, nawiązuje połączenie z serwerem i używa <xref:System.Net.Sockets.Socket.Poll%2A> do sprawdzenia stanu gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2115">The following code example creates a socket, connects to a server, and uses <xref:System.Net.Sockets.Socket.Poll%2A> to check the status of the socket.</span></span>  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-2116">Parametr nie jest jedną <see cref="T:System.Net.Sockets.SelectMode" /> z wartości. <paramref name="mode" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-2116">The <paramref name="mode" /> parameter is not one of the <see cref="T:System.Net.Sockets.SelectMode" /> values.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2117">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2117">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="0ed15-2118">Zobacz uwagi poniżej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2118">See remarks below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2119"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2119">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-2120">Pobiera typ <see cref="T:System.Net.Sockets.Socket" />protokołu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2120">Gets the protocol type of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="0ed15-2121">Jedna z <see cref="T:System.Net.Sockets.ProtocolType" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2121">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2122">Właściwość jest ustawiana <xref:System.Net.Sockets.Socket> podczas tworzenia i określa protokół używany przez program <xref:System.Net.Sockets.Socket>. <xref:System.Net.Sockets.Socket.ProtocolType%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-2122">The <xref:System.Net.Sockets.Socket.ProtocolType%2A> property is set when the <xref:System.Net.Sockets.Socket> is created, and specifies the protocol used by that <xref:System.Net.Sockets.Socket>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-2123">Poniższy przykład kodu wyświetla <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, i <xref:System.Net.Sockets.ProtocolType> do konsoli programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2123">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ed15-2124">Odbiera dane z powiązania <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2124">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-2125">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2125">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <summary><span data-ttu-id="0ed15-2126">Odbiera dane ze powiązanego <see cref="T:System.Net.Sockets.Socket" /> buforu odbioru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2126">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer.</span></span></summary>
        <returns><span data-ttu-id="0ed15-2127">Liczba odebranych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2127">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2128"><xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczytuje dane do parametru buforu i zwraca liczbę pomyślnie odczytywanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2128">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="0ed15-2129">Można wywoływać <xref:System.Net.Sockets.Socket.Receive%2A> zarówno gniazda zorientowane na połączenia, jak i bezpołączeni.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2129">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="0ed15-2130">To Przeciążenie wymaga tylko podania buforu odbioru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2130">This overload only requires you to provide a receive buffer.</span></span> <span data-ttu-id="0ed15-2131">Wartość domyślna przesunięcia buforu równa 0, rozmiar domyślny to długość parametru buforu, a wartością <xref:System.Net.Sockets.SocketFlags> <xref:System.Net.Sockets.SocketFlags.None>domyślną jest.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2131">The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="0ed15-2132">W przypadku korzystania z protokołu zorientowanego na połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym lub <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenie przychodzące przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2132">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="0ed15-2133">Metoda będzie odczytywać tylko dane przychodzące z hosta zdalnego ustanowione <xref:System.Net.Sockets.Socket.Connect%2A> w lub <xref:System.Net.Sockets.Socket.Accept%2A> w metodzie. <xref:System.Net.Sockets.Socket.Receive%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-2133">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="0ed15-2134">Jeśli używasz bezpołączeniowego protokołu, możesz również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2134">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="0ed15-2135"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A>pozwoli Ci odbierać dane przychodzące z dowolnego hosta.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2135"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="0ed15-2136">Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie Zablokowani do momentu udostępnienia danych, chyba że wartość limitu czasu została ustawiona <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>przy użyciu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2136">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0ed15-2137">W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Receive%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2137">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2138">Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w buforze stosu protokołu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie zakończona natychmiast i <xref:System.Net.Sockets.SocketException>zostanie wyświetlona.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2138">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2139">Możesz użyć właściwości, <xref:System.Net.Sockets.Socket.Available%2A> aby określić, czy dane są dostępne do odczytu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2139">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="0ed15-2140">Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2140">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="0ed15-2141">Jeśli używasz zorientowanej <xref:System.Net.Sockets.Socket>na połączenie <xref:System.Net.Sockets.Socket.Receive%2A> , Metoda odczytaje tyle danych, ile jest dostępnych, aż do rozmiaru buforu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2141">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="0ed15-2142">Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2142">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="0ed15-2143">Jeśli używasz bezpołączeniowego <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> program odczytaje pierwszy datagram umieszczony w kolejce na <xref:System.Net.Sockets.Socket.Connect%2A> adres docelowy określony w metodzie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2143">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="0ed15-2144">Jeśli odbierany datagram jest większy niż rozmiar `buffer` parametru, `buffer` jest wypełniany pierwszą częścią komunikatu, nadmiarowe <xref:System.Net.Sockets.SocketException> dane są tracone i zostaje zgłoszone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2144">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2145">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2145">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-2146">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2146">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2147">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2147">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-2148">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2148">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-2149">Poniższy przykład kodu odbiera dane połączone <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2149">The following code example receives data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-2150"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2150"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2151">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2151">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2152"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2152">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0ed15-2153">Obiekt wywołujący w stosie wywołań nie ma wymaganych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2153">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="0ed15-2154">do akceptowania połączeń z sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2154">for accepting connections from the network.</span></span> <span data-ttu-id="0ed15-2155">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2155">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="0ed15-2156">Lista <see cref="T:System.ArraySegment`1" />s typu <see cref="T:System.Byte" /> , która zawiera odebrane dane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2156">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span></span></param>
        <summary><span data-ttu-id="0ed15-2157">Odbiera dane ze powiązanego <see cref="T:System.Net.Sockets.Socket" /> z listą buforów odbioru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2157">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers.</span></span></summary>
        <returns><span data-ttu-id="0ed15-2158">Liczba odebranych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2158">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2159">Ta metoda odczytuje dane do parametru buffers i zwraca liczbę pomyślnie odczytywanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2159">This method reads data into the buffers parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="0ed15-2160">Można wywoływać zarówno gniazda zorientowane na połączenia, jak i bezpołączeni.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2160">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="0ed15-2161">To Przeciążenie wymaga podania co najmniej jednego bufora odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2161">This overload requires you to provide one or more receive buffers.</span></span>  
  
 <span data-ttu-id="0ed15-2162">W przypadku korzystania z protokołu zorientowanego na połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym lub <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenie przychodzące przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2162">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="0ed15-2163">Metoda będzie odczytywać tylko dane przychodzące z połączenia hosta zdalnego ustanowione <xref:System.Net.Sockets.Socket.Connect%2A> w metodzie lub <xref:System.Net.Sockets.Socket.Accept%2A>. <xref:System.Net.Sockets.Socket.Receive%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-2163">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="0ed15-2164">Jeśli używasz bezpołączeniowego protokołu, możesz również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2164">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="0ed15-2165"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A>pozwoli Ci odbierać dane przychodzące z dowolnego hosta.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2165"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="0ed15-2166">Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie Zablokowani do momentu udostępnienia danych, chyba że wartość limitu czasu została ustawiona <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>przy użyciu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2166">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0ed15-2167">W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Receive%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2167">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2168">Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w buforze stosu protokołu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie zakończona natychmiast i <xref:System.Net.Sockets.SocketException>zostanie wyświetlona.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2168">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2169">Możesz użyć właściwości, <xref:System.Net.Sockets.Socket.Available%2A> aby określić, czy dane są dostępne do odczytu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2169">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="0ed15-2170">Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2170">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="0ed15-2171">Jeśli używasz zorientowanej <xref:System.Net.Sockets.Socket>na połączenie <xref:System.Net.Sockets.Socket.Receive%2A> , Metoda odczytaje tyle danych, ile jest dostępnych, aż do rozmiaru buforu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2171">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="0ed15-2172">Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2172">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="0ed15-2173">Jeśli używasz bezpołączeniowego <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> Odczytaj pierwszy z kolejki w kolejce na <xref:System.Net.Sockets.Socket.Connect%2A> adres docelowy określony w metodzie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2173">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="0ed15-2174">Jeśli odbierany datagram jest większy niż rozmiar `buffers` parametru, `buffers` jest wypełniany pierwszą częścią komunikatu, nadmiarowe <xref:System.Net.Sockets.SocketException> dane są tracone i zostaje zgłoszone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2174">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2175">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2175">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-2176">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2176">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="0ed15-2177">**Uwaga** Ten element członkowski wyprowadza informacje o śledzeniu po włączeniu śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2177">**Note** This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-2178">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2178">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-2179">Parametr ma wartość <see langword="null" />. <paramref name="buffer" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-2179">The <paramref name="buffer" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2180">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2180">An error occurred while attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2181"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2181">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-2182">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2182">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-2183">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2183">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="0ed15-2184">Odbiera dane ze powiązanego <see cref="T:System.Net.Sockets.Socket" /> buforu odbioru przy użyciu określonej <see cref="T:System.Net.Sockets.SocketFlags" />wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2184">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-2185">Liczba odebranych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2185">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2186"><xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczytuje dane do parametru buforu i zwraca liczbę pomyślnie odczytywanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2186">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="0ed15-2187">Można wywoływać <xref:System.Net.Sockets.Socket.Receive%2A> zarówno gniazda zorientowane na połączenia, jak i bezpołączeni.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2187">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="0ed15-2188">To Przeciążenie wymaga jedynie podania buforu odbioru i niezbędne <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2188">This overload only requires you to provide a receive buffer and the necessary <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="0ed15-2189">Wartość domyślna przesunięcia buforu to 0, a wartość domyślna to długość parametru Byte.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2189">The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.</span></span>  
  
 <span data-ttu-id="0ed15-2190">W przypadku korzystania z protokołu zorientowanego na połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym lub <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenie przychodzące przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2190">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="0ed15-2191">Metoda będzie odczytywać tylko dane przychodzące z hosta zdalnego ustanowione <xref:System.Net.Sockets.Socket.Connect%2A> w lub <xref:System.Net.Sockets.Socket.Accept%2A> w metodzie. <xref:System.Net.Sockets.Socket.Receive%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-2191">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="0ed15-2192">Jeśli używasz bezpołączeniowego protokołu, możesz również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2192">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="0ed15-2193"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A>pozwoli Ci odbierać dane przychodzące z dowolnego hosta.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2193"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="0ed15-2194">Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie zablokowana do momentu udostępnienia danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2194">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available.</span></span> <span data-ttu-id="0ed15-2195">Jeśli jesteś w trybie bez blokowania i w buforze stosu protokołu nie ma dostępnych danych, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie zakończona natychmiast i <xref:System.Net.Sockets.SocketException>zostanie wyświetlona.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2195">If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2196">Możesz użyć właściwości, <xref:System.Net.Sockets.Socket.Available%2A> aby określić, czy dane są dostępne do odczytu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2196">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="0ed15-2197">Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2197">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.</span></span>  
  
 <span data-ttu-id="0ed15-2198">Jeśli używasz zorientowanej <xref:System.Net.Sockets.Socket>na połączenie <xref:System.Net.Sockets.Socket.Receive%2A> , Metoda odczyta tyle danych, ile jest dostępnych do rozmiaru buforu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2198">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available up to the size of the buffer.</span></span> <span data-ttu-id="0ed15-2199">Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2199">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="0ed15-2200">Jeśli używasz bezpołączeniowego <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> Odczytaj pierwszy z kolejki w kolejce na <xref:System.Net.Sockets.Socket.Connect%2A> adres docelowy określony w metodzie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2200">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="0ed15-2201">Jeśli odbierany datagram jest większy niż rozmiar `buffer` parametru, `buffer` jest wypełniany pierwszą częścią komunikatu, nadmiarowe <xref:System.Net.Sockets.SocketException> dane są tracone i zostaje zgłoszone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2201">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2202">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2202">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-2203">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2203">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2204">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2204">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-2205">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2205">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-2206">Poniższy przykład kodu określa bufor danych i <xref:System.Net.Sockets.SocketFlags> do odbioru danych przy użyciu połączenia. <xref:System.Net.Sockets.Socket></span><span class="sxs-lookup"><span data-stu-id="0ed15-2206">The following code example specifies a data buffer, and <xref:System.Net.Sockets.SocketFlags> for receiving data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-2207"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2207"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2208">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2208">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2209"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2209">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0ed15-2210">Obiekt wywołujący w stosie wywołań nie ma wymaganych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2210">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="0ed15-2211">do akceptowania połączeń z sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2211">for accepting connections from the network.</span></span> <span data-ttu-id="0ed15-2212">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2212">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="0ed15-2213">Lista <see cref="T:System.ArraySegment`1" />s typu <see cref="T:System.Byte" /> , która zawiera odebrane dane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2213">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-2214">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2214">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="0ed15-2215">Odbiera dane z powiązanego <see cref="T:System.Net.Sockets.Socket" /> z listą buforów odbioru przy użyciu określonej <see cref="T:System.Net.Sockets.SocketFlags" />wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2215">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-2216">Liczba odebranych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2216">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2217">Ta metoda odczytuje dane do `buffers` parametru i zwraca liczbę pomyślnie odczytywanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2217">This method reads data into the `buffers` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="0ed15-2218">Można wywoływać zarówno gniazda zorientowane na połączenia, jak i bezpołączeni.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2218">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="0ed15-2219">To Przeciążenie wymaga podania co najmniej jednego bufora odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2219">This overload requires you to provide one or more receive buffers.</span></span> <span data-ttu-id="0ed15-2220"><xref:System.Net.Sockets.SocketFlags> Wartość Domyślna<xref:System.Net.Sockets.SocketFlags.None>to.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2220">The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="0ed15-2221">W przypadku korzystania z protokołu zorientowanego na połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym lub <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenie przychodzące przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2221">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="0ed15-2222">Metoda będzie odczytywać tylko dane przychodzące z połączenia hosta zdalnego ustanowione <xref:System.Net.Sockets.Socket.Connect%2A> w metodzie lub <xref:System.Net.Sockets.Socket.Accept%2A>. <xref:System.Net.Sockets.Socket.Receive%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-2222">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="0ed15-2223">Jeśli używasz bezpołączeniowego protokołu, możesz również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2223">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="0ed15-2224"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A>pozwoli Ci odbierać dane przychodzące z dowolnego hosta.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2224"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="0ed15-2225">Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie Zablokowani do momentu udostępnienia danych, chyba że wartość limitu czasu została ustawiona <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>przy użyciu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2225">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0ed15-2226">W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Receive%2A> limitu czasu wywołanie <xref:System.Net.Sockets.SocketException>wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2226">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2227">Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w buforze stosu protokołu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie zakończona natychmiast i <xref:System.Net.Sockets.SocketException>zostanie wyświetlona.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2227">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2228">Możesz użyć właściwości, <xref:System.Net.Sockets.Socket.Available%2A> aby określić, czy dane są dostępne do odczytu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2228">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="0ed15-2229">Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2229">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="0ed15-2230">Jeśli używasz zorientowanej <xref:System.Net.Sockets.Socket>na połączenie <xref:System.Net.Sockets.Socket.Receive%2A> , Metoda odczytaje tyle danych, ile jest dostępnych, aż do rozmiaru buforu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2230">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="0ed15-2231">Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2231">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="0ed15-2232">Jeśli używasz bezpołączeniowego <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> Odczytaj pierwszy z kolejki w kolejce na <xref:System.Net.Sockets.Socket.Connect%2A> adres docelowy określony w metodzie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2232">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="0ed15-2233">Jeśli odbierany datagram jest większy niż rozmiar `buffers` parametru, `buffers` jest wypełniany pierwszą częścią komunikatu, nadmiarowe <xref:System.Net.Sockets.SocketException> dane są tracone i zostaje zgłoszone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2233">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2234">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2234">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-2235">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2235">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2236">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2236">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-2237">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2237">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-2238">Poniższy przykład kodu demonstruje, jak odbierać dane połączone <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2238">The following code example demonstrates how to receive data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-2239"><paramref name="buffers" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2239"><paramref name="buffers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ed15-2240">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2240">-or-</span></span> 
 <span data-ttu-id="0ed15-2241"><paramref name="buffers" />. Liczba jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2241"><paramref name="buffers" />.Count is zero.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2242">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2242">An error occurred while attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2243"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2243">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="0ed15-2244">do akceptowania połączeń z sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2244">for accepting connections from the network.</span></span> <span data-ttu-id="0ed15-2245">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2245">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-2246">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2246">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="size"><span data-ttu-id="0ed15-2247">Liczba bajtów do odebrania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2247">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-2248">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2248">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="0ed15-2249">Odbiera określoną liczbę bajtów danych z <see cref="T:System.Net.Sockets.Socket" /> podanego w buforze odbioru przy użyciu określonego. <see cref="T:System.Net.Sockets.SocketFlags" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-2249">Receives the specified number of bytes of data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-2250">Liczba odebranych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2250">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2251">Metoda odczytuje dane `buffer` do parametru i zwraca liczbę pomyślnie odczytywanych bajtów. <xref:System.Net.Sockets.Socket.Receive%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-2251">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the `buffer` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="0ed15-2252">Można wywoływać <xref:System.Net.Sockets.Socket.Receive%2A> zarówno gniazda zorientowane na połączenia, jak i bezpołączeni.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2252">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="0ed15-2253">To Przeciążenie wymaga tylko podania buforu odbioru, liczby bajtów, które mają być odbierane, oraz potrzeb <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2253">This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 <span data-ttu-id="0ed15-2254">W przypadku korzystania z protokołu zorientowanego na połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym lub <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenie przychodzące przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2254">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="0ed15-2255">Metoda będzie odczytywać tylko dane przychodzące z hosta zdalnego ustanowione <xref:System.Net.Sockets.Socket.Connect%2A> w lub <xref:System.Net.Sockets.Socket.Accept%2A> w metodzie. <xref:System.Net.Sockets.Socket.Receive%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-2255">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="0ed15-2256">Jeśli używasz bezpołączeniowego protokołu, możesz również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2256">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="0ed15-2257"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A>pozwoli Ci odbierać dane przychodzące z dowolnego hosta.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2257"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="0ed15-2258">Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie Zablokowani do momentu udostępnienia danych, chyba że wartość limitu czasu została ustawiona <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>przy użyciu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2258">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0ed15-2259">W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Receive%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2259">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2260">Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w buforze stosu protokołu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie zakończona natychmiast i <xref:System.Net.Sockets.SocketException>zostanie wyświetlona.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2260">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2261">Możesz użyć właściwości, <xref:System.Net.Sockets.Socket.Available%2A> aby określić, czy dane są dostępne do odczytu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2261">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="0ed15-2262">Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2262">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.</span></span>  
  
 <span data-ttu-id="0ed15-2263">Jeśli używasz zorientowanym <xref:System.Net.Sockets.Socket>na połączenie <xref:System.Net.Sockets.Socket.Receive%2A> , Metoda odczytaje tyle danych, ile jest dostępnych, do liczby bajtów określonej przez `size` parametr.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2263">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="0ed15-2264">Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2264">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="0ed15-2265">Jeśli używasz bezpołączeniowego <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> program odczytaje pierwszy datagram umieszczony w kolejce na <xref:System.Net.Sockets.Socket.Connect%2A> adres docelowy określony w metodzie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2265">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="0ed15-2266">Jeśli odbierany datagram jest większy niż rozmiar `buffer` parametru, `buffer` jest wypełniany pierwszą częścią komunikatu, nadmiarowe <xref:System.Net.Sockets.SocketException> dane są tracone i zostaje zgłoszone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2266">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2267">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2267">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-2268">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2268">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2269">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2269">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-2270">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2270">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-2271">Poniżej odbiera dane Znalezione w `buffer`i określa <xref:System.Net.Sockets.SocketFlags.None> dla <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2271">The following receives the data found into `buffer`, and specifies <xref:System.Net.Sockets.SocketFlags.None> for <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 [!code-cpp[Socket_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-2272"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2272"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-2273"><paramref name="size" />przekracza rozmiar <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2273"><paramref name="size" /> exceeds the size of <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2274">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2274">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2275"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2275">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0ed15-2276">Obiekt wywołujący w stosie wywołań nie ma wymaganych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2276">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="0ed15-2277">do akceptowania połączeń z sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2277">for accepting connections from the network.</span></span> <span data-ttu-id="0ed15-2278">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2278">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="0ed15-2279">Lista <see cref="T:System.ArraySegment`1" />s typu <see cref="T:System.Byte" /> , która zawiera odebrane dane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2279">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-2280">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2280">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="0ed15-2281"><see cref="T:System.Net.Sockets.SocketError" /> Obiekt, który przechowuje błąd gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2281">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="0ed15-2282">Odbiera dane z powiązanego <see cref="T:System.Net.Sockets.Socket" /> z listą buforów odbioru przy użyciu określonej <see cref="T:System.Net.Sockets.SocketFlags" />wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2282">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-2283">Liczba odebranych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2283">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2284">Ta metoda odczytuje dane do `buffers` parametru i zwraca liczbę pomyślnie odczytywanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2284">This method reads data into the `buffers` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="0ed15-2285">Można wywoływać zarówno gniazda zorientowane na połączenia, jak i bezpołączeni.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2285">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="0ed15-2286">To Przeciążenie wymaga podania co najmniej jednego bufora odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2286">This overload requires you to provide one or more receive buffers.</span></span> <span data-ttu-id="0ed15-2287"><xref:System.Net.Sockets.SocketFlags> Wartość Domyślna<xref:System.Net.Sockets.SocketFlags.None>to.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2287">The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="0ed15-2288">W przypadku korzystania z protokołu zorientowanego na połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym lub <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenie przychodzące przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2288">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="0ed15-2289">Metoda będzie odczytywać tylko dane przychodzące z połączenia hosta zdalnego ustanowione <xref:System.Net.Sockets.Socket.Connect%2A> w metodzie lub <xref:System.Net.Sockets.Socket.Accept%2A>. <xref:System.Net.Sockets.Socket.Receive%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-2289">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="0ed15-2290">Jeśli używasz bezpołączeniowego protokołu, możesz również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2290">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="0ed15-2291"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A>pozwoli Ci odbierać dane przychodzące z dowolnego hosta.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2291"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="0ed15-2292">Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie Zablokowani do momentu udostępnienia danych, chyba że wartość limitu czasu została ustawiona <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>przy użyciu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2292">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0ed15-2293">W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Receive%2A> limitu czasu wywołanie <xref:System.Net.Sockets.SocketException>wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2293">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2294">Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w buforze stosu protokołu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie zakończona natychmiast i <xref:System.Net.Sockets.SocketException>zostanie wyświetlona.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2294">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2295">Możesz użyć właściwości, <xref:System.Net.Sockets.Socket.Available%2A> aby określić, czy dane są dostępne do odczytu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2295">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="0ed15-2296">Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2296">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="0ed15-2297">Jeśli używasz zorientowanej <xref:System.Net.Sockets.Socket>na połączenie <xref:System.Net.Sockets.Socket.Receive%2A> , Metoda odczytaje tyle danych, ile jest dostępnych, aż do rozmiaru buforu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2297">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="0ed15-2298">Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2298">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="0ed15-2299">Jeśli używasz bezpołączeniowego <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> program odczytaje pierwszy datagram umieszczony w kolejce na <xref:System.Net.Sockets.Socket.Connect%2A> adres docelowy określony w metodzie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2299">If you are using a connectionless <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="0ed15-2300">Jeśli odbierany datagram jest większy niż rozmiar `buffers` parametru, `buffers` jest wypełniany pierwszą częścią komunikatu, nadmiarowe <xref:System.Net.Sockets.SocketException> dane są tracone i zostaje zgłoszone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2300">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2301">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2301">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-2302">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2302">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2303">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2303">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-2304">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2304">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-2305"><paramref name="buffers" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2305"><paramref name="buffers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ed15-2306">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2306">-or-</span></span> 
 <span data-ttu-id="0ed15-2307"><paramref name="buffers" />. Liczba jest równa zero.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2307"><paramref name="buffers" />.Count is zero.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2308">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2308">An error occurred while attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2309"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2309">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="0ed15-2310">do akceptowania połączeń z sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2310">for accepting connections from the network.</span></span> <span data-ttu-id="0ed15-2311">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2311">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-2312">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2312">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="offset"><span data-ttu-id="0ed15-2313">Lokalizacja w programie <paramref name="buffer" /> do przechowywania odebranych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2313">The location in <paramref name="buffer" /> to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="0ed15-2314">Liczba bajtów do odebrania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2314">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-2315">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2315">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="0ed15-2316">Odbiera określoną liczbę bajtów od powiązanej <see cref="T:System.Net.Sockets.Socket" /> do określonej pozycji przesunięcia buforu odbioru, używając określonej <see cref="T:System.Net.Sockets.SocketFlags" />wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2316">Receives the specified number of bytes from a bound <see cref="T:System.Net.Sockets.Socket" /> into the specified offset position of the receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-2317">Liczba odebranych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2317">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2318"><xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczytuje dane do parametru buforu i zwraca liczbę pomyślnie odczytywanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2318">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="0ed15-2319">Można wywoływać <xref:System.Net.Sockets.Socket.Receive%2A> zarówno gniazda zorientowane na połączenia, jak i bezpołączeni.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2319">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="0ed15-2320">W przypadku korzystania z protokołu zorientowanego na połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym lub <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenie przychodzące przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2320">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="0ed15-2321">Metoda będzie odczytywać tylko dane przychodzące z hosta zdalnego ustanowione <xref:System.Net.Sockets.Socket.Connect%2A> w lub <xref:System.Net.Sockets.Socket.Accept%2A> w metodzie. <xref:System.Net.Sockets.Socket.Receive%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-2321">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="0ed15-2322">Jeśli używasz bezpołączeniowego protokołu, możesz również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2322">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="0ed15-2323"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A>pozwoli Ci odbierać dane przychodzące z dowolnego hosta.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2323"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="0ed15-2324">Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie Zablokowani do momentu udostępnienia danych, chyba że wartość limitu czasu została ustawiona <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>przy użyciu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2324">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0ed15-2325">W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Receive%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2325">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2326">Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w buforze stosu protokołu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie zakończona natychmiast i <xref:System.Net.Sockets.SocketException>zostanie wyświetlona.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2326">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2327">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2327">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="0ed15-2328">Zobacz uwagi poniżej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2328">See Remarks below.</span></span> <span data-ttu-id="0ed15-2329">Możesz użyć właściwości, <xref:System.Net.Sockets.Socket.Available%2A> aby określić, czy dane są dostępne do odczytu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2329">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="0ed15-2330">Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2330">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="0ed15-2331">Jeśli używasz zorientowanej <xref:System.Net.Sockets.Socket>na połączenie <xref:System.Net.Sockets.Socket.Receive%2A> , Metoda odczytaje tyle danych, ile jest dostępnych, do liczby bajtów określonej przez parametr size.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2331">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter.</span></span> <span data-ttu-id="0ed15-2332">Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2332">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="0ed15-2333">Jeśli używasz bezpołączeniowego <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> program odczytaje pierwszy datagram umieszczony w kolejce na <xref:System.Net.Sockets.Socket.Connect%2A> adres docelowy określony w metodzie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2333">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="0ed15-2334">Jeśli odbierany datagram jest większy niż rozmiar `buffer` parametru, `buffer` jest wypełniany pierwszą częścią komunikatu, nadmiarowe <xref:System.Net.Sockets.SocketException> dane są tracone i zostaje zgłoszone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2334">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2335">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2335">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-2336">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2336">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2337">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2337">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-2338">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2338">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-2339">Poniższy przykład kodu określa bufor danych, przesunięcie, rozmiar i flagę gniazda przed odebraniem danych w połączonym <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2339">The following code example specifies a data buffer, an offset, a size, and a socket flag before receiving data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-2340"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2340"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-2341"><paramref name="offset" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2341"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-2342">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2342">-or-</span></span> 
 <span data-ttu-id="0ed15-2343"><paramref name="offset" />jest większa niż długość <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2343"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="0ed15-2344">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2344">-or-</span></span> 
 <span data-ttu-id="0ed15-2345"><paramref name="size" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2345"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-2346">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2346">-or-</span></span> 
 <span data-ttu-id="0ed15-2347"><paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości <paramref name="offset" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2347"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2348"><paramref name="socketFlags" />nie jest prawidłową kombinacją wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2348"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="0ed15-2349">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2349">-or-</span></span> 
<span data-ttu-id="0ed15-2350"><see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> Właściwość nie została ustawiona.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2350">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
<span data-ttu-id="0ed15-2351">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2351">-or-</span></span> 
<span data-ttu-id="0ed15-2352">Wystąpił błąd systemu operacyjnego podczas uzyskiwania dostępu <see cref="T:System.Net.Sockets.Socket" />do programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2352">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2353"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2353">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0ed15-2354">Obiekt wywołujący w stosie wywołań nie ma wymaganych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2354">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="0ed15-2355">do akceptowania połączeń z sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2355">for accepting connections from the network.</span></span> <span data-ttu-id="0ed15-2356">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2356">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-2357">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2357">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="0ed15-2358">Pozycja w <paramref name="buffer" /> parametrze do przechowywania odebranych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2358">The position in the <paramref name="buffer" /> parameter to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="0ed15-2359">Liczba bajtów do odebrania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2359">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-2360">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2360">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="0ed15-2361"><see cref="T:System.Net.Sockets.SocketError" /> Obiekt, który przechowuje błąd gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2361">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="0ed15-2362">Odbiera dane ze powiązanego <see cref="T:System.Net.Sockets.Socket" /> buforu odbioru przy użyciu określonej <see cref="T:System.Net.Sockets.SocketFlags" />wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2362">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-2363">Liczba odebranych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2363">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2364"><xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczytuje dane do parametru buforu i zwraca liczbę pomyślnie odczytywanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2364">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="0ed15-2365">Można wywoływać <xref:System.Net.Sockets.Socket.Receive%2A> zarówno gniazda zorientowane na połączenia, jak i bezpołączeni.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2365">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="0ed15-2366">W przypadku korzystania z protokołu zorientowanego na połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym lub <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenie przychodzące przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2366">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="0ed15-2367">Metoda będzie odczytywać tylko dane przychodzące z hosta zdalnego ustanowione <xref:System.Net.Sockets.Socket.Connect%2A> w lub <xref:System.Net.Sockets.Socket.Accept%2A> w metodzie. <xref:System.Net.Sockets.Socket.Receive%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-2367">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="0ed15-2368">Jeśli używasz bezpołączeniowego protokołu, możesz również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2368">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="0ed15-2369"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A>pozwoli Ci odbierać dane przychodzące z dowolnego hosta.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2369"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="0ed15-2370">Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie Zablokowani do momentu udostępnienia danych, chyba że wartość limitu czasu została ustawiona <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>przy użyciu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2370">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0ed15-2371">W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Receive%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2371">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2372">Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w buforze stosu protokołu, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zostanie zakończona natychmiast i <xref:System.Net.Sockets.SocketException>zostanie wyświetlona.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2372">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2373">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2373">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="0ed15-2374">Zobacz uwagi poniżej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2374">See Remarks below.</span></span> <span data-ttu-id="0ed15-2375">Możesz użyć właściwości, <xref:System.Net.Sockets.Socket.Available%2A> aby określić, czy dane są dostępne do odczytu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2375">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="0ed15-2376">Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2376">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="0ed15-2377">Jeśli używasz zorientowanej <xref:System.Net.Sockets.Socket>na połączenie <xref:System.Net.Sockets.Socket.Receive%2A> , Metoda odczytaje tyle danych, ile jest dostępnych, do liczby bajtów określonej przez parametr size.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2377">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter.</span></span> <span data-ttu-id="0ed15-2378">Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.Receive%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2378">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="0ed15-2379">Jeśli używasz bezpołączeniowego <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> program odczytaje pierwszy datagram umieszczony w kolejce na <xref:System.Net.Sockets.Socket.Connect%2A> adres docelowy określony w metodzie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2379">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="0ed15-2380">Jeśli odbierany datagram jest większy niż rozmiar `buffer` parametru, `buffer` jest wypełniany pierwszą częścią komunikatu, nadmiarowe <xref:System.Net.Sockets.SocketException> dane są tracone i zostaje zgłoszone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2380">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2381">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2381">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-2382">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2382">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2383">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2383">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-2384">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2384">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-2385"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2385"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-2386"><paramref name="offset" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2386"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-2387">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2387">-or-</span></span> 
 <span data-ttu-id="0ed15-2388"><paramref name="offset" />jest większa niż długość <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2388"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="0ed15-2389">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2389">-or-</span></span> 
 <span data-ttu-id="0ed15-2390"><paramref name="size" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2390"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-2391">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2391">-or-</span></span> 
 <span data-ttu-id="0ed15-2392"><paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości <paramref name="offset" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2392"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2393"><paramref name="socketFlags" />nie jest prawidłową kombinacją wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2393"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="0ed15-2394">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2394">-or-</span></span> 
<span data-ttu-id="0ed15-2395"><see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> Właściwość nie jest ustawiona.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2395">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property is not set.</span></span>  
  
<span data-ttu-id="0ed15-2396">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2396">-or-</span></span> 
<span data-ttu-id="0ed15-2397">Wystąpił błąd systemu operacyjnego podczas uzyskiwania dostępu <see cref="T:System.Net.Sockets.Socket" />do programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2397">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2398"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2398">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0ed15-2399">Obiekt wywołujący w stosie wywołań nie ma wymaganych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2399">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="0ed15-2400">do akceptowania połączeń z sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2400">for accepting connections from the network.</span></span> <span data-ttu-id="0ed15-2401">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2401">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="0ed15-2402">Obiekt <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> , który ma być używany dla tej asynchronicznej operacji gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2402">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="0ed15-2403">Rozpoczyna asynchroniczne żądanie odbierania danych z połączonego <see cref="T:System.Net.Sockets.Socket" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2403">Begins an asynchronous request to receive data from a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="0ed15-2404"><see langword="true" />Jeśli operacja we/wy jest w stanie oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2404"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="0ed15-2405"><see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie<paramref name="e" /> na parametrze zostanie wywołane po zakończeniu operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2405">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="0ed15-2406"><see langword="false" />Jeśli operacja we/wy została ukończona synchronicznie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2406"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="0ed15-2407">W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie <paramref name="e" /> na parametrze <paramref name="e" /> nie zostanie zgłoszone i obiekt przenoszony jako parametr może zostać zbadany natychmiast po wywołaniu metody, aby pobrać wynik operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2407">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2408"><xref:System.Net.Sockets.Socket.ReceiveAsync%2A> Metoda jest używana w podłączonych gniazdach lub powiązanych gniazdach bezpołączeni i służy do odczytywania danych przychodzących.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2408">The <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method is used on connected sockets or bound connectionless sockets and is used to read incoming data.</span></span> <span data-ttu-id="0ed15-2409">Adres lokalny gniazda musi być znany.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2409">The socket's local address must be known.</span></span>  
  
 <span data-ttu-id="0ed15-2410">W przypadku powiązanych bezpołączeniowych gniazd ta funkcja ogranicza adresy, z których odebrane komunikaty są akceptowane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2410">For bound connectionless sockets, this function restricts the addresses from which received messages are accepted.</span></span> <span data-ttu-id="0ed15-2411">Funkcja zwraca tylko komunikaty z adresu zdalnego określonego w połączeniu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2411">The function only returns messages from the remote address specified in the connection.</span></span> <span data-ttu-id="0ed15-2412">Komunikaty z innych adresów są dyskretnie odrzucane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2412">Messages from other addresses are silently discarded.</span></span>  
  
 <span data-ttu-id="0ed15-2413"><xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> Właściwość`e` parametru udostępnia dostawcy usługi okna Sockets z dodatkowymi informacjami na temat żądania odczytu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2413">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request.</span></span> <span data-ttu-id="0ed15-2414">Aby uzyskać więcej informacji na temat korzystania z tego parametru, <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>Zobacz.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2414">For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="0ed15-2415">Następujące właściwości i zdarzenia w <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiekcie są wymagane do pomyślnego wywołania tej metody:</span><span class="sxs-lookup"><span data-stu-id="0ed15-2415">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <span data-ttu-id="0ed15-2416"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> lub <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0ed15-2416"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span></span>  
  
-   <span data-ttu-id="0ed15-2417"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>Jeśli <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> jest ustawiona</span><span class="sxs-lookup"><span data-stu-id="0ed15-2417"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <span data-ttu-id="0ed15-2418"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>Jeśli <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> jest ustawiona</span><span class="sxs-lookup"><span data-stu-id="0ed15-2418"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="0ed15-2419">Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość na dowolny obiekt stanu użytkownika przed <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> wywołaniem metody, tak aby informacje były możliwe do pobierania w metodzie wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2419">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="0ed15-2420">Jeśli wywołanie zwrotne wymaga więcej informacji niż pojedynczy obiekt, można utworzyć małą klasę w celu przechowywania innych wymaganych informacji o stanie jako członków.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2420">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="0ed15-2421">W przypadku gniazd typu Byte-styl strumień dane przychodzące są umieszczane w buforze do momentu wypełnienia buforu, połączenie jest zamknięte lub wyczerpanie wewnętrznie dane buforowane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2421">For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</span></span>  
  
 <span data-ttu-id="0ed15-2422">W przypadku gniazd zorientowanych na komunikaty przychodzący komunikat jest umieszczany w buforze do całkowitego rozmiaru buforu skojarzonego z `e` parametrem.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2422">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer associated with the `e` parameter.</span></span> <span data-ttu-id="0ed15-2423">Jeśli komunikat jest większy niż bufor, bufor zostanie wypełniony pierwszą częścią komunikatu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2423">If the message is larger than the buffer, the buffer is filled with the first part of the message.</span></span>  
  
 <span data-ttu-id="0ed15-2424">W przypadku gniazd <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> zorientowanych na połączenia Metoda może wskazywać łagodne zakończenie obwodu wirtualnego w jednym z dwóch sposobów, które zależą od tego, czy gniazdo jest strumieniem typu Byte lub zorientowanym na komunikaty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2424">For connection-oriented sockets, the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented.</span></span> <span data-ttu-id="0ed15-2425">W przypadku strumieni bajtowych zero bajty, które zostały odczytane, wskazuje na bezpieczne zamknięcie i nie będzie można odczytać więcej bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2425">For byte streams, zero bytes having been read indicates graceful closure and that no more bytes will ever be read.</span></span> <span data-ttu-id="0ed15-2426">W przypadku gniazd zorientowanych na komunikaty, gdzie komunikat o wartości zero jest często dozwolony, a <xref:System.Net.Sockets.SocketException> <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> z zestawem dla natywnego kodu błędu Winsock WSAEDISCON (10101) jest używany do wskazania bezpiecznego zamknięcia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2426">For message-oriented sockets, where a zero byte message is often allowable, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure.</span></span> <span data-ttu-id="0ed15-2427">W każdym przypadku a <xref:System.Net.Sockets.SocketException> <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> z zestawem dla natywnego kodu błędu Winsock WSAECONNRESET (10054) wskazuje, że wystąpiło zamknięcie przerwania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2427">In any case, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-2428">Nieprawidłowy argument.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2428">An argument was invalid.</span></span> <span data-ttu-id="0ed15-2429">Właściwości <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> <paramref name="e" /> lub <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> parametru muszą odwoływać się do prawidłowych buforów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2429">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> properties on the <paramref name="e" /> parameter must reference valid buffers.</span></span> <span data-ttu-id="0ed15-2430">Można ustawić jedną lub drugą z tych właściwości, ale nie oba jednocześnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2430">One or the other of these properties may be set, but not both at the same time.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-2431">Operacja gniazda była już w toku przy użyciu <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiektu określonego <paramref name="e" /> w parametrze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2431">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-2432">Ta metoda wymaga systemu Windows XP lub nowszego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2432">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2433"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2433">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2434">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2434">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-2435">Pobiera lub ustawia wartość określającą rozmiar buforu <see cref="T:System.Net.Sockets.Socket" />odbioru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2435">Gets or sets a value that specifies the size of the receive buffer of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="0ed15-2436">, <see cref="T:System.Int32" /> Który zawiera rozmiar (w bajtach) bufora odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2436">An <see cref="T:System.Int32" /> that contains the size, in bytes, of the receive buffer.</span></span> <span data-ttu-id="0ed15-2437">Wartość domyślna to 8192.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2437">The default is 8192.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2438">Większy rozmiar buforu może spowodować zmniejszenie liczby pustych potwierdzeń (pakietów TCP bez części danych), ale także opóźnić Rozpoznawanie problemów z połączeniem.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2438">A larger buffer size potentially reduces the number of empty acknowledgements (TCP packets with no data portion), but might also delay the recognition of connection difficulties.</span></span> <span data-ttu-id="0ed15-2439">Należy rozważyć zwiększenie rozmiaru buforu w przypadku transferu dużych plików lub korzystania z dużej przepustowości i połączenia o dużej opóźnieniu (na przykład satelitarnego dostawcy sieci szerokopasmowej).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2439">Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-2440">Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2440">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2441">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2441">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2442"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2442">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-2443">Wartość określona dla operacji zestawu jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2443">The value specified for a set operation is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ed15-2444">Odbiera datagram i przechowuje źródłowy punkt końcowy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2444">Receives a datagram and stores the source endpoint.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] *  -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-2445">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2445">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="0ed15-2446">Element <see cref="T:System.Net.EndPoint" />, który został przesłany przez odwołanie, reprezentujący serwer zdalny.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2446">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="0ed15-2447">Odbiera datagram w buforze danych i przechowuje punkt końcowy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2447">Receives a datagram into the data buffer and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="0ed15-2448">Liczba odebranych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2448">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2449">Metoda odczytuje dane `buffer` do parametru, zwraca liczbę pomyślnie odczytywanych bajtów i przechwytuje punkt końcowy hosta, z którego dane zostały wysłane. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-2449">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="0ed15-2450">Ta metoda jest przydatna, jeśli zamierzasz otrzymywać bezpołączeni datagramy z nieznanego hosta lub wielu hostów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2450">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="0ed15-2451">To Przeciążenie wymaga jedynie podania odbioru `buffer` <xref:System.Net.EndPoint> i reprezentuje hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2451">This overload only requires you to provide a receive `buffer`, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="0ed15-2452">Wartość domyślna przesunięcia buforu równa 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2452">The buffer offset defaults to 0.</span></span> <span data-ttu-id="0ed15-2453">Wartością domyślną jest długość `buffer` parametru `socketFlags` i wartość domyślna <xref:System.Net.Sockets.SocketFlags.None>to.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2453">The size defaults to the length of the `buffer` parameter and the `socketFlags` value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2454">Przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>należy jawnie <xref:System.Net.Sockets.Socket> powiązać do lokalnego punktu końcowego przy użyciu <xref:System.Net.Sockets.Socket.Bind%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2454">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="0ed15-2455">Jeśli tego nie zrobisz, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> zostanie <xref:System.Net.Sockets.SocketException>zgłoszony.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2455">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="0ed15-2456">W przypadku protokołów bez <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> połączenia program odczyta pierwszy zakolejce datagram otrzymany do buforu sieci lokalnej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2456">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="0ed15-2457">Jeśli odbierany datagram jest większy `buffer`niż rozmiar <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> , Metoda wypełni `buffer` tyle <xref:System.Net.Sockets.SocketException>wiadomości jak to możliwe, i wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2457">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2458">Jeśli korzystasz z wiarygodnego protokołu, nadmiarowe dane zostaną utracone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2458">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="0ed15-2459">Jeśli używasz niezawodnego protokołu, nadwyżkowe dane będą przechowywane przez dostawcę usługi i można je pobrać, wywołując <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodę z wystarczającą ilością buforu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2459">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="0ed15-2460">Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda zostanie zablokowana do momentu udostępnienia danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2460">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="0ed15-2461">Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w buforze stosu protokołu, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda zostanie zakończona natychmiast i <xref:System.Net.Sockets.SocketException>zostanie wyświetlona.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2461">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2462">Możesz użyć właściwości, <xref:System.Net.Sockets.Socket.Available%2A> aby określić, czy dane są dostępne do odczytu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2462">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="0ed15-2463">Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2463">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="0ed15-2464">Chociaż <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> jest przeznaczony dla protokołów bezpołączeniowych, można również użyć protokołu z zorientowanymi połączeniami.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2464">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="0ed15-2465">Jeśli zdecydujesz się to zrobić, musisz najpierw nawiązać połączenie z hostem zdalnym, wywołując <xref:System.Net.Sockets.Socket.Connect%2A> metodę lub akceptując przychodzące połączenie hosta zdalnego przez <xref:System.Net.Sockets.Socket.Accept%2A> wywołanie metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2465">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="0ed15-2466">Jeśli połączenie nie zostanie nawiązane przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody, <xref:System.Net.Sockets.SocketException>otrzymasz.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2466">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2467">Przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody można również ustanowić domyślnego hosta zdalnego dla bezpołączeniowego protokołu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2467">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="0ed15-2468">W każdym z tych przypadków <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda `remoteEP` zignoruje parametr i będzie odbierać tylko dane z podłączonego lub domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2468">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="0ed15-2469">W przypadku gniazd zorientowanych na połączenia <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> program odczyta tyle danych, ile jest dostępnych do `buffer`rozmiaru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2469">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`.</span></span> <span data-ttu-id="0ed15-2470">Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2470">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2471">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2471">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-2472">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2472">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2473"><xref:System.Net.Sockets.AddressFamily> Używanywprogramie<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> musi być zgodny zużytym<xref:System.Net.Sockets.Socket.SendTo%2A>w. <xref:System.Net.EndPoint> <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint></span><span class="sxs-lookup"><span data-stu-id="0ed15-2473">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2474">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2474">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-2475">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2475">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-2476">Poniższy przykład kodu odbiera bezpołączeniowy datagram z hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2476">The following code example receives a connectionless datagram from a remote host.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-2477"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2477"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ed15-2478">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2478">-or-</span></span> 
 <span data-ttu-id="0ed15-2479"><paramref name="remoteEP" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2479"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2480">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2480">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2481"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2481">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0ed15-2482">Obiekt wywołujący w stosie wywołań nie ma wymaganych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2482">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="0ed15-2483">do akceptowania połączeń z sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2483">for accepting connections from the network.</span></span> <span data-ttu-id="0ed15-2484">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2484">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-2485">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2485">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-2486">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2486">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="0ed15-2487">Element <see cref="T:System.Net.EndPoint" />, który został przesłany przez odwołanie, reprezentujący serwer zdalny.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2487">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="0ed15-2488">Odbiera datagram do buforu danych przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />i przechowuje punkt końcowy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2488">Receives a datagram into the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="0ed15-2489">Liczba odebranych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2489">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2490">Metoda odczytuje dane `buffer` do parametru, zwraca liczbę pomyślnie odczytywanych bajtów i przechwytuje punkt końcowy hosta, z którego dane zostały wysłane. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-2490">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="0ed15-2491">Ta metoda jest przydatna, jeśli zamierzasz otrzymywać bezpołączeni datagramy z nieznanego hosta lub wielu hostów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2491">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="0ed15-2492">To Przeciążenie wymaga jedynie podania buforu odbioru, niezbędnego <xref:System.Net.Sockets.SocketFlags> <xref:System.Net.EndPoint> i reprezentującego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2492">This overload only requires you to provide a receive buffer, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="0ed15-2493">Wartość domyślna przesunięcia to 0, a rozmiar domyślny to długość parametru buforu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2493">The offset defaults to 0 and the size defaults to the length of the buffer parameter.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2494">Przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>należy jawnie <xref:System.Net.Sockets.Socket> powiązać do lokalnego punktu końcowego przy użyciu <xref:System.Net.Sockets.Socket.Bind%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2494">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="0ed15-2495">Jeśli tego nie zrobisz, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> zostanie <xref:System.Net.Sockets.SocketException>zgłoszony.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2495">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="0ed15-2496">W przypadku protokołów bez <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> połączenia program odczyta pierwszy zakolejce datagram otrzymany do buforu sieci lokalnej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2496">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="0ed15-2497">Jeśli odbierany datagram jest większy `buffer`niż rozmiar <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> , Metoda wypełni `buffer` tyle <xref:System.Net.Sockets.SocketException>wiadomości jak to możliwe, i wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2497">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2498">Jeśli korzystasz z wiarygodnego protokołu, nadmiarowe dane zostaną utracone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2498">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="0ed15-2499">Jeśli używasz niezawodnego protokołu, nadwyżkowe dane będą przechowywane przez dostawcę usługi i można je pobrać, wywołując <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodę z wystarczającą ilością buforu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2499">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="0ed15-2500">Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda zostanie zablokowana do momentu udostępnienia danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2500">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="0ed15-2501">Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w buforze stosu protokołu, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda zostanie zakończona natychmiast i <xref:System.Net.Sockets.SocketException>zostanie wyświetlona.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2501">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2502">Możesz użyć właściwości, <xref:System.Net.Sockets.Socket.Available%2A> aby określić, czy dane są dostępne do odczytu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2502">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="0ed15-2503">Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2503">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="0ed15-2504">Chociaż <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> jest przeznaczony dla protokołów bezpołączeniowych, można również użyć protokołu z zorientowanymi połączeniami.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2504">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="0ed15-2505">Jeśli zdecydujesz się to zrobić, musisz najpierw nawiązać połączenie z hostem zdalnym, wywołując <xref:System.Net.Sockets.Socket.Connect%2A> metodę lub akceptując przychodzące połączenie hosta zdalnego przez <xref:System.Net.Sockets.Socket.Accept%2A> wywołanie metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2505">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="0ed15-2506">Jeśli połączenie nie zostanie nawiązane przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody, <xref:System.Net.Sockets.SocketException>otrzymasz.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2506">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2507">Przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody można również ustanowić domyślnego hosta zdalnego dla bezpołączeniowego protokołu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2507">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="0ed15-2508">W każdym z tych przypadków <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda `remoteEP` zignoruje parametr i będzie odbierać tylko dane z podłączonego lub domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2508">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="0ed15-2509">W przypadku gniazd zorientowanych na połączenia <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> program odczyta tyle danych, ile jest dostępnych do `buffer`rozmiaru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2509">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`.</span></span> <span data-ttu-id="0ed15-2510">Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2510">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2511">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2511">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-2512">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2512">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2513"><xref:System.Net.Sockets.AddressFamily> Używanywprogramie<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> musi być zgodny zużytym<xref:System.Net.Sockets.Socket.SendTo%2A>w. <xref:System.Net.EndPoint> <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint></span><span class="sxs-lookup"><span data-stu-id="0ed15-2513">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2514">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2514">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-2515">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2515">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-2516">Poniższy przykład kodu odbiera bezpołączeniowy datagram z hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2516">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="0ed15-2517"><xref:System.Net.Sockets.SocketFlags>są przesyłane do <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2517"><xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-2518"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2518"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ed15-2519">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2519">-or-</span></span> 
 <span data-ttu-id="0ed15-2520"><paramref name="remoteEP" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2520"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2521">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2521">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2522"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2522">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0ed15-2523">Obiekt wywołujący w stosie wywołań nie ma wymaganych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2523">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="0ed15-2524">do akceptowania połączeń z sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2524">for accepting connections from the network.</span></span> <span data-ttu-id="0ed15-2525">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2525">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-2526">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2526">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="size"><span data-ttu-id="0ed15-2527">Liczba bajtów do odebrania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2527">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-2528">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2528">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="0ed15-2529">Element <see cref="T:System.Net.EndPoint" />, który został przesłany przez odwołanie, reprezentujący serwer zdalny.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2529">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="0ed15-2530">Odbiera określoną liczbę bajtów w buforze danych przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />i przechowuje punkt końcowy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2530">Receives the specified number of bytes into the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="0ed15-2531">Liczba odebranych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2531">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2532">Metoda odczytuje dane `buffer` do parametru, zwraca liczbę pomyślnie odczytywanych bajtów i przechwytuje punkt końcowy hosta, z którego dane zostały wysłane. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-2532">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="0ed15-2533">Ta metoda jest przydatna, jeśli zamierzasz otrzymywać bezpołączeni datagramy z nieznanego hosta lub wielu hostów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2533">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="0ed15-2534">To Przeciążenie wymaga jedynie podania buforu odbioru, liczby bajtów, które mają być odbierane, niezbędne <xref:System.Net.Sockets.SocketFlags> <xref:System.Net.EndPoint> i reprezentujących hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2534">This overload only requires you to provide a receive buffer, the number of bytes you want to receive, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="0ed15-2535">Wartość domyślna przesunięcia buforu równa 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2535">The buffer offset defaults to 0.</span></span>  
  
 <span data-ttu-id="0ed15-2536">W przypadku protokołów bez <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> połączenia program odczyta pierwszy zakolejce datagram otrzymany do buforu sieci lokalnej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2536">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="0ed15-2537">Jeśli odbierany datagram jest większy `buffer`niż rozmiar <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> , Metoda wypełni `buffer` tyle <xref:System.Net.Sockets.SocketException>wiadomości jak to możliwe, i wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2537">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2538">Jeśli korzystasz z wiarygodnego protokołu, nadmiarowe dane zostaną utracone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2538">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="0ed15-2539">Jeśli używasz niezawodnego protokołu, nadwyżkowe dane będą przechowywane przez dostawcę usługi i można je pobrać, wywołując <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodę z wystarczającą ilością buforu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2539">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="0ed15-2540">Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda zostanie zablokowana do momentu udostępnienia danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2540">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="0ed15-2541">Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w buforze stosu protokołu, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda zostanie zakończona natychmiast i <xref:System.Net.Sockets.SocketException>zostanie wyświetlona.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2541">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2542">Możesz użyć właściwości, <xref:System.Net.Sockets.Socket.Available%2A> aby określić, czy dane są dostępne do odczytu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2542">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="0ed15-2543">Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2543">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="0ed15-2544">Chociaż <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> jest przeznaczony dla protokołów bezpołączeniowych, można również użyć protokołu z zorientowanymi połączeniami.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2544">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="0ed15-2545">Jeśli zdecydujesz się to zrobić, musisz najpierw nawiązać połączenie z hostem zdalnym, wywołując <xref:System.Net.Sockets.Socket.Connect%2A> metodę lub akceptując przychodzące połączenie hosta zdalnego przez <xref:System.Net.Sockets.Socket.Accept%2A> wywołanie metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2545">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="0ed15-2546">Jeśli połączenie nie zostanie nawiązane przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody, <xref:System.Net.Sockets.SocketException>otrzymasz.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2546">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2547">Przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody można również ustanowić domyślnego hosta zdalnego dla bezpołączeniowego protokołu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2547">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="0ed15-2548">W każdym z tych przypadków <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda `remoteEP` zignoruje parametr i będzie odbierać tylko dane z podłączonego lub domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2548">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="0ed15-2549">W przypadku gniazd zorientowanych na połączenia <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> program odczyta tyle danych, ile jest dostępnych do liczby bajtów określonej `size` przez parametr.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2549">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="0ed15-2550">Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2550">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2551">Przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>należy jawnie <xref:System.Net.Sockets.Socket> powiązać do lokalnego punktu końcowego przy użyciu <xref:System.Net.Sockets.Socket.Bind%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2551">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="0ed15-2552">Jeśli tego nie zrobisz, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> zostanie <xref:System.Net.Sockets.SocketException>zgłoszony.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2552">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2553">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2553">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-2554">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2554">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2555"><xref:System.Net.Sockets.AddressFamily> Używanywprogramie<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> musi być zgodny zużytym<xref:System.Net.Sockets.Socket.SendTo%2A>w. <xref:System.Net.EndPoint> <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint></span><span class="sxs-lookup"><span data-stu-id="0ed15-2555">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2556">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2556">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-2557">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2557">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-2558">Poniższy przykład kodu odbiera bezpołączeniowy datagram z hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2558">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="0ed15-2559">Rozmiar buforu i <xref:System.Net.Sockets.SocketFlags> są przesyłane <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> do metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2559">The buffer size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-2560"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2560"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ed15-2561">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2561">-or-</span></span> 
 <span data-ttu-id="0ed15-2562"><paramref name="remoteEP" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2562"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-2563"><paramref name="size" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2563"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-2564">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2564">-or-</span></span> 
 <span data-ttu-id="0ed15-2565"><paramref name="size" />jest większa niż długość <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2565"><paramref name="size" /> is greater than the length of <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2566"><paramref name="socketFlags" />nie jest prawidłową kombinacją wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2566"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="0ed15-2567">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2567">-or-</span></span> 
<span data-ttu-id="0ed15-2568"><see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> Właściwość nie została ustawiona.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2568">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
<span data-ttu-id="0ed15-2569">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2569">-or-</span></span> 
<span data-ttu-id="0ed15-2570">Wystąpił błąd systemu operacyjnego podczas uzyskiwania dostępu <see cref="T:System.Net.Sockets.Socket" />do programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2570">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2571"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2571">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0ed15-2572">Obiekt wywołujący w stosie wywołań nie ma wymaganych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2572">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="0ed15-2573">do akceptowania połączeń z sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2573">for accepting connections from the network.</span></span> <span data-ttu-id="0ed15-2574">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2574">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-2575">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2575">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="offset"><span data-ttu-id="0ed15-2576">Pozycja w <paramref name="buffer" /> parametrze do przechowywania odebranych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2576">The position in the <paramref name="buffer" /> parameter to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="0ed15-2577">Liczba bajtów do odebrania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2577">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-2578">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2578">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="0ed15-2579">Element <see cref="T:System.Net.EndPoint" />, który został przesłany przez odwołanie, reprezentujący serwer zdalny.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2579">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="0ed15-2580">Odbiera określoną liczbę bajtów danych w określonej lokalizacji w buforze danych, używając określonego <see cref="T:System.Net.Sockets.SocketFlags" />i zapisuje punkt końcowy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2580">Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="0ed15-2581">Liczba odebranych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2581">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2582">Metoda odczytuje dane `buffer` do parametru, zwraca liczbę pomyślnie odczytywanych bajtów i przechwytuje punkt końcowy hosta, z którego dane zostały wysłane. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-2582">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="0ed15-2583">Ta metoda jest przydatna, jeśli zamierzasz otrzymywać bezpołączeni datagramy z nieznanego hosta lub wielu hostów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2583">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="0ed15-2584">W przypadku protokołów bez <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> połączenia program odczyta pierwszy zakolejce datagram otrzymany do buforu sieci lokalnej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2584">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="0ed15-2585">Jeśli odbierany datagram jest większy `buffer`niż rozmiar <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> , Metoda wypełni `buffer` tyle <xref:System.Net.Sockets.SocketException>wiadomości jak to możliwe, i wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2585">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2586">Jeśli korzystasz z wiarygodnego protokołu, nadmiarowe dane zostaną utracone.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2586">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="0ed15-2587">Jeśli używasz niezawodnego protokołu, nadwyżkowe dane będą przechowywane przez dostawcę usługi i można je pobrać, wywołując <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodę z wystarczającą ilością buforu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2587">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="0ed15-2588">Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda zostanie zablokowana do momentu udostępnienia danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2588">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="0ed15-2589">Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w buforze stosu protokołu, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda zostanie zakończona natychmiast i <xref:System.Net.Sockets.SocketException>zostanie wyświetlona.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2589">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2590">Możesz użyć właściwości, <xref:System.Net.Sockets.Socket.Available%2A> aby określić, czy dane są dostępne do odczytu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2590">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="0ed15-2591">Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2591">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="0ed15-2592">Chociaż <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> jest przeznaczony dla protokołów bezpołączeniowych, można również użyć protokołu z zorientowanymi połączeniami.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2592">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="0ed15-2593">Jeśli zdecydujesz się to zrobić, musisz najpierw nawiązać połączenie z hostem zdalnym, wywołując <xref:System.Net.Sockets.Socket.Connect%2A> metodę lub akceptując przychodzące połączenie hosta zdalnego przez <xref:System.Net.Sockets.Socket.Accept%2A> wywołanie metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2593">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="0ed15-2594">Jeśli połączenie nie zostanie nawiązane przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody, <xref:System.Net.Sockets.SocketException>otrzymasz.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2594">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2595">Przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody można również ustanowić domyślnego hosta zdalnego dla bezpołączeniowego protokołu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2595">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="0ed15-2596">W każdym z tych przypadków <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda `remoteEP` zignoruje parametr i będzie odbierać tylko dane z podłączonego lub domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2596">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="0ed15-2597">W przypadku gniazd zorientowanych na połączenia <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> program będzie odczytywać tyle danych, ile jest dostępnych do wielkości bajtów określonych `size` przez parametr.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2597">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the amount of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="0ed15-2598">Jeśli host zdalny zamknie <xref:System.Net.Sockets.Socket> połączenie <xref:System.Net.Sockets.Socket.Shutdown%2A> z metodą, a wszystkie dostępne dane zostały odebrane, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda zakończy się natychmiast i zwróci zero bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2598">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2599">Przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>należy jawnie <xref:System.Net.Sockets.Socket> powiązać do lokalnego punktu końcowego przy użyciu <xref:System.Net.Sockets.Socket.Bind%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2599">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="0ed15-2600">Jeśli tego nie zrobisz, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> zostanie <xref:System.Net.Sockets.SocketException>zgłoszony.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2600">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2601">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2601">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-2602">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2602">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2603"><xref:System.Net.Sockets.AddressFamily> Używanywprogramie<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> musi być zgodny zużytym<xref:System.Net.Sockets.Socket.SendTo%2A>w. <xref:System.Net.EndPoint> <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint></span><span class="sxs-lookup"><span data-stu-id="0ed15-2603">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2604">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2604">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-2605">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2605">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-2606">Poniższy przykład kodu odbiera bezpołączeniowy datagram z hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2606">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="0ed15-2607">Przesunięcie, rozmiar buforu i <xref:System.Net.Sockets.SocketFlags> są przesyłane <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> do metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2607">The offset, buffer size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-2608"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2608"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ed15-2609">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2609">-or-</span></span> 
 <span data-ttu-id="0ed15-2610"><paramref name="remoteEP" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2610"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-2611"><paramref name="offset" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2611"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-2612">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2612">-or-</span></span> 
 <span data-ttu-id="0ed15-2613"><paramref name="offset" />jest większa niż długość <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2613"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="0ed15-2614">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2614">-or-</span></span> 
 <span data-ttu-id="0ed15-2615"><paramref name="size" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2615"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-2616">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2616">-or-</span></span> 
 <span data-ttu-id="0ed15-2617"><paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości parametru przesunięcia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2617"><paramref name="size" /> is greater than the length of the <paramref name="buffer" /> minus the value of the offset parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2618"><paramref name="socketFlags" />nie jest prawidłową kombinacją wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2618"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="0ed15-2619">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2619">-or-</span></span> 
<span data-ttu-id="0ed15-2620"><see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> Właściwość nie została ustawiona.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2620">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
<span data-ttu-id="0ed15-2621">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2621">-or-</span></span> 
<span data-ttu-id="0ed15-2622">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2622">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2623"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2623">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="0ed15-2624">do akceptowania połączeń z sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2624">for accepting connections from the network.</span></span> <span data-ttu-id="0ed15-2625">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2625">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="0ed15-2626">Obiekt <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> , który ma być używany dla tej asynchronicznej operacji gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2626">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="0ed15-2627">Rozpoczyna asynchroniczne odbieranie danych z określonego urządzenia sieciowego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2627">Begins to asynchronously receive data from a specified network device.</span></span></summary>
        <returns><span data-ttu-id="0ed15-2628"><see langword="true" />Jeśli operacja we/wy jest w stanie oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2628"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="0ed15-2629"><see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie<paramref name="e" /> na parametrze zostanie wywołane po zakończeniu operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2629">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="0ed15-2630"><see langword="false" />Jeśli operacja we/wy została ukończona synchronicznie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2630"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="0ed15-2631">W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie <paramref name="e" /> na parametrze <paramref name="e" /> nie zostanie zgłoszone i obiekt przenoszony jako parametr może zostać zbadany natychmiast po wywołaniu metody, aby pobrać wynik operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2631">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2632"><xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> Metoda jest używana głównie do odbierania danych w bezpołączeniowym gnieździe.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2632">The <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method is used primarily to receive data on a connectionless socket.</span></span> <span data-ttu-id="0ed15-2633">Adres lokalny gniazda musi być znany.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2633">The socket's local address must be known.</span></span>  
  
 <span data-ttu-id="0ed15-2634">Obiekt wywołujący musi ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Właściwość <xref:System.Net.IPEndPoint> na hoście zdalnym, z którego mają zostać odebrane dane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2634">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.</span></span>  
  
 <span data-ttu-id="0ed15-2635"><xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> Właściwość`e` parametru udostępnia dostawcy usługi okna Sockets z dodatkowymi informacjami na temat żądania odczytu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2635">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request.</span></span> <span data-ttu-id="0ed15-2636">Aby uzyskać więcej informacji na temat korzystania z tego parametru, <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>Zobacz.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2636">For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="0ed15-2637">Następujące właściwości i zdarzenia w <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiekcie są wymagane do pomyślnego wywołania tej metody:</span><span class="sxs-lookup"><span data-stu-id="0ed15-2637">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="0ed15-2638">Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość na dowolny obiekt stanu użytkownika przed <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> wywołaniem metody, tak aby informacje były możliwe do pobierania w metodzie wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2638">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="0ed15-2639">Jeśli wywołanie zwrotne wymaga więcej informacji niż pojedynczy obiekt, można utworzyć małą klasę w celu przechowywania innych wymaganych informacji o stanie jako członków.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2639">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="0ed15-2640">W przypadku gniazd zorientowanych na komunikaty przychodzący komunikat jest umieszczany w buforze do całkowitego rozmiaru buforu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2640">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</span></span> <span data-ttu-id="0ed15-2641">Właściwości <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> i<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> określają, gdzie w buforze umieszczane są dane oraz ilość danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2641">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 <span data-ttu-id="0ed15-2642">W przypadku gniazd typu Byte-styl strumień dane przychodzące są umieszczane w buforze do momentu wypełnienia buforu, połączenie jest zamknięte lub wyczerpanie wewnętrznie dane buforowane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2642">For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</span></span> <span data-ttu-id="0ed15-2643">Właściwości <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> i<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> określają, gdzie w buforze umieszczane są dane oraz ilość danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2643">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-2644"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> Nie może mieć wartości null.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2644">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-2645">Operacja gniazda była już w toku przy użyciu <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiektu określonego <paramref name="e" /> w parametrze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2645">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-2646">Ta metoda wymaga systemu Windows XP lub nowszego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2646">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2647"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2647">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2648">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2648">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int *  *  *  -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-2649">Tablica typu <see cref="T:System.Byte" /> będącego lokalizacją magazynu dla odebranych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2649">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="offset"><span data-ttu-id="0ed15-2650">Pozycja w <paramref name="buffer" /> parametrze do przechowywania odebranych danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2650">The position in the <paramref name="buffer" /> parameter to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="0ed15-2651">Liczba bajtów do odebrania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2651">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-2652">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2652">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="0ed15-2653">Element <see cref="T:System.Net.EndPoint" />, który został przesłany przez odwołanie, reprezentujący serwer zdalny.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2653">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <param name="ipPacketInformation"><span data-ttu-id="0ed15-2654"><see cref="T:System.Net.Sockets.IPPacketInformation" /> Adres i informacje o interfejsie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2654">An <see cref="T:System.Net.Sockets.IPPacketInformation" /> holding address and interface information.</span></span></param>
        <summary><span data-ttu-id="0ed15-2655">Odbiera określoną liczbę bajtów danych w określonej lokalizacji w buforze danych, używając określonego <see cref="T:System.Net.Sockets.SocketFlags" />i zapisuje punkt końcowy oraz informacje o pakiecie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2655">Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint and packet information.</span></span></summary>
        <returns><span data-ttu-id="0ed15-2656">Liczba odebranych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2656">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2657">Metoda odczytuje dane `buffer` do parametru, zwraca liczbę pomyślnie odczytywanych bajtów i przechwytuje zdalny punkt końcowy hosta, z którego dane zostały wysłane, a także informacje o odebranym pakiecie. <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-2657">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent, as well as information about the received packet.</span></span>  
  
 <span data-ttu-id="0ed15-2658"><xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Metoda jest używana głównie do odbierania danych komunikatów w bezpołączeniowym gnieździe.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2658">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method is used primarily to receive message data on a connectionless socket.</span></span> <span data-ttu-id="0ed15-2659">Adres lokalny gniazda musi być znany.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2659">The socket's local address must be known.</span></span> <span data-ttu-id="0ed15-2660">Tej metody można używać tylko z datagramami i gniazdami nieprzetworzonymi.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2660">This method can only be used with datagram and raw sockets.</span></span> <span data-ttu-id="0ed15-2661">Gniazdo musi być zainicjowane z typem gniazda ustawionym na <xref:System.Net.Sockets.SocketType.Dgram> lub <xref:System.Net.Sockets.SocketType.Raw> przed wywołaniem tej metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2661">The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method.</span></span> <span data-ttu-id="0ed15-2662">Można to zrobić, gdy gniazdo jest zbudowane przy użyciu <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2662">This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span></span>  
  
 <span data-ttu-id="0ed15-2663">W przypadku gniazd zorientowanych na komunikaty przychodzący komunikat jest umieszczany `buffer` w parametrze do całkowitego rozmiaru określonego `size` w parametrze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2663">For message-oriented sockets, an incoming message is placed into the `buffer` parameter up to the total size specified in the `size` parameter.</span></span> <span data-ttu-id="0ed15-2664">Parametr określa miejsce `buffer` , w którym znajdują się dane. `offset`</span><span class="sxs-lookup"><span data-stu-id="0ed15-2664">The `offset` parameter determines where in the `buffer` the data is placed.</span></span> <span data-ttu-id="0ed15-2665">Rzeczywista ilość danych umieszczonych w polu `buffer` jest zwracana <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> przez metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2665">The actual amount of data placed into the `buffer` is returned by the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-2666">Metoda automatycznie <xref:System.Net.Sockets.Socket>ustawia opcję `true` gniazda przy pierwszym wywołaniu dla danego elementu. <xref:System.Net.Sockets.SocketOptionName.PacketInformation> <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-2666">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method automatically method sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-2667">Jednak zwracany <xref:System.Net.Sockets.IPPacketInformation> obiekt będzie prawidłowy tylko dla pakietów, które docierają do komputera lokalnego po ustawieniu opcji gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2667">However, the returned <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set.</span></span> <span data-ttu-id="0ed15-2668">Jeśli gniazdo jest wysyłane <xref:System.Net.Sockets.Socket.Bind%2A> pakiety między <xref:System.Net.Sockets.Socket.Connect%2A>, gdy jest ono powiązane z lokalnym punktem końcowym (jawnie przez metodę lub niejawnie przez jedną z metod <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, lub <xref:System.Net.Sockets.Socket.SendToAsync%2A> ) i pierwsze wywołanie <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> elementu Metoda wywołania <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metody zwróci nieprawidłowe <xref:System.Net.Sockets.IPPacketInformation> obiekty dla tych pakietów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2668">If a socket is sent packets between when it is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and its first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method will return invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.</span></span>  
  
 <span data-ttu-id="0ed15-2669">Aby upewnić się <xref:System.Net.Sockets.IPPacketInformation> , że wszystkie obiekty są prawidłowe, aplikacja powinna <xref:System.Net.Sockets.SocketOptionName.PacketInformation> ustawić opcję gniazda `true` na przed powiązaniem z lokalnym punktem końcowym przy <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> użyciu metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2669">To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.</span></span>  
  
 <span data-ttu-id="0ed15-2670">Aplikacja może sprawdzić parametr, `ipPacketInformation` Jeśli musi wiedzieć, czy datagram został wysłany przy użyciu adresu emisji pojedynczej, multiemisji lub emisji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2670">An application can examine the `ipPacketInformation` parameter if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2671"><xref:System.Net.Sockets.AddressFamily> Używanywprogramie<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> musi być zgodny zużytym<xref:System.Net.Sockets.Socket.SendTo%2A>w. <xref:System.Net.EndPoint> <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint></span><span class="sxs-lookup"><span data-stu-id="0ed15-2671">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2672">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2672">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-2673">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2673">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-2674"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2674"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ed15-2675">\-oraz</span><span class="sxs-lookup"><span data-stu-id="0ed15-2675">\- or-</span></span> 
 <span data-ttu-id="0ed15-2676"><paramref name="remoteEP" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2676"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-2677"><paramref name="offset" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2677"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-2678">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2678">-or-</span></span> 
 <span data-ttu-id="0ed15-2679"><paramref name="offset" />jest większa niż długość <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2679"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="0ed15-2680">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2680">-or-</span></span> 
 <span data-ttu-id="0ed15-2681"><paramref name="size" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2681"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-2682">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2682">-or-</span></span> 
 <span data-ttu-id="0ed15-2683"><paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości parametru przesunięcia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2683"><paramref name="size" /> is greater than the length of the <paramref name="buffer" /> minus the value of the offset parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2684"><paramref name="socketFlags" />nie jest prawidłową kombinacją wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2684"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="0ed15-2685">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2685">-or-</span></span> 
<span data-ttu-id="0ed15-2686"><see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> Właściwość nie została ustawiona.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2686">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
<span data-ttu-id="0ed15-2687">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2687">-or-</span></span> 
<span data-ttu-id="0ed15-2688">.NET Framework jest uruchomiona na procesorze AMD 64-bitowym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2688">The .NET Framework is running on an AMD 64-bit processor.</span></span>  
  
<span data-ttu-id="0ed15-2689">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2689">-or-</span></span> 
<span data-ttu-id="0ed15-2690">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2690">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2691"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2691">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-2692">System operacyjny to Windows 2000 lub starszy, a ta metoda wymaga systemu Windows XP.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2692">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="0ed15-2693">do akceptowania połączeń z sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2693">for accepting connections from the network.</span></span> <span data-ttu-id="0ed15-2694">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2694">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="0ed15-2695">Obiekt <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> , który ma być używany dla tej asynchronicznej operacji gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2695">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="0ed15-2696">Rozpoczyna asynchroniczne odbieranie określonej liczby bajtów danych w określonej lokalizacji w buforze danych przy użyciu określonego <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />i przechowywanie informacji o punkcie końcowym i pakiecie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2696">Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />, and stores the endpoint and packet information.</span></span></summary>
        <returns><span data-ttu-id="0ed15-2697"><see langword="true" />Jeśli operacja we/wy jest w stanie oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2697"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="0ed15-2698"><see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie<paramref name="e" /> na parametrze zostanie wywołane po zakończeniu operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2698">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="0ed15-2699"><see langword="false" />Jeśli operacja we/wy została ukończona synchronicznie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2699"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="0ed15-2700">W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie <paramref name="e" /> na parametrze <paramref name="e" /> nie zostanie zgłoszone i obiekt przenoszony jako parametr może zostać zbadany natychmiast po wywołaniu metody, aby pobrać wynik operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2700">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2701"><xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> Metoda jest używana głównie do odbierania danych komunikatów w bezpołączeniowym gnieździe.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2701">The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method is used primarily to receive message data on a connectionless socket.</span></span> <span data-ttu-id="0ed15-2702">Adres lokalny gniazda musi być znany.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2702">The socket's local address must be known.</span></span> <span data-ttu-id="0ed15-2703">Tej metody można używać tylko z datagramami i gniazdami nieprzetworzonymi.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2703">This method can only be used with datagram and raw sockets.</span></span> <span data-ttu-id="0ed15-2704">Gniazdo musi być zainicjowane z typem gniazda ustawionym na <xref:System.Net.Sockets.SocketType.Dgram> lub <xref:System.Net.Sockets.SocketType.Raw> przed wywołaniem tej metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2704">The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method.</span></span> <span data-ttu-id="0ed15-2705">Można to zrobić, gdy gniazdo jest zbudowane przy użyciu <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2705">This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span></span>  
  
 <span data-ttu-id="0ed15-2706">Obiekt wywołujący musi ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Właściwość <xref:System.Net.IPEndPoint> na hoście zdalnym, z którego mają zostać odebrane dane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2706">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.</span></span>  
  
 <span data-ttu-id="0ed15-2707">Następujące właściwości i zdarzenia w <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiekcie są wymagane do pomyślnego wywołania tej metody:</span><span class="sxs-lookup"><span data-stu-id="0ed15-2707">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="0ed15-2708">Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość na dowolny obiekt stanu użytkownika przed <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> wywołaniem metody, tak aby informacje były możliwe do pobierania w metodzie wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2708">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="0ed15-2709">Jeśli wywołanie zwrotne wymaga więcej informacji niż pojedynczy obiekt, można utworzyć małą klasę w celu przechowywania innych wymaganych informacji o stanie jako członków.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2709">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="0ed15-2710">W przypadku gniazd zorientowanych na komunikaty przychodzący komunikat jest umieszczany w buforze do całkowitego rozmiaru buforu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2710">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</span></span> <span data-ttu-id="0ed15-2711">Właściwości <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> i<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> określają, gdzie w buforze umieszczane są dane oraz ilość danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2711">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 <span data-ttu-id="0ed15-2712">Metoda automatycznie <xref:System.Net.Sockets.Socket>ustawia opcję `true` gniazda przy pierwszym wywołaniu dla danego elementu. <xref:System.Net.Sockets.SocketOptionName.PacketInformation> <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-2712">The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method automatically sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-2713"><xref:System.Net.Sockets.IPPacketInformation> Jednak obiekt będzie prawidłowy tylko dla pakietów, które docierają do komputera lokalnego po ustawieniu opcji gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2713">However, the <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set.</span></span> <span data-ttu-id="0ed15-2714">Jeśli gniazdo jest wysyłane <xref:System.Net.Sockets.Socket.Bind%2A> pakiety między <xref:System.Net.Sockets.Socket.Connect%2A>, gdy gniazdo jest powiązane z lokalnym punktem końcowym (jawnie przez metodę lub niejawnie przez jedną z metod, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>lub <xref:System.Net.Sockets.Socket.SendToAsync%2A> ) i pierwsze wywołanie elementu <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>Metoda, wywołania <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> metody powodują nieprawidłowe <xref:System.Net.Sockets.IPPacketInformation> obiekty dla tych pakietów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2714">If a socket is sent packets between when the socket is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and the first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method will result in invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.</span></span>  
  
 <span data-ttu-id="0ed15-2715">Aby upewnić się <xref:System.Net.Sockets.IPPacketInformation> , że wszystkie obiekty są prawidłowe, aplikacja powinna <xref:System.Net.Sockets.SocketOptionName.PacketInformation> ustawić opcję gniazda`true` na przed powiązaniem z lokalnym punktem końcowym przy <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> użyciu metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2715">To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to`true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.</span></span>  
  
 <span data-ttu-id="0ed15-2716">Aplikacja może przeanalizować <xref:System.Net.Sockets.IPPacketInformation> obiekty, jeśli trzeba wiedzieć, czy datagram został wysłany przy użyciu adresu emisji pojedynczej, multiemisji lub emisji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2716">An application can examine the resulting <xref:System.Net.Sockets.IPPacketInformation> objects if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-2717"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> Nie może mieć wartości null.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2717">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-2718">Ta metoda wymaga systemu Windows XP lub nowszego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2718">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2719"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2719">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2720">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2720">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-2721">Pobiera lub ustawia wartość określającą czas, po upływie którego zostanie przekroczony <see cref="Overload:System.Net.Sockets.Socket.Receive" /> limit czasu wywołania synchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2721">Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Receive" /> call will time out.</span></span></summary>
        <value><span data-ttu-id="0ed15-2722">Wartość limitu czasu (w milisekundach).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2722">The time-out value, in milliseconds.</span></span> <span data-ttu-id="0ed15-2723">Wartość domyślna to 0, co oznacza nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2723">The default value is 0, which indicates an infinite time-out period.</span></span> <span data-ttu-id="0ed15-2724">Określenie-1 wskazuje także nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2724">Specifying -1 also indicates an infinite time-out period.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2725">Ta opcja dotyczy tylko wywołań <xref:System.Net.Sockets.Socket.Receive%2A> synchronicznych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2725">This option applies to synchronous <xref:System.Net.Sockets.Socket.Receive%2A> calls only.</span></span> <span data-ttu-id="0ed15-2726">W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Receive%2A> limitu czasu Metoda <xref:System.Net.Sockets.SocketException>wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2726">If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-2727">Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2727">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2728">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2728">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2729"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2729">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-2730">Wartość określona dla operacji zestawu jest mniejsza niż-1.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2730">The value specified for a set operation is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-2731">Pobiera zdalny punkt końcowy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2731">Gets the remote endpoint.</span></span></summary>
        <value><span data-ttu-id="0ed15-2732"><see cref="T:System.Net.EndPoint" /> Z którym<see cref="T:System.Net.Sockets.Socket" /> komunikuje się.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2732">The <see cref="T:System.Net.EndPoint" /> with which the <see cref="T:System.Net.Sockets.Socket" /> is communicating.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2733">Jeśli używasz protokołu zorientowanego na połączenie, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> Właściwość <xref:System.Net.EndPoint> pobiera, który zawiera zdalny adres IP i numer <xref:System.Net.Sockets.Socket> portu, z którym jest połączony.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2733">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property gets the <xref:System.Net.EndPoint> that contains the remote IP address and port number to which the <xref:System.Net.Sockets.Socket> is connected.</span></span> <span data-ttu-id="0ed15-2734">Jeśli używasz protokołu bezpołączeniowego, zawiera <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> domyślny zdalny adres IP i numer portu, z <xref:System.Net.Sockets.Socket> którym będzie się komunikować.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2734">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> contains the default remote IP address and port number with which the <xref:System.Net.Sockets.Socket> will communicate.</span></span> <span data-ttu-id="0ed15-2735">Należy rzutować to <xref:System.Net.EndPoint> <xref:System.Net.IPEndPoint> przed pobraniem jakichkolwiek informacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2735">You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information.</span></span> <span data-ttu-id="0ed15-2736">Następnie można wywołać <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> metodę, aby pobrać zdalny <xref:System.Net.IPAddress>i <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> metodę pobierania numeru portu zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2736">You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to retrieve the remote <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to retrieve the remote port number.</span></span>  
  
 <span data-ttu-id="0ed15-2737">Jest ustawiony po wywołaniu jednej <xref:System.Net.Sockets.Socket.Accept%2A> lub <xref:System.Net.Sockets.Socket.Connect%2A>. <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-2737">The <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> is set after a call to either <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="0ed15-2738">Jeśli spróbujesz uzyskać dostęp do tej właściwości wcześniej <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> , spowoduje to <xref:System.Net.Sockets.SocketException>zgłoszenie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2738">If you try to access this property earlier, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2739">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2739">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-2740">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2740">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2741">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2741">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-2742">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2742">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-2743">Poniższy przykład kodu pobiera i wyświetla lokalne i zdalne punkty końcowe.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2743">The following code example retrieves and displays the local and remote endpoints.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2744">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2744">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2745"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2745">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SafeSocketHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.SafeSocketHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeSocketHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SafeSocketHandle ^ SafeHandle { System::Net::Sockets::SafeSocketHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : System.Net.Sockets.SafeSocketHandle" Usage="System.Net.Sockets.Socket.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SafeSocketHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-2746">Pobiera, który reprezentuje uchwyt gniazda, który jest hermetyzowany <see cref="T:System.Net.Sockets.Socket" /> bieżący obiekt. <see cref="T:System.Net.Sockets.SafeSocketHandle" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-2746">Gets a <see cref="T:System.Net.Sockets.SafeSocketHandle" /> that represents the socket handle that the current <see cref="T:System.Net.Sockets.Socket" /> object encapsulates.</span></span></summary>
        <value><span data-ttu-id="0ed15-2747">Dojście gniazda uwidocznione w bezpieczny sposób dla gniazda, które jest hermetyzowane przez bieżący <see cref="T:System.Net.Sockets.Socket" /> obiekt.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2747">A socket handle exposed in a safe manner for the socket that the current <see cref="T:System.Net.Sockets.Socket" /> object encapsulates.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

> [!IMPORTANT]
> <span data-ttu-id="0ed15-2748">Użycie funkcji <xref:System.Net.Sockets.SafeSocketHandle> do działania w gnieździe bezpośrednio może spowodować Nieudokumentowany stan.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2748">Using the <xref:System.Net.Sockets.SafeSocketHandle> to operate on the socket directly may result in an undocumented state.</span></span> 

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="checkError" Type="System.Collections.IList" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="microSeconds" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="checkRead"><span data-ttu-id="0ed15-2749"><see cref="T:System.Collections.IList" /> Wystąpienia<see cref="T:System.Net.Sockets.Socket" /> umożliwiające sprawdzenie czytelności.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2749">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for readability.</span></span></param>
        <param name="checkWrite"><span data-ttu-id="0ed15-2750"><see cref="T:System.Collections.IList" /> Wystąpienia<see cref="T:System.Net.Sockets.Socket" /> do sprawdzenia dla writability.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2750">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for writability.</span></span></param>
        <param name="checkError"><span data-ttu-id="0ed15-2751"><see cref="T:System.Collections.IList" /> Wystąpieniado<see cref="T:System.Net.Sockets.Socket" /> sprawdzenia pod kątem błędów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2751">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for errors.</span></span></param>
        <param name="microSeconds"><span data-ttu-id="0ed15-2752">Wartość limitu czasu w mikrosekundach.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2752">The time-out value, in microseconds.</span></span> <span data-ttu-id="0ed15-2753">Wartość-1 oznacza nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2753">A -1 value indicates an infinite time-out.</span></span></param>
        <summary><span data-ttu-id="0ed15-2754">Określa stan co najmniej jednego gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2754">Determines the status of one or more sockets.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2755"><xref:System.Net.Sockets.Socket.Select%2A>to metoda statyczna, która określa stan jednego lub większej liczby <xref:System.Net.Sockets.Socket> wystąpień.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2755"><xref:System.Net.Sockets.Socket.Select%2A> is a static method that determines the status of one or more <xref:System.Net.Sockets.Socket> instances.</span></span> <span data-ttu-id="0ed15-2756"><xref:System.Collections.IList> Aby można było użyć metody, <xref:System.Net.Sockets.Socket.Select%2A> należy umieścić jeden lub więcej gniazd.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2756">You must place one or more sockets into an <xref:System.Collections.IList> before you can use the <xref:System.Net.Sockets.Socket.Select%2A> method.</span></span> <span data-ttu-id="0ed15-2757">Sprawdź dostępność, wywołując <xref:System.Net.Sockets.Socket.Select%2A> <xref:System.Collections.IList> metodę jako `checkRead` parametr.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2757">Check for readability by calling <xref:System.Net.Sockets.Socket.Select%2A> with the <xref:System.Collections.IList> as the `checkRead` parameter.</span></span> <span data-ttu-id="0ed15-2758">Aby sprawdzić gniazda dla writability, użyj `checkWrite` parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2758">To check your sockets for writability, use the `checkWrite` parameter.</span></span> <span data-ttu-id="0ed15-2759">W celu wykrycia warunków błędów `checkError`Użyj.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2759">For detecting error conditions, use `checkError`.</span></span> <span data-ttu-id="0ed15-2760">Po wywołaniu <xref:System.Net.Sockets.Socket.Select%2A> <xref:System.Collections.IList> , zostanie wypełnione tylko te gniazda, które spełniają warunki.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2760">After calling <xref:System.Net.Sockets.Socket.Select%2A>, the <xref:System.Collections.IList> will be filled with only those sockets that satisfy the conditions.</span></span>  
  
 <span data-ttu-id="0ed15-2761">Jeśli jesteś w stanie nasłuchiwania, czytelność oznacza, że wywołanie <xref:System.Net.Sockets.Socket.Accept%2A> zakończy się pomyślnie bez blokowania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2761">If you are in a listening state, readability means that a call to <xref:System.Net.Sockets.Socket.Accept%2A> will succeed without blocking.</span></span> <span data-ttu-id="0ed15-2762">Jeśli połączenie zostało już zaakceptowane, czytelność oznacza, że dane są dostępne do odczytu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2762">If you have already accepted the connection, readability means that data is available for reading.</span></span> <span data-ttu-id="0ed15-2763">W takich przypadkach wszystkie operacje odbioru będą kończyły się powodzeniem bez blokowania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2763">In these cases, all receive operations will succeed without blocking.</span></span> <span data-ttu-id="0ed15-2764">Czytelność może również wskazywać, czy <xref:System.Net.Sockets.Socket> obiekt zdalny zamknie połączenie; w takim przypadku <xref:System.Net.Sockets.Socket.Receive%2A> wywołanie metody zwróci wartość natychmiast, z zwróceniem zero bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2764">Readability can also indicate whether the remote <xref:System.Net.Sockets.Socket> has shut down the connection; in that case a call to <xref:System.Net.Sockets.Socket.Receive%2A> will return immediately, with zero bytes returned.</span></span>  
  
 <span data-ttu-id="0ed15-2765"><xref:System.Net.Sockets.Socket.Select%2A>zwraca, gdy co najmniej jedno z gniazd zainteresowania `checkRead`(gniazda na listach, `checkWrite`i `checkError` `microSeconds` ) spełnia określone kryteria lub parametr zostanie przekroczony, zależnie od tego, co nastąpi wcześniej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2765"><xref:System.Net.Sockets.Socket.Select%2A> returns when at least one of the sockets of interest (the sockets in the `checkRead`, `checkWrite`, and `checkError` lists) meets its specified criteria, or the `microSeconds` parameter is exceeded, whichever comes first.</span></span> <span data-ttu-id="0ed15-2766">Ustawienie `microSeconds` wartość-1 określa nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2766">Setting `microSeconds` to -1 specifies an infinite time-out.</span></span>  
  
 <span data-ttu-id="0ed15-2767">W przypadku wywołania nieblokującego do <xref:System.Net.Sockets.Socket.Connect%2A>, writability oznacza, że połączenie zostało nawiązane pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2767">If you make a nonblocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, writability means that you have connected successfully.</span></span> <span data-ttu-id="0ed15-2768">Jeśli nawiązano już połączenie, writability oznacza, że wszystkie operacje wysyłania będą kończyły się powodzeniem bez blokowania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2768">If you already have a connection established, writability means that all send operations will succeed without blocking.</span></span>  
  
 <span data-ttu-id="0ed15-2769">Jeśli wykonano wywołanie nieblokujące do <xref:System.Net.Sockets.Socket.Connect%2A> `checkerror` , parametr identyfikuje gniazda, które nie połączyły się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2769">If you have made a non-blocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, the `checkerror` parameter identifies sockets that have not connected successfully.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2770">Użyj metody <xref:System.Net.Sockets.Socket.Poll%2A> , jeśli chcesz tylko określić stan pojedynczej. <xref:System.Net.Sockets.Socket></span><span class="sxs-lookup"><span data-stu-id="0ed15-2770">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method if you only want to determine the status of a single <xref:System.Net.Sockets.Socket>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2771">Ta metoda nie może wykryć niektórych rodzajów problemów z połączeniami, takich jak przerwany kabel sieciowy lub że host zdalny został zamknięty nieprawidłowo.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2771">This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</span></span> <span data-ttu-id="0ed15-2772">Należy podjąć próbę wysłania lub odebrania danych w celu wykrycia tego rodzaju błędów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2772">You must attempt to send or receive data to detect these kinds of errors.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2773">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2773">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-2774">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2774">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-2775">Poniższy przykład kodu używa <xref:System.Net.Sockets.Socket.Select%2A> do określenia, które gniazda nasłuchujące mają żądanie połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2775">The following code example uses <xref:System.Net.Sockets.Socket.Select%2A> to determine which listening sockets have a connection request.</span></span>  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-2776"><paramref name="checkRead" /> Parametr jest<see langword="null" /> lub pusty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2776">The <paramref name="checkRead" /> parameter is <see langword="null" /> or empty.</span></span>  
  
<span data-ttu-id="0ed15-2777">- i -</span><span class="sxs-lookup"><span data-stu-id="0ed15-2777">-and-</span></span> 
<span data-ttu-id="0ed15-2778"><paramref name="checkWrite" /> Parametr jest<see langword="null" /> lub pusty</span><span class="sxs-lookup"><span data-stu-id="0ed15-2778">The <paramref name="checkWrite" /> parameter is <see langword="null" /> or empty</span></span> 
<span data-ttu-id="0ed15-2779">- i -</span><span class="sxs-lookup"><span data-stu-id="0ed15-2779">-and-</span></span> 
<span data-ttu-id="0ed15-2780"><paramref name="checkError" /> Parametr jest<see langword="null" /> lub pusty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2780">The <paramref name="checkError" /> parameter is <see langword="null" /> or empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2781">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2781">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ed15-2782">Wysyła dane do połączonej <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2782">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-2783">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2783">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <summary><span data-ttu-id="0ed15-2784">Wysyła dane do połączonej <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2784">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-2785">Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2785">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2786"><xref:System.Net.Sockets.Socket.Send%2A>synchronicznie wysyła dane do hosta zdalnego określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metodzie lub <xref:System.Net.Sockets.Socket.Accept%2A> i zwraca liczbę pomyślnie wysłanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2786"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="0ed15-2787"><xref:System.Net.Sockets.Socket.Send%2A>może być używany zarówno dla protokołów zorientowanych na połączenia, jak i bezpołączeni.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2787"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="0ed15-2788">To Przeciążenie wymaga buforu zawierającego dane, które mają zostać wysłane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2788">This overload requires a buffer that contains the data you want to send.</span></span> <span data-ttu-id="0ed15-2789"><xref:System.Net.Sockets.SocketFlags> Wartość domyślna to 0, przesunięcie buforu domyślnie równa 0 i liczba bajtów, które mają zostać wysłane domyślnie do rozmiaru buforu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2789">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span>  
  
 <span data-ttu-id="0ed15-2790">Jeśli używasz bezpołączeniowego protokołu, musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosić <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2790">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2791">W przypadku korzystania z protokołu zorientowanego na połączenia należy użyć polecenia <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym, lub użyć <xref:System.Net.Sockets.Socket.Accept%2A> do zaakceptowania połączenia przychodzącego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2791">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="0ed15-2792">Jeśli używasz bezpołączeniowego protokołu i planujesz wysyłać dane do kilku różnych hostów, użyj <xref:System.Net.Sockets.Socket.SendTo%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2792">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="0ed15-2793">Jeśli <xref:System.Net.Sockets.Socket.SendTo%2A> Metoda nie zostanie użyta, należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed każdym wywołaniem <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2793">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="0ed15-2794">Możesz użyć <xref:System.Net.Sockets.Socket.SendTo%2A> nawet po ustanowieniu domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2794">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="0ed15-2795">Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> , wykonując inne <xref:System.Net.Sockets.Socket.Connect%2A>wywołanie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2795">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="0ed15-2796">W przypadku korzystania z protokołu <xref:System.Net.Sockets.Socket.Send%2A> zorientowanego na połączenia program zablokuje do momentu wysłania wszystkich bajtów w buforze, chyba że limit czasu został ustawiony przy użyciu. <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0ed15-2796">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0ed15-2797">W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2797">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2798">W trybie nieblokującym może <xref:System.Net.Sockets.Socket.Send%2A> zakończyć się pomyślnie nawet wtedy, gdy wyśle on mniejszą liczbę bajtów w buforze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2798">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="0ed15-2799">Jest to odpowiedzialność aplikacji do śledzenia liczby wysłanych bajtów i ponawiania operacji do momentu, gdy aplikacja wyśle bajty w buforze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2799">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="0ed15-2800">Nie ma również gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2800">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="0ed15-2801">Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2801">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="0ed15-2802">Pomyślne zakończenie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2802">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2803">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2803">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-2804">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2804">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2805">Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2805">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="0ed15-2806">Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2806">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2807">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2807">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-2808">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2808">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-2809">Poniższy przykład kodu demonstruje wysyłanie danych w połączonym <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2809">The following code example demonstrates sending data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-2810"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2810"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2811">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2811">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2812"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2812">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="0ed15-2813">Lista <see cref="T:System.ArraySegment`1" />s typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2813">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <summary><span data-ttu-id="0ed15-2814">Wysyła zestaw buforów z listy do połączonej <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2814">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-2815">Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2815">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2816"><xref:System.Net.Sockets.Socket.Send%2A>może być używany zarówno dla protokołów zorientowanych na połączenia, jak i bezpołączeni.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2816"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="0ed15-2817">To Przeciążenie wymaga co najmniej jednego buforu zawierającego dane, które mają zostać wysłane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2817">This overload requires at least one buffer that contains the data you want to send.</span></span>  
  
 <span data-ttu-id="0ed15-2818">Jeśli używasz bezpołączeniowego protokołu, musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosić <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2818">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2819">W przypadku korzystania z protokołu zorientowanego na połączenia należy użyć polecenia <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym, lub użyć <xref:System.Net.Sockets.Socket.Accept%2A> do zaakceptowania połączenia przychodzącego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2819">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="0ed15-2820">Jeśli używasz bezpołączeniowego protokołu i planujesz wysyłać dane do kilku różnych hostów, użyj <xref:System.Net.Sockets.Socket.SendTo%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2820">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="0ed15-2821">Jeśli <xref:System.Net.Sockets.Socket.SendTo%2A> Metoda nie zostanie użyta, należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed każdym wywołaniem <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2821">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="0ed15-2822">Możesz użyć <xref:System.Net.Sockets.Socket.SendTo%2A> nawet po ustanowieniu domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2822">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="0ed15-2823">Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> , wykonując inne <xref:System.Net.Sockets.Socket.Connect%2A>wywołanie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2823">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="0ed15-2824">W przypadku korzystania z protokołu <xref:System.Net.Sockets.Socket.Send%2A> zorientowanego na połączenia program zablokuje do momentu wysłania wszystkich bajtów w buforze, chyba że limit czasu został ustawiony przy użyciu. <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0ed15-2824">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0ed15-2825">W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2825">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2826">W trybie nieblokującym może <xref:System.Net.Sockets.Socket.Send%2A> zakończyć się pomyślnie nawet wtedy, gdy wyśle on mniejszą liczbę bajtów w buforze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2826">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="0ed15-2827">Jest to odpowiedzialność aplikacji do śledzenia liczby wysłanych bajtów i ponawiania operacji do momentu, gdy aplikacja wyśle bajty w buforze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2827">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="0ed15-2828">Nie ma również gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2828">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="0ed15-2829">Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2829">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="0ed15-2830">Pomyślne zakończenie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2830">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2831">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2831">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-2832">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2832">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2833">Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2833">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="0ed15-2834">Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2834">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2835">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2835">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-2836">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2836">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-2837"><paramref name="buffers" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2837"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-2838"><paramref name="buffers" />jest puste.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2838"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2839">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2839">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="0ed15-2840">Zobacz uwagi poniżej.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2840">See remarks section below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2841"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2841">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-2842">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2842">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-2843">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2843">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="0ed15-2844">Wysyła dane do połączonego <see cref="T:System.Net.Sockets.Socket" /> przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2844">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" /> using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-2845">Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2845">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2846"><xref:System.Net.Sockets.Socket.Send%2A>synchronicznie wysyła dane do hosta zdalnego ustanowionego w <xref:System.Net.Sockets.Socket.Connect%2A> metodzie lub <xref:System.Net.Sockets.Socket.Accept%2A> i zwraca liczbę pomyślnie wysłanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2846"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="0ed15-2847">Metoda <xref:System.Net.Sockets.Socket.Send%2A> ta może być używana zarówno dla protokołów zorientowanych na połączenia, jak i bezpołączeni.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2847">The <xref:System.Net.Sockets.Socket.Send%2A> method can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="0ed15-2848">To Przeciążenie wymaga bufora zawierającego dane, które mają zostać wysłane, oraz kombinacji <xref:System.Net.Sockets.SocketFlags>bitowe.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2848">This overload requires a buffer that contains the data you want to send and a bitwise combination of <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="0ed15-2849">Wartość domyślna przesunięcia buforu jest równa 0, a liczba bajtów do wysłania domyślnie do rozmiaru buforu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2849">The buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span> <span data-ttu-id="0ed15-2850">Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketflags` jako wartość parametru, wysyłane dane nie będą kierowane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2850">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter value, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="0ed15-2851">Jeśli używasz bezpołączeniowego protokołu, musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosić <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2851">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2852">W przypadku korzystania z protokołu zorientowanego na połączenia należy użyć polecenia <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym, lub użyć <xref:System.Net.Sockets.Socket.Accept%2A> do zaakceptowania połączenia przychodzącego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2852">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="0ed15-2853">Jeśli używasz bezpołączeniowego protokołu i planujesz wysyłać dane do kilku różnych hostów, użyj <xref:System.Net.Sockets.Socket.SendTo%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2853">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="0ed15-2854">Jeśli <xref:System.Net.Sockets.Socket.SendTo%2A> Metoda nie zostanie użyta, należy <xref:System.Net.Sockets.Socket.Connect%2A> wywołać <xref:System.Net.Sockets.Socket.Send%2A>metodę przed każdym wywołaniem.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2854">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="0ed15-2855">Możesz użyć <xref:System.Net.Sockets.Socket.SendTo%2A> nawet po ustanowieniu domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2855">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="0ed15-2856">Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> , wykonując inne <xref:System.Net.Sockets.Socket.Connect%2A>wywołanie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2856">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="0ed15-2857">W przypadku korzystania z protokołu <xref:System.Net.Sockets.Socket.Send%2A> zorientowanego na połączenia program zablokuje do momentu wysłania wszystkich bajtów w buforze, chyba że limit czasu został ustawiony przy użyciu. <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0ed15-2857">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0ed15-2858">W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2858">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2859">W trybie nieblokującym może <xref:System.Net.Sockets.Socket.Send%2A> zakończyć się pomyślnie nawet wtedy, gdy wyśle on mniejszą liczbę bajtów w buforze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2859">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="0ed15-2860">Jest to odpowiedzialność aplikacji do śledzenia liczby wysłanych bajtów i ponawiania operacji do momentu, gdy aplikacja wyśle żądaną liczbę bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2860">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="0ed15-2861">Nie ma również gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2861">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="0ed15-2862">Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2862">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="0ed15-2863">Pomyślne zakończenie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2863">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2864">Należy upewnić się, że rozmiar buforu nie przekracza maksymalnego rozmiaru pakietu dostawcy usługi.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2864">You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="0ed15-2865">Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.Send%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2865">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2866">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2866">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-2867">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2867">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2868">Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2868">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="0ed15-2869">Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2869">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2870">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2870">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-2871">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2871">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-2872">Poniższy przykład kodu demonstruje wysyłanie danych w połączonym <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2872">The following code example demonstrates sending data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-2873"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2873"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2874">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2874">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2875"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2875">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="0ed15-2876">Lista <see cref="T:System.ArraySegment`1" />s typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2876">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-2877">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2877">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="0ed15-2878">Wysyła zestaw buforów z listy do połączonego <see cref="T:System.Net.Sockets.Socket" />, przy użyciu określonego. <see cref="T:System.Net.Sockets.SocketFlags" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-2878">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-2879">Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2879">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2880">To Przeciążenie wymaga co najmniej jednego buforu zawierającego dane, które mają zostać wysłane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2880">This overload requires at least one buffer that contains the data you want to send.</span></span> <span data-ttu-id="0ed15-2881"><xref:System.Net.Sockets.SocketFlags> Wartość domyślna to 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2881">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span> <span data-ttu-id="0ed15-2882">Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketFlags` jako parametr, wysyłane dane nie będą kierowane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2882">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="0ed15-2883">Jeśli używasz bezpołączeniowego protokołu, musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosić <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2883">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2884">W przypadku korzystania z protokołu zorientowanego na połączenia należy użyć polecenia <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym, lub użyć <xref:System.Net.Sockets.Socket.Accept%2A> do zaakceptowania połączenia przychodzącego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2884">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="0ed15-2885">Jeśli używasz bezpołączeniowego protokołu i planujesz wysyłać dane do kilku różnych hostów, użyj <xref:System.Net.Sockets.Socket.SendTo%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2885">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="0ed15-2886">Jeśli <xref:System.Net.Sockets.Socket.SendTo%2A> Metoda nie zostanie użyta, należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed każdym wywołaniem <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2886">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="0ed15-2887">Możesz użyć <xref:System.Net.Sockets.Socket.SendTo%2A> nawet po ustanowieniu domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2887">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="0ed15-2888">Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> , wykonując inne <xref:System.Net.Sockets.Socket.Connect%2A>wywołanie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2888">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="0ed15-2889">W przypadku korzystania z protokołu <xref:System.Net.Sockets.Socket.Send%2A> zorientowanego na połączenia program zablokuje do momentu wysłania wszystkich bajtów w buforze, chyba że limit czasu został ustawiony przy użyciu. <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0ed15-2889">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0ed15-2890">W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2890">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2891">W trybie bez blokowania może zakończyć <xref:System.Net.Sockets.Socket.Send%2A> się pomyślnie nawet wtedy, gdy wysyła wartość mniejszą niż liczba bajtów w buforze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2891">In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="0ed15-2892">Jest to odpowiedzialność aplikacji do śledzenia liczby wysłanych bajtów i ponawiania operacji do momentu, gdy aplikacja wyśle bajty w buforze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2892">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="0ed15-2893">Nie ma również gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2893">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="0ed15-2894">Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2894">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="0ed15-2895">Pomyślne zakończenie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2895">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2896">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2896">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-2897">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2897">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2898">Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2898">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="0ed15-2899">Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2899">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2900">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2900">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-2901">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2901">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-2902"><paramref name="buffers" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2902"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-2903"><paramref name="buffers" />jest puste.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2903"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2904">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2904">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2905"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2905">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-2906">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2906">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="size"><span data-ttu-id="0ed15-2907">Liczba bajtów do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2907">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-2908">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2908">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="0ed15-2909">Wysyła określoną liczbę bajtów danych do połączonego <see cref="T:System.Net.Sockets.Socket" />, przy użyciu określonego. <see cref="T:System.Net.Sockets.SocketFlags" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-2909">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-2910">Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2910">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2911"><xref:System.Net.Sockets.Socket.Send%2A>synchronicznie wysyła dane do hosta zdalnego ustanowionego w <xref:System.Net.Sockets.Socket.Connect%2A> metodzie lub <xref:System.Net.Sockets.Socket.Accept%2A> i zwraca liczbę pomyślnie wysłanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2911"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="0ed15-2912"><xref:System.Net.Sockets.Socket.Send%2A>może być używany zarówno dla protokołów zorientowanych na połączenia, jak i bezpołączeni.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2912"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="0ed15-2913">To Przeciążenie wymaga bufora zawierającego dane, które mają zostać wysłane, liczbę bajtów do wysłania oraz bitową kombinację dowolnych <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2913">This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, and a bitwise combination of any <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="0ed15-2914">Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketflags` jako parametr, wysyłane dane nie będą kierowane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2914">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="0ed15-2915">Jeśli używasz bezpołączeniowego protokołu, musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosić <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2915">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2916">W przypadku korzystania z protokołu zorientowanego na połączenia należy użyć polecenia <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym, lub użyć <xref:System.Net.Sockets.Socket.Accept%2A> do zaakceptowania połączenia przychodzącego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2916">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="0ed15-2917">Jeśli używasz bezpołączeniowego protokołu i planujesz wysyłać dane do kilku różnych hostów, użyj <xref:System.Net.Sockets.Socket.SendTo%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2917">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="0ed15-2918">Jeśli <xref:System.Net.Sockets.Socket.SendTo%2A> Metoda nie zostanie użyta, należy <xref:System.Net.Sockets.Socket.Connect%2A> wywołać metodę <xref:System.Net.Sockets.Socket.Send%2A> przed każdym wywołaniem metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2918">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="0ed15-2919">Możesz użyć <xref:System.Net.Sockets.Socket.SendTo%2A> nawet po ustanowieniu domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2919">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="0ed15-2920">Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> , wykonując inne <xref:System.Net.Sockets.Socket.Connect%2A>wywołanie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2920">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="0ed15-2921">W przypadku protokołu <xref:System.Net.Sockets.Socket.Send%2A> zorientowanego na połączenia program zablokuje do momentu wysłania żądanej liczby bajtów, chyba że limit czasu został ustawiony przy <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>użyciu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2921">With a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0ed15-2922">W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2922">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2923">W trybie niezablokowanym, <xref:System.Net.Sockets.Socket.Send%2A> może zakończyć się pomyślnie nawet wtedy, gdy wysyła mniej niż liczba żądanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2923">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="0ed15-2924">Jest to odpowiedzialność aplikacji do śledzenia liczby wysłanych bajtów i ponawiania operacji do momentu, gdy aplikacja wyśle żądaną liczbę bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2924">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="0ed15-2925">Nie ma również gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2925">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="0ed15-2926">Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2926">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="0ed15-2927">Pomyślne zakończenie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2927">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2928">Należy upewnić się, że rozmiar nie przekracza maksymalnego rozmiaru pakietu dostawcy usługi.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2928">You must ensure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="0ed15-2929">Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.Send%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2929">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2930">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2930">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-2931">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2931">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2932">Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2932">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="0ed15-2933">Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2933">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2934">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2934">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-2935">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2935">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-2936">Poniższy przykład kodu wysyła dane Znalezione w buforze i określa <xref:System.Net.Sockets.SocketFlags.None> dla. <xref:System.Net.Sockets.SocketFlags></span><span class="sxs-lookup"><span data-stu-id="0ed15-2936">The following code example sends the data found in buffer, and specifies <xref:System.Net.Sockets.SocketFlags.None> for <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-2937"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2937"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-2938"><paramref name="size" />jest mniejsza niż 0 lub przekracza rozmiar buforu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2938"><paramref name="size" /> is less than 0 or exceeds the size of the buffer.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2939"><paramref name="socketFlags" />nie jest prawidłową kombinacją wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2939"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="0ed15-2940">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-2940">-or-</span></span> 
<span data-ttu-id="0ed15-2941">Wystąpił błąd systemu operacyjnego podczas uzyskiwania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2941">An operating system error occurs while accessing the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2942"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2942">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="0ed15-2943">Lista <see cref="T:System.ArraySegment`1" />s typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2943">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-2944">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2944">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="0ed15-2945"><see cref="T:System.Net.Sockets.SocketError" /> Obiekt, który przechowuje błąd gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2945">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="0ed15-2946">Wysyła zestaw buforów z listy do połączonego <see cref="T:System.Net.Sockets.Socket" />, przy użyciu określonego. <see cref="T:System.Net.Sockets.SocketFlags" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-2946">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-2947">Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2947">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2948">To Przeciążenie wymaga co najmniej jednego buforu zawierającego dane, które mają zostać wysłane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2948">This overload requires at least one buffer that contains the data you want to send.</span></span> <span data-ttu-id="0ed15-2949"><xref:System.Net.Sockets.SocketFlags> Wartość domyślna to 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2949">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span> <span data-ttu-id="0ed15-2950">Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketFlags` jako parametr, wysyłane dane nie będą kierowane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2950">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="0ed15-2951">Jeśli używasz bezpołączeniowego protokołu, musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosić <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2951">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2952">W przypadku korzystania z protokołu zorientowanego na połączenia należy użyć polecenia <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym, lub użyć <xref:System.Net.Sockets.Socket.Accept%2A> do zaakceptowania połączenia przychodzącego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2952">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="0ed15-2953">Jeśli używasz bezpołączeniowego protokołu i planujesz wysyłać dane do kilku różnych hostów, użyj <xref:System.Net.Sockets.Socket.SendTo%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2953">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="0ed15-2954">Jeśli <xref:System.Net.Sockets.Socket.SendTo%2A> Metoda nie zostanie użyta, należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed każdym wywołaniem <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2954">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="0ed15-2955">Możesz użyć <xref:System.Net.Sockets.Socket.SendTo%2A> nawet po ustanowieniu domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2955">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="0ed15-2956">Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> , wykonując inne <xref:System.Net.Sockets.Socket.Connect%2A>wywołanie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2956">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="0ed15-2957">W przypadku korzystania z protokołu <xref:System.Net.Sockets.Socket.Send%2A> zorientowanego na połączenia program zablokuje do momentu wysłania wszystkich bajtów w buforze, chyba że limit czasu został ustawiony przy użyciu. <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0ed15-2957">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0ed15-2958">W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2958">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2959">W trybie bez blokowania może zakończyć <xref:System.Net.Sockets.Socket.Send%2A> się pomyślnie nawet wtedy, gdy wysyła wartość mniejszą niż liczba bajtów w buforze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2959">In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="0ed15-2960">Jest to odpowiedzialność aplikacji do śledzenia liczby wysłanych bajtów i ponawiania operacji do momentu, gdy aplikacja wyśle bajty w buforze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2960">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="0ed15-2961">Nie ma również gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2961">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="0ed15-2962">Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2962">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="0ed15-2963">Pomyślne zakończenie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2963">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2964">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2964">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-2965">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2965">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2966">Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2966">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="0ed15-2967">Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2967">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2968">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2968">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-2969">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-2969">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-2970"><paramref name="buffers" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2970"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-2971"><paramref name="buffers" />jest puste.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2971"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-2972">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2972">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-2973"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2973">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-2974">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2974">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="offset"><span data-ttu-id="0ed15-2975">Pozycja w buforze danych, w której mają zostać rozpoczęte wysyłanie danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2975">The position in the data buffer at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="0ed15-2976">Liczba bajtów do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2976">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-2977">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2977">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="0ed15-2978">Wysyła określoną liczbę bajtów danych do połączonego <see cref="T:System.Net.Sockets.Socket" />, rozpoczynając od określonego przesunięcia i używając określonego. <see cref="T:System.Net.Sockets.SocketFlags" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-2978">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-2979">Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2979">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-2980"><xref:System.Net.Sockets.Socket.Send%2A>synchronicznie wysyła dane do hosta zdalnego określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metodzie lub <xref:System.Net.Sockets.Socket.Accept%2A> i zwraca liczbę pomyślnie wysłanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2980"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="0ed15-2981"><xref:System.Net.Sockets.Socket.Send%2A>może być używany zarówno dla protokołów zorientowanych na połączenia, jak i bezpołączeni.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2981"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="0ed15-2982">W tym przeciążeniu, jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketflags` jako parametr, wysyłane dane nie będą kierowane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2982">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="0ed15-2983">Jeśli używasz bezpołączeniowego protokołu, musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosić <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2983">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2984">W przypadku korzystania z protokołu zorientowanego na połączenia należy użyć polecenia <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym, lub użyć <xref:System.Net.Sockets.Socket.Accept%2A> do zaakceptowania połączenia przychodzącego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2984">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="0ed15-2985">Jeśli używasz bezpołączeniowego protokołu i planujesz wysyłać dane do kilku różnych hostów, użyj polecenia <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2985">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="0ed15-2986">Jeśli nie używasz <xref:System.Net.Sockets.Socket.SendTo%2A>, musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed każdym wywołaniem do <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2986">If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="0ed15-2987">Nie można jej używać <xref:System.Net.Sockets.Socket.SendTo%2A> nawet po ustanowieniu domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2987">It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="0ed15-2988">Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> , wykonując inne <xref:System.Net.Sockets.Socket.Connect%2A>wywołanie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2988">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="0ed15-2989">Należy również upewnić się, że rozmiar nie przekracza maksymalnego rozmiaru pakietu dostawcy usługi.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2989">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="0ed15-2990">Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.Send%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2990">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="0ed15-2991">Jeśli używasz protokołu zorientowanego na połączenie, <xref:System.Net.Sockets.Socket.Send%2A> program zablokuje do momentu wysłania żądanej liczby bajtów, chyba że limit czasu został ustawiony przy użyciu. <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0ed15-2991">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0ed15-2992">W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2992">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-2993">W trybie niezablokowanym, <xref:System.Net.Sockets.Socket.Send%2A> może zakończyć się pomyślnie nawet wtedy, gdy wysyła mniej niż liczba żądanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2993">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="0ed15-2994">Jest to odpowiedzialność aplikacji do śledzenia liczby wysłanych bajtów i ponawiania operacji do momentu, gdy aplikacja wyśle żądaną liczbę bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2994">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="0ed15-2995">Nie ma również gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2995">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="0ed15-2996">Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2996">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="0ed15-2997">Pomyślne zakończenie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2997">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-2998">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2998">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-2999">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-2999">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3000">Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3000">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="0ed15-3001">Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3001">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3002">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3002">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-3003">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-3003">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-3004">Poniższy przykład kodu określa bufor danych, przesunięcie, rozmiar i <xref:System.Net.Sockets.SocketFlags> na potrzeby wysyłania danych do połączonej. <xref:System.Net.Sockets.Socket></span><span class="sxs-lookup"><span data-stu-id="0ed15-3004">The following code example specifies the data buffer, an offset, a size, and <xref:System.Net.Sockets.SocketFlags> for sending data to a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-3005"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3005"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-3006"><paramref name="offset" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3006"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-3007">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-3007">-or-</span></span> 
 <span data-ttu-id="0ed15-3008"><paramref name="offset" />jest większa niż długość <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3008"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="0ed15-3009">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-3009">-or-</span></span> 
 <span data-ttu-id="0ed15-3010"><paramref name="size" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3010"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-3011">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-3011">-or-</span></span> 
 <span data-ttu-id="0ed15-3012"><paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości <paramref name="offset" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3012"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-3013"><paramref name="socketFlags" />nie jest prawidłową kombinacją wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3013"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="0ed15-3014">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-3014">-or-</span></span> 
<span data-ttu-id="0ed15-3015">Wystąpił błąd systemu operacyjnego podczas uzyskiwania dostępu <see cref="T:System.Net.Sockets.Socket" />do programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3015">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-3016"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3016">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-3017">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3017">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="offset"><span data-ttu-id="0ed15-3018">Pozycja w buforze danych, w której mają zostać rozpoczęte wysyłanie danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3018">The position in the data buffer at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="0ed15-3019">Liczba bajtów do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3019">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-3020">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3020">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="0ed15-3021"><see cref="T:System.Net.Sockets.SocketError" /> Obiekt, który przechowuje błąd gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3021">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="0ed15-3022">Wysyła określoną liczbę bajtów danych do połączonego <see cref="T:System.Net.Sockets.Socket" />, rozpoczynając od określonego przesunięcia i używając określonego<see cref="T:System.Net.Sockets.SocketFlags" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-3022">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" /></span></span></summary>
        <returns><span data-ttu-id="0ed15-3023">Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3023">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-3024"><xref:System.Net.Sockets.Socket.Send%2A>synchronicznie wysyła dane do hosta zdalnego określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metodzie lub <xref:System.Net.Sockets.Socket.Accept%2A> i zwraca liczbę pomyślnie wysłanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3024"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="0ed15-3025"><xref:System.Net.Sockets.Socket.Send%2A>może być używany zarówno dla protokołów zorientowanych na połączenia, jak i bezpołączeni.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3025"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="0ed15-3026">W tym przeciążeniu, jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketflags` jako parametr, wysyłane dane nie będą kierowane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3026">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="0ed15-3027">Jeśli używasz bezpołączeniowego protokołu, musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosić <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3027">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-3028">W przypadku korzystania z protokołu zorientowanego na połączenia należy użyć polecenia <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym, lub użyć <xref:System.Net.Sockets.Socket.Accept%2A> do zaakceptowania połączenia przychodzącego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3028">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="0ed15-3029">Jeśli używasz bezpołączeniowego protokołu i planujesz wysyłać dane do kilku różnych hostów, użyj polecenia <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3029">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="0ed15-3030">Jeśli nie używasz <xref:System.Net.Sockets.Socket.SendTo%2A>, musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed każdym wywołaniem do <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3030">If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="0ed15-3031">Nie można jej używać <xref:System.Net.Sockets.Socket.SendTo%2A> nawet po ustanowieniu domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3031">It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="0ed15-3032">Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> , wykonując inne <xref:System.Net.Sockets.Socket.Connect%2A>wywołanie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3032">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="0ed15-3033">Należy również upewnić się, że rozmiar nie przekracza maksymalnego rozmiaru pakietu dostawcy usługi.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3033">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="0ed15-3034">Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.Send%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3034">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="0ed15-3035">Jeśli używasz protokołu zorientowanego na połączenie, <xref:System.Net.Sockets.Socket.Send%2A> program zablokuje do momentu wysłania żądanej liczby bajtów, chyba że limit czasu został ustawiony przy użyciu. <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0ed15-3035">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0ed15-3036">W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu wywołanie zwróci <xref:System.Net.Sockets.SocketException>wartość.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3036">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-3037">W trybie niezablokowanym, <xref:System.Net.Sockets.Socket.Send%2A> może zakończyć się pomyślnie nawet wtedy, gdy wysyła mniej niż liczba żądanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3037">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="0ed15-3038">Jest to odpowiedzialność aplikacji do śledzenia liczby wysłanych bajtów i ponawiania operacji do momentu, gdy aplikacja wyśle żądaną liczbę bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3038">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="0ed15-3039">Nie ma również gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3039">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="0ed15-3040">Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3040">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="0ed15-3041">Pomyślne zakończenie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3041">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3042">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3042">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-3043">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3043">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3044">Pomyślne zakończenie wysyłania nie wskazuje, że dane zostały dostarczone pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3044">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="0ed15-3045">Jeśli w systemie transportowym nie ma dostępnego miejsca w buforze do przechowywania przesyłanych danych, wysyłanie zostanie zablokowane, chyba że gniazdo zostało umieszczone w trybie nieblokującym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3045">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3046">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3046">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-3047">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-3047">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-3048">Poniższy przykład kodu określa bufor danych, przesunięcie, rozmiar i <xref:System.Net.Sockets.SocketFlags> na potrzeby wysyłania danych do połączonej. <xref:System.Net.Sockets.Socket></span><span class="sxs-lookup"><span data-stu-id="0ed15-3048">The following code example specifies the data buffer, an offset, a size, and <xref:System.Net.Sockets.SocketFlags> for sending data to a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-3049"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3049"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-3050"><paramref name="offset" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3050"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-3051">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-3051">-or-</span></span> 
 <span data-ttu-id="0ed15-3052"><paramref name="offset" />jest większa niż długość <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3052"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="0ed15-3053">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-3053">-or-</span></span> 
 <span data-ttu-id="0ed15-3054"><paramref name="size" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3054"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-3055">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-3055">-or-</span></span> 
 <span data-ttu-id="0ed15-3056"><paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości <paramref name="offset" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3056"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-3057"><paramref name="socketFlags" />nie jest prawidłową kombinacją wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3057"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="0ed15-3058">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-3058">-or-</span></span> 
<span data-ttu-id="0ed15-3059">Wystąpił błąd systemu operacyjnego podczas uzyskiwania dostępu <see cref="T:System.Net.Sockets.Socket" />do programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3059">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-3060"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3060">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="0ed15-3061">Obiekt <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> , który ma być używany dla tej asynchronicznej operacji gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3061">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="0ed15-3062">Asynchronicznie wysyła dane do połączonego <see cref="T:System.Net.Sockets.Socket" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3062">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="0ed15-3063"><see langword="true" />Jeśli operacja we/wy jest w stanie oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3063"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="0ed15-3064"><see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie<paramref name="e" /> na parametrze zostanie wywołane po zakończeniu operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3064">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="0ed15-3065"><see langword="false" />Jeśli operacja we/wy została ukończona synchronicznie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3065"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="0ed15-3066">W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie <paramref name="e" /> na parametrze <paramref name="e" /> nie zostanie zgłoszone i obiekt przenoszony jako parametr może zostać zbadany natychmiast po wywołaniu metody, aby pobrać wynik operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3066">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-3067"><xref:System.Net.Sockets.Socket.SendAsync%2A> Metoda jest używana do zapisywania danych wychodzących z co najmniej jednego bufora w gnieździe zorientowanym na połączenie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3067">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method is used to write outgoing data from one or more buffers on a connection-oriented socket.</span></span> <span data-ttu-id="0ed15-3068">Ta metoda może być również używana w gniazdach bez połączenia, które określiły host zdalny w operacji łączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3068">This method can also be used, however, on connectionless sockets that have specified a remote host on a connect operation.</span></span>  
  
 <span data-ttu-id="0ed15-3069"><xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.ConnectAsync%2A> <xref:System.Net.Sockets.Socket.AcceptAsync%2A> <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.Connect%2A>Metoda uruchamia asynchroniczną operację wysyłania do hosta zdalnego, który został ustanowiony w metodzie <xref:System.Net.Sockets.Socket.BeginConnect%2A>,,,, lub. <xref:System.Net.Sockets.Socket.SendAsync%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-3069">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-3070">Następujące właściwości i zdarzenia w <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiekcie są wymagane do pomyślnego wywołania tej metody:</span><span class="sxs-lookup"><span data-stu-id="0ed15-3070">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <span data-ttu-id="0ed15-3071"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> lub <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0ed15-3071"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span></span>  
  
-   <span data-ttu-id="0ed15-3072"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>Jeśli <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> jest ustawiona</span><span class="sxs-lookup"><span data-stu-id="0ed15-3072"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <span data-ttu-id="0ed15-3073"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>Jeśli <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> jest ustawiona</span><span class="sxs-lookup"><span data-stu-id="0ed15-3073"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="0ed15-3074">Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość na dowolny obiekt stanu użytkownika przed <xref:System.Net.Sockets.Socket.SendAsync%2A> wywołaniem metody, tak aby informacje były możliwe do pobierania w metodzie wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3074">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="0ed15-3075">Jeśli wywołanie zwrotne wymaga więcej informacji niż pojedynczy obiekt, można utworzyć małą klasę w celu przechowywania innych wymaganych informacji o stanie jako członków.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3075">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="0ed15-3076"><xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.AcceptAsync%2A> <xref:System.Net.Sockets.Socket.Accept%2A>Metoda zgłosi wyjątek, jeśli nie zostanie najpierw wywołana,,,, lub <xref:System.Net.Sockets.Socket.ConnectAsync%2A>. <xref:System.Net.Sockets.Socket.SendAsync%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-3076">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A><xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.</span></span>  
  
 <span data-ttu-id="0ed15-3077"><xref:System.Net.Sockets.Socket.SendAsync%2A> Wywołanie metody daje możliwość wysyłania danych w osobnym wątku wykonania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3077">Calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="0ed15-3078">W przypadku gniazd zorientowanych na komunikaty nie przekraczaj maksymalnego rozmiaru komunikatu dostawcy usługi Windows Sockets.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3078">For message-oriented sockets, do not exceed the maximum message size of the underlying Windows sockets service provider.</span></span> <span data-ttu-id="0ed15-3079">Jeśli dane są zbyt długie do przekazania przez bazowego dostawcę usług, żadne dane nie są przesyłane, a <xref:System.Net.Sockets.Socket.SendAsync%2A> Metoda <xref:System.Net.Sockets.SocketException> zgłasza z <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> zestawem natywny kod błędu WSAEMSGSIZE Winsock (10040).</span><span class="sxs-lookup"><span data-stu-id="0ed15-3079">If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <xref:System.Net.Sockets.Socket.SendAsync%2A> method throws a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAEMSGSIZE error code (10040).</span></span>  
  
 <span data-ttu-id="0ed15-3080">Należy zauważyć, że pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendAsync%2A> metody nie wskazuje, że dane zostały dostarczone pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3080">Note that the successful completion of the <xref:System.Net.Sockets.Socket.SendAsync%2A> method does not indicate that the data was successfully delivered.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-3081">Właściwości <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> <paramref name="e" /> lub <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> parametru muszą odwoływać się do prawidłowych buforów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3081">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> properties on the <paramref name="e" /> parameter must reference valid buffers.</span></span> <span data-ttu-id="0ed15-3082">Można ustawić jedną lub drugą z tych właściwości, ale nie oba jednocześnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3082">One or the other of these properties may be set, but not both at the same time.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-3083">Operacja gniazda była już w toku przy użyciu <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiektu określonego <paramref name="e" /> w parametrze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3083">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-3084">Ta metoda wymaga systemu Windows XP lub nowszego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3084">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-3085"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3085">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-3086"><see cref="M:System.Net.Sockets.Socket.Accept" /> <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />Program nie <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />jest jeszcze połączony lub nie został uzyskany za pośrednictwem metody,, lub. <see cref="T:System.Net.Sockets.Socket" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-3086">The <see cref="T:System.Net.Sockets.Socket" /> is not yet connected or was not obtained via an <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />,or <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />, method.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-3087">Pobiera lub ustawia wartość określającą rozmiar buforu <see cref="T:System.Net.Sockets.Socket" />wysyłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3087">Gets or sets a value that specifies the size of the send buffer of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="0ed15-3088">, <see cref="T:System.Int32" /> Który zawiera rozmiar (w bajtach) bufora wysyłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3088">An <see cref="T:System.Int32" /> that contains the size, in bytes, of the send buffer.</span></span> <span data-ttu-id="0ed15-3089">Wartość domyślna to 8192.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3089">The default is 8192.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-3090">Większy rozmiar buforu może opóźnić rozpoznawanie trudności z połączeniem.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3090">A larger buffer size might delay the recognition of connection difficulties.</span></span> <span data-ttu-id="0ed15-3091">Należy rozważyć zwiększenie rozmiaru buforu w przypadku transferu dużych plików lub korzystania z dużej przepustowości i połączenia o dużej opóźnieniu (na przykład satelitarnego dostawcy sieci szerokopasmowej).</span><span class="sxs-lookup"><span data-stu-id="0ed15-3091">Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-3092">Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.SendBufferSize%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3092">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.SendBufferSize%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-3093">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3093">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-3094"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3094">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-3095">Wartość określona dla operacji zestawu jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3095">The value specified for a set operation is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ed15-3096">Wysyła synchronicznie do połączonego <see cref="T:System.Net.Sockets.Socket" />pliku i opcjonalne dane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3096">Sends a file and optional data synchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="0ed15-3097">A <see cref="T:System.String" /> , który zawiera ścieżkę i nazwę pliku do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3097">A <see cref="T:System.String" /> that contains the path and name of the file to be sent.</span></span> <span data-ttu-id="0ed15-3098">Ten parametr może być <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3098">This parameter can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="0ed15-3099">Wysyła plik <paramref name="fileName" /> do połączonego <see cref="T:System.Net.Sockets.Socket" /> obiektu za pomocą <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> flagi wysyłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3099">Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object with the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> transmit flag.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-3100">To Przeciążenie wysyła plik `fileName` do połączonego gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3100">This overload sends the file `fileName` to the connected socket.</span></span> <span data-ttu-id="0ed15-3101">`null` `preBuffer` `postBuffer` Parametr ma wartość domyślną (0), a parametry i są domyślne dla. <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> `flags`</span><span class="sxs-lookup"><span data-stu-id="0ed15-3101">The `flags` parameter defaults to <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0), and the `preBuffer` and `postBuffer` parameters default to `null`.</span></span> <span data-ttu-id="0ed15-3102">Jeśli `fileName` znajduje się w katalogu lokalnym, może być identyfikowana przy użyciu tylko nazwy pliku; w przeciwnym razie należy określić pełną ścieżkę i nazwę pliku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3102">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="0ed15-3103">Symbole wieloznaczne (".. \\\\\\\\obsługiwane są \myfile.txt ") i nazwy udziałów UNC (" \shared Directory \myfile.txt "). \\</span><span class="sxs-lookup"><span data-stu-id="0ed15-3103">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="0ed15-3104">Jeśli plik nie zostanie znaleziony, zostanie zgłoszony wyjątek <xref:System.IO.FileNotFoundException> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-3104">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="0ed15-3105">Ta metoda używa `TransmitFile` funkcji znalezionej w interfejsie API Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3105">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="0ed15-3106">Aby uzyskać więcej informacji na `TransmitFile` temat funkcji i jej flag, zobacz dokumentację usługi [Windows Sockets](/windows/desktop/WinSock/) .</span><span class="sxs-lookup"><span data-stu-id="0ed15-3106">For more information about the `TransmitFile` function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="0ed15-3107"><xref:System.Net.Sockets.Socket.SendFile%2A>synchronicznie wysyła plik do hosta zdalnego określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metodzie lub. <xref:System.Net.Sockets.Socket.Accept%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-3107"><xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="0ed15-3108"><xref:System.Net.Sockets.Socket.SendFile%2A>może być używany zarówno dla sieci zorientowanych na połączenia, jak i dla protokołów bezpołączeniowych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3108"><xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.</span></span>  
  
 <span data-ttu-id="0ed15-3109">Jeśli używasz bezpołączeniowego protokołu, musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody, w przeciwnym razie <xref:System.Net.Sockets.Socket.SendFile%2A> zgłasza <xref:System.Net.Sockets.SocketException> wyjątek.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3109">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span> <span data-ttu-id="0ed15-3110">W przypadku korzystania z protokołu zorientowanego na połączenia należy użyć polecenia <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym lub użyć <xref:System.Net.Sockets.Socket.Accept%2A> do akceptowania połączenia przychodzącego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3110">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="0ed15-3111">Jeśli używasz protokołu zorientowanego na połączenia, <xref:System.Net.Sockets.Socket.SendFile%2A> bloki do momentu wysłania pliku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3111">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the file is sent.</span></span> <span data-ttu-id="0ed15-3112">W trybie <xref:System.Net.Sockets.Socket.SendFile%2A> nieblokującym może zakończyć się pomyślnie przed wysłaniem całego pliku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3112">In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent.</span></span> <span data-ttu-id="0ed15-3113">Nie ma żadnej gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3113">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="0ed15-3114">Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3114">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="0ed15-3115">Pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendFile%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3115">A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3116">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3116">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-3117">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3117">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3118">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3118">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-3119">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-3119">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-3120">Poniższy przykład kodu tworzy i łączy gniazdo, a następnie wysyła plik do hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3120">The following code example creates and connects a socket and then sends a file to the remote host.</span></span> <span data-ttu-id="0ed15-3121">Plik "test. txt" znajduje się w katalogu głównym komputera lokalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3121">The file "test.txt" is located in the root directory of the local machine.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-3122">Gniazdo nie jest połączone z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3122">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-3123"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3123">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-3124"><see cref="T:System.Net.Sockets.Socket" /> Obiekt nie jest w trybie blokowania i nie może zaakceptować tego wywołania synchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3124">The <see cref="T:System.Net.Sockets.Socket" /> object is not in blocking mode and cannot accept this synchronous call.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="0ed15-3125">Nie znaleziono <paramref name="fileName" /> pliku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3125">The file <paramref name="fileName" /> was not found.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-3126">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3126">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="0ed15-3127">A <see cref="T:System.String" /> , który zawiera ścieżkę i nazwę pliku do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3127">A <see cref="T:System.String" /> that contains the path and name of the file to be sent.</span></span> <span data-ttu-id="0ed15-3128">Ten parametr może być <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3128">This parameter can be <see langword="null" />.</span></span></param>
        <param name="preBuffer"><span data-ttu-id="0ed15-3129"><see cref="T:System.Byte" /> Tablica zawierająca dane, które mają zostać wysłane przed wysłaniem pliku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3129">A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent.</span></span> <span data-ttu-id="0ed15-3130">Ten parametr może być <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3130">This parameter can be <see langword="null" />.</span></span></param>
        <param name="postBuffer"><span data-ttu-id="0ed15-3131"><see cref="T:System.Byte" /> Tablica zawierająca dane, które mają zostać wysłane po wysłaniu pliku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3131">A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent.</span></span> <span data-ttu-id="0ed15-3132">Ten parametr może być <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3132">This parameter can be <see langword="null" />.</span></span></param>
        <param name="flags"><span data-ttu-id="0ed15-3133">Co najmniej jedna wartość. <see cref="T:System.Net.Sockets.TransmitFileOptions" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-3133">One or more of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</span></span></param>
        <summary><span data-ttu-id="0ed15-3134">Wysyła plik <paramref name="fileName" /> i bufory danych do połączonego <see cref="T:System.Net.Sockets.Socket" /> obiektu przy użyciu określonej <see cref="T:System.Net.Sockets.TransmitFileOptions" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3134">Sends the file <paramref name="fileName" /> and buffers of data to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the specified <see cref="T:System.Net.Sockets.TransmitFileOptions" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-3135">To Przeciążenie wymaga nazwy pliku, który chcesz wysłać, oraz bitowej kombinacji <xref:System.Net.Sockets.TransmitFileOptions> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3135">This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values.</span></span> <span data-ttu-id="0ed15-3136">`preBuffer` Parametr zawiera wszystkie dane, które mają poprzedzać plik.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3136">The `preBuffer` parameter contains any data you want to precede the file.</span></span> <span data-ttu-id="0ed15-3137">`postBuffer`zawiera dane, które mają być zgodne z plikiem.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3137">`postBuffer` contains data you want to follow the file.</span></span> <span data-ttu-id="0ed15-3138">Jeśli `fileName` znajduje się w bieżącym katalogu roboczym, może być zidentyfikowany przy użyciu tylko nazwy pliku; w przeciwnym razie należy określić pełną ścieżkę i nazwę pliku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3138">If `fileName` is in the current working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="0ed15-3139">Symbole wieloznaczne (".. \\\\\\\\obsługiwane są \myfile.txt ") i nazwy udziałów UNC (" \shared Directory \myfile.txt "). \\</span><span class="sxs-lookup"><span data-stu-id="0ed15-3139">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span>  
  
 <span data-ttu-id="0ed15-3140">`flags` Parametr udostępnia dostawcy usługi okna Sockets z dodatkowymi informacjami na temat transferu plików.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3140">The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="0ed15-3141">Aby uzyskać więcej informacji na temat korzystania z tego parametru, <xref:System.Net.Sockets.TransmitFileOptions>Zobacz.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3141">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="0ed15-3142">Ta metoda używa `TransmitFile` funkcji znalezionej w interfejsie API Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3142">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="0ed15-3143">Aby uzyskać więcej informacji na `TransmitFile` temat funkcji i jej flag, zobacz dokumentację usługi [Windows Sockets](/windows/desktop/WinSock/) .</span><span class="sxs-lookup"><span data-stu-id="0ed15-3143">For more information about the `TransmitFile` function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="0ed15-3144"><xref:System.Net.Sockets.Socket.SendFile%2A>synchronicznie wysyła plik do hosta zdalnego określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metodzie lub. <xref:System.Net.Sockets.Socket.Accept%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-3144"><xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="0ed15-3145"><xref:System.Net.Sockets.Socket.SendFile%2A>może być używany zarówno dla sieci zorientowanych na połączenia, jak i dla protokołów bezpołączeniowych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3145"><xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.</span></span>  
  
 <span data-ttu-id="0ed15-3146">Jeśli używasz bezpołączeniowego protokołu, musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody; w przeciwnym razie <xref:System.Net.Sockets.Socket.SendFile%2A> zgłasza <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3146">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method; otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-3147">W przypadku korzystania z protokołu zorientowanego na połączenia należy użyć polecenia <xref:System.Net.Sockets.Socket.Connect%2A> , aby nawiązać połączenie z hostem zdalnym, lub użyć <xref:System.Net.Sockets.Socket.Accept%2A> do zaakceptowania połączenia przychodzącego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3147">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="0ed15-3148">Jeśli używasz protokołu zorientowanego na połączenia, <xref:System.Net.Sockets.Socket.SendFile%2A> bloki do momentu wysłania całego pliku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3148">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the entire file is sent.</span></span> <span data-ttu-id="0ed15-3149">W trybie <xref:System.Net.Sockets.Socket.SendFile%2A> nieblokującym może zakończyć się pomyślnie przed wysłaniem całego pliku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3149">In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent.</span></span> <span data-ttu-id="0ed15-3150">Nie ma żadnej gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3150">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="0ed15-3151">Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3151">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="0ed15-3152">Pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendFile%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3152">A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3153">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3153">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-3154">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3154">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3155">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3155">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-3156">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-3156">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-3157">Poniższy przykład kodu tworzy i łączy gniazdo.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3157">The following code example creates and connects a socket.</span></span> <span data-ttu-id="0ed15-3158">Plik "test. txt" znajduje się w katalogu głównym komputera lokalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3158">The file "test.txt" is located in the root directory of the local machine.</span></span> <span data-ttu-id="0ed15-3159">W tym przykładzie utworzymy przedpostbufferę i dane, a następnie wyślesz je do zdalnego hosta z plikiem.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3159">In this example, we create a prebuffer and postbuffer of data and send them to the remote host with the file.</span></span> <span data-ttu-id="0ed15-3160">Używane są <xref:System.Net.Sockets.TransmitFileOptions> ustawienia domyślne.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3160">The default <xref:System.Net.Sockets.TransmitFileOptions> are used.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-3161">System operacyjny nie jest systemem Windows NT lub nowszym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3161">The operating system is not Windows NT or later.</span></span>  
  
<span data-ttu-id="0ed15-3162">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-3162">-or-</span></span>
  
 <span data-ttu-id="0ed15-3163">Gniazdo nie jest połączone z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3163">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-3164"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3164">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-3165"><see cref="T:System.Net.Sockets.Socket" /> Obiekt nie jest w trybie blokowania i nie może zaakceptować tego wywołania synchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3165">The <see cref="T:System.Net.Sockets.Socket" /> object is not in blocking mode and cannot accept this synchronous call.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="0ed15-3166">Nie znaleziono <paramref name="fileName" /> pliku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3166">The file <paramref name="fileName" /> was not found.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-3167">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3167">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="0ed15-3168">Obiekt <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> , który ma być używany dla tej asynchronicznej operacji gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3168">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="0ed15-3169">Wysyła kolekcję plików lub buforów danych pamięci asynchronicznie do połączonego <see cref="T:System.Net.Sockets.Socket" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3169">Sends a collection of files or in memory data buffers asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="0ed15-3170"><see langword="true" />Jeśli operacja we/wy jest w stanie oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3170"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="0ed15-3171"><see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie<paramref name="e" /> na parametrze zostanie wywołane po zakończeniu operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3171">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="0ed15-3172"><see langword="false" />Jeśli operacja we/wy została ukończona synchronicznie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3172"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="0ed15-3173">W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie <paramref name="e" /> na parametrze <paramref name="e" /> nie zostanie zgłoszone i obiekt przenoszony jako parametr może zostać zbadany natychmiast po wywołaniu metody, aby pobrać wynik operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3173">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-3174"><xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Metoda jest używana do wysyłania kolekcji plików lub buforów danych pamięci do hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3174">The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is used to send a collection of files or in memory data buffers to remote host.</span></span> <span data-ttu-id="0ed15-3175">Ta <xref:System.Net.Sockets.Socket> wartość musi być już połączona z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3175">The <xref:System.Net.Sockets.Socket> must already be connected to the remote host.</span></span>  
  
 <span data-ttu-id="0ed15-3176"><xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> Jeśli odwołuje się do pliku w katalogu roboczym, można go zidentyfikować za pomocą tylko nazwy pliku; w przeciwnym razie należy określić pełną ścieżkę i nazwę pliku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3176">If a <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="0ed15-3177">Obsługiwane są symbole wieloznaczne i nazwy udziałów UNC.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3177">Wildcards and UNC share names are supported.</span></span> <span data-ttu-id="0ed15-3178">Jeśli plik nie zostanie znaleziony, <xref:System.IO.FileNotFoundException> zostanie zgłoszony.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3178">If the file is not found, <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="0ed15-3179">Aby otrzymywać powiadomienia o zakończeniu, należy utworzyć metodę wywołania zwrotnego implementującą delegata\<EventHandler SocketAsyncEventArgs > i dołączyć wywołanie zwrotne <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> do zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3179">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="0ed15-3180"><xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> Właściwość`e` na parametrze udostępnia dostawcy usługi Window Sockets z dodatkowymi informacjami na temat transferu plików.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3180">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="0ed15-3181">Aby uzyskać więcej informacji na temat korzystania z tego parametru, <xref:System.Net.Sockets.TransmitFileOptions>Zobacz.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3181">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="0ed15-3182">Następujące właściwości i zdarzenia w <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiekcie są wymagane do pomyślnego wywołania tej metody:</span><span class="sxs-lookup"><span data-stu-id="0ed15-3182">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="0ed15-3183">Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość na dowolny obiekt stanu użytkownika przed <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> wywołaniem metody, tak aby informacje były możliwe do pobierania w metodzie wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3183">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="0ed15-3184">Jeśli wywołanie zwrotne wymaga więcej informacji niż pojedynczy obiekt, można utworzyć małą klasę w celu przechowywania innych wymaganych informacji o stanie jako członków.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3184">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="0ed15-3185">Ta metoda używa funkcji TransmitPackets znajdującej się w interfejsie API Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3185">This method uses the TransmitPackets function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="0ed15-3186">Aby uzyskać więcej informacji na temat funkcji TransmitPackets i jej flag, zobacz dokumentację usługi [Windows Sockets](/windows/desktop/WinSock/) .</span><span class="sxs-lookup"><span data-stu-id="0ed15-3186">For more information about the TransmitPackets function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="0ed15-3187">Chociaż są <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> przeznaczone dla protokołów zorientowanych na połączenia, Metoda również działa dla protokołów bezpołączeniowych, pod warunkiem, że <xref:System.Net.Sockets.Socket.Connect%2A>należy najpierw <xref:System.Net.Sockets.Socket.ConnectAsync%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>wywołać metodę, lub, aby określić domyślny host zdalny.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3187">Although intended for connection-oriented protocols, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method to establish a default remote host.</span></span> <span data-ttu-id="0ed15-3188">W przypadku protokołów bez połączenia należy również upewnić się, że rozmiar pliku nie przekracza maksymalnego rozmiaru pakietu podstawowego dostawcy usług.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3188">With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="0ed15-3189">Jeśli tak, datagram nie jest wysyłany i <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> <xref:System.Net.Sockets.SocketException> zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3189">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
 <span data-ttu-id="0ed15-3190"><xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Metoda jest zoptymalizowana według systemu operacyjnego, w którym jest używana.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3190">The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized according to the operating system on which it is used.</span></span> <span data-ttu-id="0ed15-3191">W systemie Windows Server wersje <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Metoda jest zoptymalizowana pod kątem wysokiej wydajności.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3191">On Windows server editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for high performance.</span></span>  
  
 <span data-ttu-id="0ed15-3192">W przypadku wersji <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> klienta systemu Windows Metoda jest zoptymalizowana pod kątem minimalnej ilości pamięci i wykorzystania zasobów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3192">On Windows client editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for minimum memory and resource utilization.</span></span>  
  
 <span data-ttu-id="0ed15-3193"><xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> Użycie flagi<xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> we właściwości`e` parametru może zapewnić znaczne korzyści z wydajności.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3193">Use of the <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> property on the `e` parameter can deliver significant performance benefits.</span></span> <span data-ttu-id="0ed15-3194">Jeśli wątek inicjujący <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> wywołanie metody jest używany w przypadku dużych obliczeń, istnieje prawdopodobieństwo, że jest to mało prawdopodobne, że APCs może być niemożliwe do uruchomienia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3194">If the thread initiating the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching.</span></span> <span data-ttu-id="0ed15-3195">Należy zauważyć, że istnieje różnica między APCs jądra a trybem użytkownika.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3195">Note that there is a difference between kernel and user-mode APCs.</span></span> <span data-ttu-id="0ed15-3196">APCs jądra, gdy wątek jest w stanie oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3196">Kernel APCs launch when a thread is in a wait state.</span></span> <span data-ttu-id="0ed15-3197">APCs trybu użytkownika, gdy wątek jest w stanie oczekiwania na alert</span><span class="sxs-lookup"><span data-stu-id="0ed15-3197">User-mode APCs launch when a thread is in an alertable wait state</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="0ed15-3198">Nie znaleziono pliku określonego we <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> właściwości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3198">The file specified in the <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> property was not found.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-3199">Operacja gniazda była już w toku przy użyciu <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiektu określonego <paramref name="e" /> w parametrze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3199">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-3200">Ta metoda wymaga systemu Windows XP lub nowszego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3200">Windows XP or later is required for this method.</span></span> <span data-ttu-id="0ed15-3201">Ten wyjątek występuje również wtedy, <see cref="T:System.Net.Sockets.Socket" /> gdy nie jest podłączony do hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3201">This exception also occurs if the <see cref="T:System.Net.Sockets.Socket" /> is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-3202"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3202">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-3203">Jest używany <see cref="T:System.Net.Sockets.Socket" /> bezpołączeniowy i wysyłany plik przekracza maksymalny rozmiar pakietu podstawowego transportu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3203">A connectionless <see cref="T:System.Net.Sockets.Socket" /> is being used and the file being sent exceeds the maximum packet size of the underlying transport.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-3204">Pobiera lub ustawia wartość określającą czas, po upływie którego zostanie przekroczony <see cref="Overload:System.Net.Sockets.Socket.Send" /> limit czasu wywołania synchronicznego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3204">Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Send" /> call will time out.</span></span></summary>
        <value><span data-ttu-id="0ed15-3205">Wartość limitu czasu (w milisekundach).</span><span class="sxs-lookup"><span data-stu-id="0ed15-3205">The time-out value, in milliseconds.</span></span> <span data-ttu-id="0ed15-3206">Jeśli właściwość zostanie ustawiona z wartością z zakresu od 1 do 499, wartość zostanie zmieniona na 500.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3206">If you set the property with a value between 1 and 499, the value will be changed to 500.</span></span> <span data-ttu-id="0ed15-3207">Wartość domyślna to 0, co oznacza nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3207">The default value is 0, which indicates an infinite time-out period.</span></span> <span data-ttu-id="0ed15-3208">Określenie-1 wskazuje także nieskończony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3208">Specifying -1 also indicates an infinite time-out period.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-3209">Ta opcja dotyczy tylko wywołań <xref:System.Net.Sockets.Socket.Send%2A> synchronicznych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3209">This option applies to synchronous <xref:System.Net.Sockets.Socket.Send%2A> calls only.</span></span> <span data-ttu-id="0ed15-3210">W przypadku przekroczenia <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu Metoda <xref:System.Net.Sockets.SocketException>wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3210">If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-3211">Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.SendTimeout%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3211">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.SendTimeout%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-3212">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3212">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-3213"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3213">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-3214">Wartość określona dla operacji zestawu jest mniejsza niż-1.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3214">The value specified for a set operation is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ed15-3215">Wysyła dane do określonego punktu końcowego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3215">Sends data to a specific endpoint.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-3216">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3216">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="0ed15-3217"><see cref="T:System.Net.EndPoint" /> Reprezentuje miejsce docelowe dla danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3217">The <see cref="T:System.Net.EndPoint" /> that represents the destination for the data.</span></span></param>
        <summary><span data-ttu-id="0ed15-3218">Wysyła dane do określonego punktu końcowego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3218">Sends data to the specified endpoint.</span></span></summary>
        <returns><span data-ttu-id="0ed15-3219">Liczba wysłanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3219">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-3220">W tym przeciążeniu wartość domyślna przesunięcia bufora to 0, liczba bajtów wysyłanych domyślnie do rozmiaru `buffer` parametru, a wartością domyślną jest <xref:System.Net.Sockets.SocketFlags> 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3220">In this overload, the buffer offset defaults to 0, the number of bytes to send defaults to the size of the `buffer` parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span>  
  
 <span data-ttu-id="0ed15-3221">Jeśli używasz bezpołączeniowego protokołu, nie musisz nawiązać domyślnego hosta zdalnego z <xref:System.Net.Sockets.Socket.Connect%2A> metodą przed wywołaniem. <xref:System.Net.Sockets.Socket.SendTo%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-3221">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="0ed15-3222">Wystarczy wykonać tę czynność tylko wtedy, gdy zamierzasz wywołać <xref:System.Net.Sockets.Socket.Send%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3222">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="0ed15-3223">Jeśli wywołasz <xref:System.Net.Sockets.Socket.Connect%2A> metodę przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` parametr zastąpi określony domyślny host zdalny tylko dla tej operacji wysyłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3223">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="0ed15-3224">Nie jest również wymagane wywoływanie <xref:System.Net.Sockets.Socket.Bind%2A> metody, ponieważ dostawca usługi bazowej przypisze najbardziej odpowiedni adres sieci lokalnej i numer portu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3224">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="0ed15-3225">Jeśli trzeba zidentyfikować przypisany adres sieci lokalnej i numer portu, można użyć <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwości <xref:System.Net.Sockets.Socket.SendTo%2A> po pomyślnym ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3225">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="0ed15-3226">Chociaż są przeznaczone dla bezpołączeniych protokołów, <xref:System.Net.Sockets.Socket.SendTo%2A> działa również z protokołami zorientowanymi na połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3226">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="0ed15-3227">W przypadku korzystania z protokołu zorientowanego na połączenia należy najpierw ustanowić połączenie z hostem zdalnym, wywołując <xref:System.Net.Sockets.Socket.Connect%2A> metodę lub akceptując żądanie połączenia przychodzącego <xref:System.Net.Sockets.Socket.Accept%2A> za pomocą metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3227">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="0ed15-3228">Jeśli połączenie z hostem zdalnym nie zostanie nawiązane lub zaakceptowane, <xref:System.Net.Sockets.Socket.SendTo%2A> program zgłosi wartość. <xref:System.Net.Sockets.SocketException></span><span class="sxs-lookup"><span data-stu-id="0ed15-3228">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-3229">Przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A> metody można również ustanowić domyślnego hosta zdalnego dla bezpołączeniowego protokołu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3229">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="0ed15-3230">W każdym z tych przypadków <xref:System.Net.Sockets.Socket.SendTo%2A> program zignoruje ten `remoteEP` parametr i wyśle tylko dane do podłączonego lub domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3230">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="0ed15-3231">Blokowanie gniazd zostanie zablokowane do momentu wysłania wszystkich bajtów w buforze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3231">Blocking sockets will block until the all of the bytes in the buffer are sent.</span></span> <span data-ttu-id="0ed15-3232">Ponieważ nie jest <xref:System.Net.Sockets.Socket> wykonywane natychmiastowe zakończenie, może nie wysłać wszystkich bajtów `buffer`w.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3232">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`.</span></span> <span data-ttu-id="0ed15-3233">Jest to odpowiedzialność aplikacji do śledzenia liczby wysłanych bajtów i ponawiania operacji do momentu, gdy aplikacja wyśle wszystkie bajty w `buffer`.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3233">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`.</span></span> <span data-ttu-id="0ed15-3234">Nie ma również gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3234">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="0ed15-3235">Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych wychodzących.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3235">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="0ed15-3236">Pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendTo%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3236">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="0ed15-3237">Jeśli używasz protokołu bezpołączeni w trybie blokowania, <xref:System.Net.Sockets.Socket.SendTo%2A> program zablokuje do momentu wysłania datagramu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3237">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="0ed15-3238">Jeśli chcesz wysłać dane do adresu emisji, musisz najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodę i ustawić opcję gniazda na. <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0ed15-3238">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0ed15-3239">Należy również upewnić się, że liczba wysłanych bajtów nie przekracza maksymalnego rozmiaru pakietu podstawowego dostawcy usług.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3239">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="0ed15-3240">Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.SendTo%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3240">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3241">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3241">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-3242">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3242">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3243">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3243">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-3244">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-3244">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-3245">Poniższy przykład kodu wysyła bezpołączeniowy datagram do określonego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3245">The following code example sends a connectionless datagram to the specified remote host.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-3246"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3246"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ed15-3247">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-3247">-or-</span></span> 
 <span data-ttu-id="0ed15-3248"><paramref name="remoteEP" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3248"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-3249">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3249">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-3250"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3250">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-3251">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3251">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-3252">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3252">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="0ed15-3253"><see cref="T:System.Net.EndPoint" /> Reprezentuje lokalizację docelową dla danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3253">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span></span></param>
        <summary><span data-ttu-id="0ed15-3254">Wysyła dane do określonego punktu końcowego przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3254">Sends data to a specific endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-3255">Liczba wysłanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3255">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-3256">W tym przeciążeniu bufor przesunięty domyślnie do wartości 0 i liczba bajtów, które mają zostać wysłane domyślnie do rozmiaru `buffer`.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3256">In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the `buffer`.</span></span> <span data-ttu-id="0ed15-3257">Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketflags` jako parametr, wysyłane dane nie będą kierowane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3257">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="0ed15-3258">Jeśli używasz bezpołączeniowego protokołu, nie musisz nawiązać domyślnego hosta zdalnego z <xref:System.Net.Sockets.Socket.Connect%2A> metodą przed wywołaniem. <xref:System.Net.Sockets.Socket.SendTo%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-3258">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="0ed15-3259">Wystarczy wykonać tę czynność tylko wtedy, gdy zamierzasz wywołać <xref:System.Net.Sockets.Socket.Send%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3259">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="0ed15-3260">Jeśli wywołasz <xref:System.Net.Sockets.Socket.Connect%2A> metodę przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` parametr zastąpi określony domyślny host zdalny tylko dla tej operacji wysyłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3260">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="0ed15-3261">Nie jest również wymagane wywoływanie <xref:System.Net.Sockets.Socket.Bind%2A> metody, ponieważ dostawca usługi bazowej przypisze najbardziej odpowiedni adres sieci lokalnej i numer portu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3261">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="0ed15-3262">Jeśli trzeba zidentyfikować przypisany adres sieci lokalnej i numer portu, można użyć <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwości <xref:System.Net.Sockets.Socket.SendTo%2A> po pomyślnym ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3262">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="0ed15-3263">Chociaż są przeznaczone dla bezpołączeniych protokołów, <xref:System.Net.Sockets.Socket.SendTo%2A> działa również z protokołami zorientowanymi na połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3263">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="0ed15-3264">W przypadku korzystania z protokołu zorientowanego na połączenia należy najpierw ustanowić połączenie z hostem zdalnym, wywołując <xref:System.Net.Sockets.Socket.Connect%2A> metodę lub akceptując żądanie połączenia przychodzącego <xref:System.Net.Sockets.Socket.Accept%2A> za pomocą metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3264">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="0ed15-3265">Jeśli połączenie z hostem zdalnym nie zostanie nawiązane lub zaakceptowane, <xref:System.Net.Sockets.Socket.SendTo%2A> program zgłosi wartość. <xref:System.Net.Sockets.SocketException></span><span class="sxs-lookup"><span data-stu-id="0ed15-3265">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-3266">Przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A> metody można również ustanowić domyślnego hosta zdalnego dla bezpołączeniowego protokołu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3266">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="0ed15-3267">W każdym z tych przypadków <xref:System.Net.Sockets.Socket.SendTo%2A> program zignoruje ten `remoteEP` parametr i wyśle tylko dane do podłączonego lub domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3267">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="0ed15-3268">Blokowanie gniazd zostanie zablokowane do momentu wysłania żądanych wszystkich bajtów `buffer` w.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3268">Blocking sockets will block until the requested all of the bytes in the `buffer` are sent.</span></span> <span data-ttu-id="0ed15-3269">Ponieważ nie jest <xref:System.Net.Sockets.Socket> wykonywane natychmiastowe zakończenie, może nie wysłać wszystkich bajtów `buffer`w.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3269">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`.</span></span> <span data-ttu-id="0ed15-3270">Jest to odpowiedzialność aplikacji do śledzenia liczby wysłanych bajtów i ponawiania operacji do momentu, gdy aplikacja wyśle wszystkie bajty w `buffer`.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3270">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`.</span></span> <span data-ttu-id="0ed15-3271">Nie ma również gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3271">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="0ed15-3272">Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych, które zostaną zebrane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3272">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="0ed15-3273">Pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendTo%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3273">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="0ed15-3274">Jeśli używasz protokołu bezpołączeni w trybie blokowania, <xref:System.Net.Sockets.Socket.SendTo%2A> program zablokuje do momentu wysłania datagramu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3274">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="0ed15-3275">Jeśli chcesz wysłać dane do adresu emisji, musisz najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodę i ustawić opcję gniazda na. <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0ed15-3275">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0ed15-3276">Należy również upewnić się, że liczba wysłanych bajtów nie przekracza maksymalnego rozmiaru pakietu podstawowego dostawcy usług.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3276">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="0ed15-3277">Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.SendTo%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3277">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3278">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3278">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-3279">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3279">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3280">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3280">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-3281">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-3281">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-3282">Poniższy przykład kodu wysyła bezpołączeniowy datagram do określonego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3282">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="0ed15-3283"><xref:System.Net.Sockets.SocketFlags>są przesyłane do <xref:System.Net.Sockets.Socket.SendTo%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3283"><xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-3284"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3284"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ed15-3285">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-3285">-or-</span></span> 
 <span data-ttu-id="0ed15-3286"><paramref name="remoteEP" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3286"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-3287">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3287">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-3288"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3288">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-3289">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3289">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="size"><span data-ttu-id="0ed15-3290">Liczba bajtów do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3290">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-3291">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3291">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="0ed15-3292"><see cref="T:System.Net.EndPoint" /> Reprezentuje lokalizację docelową dla danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3292">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span></span></param>
        <summary><span data-ttu-id="0ed15-3293">Wysyła określoną liczbę bajtów danych do określonego punktu końcowego przy użyciu określonej <see cref="T:System.Net.Sockets.SocketFlags" />wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3293">Sends the specified number of bytes of data to the specified endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-3294">Liczba wysłanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3294">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-3295">W tym przeciążeniu przesunięcie buforu domyślnie wynosi 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3295">In this overload, the buffer offset defaults to 0.</span></span> <span data-ttu-id="0ed15-3296">Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketflags` jako parametr, wysyłane dane nie będą kierowane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3296">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="0ed15-3297">Jeśli używasz bezpołączeniowego protokołu, nie musisz nawiązać domyślnego hosta zdalnego z <xref:System.Net.Sockets.Socket.Connect%2A> metodą przed wywołaniem. <xref:System.Net.Sockets.Socket.SendTo%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-3297">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="0ed15-3298">Wystarczy wykonać tę czynność tylko wtedy, gdy zamierzasz wywołać <xref:System.Net.Sockets.Socket.Send%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3298">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="0ed15-3299">Jeśli wywołasz <xref:System.Net.Sockets.Socket.Connect%2A> metodę przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` parametr zastąpi określony domyślny host zdalny tylko dla tej operacji wysyłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3299">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="0ed15-3300">Nie jest również wymagane wywoływanie <xref:System.Net.Sockets.Socket.Bind%2A> metody, ponieważ dostawca usługi bazowej przypisze najbardziej odpowiedni adres sieci lokalnej i numer portu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3300">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="0ed15-3301">Jeśli trzeba zidentyfikować przypisany adres sieci lokalnej i numer portu, można użyć <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwości <xref:System.Net.Sockets.Socket.SendTo%2A> po pomyślnym ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3301">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="0ed15-3302">Chociaż są przeznaczone dla bezpołączeniych protokołów, <xref:System.Net.Sockets.Socket.SendTo%2A> działa również z protokołami zorientowanymi na połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3302">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="0ed15-3303">W przypadku korzystania z protokołu zorientowanego na połączenia należy najpierw ustanowić połączenie z hostem zdalnym, wywołując <xref:System.Net.Sockets.Socket.Connect%2A> metodę lub akceptując żądanie połączenia przychodzącego <xref:System.Net.Sockets.Socket.Accept%2A> za pomocą metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3303">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="0ed15-3304">Jeśli połączenie z hostem zdalnym nie zostanie nawiązane lub zaakceptowane, <xref:System.Net.Sockets.Socket.SendTo%2A> program zgłosi wartość. <xref:System.Net.Sockets.SocketException></span><span class="sxs-lookup"><span data-stu-id="0ed15-3304">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-3305">Przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A> metody można również ustanowić domyślnego hosta zdalnego dla bezpołączeniowego protokołu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3305">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="0ed15-3306">W każdym z tych przypadków <xref:System.Net.Sockets.Socket.SendTo%2A> program zignoruje ten `remoteEP` parametr i wyśle tylko dane do podłączonego lub domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3306">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="0ed15-3307">Blokowanie gniazd zostanie zablokowane do momentu wysłania żądanej liczby bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3307">Blocking sockets will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="0ed15-3308">Ponieważ nie jest <xref:System.Net.Sockets.Socket> wykonywane natychmiastowe zakończenie, może nie wysłać wszystkich żądanych bajtów w ramach jednej operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3308">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation.</span></span> <span data-ttu-id="0ed15-3309">Jest to odpowiedzialność aplikacji do śledzenia liczby wysłanych bajtów i ponawiania operacji do momentu, gdy aplikacja wyśle żądaną liczbę bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3309">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="0ed15-3310">Nie ma również gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3310">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="0ed15-3311">Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych, które zostaną zebrane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3311">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="0ed15-3312">Pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendTo%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3312">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="0ed15-3313">Jeśli używasz protokołu bezpołączeni w trybie blokowania, <xref:System.Net.Sockets.Socket.SendTo%2A> program zablokuje do momentu wysłania datagramu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3313">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="0ed15-3314">Jeśli chcesz wysłać dane do adresu emisji, musisz najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodę i ustawić opcję gniazda na. <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0ed15-3314">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0ed15-3315">Należy również upewnić się, że liczba wysłanych bajtów nie przekracza maksymalnego rozmiaru pakietu podstawowego dostawcy usług.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3315">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="0ed15-3316">Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.SendTo%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3316">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3317">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3317">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-3318">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3318">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3319">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3319">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-3320">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-3320">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-3321">Poniższy przykład kodu wysyła bezpołączeniowy datagram do określonego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3321">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="0ed15-3322">Rozmiar i <xref:System.Net.Sockets.SocketFlags> są przesyłane <xref:System.Net.Sockets.Socket.SendTo%2A> do metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3322">The size and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-3323"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3323"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ed15-3324">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-3324">-or-</span></span> 
 <span data-ttu-id="0ed15-3325"><paramref name="remoteEP" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3325"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-3326">Określona <paramref name="size" /> wartość przekracza <paramref name="buffer" />rozmiar.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3326">The specified <paramref name="size" /> exceeds the size of <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-3327">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3327">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-3328"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3328">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="0ed15-3329">Tablica typu <see cref="T:System.Byte" /> , która zawiera dane do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3329">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="offset"><span data-ttu-id="0ed15-3330">Pozycja w buforze danych, w której mają zostać rozpoczęte wysyłanie danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3330">The position in the data buffer at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="0ed15-3331">Liczba bajtów do wysłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3331">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="0ed15-3332">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3332">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="0ed15-3333"><see cref="T:System.Net.EndPoint" /> Reprezentuje lokalizację docelową dla danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3333">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span></span></param>
        <summary><span data-ttu-id="0ed15-3334">Wysyła określoną liczbę bajtów danych do określonego punktu końcowego, rozpoczynając od określonej lokalizacji w buforze i używając określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3334">Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="0ed15-3335">Liczba wysłanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3335">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-3336">W tym przeciążeniu, jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> flagę `socketflags` jako parametr, wysyłane dane nie będą kierowane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3336">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="0ed15-3337">Jeśli używasz bezpołączeniowego protokołu, nie musisz nawiązać domyślnego hosta zdalnego z <xref:System.Net.Sockets.Socket.Connect%2A> metodą przed wywołaniem. <xref:System.Net.Sockets.Socket.SendTo%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-3337">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="0ed15-3338">Wystarczy wykonać tę czynność tylko wtedy, gdy zamierzasz wywołać <xref:System.Net.Sockets.Socket.Send%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3338">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="0ed15-3339">Jeśli wywołasz <xref:System.Net.Sockets.Socket.Connect%2A> metodę przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` parametr zastąpi określony domyślny host zdalny tylko dla tej operacji wysyłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3339">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="0ed15-3340">Nie jest również wymagane wywoływanie <xref:System.Net.Sockets.Socket.Bind%2A> metody, ponieważ dostawca usługi bazowej przypisze najbardziej odpowiedni adres sieci lokalnej i numer portu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3340">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="0ed15-3341">Jeśli trzeba zidentyfikować przypisany adres sieci lokalnej i numer portu, można użyć <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwości <xref:System.Net.Sockets.Socket.SendTo%2A> po pomyślnym ukończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3341">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="0ed15-3342">Chociaż są przeznaczone dla bezpołączeniych protokołów, <xref:System.Net.Sockets.Socket.SendTo%2A> działa również z protokołami zorientowanymi na połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3342">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="0ed15-3343">W przypadku korzystania z protokołu zorientowanego na połączenia należy najpierw ustanowić połączenie z hostem zdalnym, wywołując <xref:System.Net.Sockets.Socket.Connect%2A> metodę lub akceptując żądanie połączenia przychodzącego <xref:System.Net.Sockets.Socket.Accept%2A> za pomocą metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3343">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="0ed15-3344">Jeśli połączenie z hostem zdalnym nie zostanie nawiązane lub zaakceptowane, <xref:System.Net.Sockets.Socket.SendTo%2A> program zgłosi wartość. <xref:System.Net.Sockets.SocketException></span><span class="sxs-lookup"><span data-stu-id="0ed15-3344">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-3345">Przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A> metody można również ustanowić domyślnego hosta zdalnego dla bezpołączeniowego protokołu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3345">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="0ed15-3346">W każdym z tych przypadków <xref:System.Net.Sockets.Socket.SendTo%2A> program zignoruje ten `remoteEP` parametr i wyśle tylko dane do podłączonego lub domyślnego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3346">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="0ed15-3347">Blokowanie gniazd zostanie zablokowane do momentu wysłania żądanej liczby bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3347">Blocking sockets will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="0ed15-3348">Od momentu natychmiastowego <xref:System.Net.Sockets.Socket> zakończenia nie można wysłać wszystkich żądanych bajtów w ramach jednej operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3348">Since a non-blocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation.</span></span> <span data-ttu-id="0ed15-3349">Aplikacje są odpowiedzialne za śledzenie liczby wysłanych bajtów i ponawianie operacji do momentu wysłania przez aplikację żądanej liczby bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3349">It is your applications responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="0ed15-3350">Nie ma również gwarancji, że wysyłane dane będą natychmiast wyświetlane w sieci.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3350">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="0ed15-3351">Aby zwiększyć wydajność sieci, system bazowy może opóźnić przesyłanie do momentu zebrania znacznej ilości danych, które zostaną zebrane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3351">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="0ed15-3352">Pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendTo%2A> metody oznacza, że podstawowy system miał miejsce do buforowania danych do wysłania przez sieć.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3352">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="0ed15-3353">Jeśli używasz protokołu bezpołączeni w trybie blokowania, <xref:System.Net.Sockets.Socket.SendTo%2A> program zablokuje do momentu wysłania datagramu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3353">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="0ed15-3354">Jeśli chcesz wysłać dane do adresu emisji, musisz najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodę i ustawić opcję gniazda na. <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0ed15-3354">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0ed15-3355">Należy również upewnić się, że rozmiar nie przekracza maksymalnego rozmiaru pakietu dostawcy usługi.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3355">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="0ed15-3356">Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.SendTo%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3356">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3357">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3357">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-3358">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3358">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3359">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3359">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-3360">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-3360">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-3361">Poniższy przykład kodu wysyła bezpołączeniowy datagram do określonego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3361">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="0ed15-3362">Przesunięcie, rozmiar i <xref:System.Net.Sockets.SocketFlags> są przesyłane <xref:System.Net.Sockets.Socket.SendTo%2A> do metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3362">The offset, size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-3363"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3363"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ed15-3364">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-3364">-or-</span></span> 
 <span data-ttu-id="0ed15-3365"><paramref name="remoteEP" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3365"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-3366"><paramref name="offset" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3366"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-3367">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-3367">-or-</span></span> 
 <span data-ttu-id="0ed15-3368"><paramref name="offset" />jest większa niż długość <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3368"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="0ed15-3369">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-3369">-or-</span></span> 
 <span data-ttu-id="0ed15-3370"><paramref name="size" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3370"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="0ed15-3371">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-3371">-or-</span></span> 
 <span data-ttu-id="0ed15-3372"><paramref name="size" />jest większa niż długość <paramref name="buffer" /> minus wartości <paramref name="offset" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3372"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-3373"><paramref name="socketFlags" />nie jest prawidłową kombinacją wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3373"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="0ed15-3374">—lub—</span><span class="sxs-lookup"><span data-stu-id="0ed15-3374">-or-</span></span> 
<span data-ttu-id="0ed15-3375">Wystąpił błąd systemu operacyjnego podczas uzyskiwania dostępu <see cref="T:System.Net.Sockets.Socket" />do programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3375">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-3376"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3376">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0ed15-3377">Obiekt wywołujący w stosie wywołań nie ma wymaganych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3377">A caller in the call stack does not have the required permissions.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="0ed15-3378">Obiekt <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> , który ma być używany dla tej asynchronicznej operacji gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3378">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="0ed15-3379">Wysyła dane asynchronicznie do określonego hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3379">Sends data asynchronously to a specific remote host.</span></span></summary>
        <returns><span data-ttu-id="0ed15-3380"><see langword="true" />Jeśli operacja we/wy jest w stanie oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3380"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="0ed15-3381"><see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie<paramref name="e" /> na parametrze zostanie wywołane po zakończeniu operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3381">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="0ed15-3382"><see langword="false" />Jeśli operacja we/wy została ukończona synchronicznie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3382"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="0ed15-3383">W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie <paramref name="e" /> na parametrze <paramref name="e" /> nie zostanie zgłoszone i obiekt przenoszony jako parametr może zostać zbadany natychmiast po wywołaniu metody, aby pobrać wynik operacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3383">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-3384">Metoda uruchamia asynchroniczną operację wysyłania do hosta zdalnego określonego <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> we właściwości `e` parametru. <xref:System.Net.Sockets.Socket.SendToAsync%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-3384">The <xref:System.Net.Sockets.Socket.SendToAsync%2A> method starts an asynchronous send operation to the remote host specified in the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property of the `e` parameter.</span></span> <span data-ttu-id="0ed15-3385"><xref:System.Net.Sockets.Socket.SendToAsync%2A> Wywołanie metody daje możliwość wysyłania danych w osobnym wątku wykonania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3385">Calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method gives you the ability to send data within a separate execution thread.</span></span> <span data-ttu-id="0ed15-3386">Mimo że ta metoda jest przeznaczona dla protokołów bezpołączeniowych, <xref:System.Net.Sockets.Socket.SendToAsync%2A> działa z protokołami bezpołączeniowymi i zorientowanymi na połączenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3386">Although this method is intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendToAsync%2A> works with both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="0ed15-3387">Aby otrzymywać powiadomienia o zakończeniu, należy utworzyć metodę wywołania zwrotnego implementującą delegata\<EventHandler SocketAsyncEventArgs > i dołączyć wywołanie zwrotne <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> do zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3387">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="0ed15-3388">Następujące właściwości i zdarzenia w <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiekcie są wymagane do pomyślnego wywołania tej metody:</span><span class="sxs-lookup"><span data-stu-id="0ed15-3388">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="0ed15-3389">Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość na dowolny obiekt stanu użytkownika przed <xref:System.Net.Sockets.Socket.SendToAsync%2A> wywołaniem metody, tak aby informacje były możliwe do pobierania w metodzie wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3389">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="0ed15-3390">Jeśli wywołanie zwrotne wymaga więcej informacji niż pojedynczy obiekt, można utworzyć małą klasę w celu przechowywania innych wymaganych informacji o stanie jako członków.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3390">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="0ed15-3391">W przypadku korzystania z <xref:System.Net.Sockets.Socket.Accept%2A>protokołu zorientowanego na połączenia należy najpierw wywołać metodę <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.AcceptAsync%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>,,, lub <xref:System.Net.Sockets.Socket.ConnectAsync%2A> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-3391">If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span> <span data-ttu-id="0ed15-3392">W <xref:System.Net.Sockets.Socket.SendToAsync%2A> przeciwnym razie <xref:System.Net.Sockets.SocketException>wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3392">Otherwise <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-3393"><xref:System.Net.Sockets.Socket.SendToAsync%2A> W przypadku korzystania z protokołu zorientowanego na połączenia Metoda <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> zignoruje Właściwość <xref:System.Net.EndPoint?displayProperty=nameWithType> i wyśle dane <xref:System.Net.Sockets.Socket.Accept%2A>do ustanowionych w, <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.AcceptAsync%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A>,,, <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Metoda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3393">When using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method will ignore the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property and send data to the <xref:System.Net.EndPoint?displayProperty=nameWithType> established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-3394">Jeśli używasz bezpołączeniowego protokołu, nie <xref:System.Net.Sockets.Socket.BeginConnect%2A>musisz nawiązać domyślnego hosta zdalnego z, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metody przed wywołaniem <xref:System.Net.Sockets.Socket.SendToAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3394">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>.</span></span> <span data-ttu-id="0ed15-3395">Wystarczy wykonać tę czynność tylko wtedy, gdy zamierzasz wywołać <xref:System.Net.Sockets.Socket.BeginSend%2A> metody lub. <xref:System.Net.Sockets.Socket.SendAsync%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-3395">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.SendAsync%2A> methods.</span></span> <span data-ttu-id="0ed15-3396">W przypadku <xref:System.Net.Sockets.Socket.BeginConnect%2A>wywołania metody, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> <xref:System.Net.Sockets.Socket.Connect%2A>, lub przed wywołaniem <xref:System.Net.Sockets.Socket.SendToAsync%2A> <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Właściwość zastąpi określony domyślny host zdalny tylko dla tej operacji wysyłania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3396">If you do call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>, the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="0ed15-3397">Nie jest również wymagane wywoływanie <xref:System.Net.Sockets.Socket.Bind%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3397">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="0ed15-3398">W takim przypadku Dostawca usługi podstawowej będzie przypisywać najbardziej odpowiedni adres IP sieci lokalnej i numer portu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3398">In this case, the underlying service provider will assign the most appropriate local network IP address and port number.</span></span> <span data-ttu-id="0ed15-3399">Użyj numeru portu równego zero, jeśli chcesz, aby Dostawca usługi podstawowej wybierał bezpłatny port.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3399">Use a port number of zero if you want the underlying service provider to select a free port.</span></span> <span data-ttu-id="0ed15-3400">Jeśli musisz zidentyfikować przypisany adres IP sieci lokalnej i numer portu, możesz użyć <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwości <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> po zasygnalizowaniu zdarzenia i wywołaniu skojarzonych delegatów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3400">If you need to identify the assigned local network IP address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event is signaled and the associated delegates are called.</span></span>  
  
 <span data-ttu-id="0ed15-3401">Aby wysłać dane do adresu emisji, należy najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodę i ustawić dla <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> opcji gniazda wartość true.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3401">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option for <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> to true.</span></span> <span data-ttu-id="0ed15-3402">Należy również upewnić się, że rozmiar buforu nie przekracza maksymalnego rozmiaru pakietu podstawowego dostawcy usług.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3402">You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="0ed15-3403">Jeśli tak, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.SendToAsync%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3403">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="0ed15-3404">Jeśli określisz flagę DontRoute we <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> właściwości, wysyłane dane nie będą kierowane.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3404">If you specify the DontRoute flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="0ed15-3405">W przypadku gniazd zorientowanych na komunikaty należy zachować ostrożność, aby nie przekroczyć maksymalnego rozmiaru komunikatu dotyczącego transportowego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3405">For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport.</span></span> <span data-ttu-id="0ed15-3406">Jeśli rozmiar buforu przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług, datagram nie zostanie wysłany i <xref:System.Net.Sockets.Socket.SendToAsync%2A> <xref:System.Net.Sockets.SocketException>wygeneruje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3406">If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="0ed15-3407">Pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendToAsync%2A> metody nie wskazuje, że dane zostały dostarczone pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3407">The successful completion of a <xref:System.Net.Sockets.Socket.SendToAsync%2A> method does not indicate that the data was successfully delivered.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-3408"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> Nie może mieć wartości null.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3408">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-3409">Operacja gniazda była już w toku przy użyciu <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiektu określonego <paramref name="e" /> w parametrze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3409">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-3410">Ta metoda wymaga systemu Windows XP lub nowszego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3410">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-3411"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3411">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-3412">Określony protokół jest zorientowany na połączenie, ale <see cref="T:System.Net.Sockets.Socket" /> nie jest jeszcze podłączony.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3412">The protocol specified is connection-oriented, but the <see cref="T:System.Net.Sockets.Socket" /> is not yet connected.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="level"><span data-ttu-id="0ed15-3413">Poziom ochrony adresów IP do ustawienia w tym gnieździe.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3413">The IP protection level to set on this socket.</span></span></param>
        <summary><span data-ttu-id="0ed15-3414">Ustaw poziom ochrony adresów IP w gnieździe.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3414">Set the IP protection level on a socket.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-3415"><xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> Metoda umożliwia ograniczenie gniazda IPv6 lub IP do nasłuchiwania w określonym zakresie, takich jak adresy z tego samego linku lokalnego lub lokalnego prefiksu lokacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3415">The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method enables restricting an a IPv6 or IP socket to listen on a specified scope, such as addresses with the same link local or site local prefix.</span></span> <span data-ttu-id="0ed15-3416">Ta opcja gniazda umożliwia aplikacjom nakładanie ograniczeń dostępu w przypadku protokołu IPv6 lub IP Sockets.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3416">This socket option enables applications to place access restrictions on IPv6 or IP sockets.</span></span> <span data-ttu-id="0ed15-3417">Takie ograniczenia umożliwiają aplikacji działającej w prywatnej sieci LAN, aby po prostu i niezawodnie zabezpieczyć się przed atakami zewnętrznymi.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3417">Such restrictions enable an application running on a private LAN to simply and robustly harden itself against external attacks.</span></span> <span data-ttu-id="0ed15-3418">Tej opcji gniazda można także użyć w celu usunięcia ograniczeń dostępu, `level` Jeśli parametr jest ustawiony na. <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted></span><span class="sxs-lookup"><span data-stu-id="0ed15-3418">This socket option can also be used to remove access restrictions if the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>.</span></span> <span data-ttu-id="0ed15-3419">Ta opcja gniazda rozszerza lub zawęża zakres gniazda nasłuchiwania, umożliwiając nieograniczony dostęp z publicznych i prywatnych użytkowników, jeśli jest to konieczne, lub ograniczanie dostępu tylko do tej samej lokacji, zgodnie z wymaganiami.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3419">This socket option widens or narrows the scope of a listening socket, enabling unrestricted access from public and private users when appropriate, or restricting access only to the same site, as required.</span></span>  
  
 <span data-ttu-id="0ed15-3420">Ta opcja gniazda ma zdefiniowane poziomy ochrony określone w <xref:System.Net.Sockets.IPProtectionLevel> wyliczeniu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3420">This socket option has defined protection levels specified in the <xref:System.Net.Sockets.IPProtectionLevel> enumeration.</span></span>  
  
 <span data-ttu-id="0ed15-3421">Metoda jest używana do włączania lub wyłączania przechodzenia między adresami sieciowymi (NAT) <xref:System.Net.Sockets.Socket> dla wystąpienia. <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-3421">The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method is used to enable or disable Network Address Traversal (NAT) for a <xref:System.Net.Sockets.Socket> instance.</span></span> <span data-ttu-id="0ed15-3422">Przechodzenie NAT może być zapewnione przy użyciu protokołu Teredo, 6to4 lub tunelu ISATAP.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3422">NAT traversal may be provided using Teredo, 6to4, or an ISATAP tunnel.</span></span>  
  
 <span data-ttu-id="0ed15-3423">Gdy parametr jest ustawiony na <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted> <xref:System.Net.Sockets.IPProtectionLevel.Restricted> lub<xref:System.Net.Sockets.Socket> , jawnie wyłącza przechodzenie translatora adresów sieciowych dla wystąpienia. `level`</span><span class="sxs-lookup"><span data-stu-id="0ed15-3423">When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, or <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, this explicitly disables NAT traversal for a <xref:System.Net.Sockets.Socket> instance.</span></span>  
  
 <span data-ttu-id="0ed15-3424">Gdy parametr jest ustawiony na <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, może to <xref:System.Net.Sockets.Socket> umożliwić Przechodzenie translatora adresów sieciowych w zależności od zasad zapory w miejscu systemu. `level`</span><span class="sxs-lookup"><span data-stu-id="0ed15-3424">When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, this may allow NAT traversal for a <xref:System.Net.Sockets.Socket> depending on firewall rules in place on the system.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ed15-3425">Parametr nie może być <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />. <paramref name="level" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-3425">The <paramref name="level" /> parameter cannot be <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />.</span></span> <span data-ttu-id="0ed15-3426">Nie można ustawić wartości unnieokreślone dla poziomu ochrony adresów IP.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3426">The IP protection level cannot be set to unspecified.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-3427">Gniazdo musi mieć wartość <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />. <see cref="T:System.Net.Sockets.AddressFamily" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-3427">The <see cref="T:System.Net.Sockets.AddressFamily" /> of the socket must be either <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</span></span></exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ed15-3428"><see cref="T:System.Net.Sockets.Socket" /> Ustawia opcję.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3428">Sets a <see cref="T:System.Net.Sockets.Socket" /> option.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="0ed15-3429">Jedna z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3429">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="0ed15-3430">Jedna z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3430">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="0ed15-3431">Wartość opcji, reprezentowana jako <see cref="T:System.Boolean" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3431">The value of the option, represented as a <see cref="T:System.Boolean" />.</span></span></param>
        <summary><span data-ttu-id="0ed15-3432">Ustawia określoną <see cref="T:System.Net.Sockets.Socket" /> opcję dla określonej <see cref="T:System.Boolean" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3432">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified <see cref="T:System.Boolean" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-3433"><xref:System.Net.Sockets.Socket>opcje określają zachowanie bieżącego <xref:System.Net.Sockets.Socket>elementu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3433"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-3434">Ustaw, aby włączyć opcję, lub `false` aby wyłączyć opcję. `optionValue` `true`</span><span class="sxs-lookup"><span data-stu-id="0ed15-3434">Set `optionValue` to `true` to enable the option, or to `false` to disable the option.</span></span>  
  
 <span data-ttu-id="0ed15-3435"><xref:System.Net.Sockets.Socket>opcje są pogrupowane według poziomu obsługi protokołu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3435"><xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.</span></span>  
  
 <span data-ttu-id="0ed15-3436">Poniżej wymieniono różne <xref:System.Net.Sockets.Socket> opcje, które można ustawić za pomocą tego przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3436">Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload.</span></span> <span data-ttu-id="0ed15-3437">Te opcje są pogrupowane według odpowiedniej <xref:System.Net.Sockets.SocketOptionLevel> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3437">These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value.</span></span> <span data-ttu-id="0ed15-3438">Jeśli zamierzasz ustawić dowolną z tych opcji, pamiętaj, aby użyć odpowiedniej <xref:System.Net.Sockets.SocketOptionLevel> wartości `optionLevel` parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3438">If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value for the `optionLevel` parameter.</span></span> <span data-ttu-id="0ed15-3439">Opcja wybrana do ustawienia musi być określona w `optionName` parametrze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3439">The option you choose to set must be specified in the `optionName` parameter.</span></span> <span data-ttu-id="0ed15-3440">Jeśli chcesz uzyskać bieżącą wartość dowolnej z wymienionych opcji, użyj <xref:System.Net.Sockets.Socket.GetSocketOption%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3440">If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-3441"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType>Opcje, które można ustawić za pomocą tego przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3441"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <span data-ttu-id="0ed15-3442"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType>Opcje, które można ustawić za pomocą tego przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3442"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <span data-ttu-id="0ed15-3443"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType>Opcje, które można ustawić za pomocą tego przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3443"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <span data-ttu-id="0ed15-3444"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType>Opcje, które można ustawić za pomocą tego przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3444"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <span data-ttu-id="0ed15-3445">Aby uzyskać więcej informacji na temat tych opcji, zapoznaj się z <xref:System.Net.Sockets.SocketOptionName> wyliczeniem.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3445">For more information on these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3446">Jeśli wystąpi <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> wyjątek, użyj właściwości, aby uzyskać określony kod błędu. <xref:System.Net.Sockets.SocketException></span><span class="sxs-lookup"><span data-stu-id="0ed15-3446">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-3447">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3447">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-3448">Poniższy przykład kodu otwiera gniazdo i włącza `DontLinger` opcje `OutOfBandInline` i gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3448">The following code example opens a socket and enables the `DontLinger` and the `OutOfBandInline` socket options.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-3449"><see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3449">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-3450">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3450">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="0ed15-3451">Jedna z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3451">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="0ed15-3452">Jedna z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3452">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="0ed15-3453">Tablica typu <see cref="T:System.Byte" /> , która reprezentuje wartość opcji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3453">An array of type <see cref="T:System.Byte" /> that represents the value of the option.</span></span></param>
        <summary><span data-ttu-id="0ed15-3454">Ustawia określoną <see cref="T:System.Net.Sockets.Socket" /> opcję na określoną wartość, reprezentowane jako tablica bajtów.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3454">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as a byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-3455"><xref:System.Net.Sockets.Socket>opcje określają zachowanie bieżącego <xref:System.Net.Sockets.Socket>elementu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3455"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-3456">Użyj tego przeciążenia, aby ustawić <xref:System.Net.Sockets.Socket> te opcje, które wymagają tablicy bajtowej jako wartości opcji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3456">Use this overload to set those <xref:System.Net.Sockets.Socket> options that require a byte array as an option value.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3457">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3457">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-3458">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3458">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3459">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3459">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-3460">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-3460">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-3461">Poniższy przykład kodu ustawia <xref:System.Net.Sockets.LingerOption> wartości i <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3461">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-3462">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3462">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-3463"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3463">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="0ed15-3464">Jedna z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3464">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="0ed15-3465">Jedna z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3465">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="0ed15-3466">Wartość opcji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3466">A value of the option.</span></span></param>
        <summary><span data-ttu-id="0ed15-3467">Ustawia określoną <see cref="T:System.Net.Sockets.Socket" /> opcję na określoną wartość całkowitą.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3467">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified integer value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-3468"><xref:System.Net.Sockets.Socket>opcje określają zachowanie bieżącego <xref:System.Net.Sockets.Socket>elementu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3468"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-3469">Dla opcji z <xref:System.Boolean> typem danych określ wartość różną od zera, aby włączyć tę opcję, i wartość zerową, aby wyłączyć opcję.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3469">For an option with a <xref:System.Boolean> data type, specify a nonzero value to enable the option, and a zero value to disable the option.</span></span> <span data-ttu-id="0ed15-3470">Dla opcji z typem danych Integer Określ odpowiednią wartość.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3470">For an option with an integer data type, specify the appropriate value.</span></span> <span data-ttu-id="0ed15-3471"><xref:System.Net.Sockets.Socket>opcje są pogrupowane według poziomu obsługi protokołu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3471"><xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.</span></span>  
  
 <span data-ttu-id="0ed15-3472">Poniżej wymieniono różne <xref:System.Net.Sockets.Socket> opcje, które można ustawić za pomocą tego przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3472">Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload.</span></span> <span data-ttu-id="0ed15-3473">Te opcje są pogrupowane według odpowiednich <xref:System.Net.Sockets.SocketOptionLevel>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3473">These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel>.</span></span> <span data-ttu-id="0ed15-3474">Jeśli zamierzasz ustawić dowolną z tych opcji, upewnij się, że użyto odpowiedniej <xref:System.Net.Sockets.SocketOptionLevel> `optionLevel` wartości parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3474">If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> for the `optionLevel` parameter.</span></span> <span data-ttu-id="0ed15-3475">Opcja wybrana do ustawienia musi być określona w `optionName` parametrze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3475">The option you choose to set must be specified in the `optionName` parameter.</span></span> <span data-ttu-id="0ed15-3476">Jeśli chcesz uzyskać bieżącą wartość dowolnej z wymienionych opcji, użyj <xref:System.Net.Sockets.Socket.GetSocketOption%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3476">If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
 <span data-ttu-id="0ed15-3477"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType>Opcje, które można ustawić za pomocą tego przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3477"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <span data-ttu-id="0ed15-3478"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType>Opcje, które można ustawić za pomocą tego przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3478"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <span data-ttu-id="0ed15-3479"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType>Opcje, które można ustawić za pomocą tego przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3479"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <span data-ttu-id="0ed15-3480"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType>Opcje, które można ustawić za pomocą tego przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3480"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <span data-ttu-id="0ed15-3481"><xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType>Opcje, które można ustawić za pomocą tego przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3481"><xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 <span data-ttu-id="0ed15-3482">Aby uzyskać więcej informacji na temat tych opcji, zapoznaj się z <xref:System.Net.Sockets.SocketOptionName> wyliczeniem.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3482">For more information about these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3483">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3483">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-3484">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3484">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3485">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3485">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-3486">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-3486">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-3487">Poniższy przykład kodu ustawia <xref:System.Net.Sockets.LingerOption> wartości i <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3487">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-3488">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3488">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-3489"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3489">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Object" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="0ed15-3490">Jedna z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3490">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="0ed15-3491">Jedna z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3491">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="0ed15-3492"><see cref="T:System.Net.Sockets.LingerOption" /> Lub<see cref="T:System.Net.Sockets.MulticastOption" /> , który zawiera wartość opcji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3492">A <see cref="T:System.Net.Sockets.LingerOption" /> or <see cref="T:System.Net.Sockets.MulticastOption" /> that contains the value of the option.</span></span></param>
        <summary><span data-ttu-id="0ed15-3493">Ustawia określoną <see cref="T:System.Net.Sockets.Socket" /> opcję na określoną wartość, reprezentowane jako obiekt.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3493">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-3494"><xref:System.Net.Sockets.Socket>opcje określają zachowanie bieżącego <xref:System.Net.Sockets.Socket>elementu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3494"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-3495">Użyj tego <xref:System.Net.Sockets.SocketOptionName.Linger>przeciążenia, aby ustawić opcje <xref:System.Net.Sockets.SocketOptionName.AddMembership>, i <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="0ed15-3495">Use this overload to set the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options.</span></span> <span data-ttu-id="0ed15-3496"><xref:System.Net.Sockets.Socket> Dla opcji Użyj`optionLevel` parametru. <xref:System.Net.Sockets.SocketOptionName.Linger></span><span class="sxs-lookup"><span data-stu-id="0ed15-3496">For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter.</span></span> <span data-ttu-id="0ed15-3497">Dla <xref:System.Net.Sockets.SocketOptionName.AddMembership> i <xref:System.Net.Sockets.SocketOptionName.DropMembership>, użyj <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3497">For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span></span> <span data-ttu-id="0ed15-3498">Jeśli chcesz uzyskać bieżącą wartość dowolnej z wymienionych powyżej opcji, użyj <xref:System.Net.Sockets.Socket.GetSocketOption%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3498">If you want to get the current value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3499">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3499">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-3500">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3500">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-3501">Poniższy przykład kodu ustawia <xref:System.Net.Sockets.LingerOption> wartości i <xref:System.Net.Sockets.Socket.Send%2A> limit czasu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3501">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ed15-3502"><paramref name="optionValue" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3502"><paramref name="optionValue" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-3503">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3503">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-3504"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3504">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how"><span data-ttu-id="0ed15-3505">Jedna z <see cref="T:System.Net.Sockets.SocketShutdown" /> wartości, która określa operację, która nie będzie już dozwolona.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3505">One of the <see cref="T:System.Net.Sockets.SocketShutdown" /> values that specifies the operation that will no longer be allowed.</span></span></param>
        <summary><span data-ttu-id="0ed15-3506">Wyłącza wysyłanie i odbiera w <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3506">Disables sends and receives on a <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-3507">W przypadku korzystania z ukierunkowanych <xref:System.Net.Sockets.Socket>połączeń, zawsze <xref:System.Net.Sockets.Socket.Shutdown%2A> Wywołaj metodę przed zamknięciem <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3507">When using a connection-oriented <xref:System.Net.Sockets.Socket>, always call the <xref:System.Net.Sockets.Socket.Shutdown%2A> method before closing the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-3508">Gwarantuje to, że wszystkie dane zostaną wysłane i odebrane w podłączonym gnieździe przed jego zamknięciem.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3508">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="0ed15-3509">Wywołaj <xref:System.Net.Sockets.Socket.Close%2A> metodę, aby zwolnić wszystkie zarządzane i niezarządzane zasoby skojarzone <xref:System.Net.Sockets.Socket>z.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3509">Call the <xref:System.Net.Sockets.Socket.Close%2A> method to free all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-3510">Nie próbuj ponownie używać <xref:System.Net.Sockets.Socket> po zamknięciu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3510">Do not attempt to reuse the <xref:System.Net.Sockets.Socket> after closing.</span></span>  
  
 <span data-ttu-id="0ed15-3511">W poniższej tabeli przedstawiono <xref:System.Net.Sockets.SocketShutdown> wartości wyliczenia, które są prawidłowe `how` dla parametru.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3511">The following table shows the <xref:System.Net.Sockets.SocketShutdown> enumeration values that are valid for the `how` parameter.</span></span>  
  
|<span data-ttu-id="0ed15-3512">Wartość</span><span class="sxs-lookup"><span data-stu-id="0ed15-3512">Value</span></span>|<span data-ttu-id="0ed15-3513">Opis</span><span class="sxs-lookup"><span data-stu-id="0ed15-3513">Description</span></span>|  
|-----------|-----------------|  
|<span data-ttu-id="0ed15-3514">Send</span><span class="sxs-lookup"><span data-stu-id="0ed15-3514">Send</span></span>|<span data-ttu-id="0ed15-3515">Wyłącz wysyłanie na ten <xref:System.Net.Sockets.Socket>temat.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3515">Disable sending on this <xref:System.Net.Sockets.Socket>.</span></span>|  
|<span data-ttu-id="0ed15-3516">Receive</span><span class="sxs-lookup"><span data-stu-id="0ed15-3516">Receive</span></span>|<span data-ttu-id="0ed15-3517">Wyłącz otrzymywanie na tym <xref:System.Net.Sockets.Socket>komputerze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3517">Disable receiving on this <xref:System.Net.Sockets.Socket>.</span></span>|  
|<span data-ttu-id="0ed15-3518">Oba</span><span class="sxs-lookup"><span data-stu-id="0ed15-3518">Both</span></span>|<span data-ttu-id="0ed15-3519">Wyłącz wysyłanie i otrzymywanie na tym <xref:System.Net.Sockets.Socket>komputerze.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3519">Disable both sending and receiving on this <xref:System.Net.Sockets.Socket>.</span></span>|  
  
 <span data-ttu-id="0ed15-3520">Ustawienie `how` określa,żekolejnewywołaniametodysąniedozwolone.<xref:System.Net.Sockets.SocketShutdown.Send> <xref:System.Net.Sockets.Socket.Send%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-3520">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Send> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Send%2A> are not allowed.</span></span> <span data-ttu-id="0ed15-3521">Jeśli używasz bezpołączeniowego <xref:System.Net.Sockets.Socket>, określenie <xref:System.Net.Sockets.SocketShutdown.Send> nie będzie miało żadnego efektu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3521">If you are using a connectionless <xref:System.Net.Sockets.Socket>, specifying <xref:System.Net.Sockets.SocketShutdown.Send> will have no effect.</span></span>  
  
 <span data-ttu-id="0ed15-3522">Ustawienie `how` określa,żekolejnewywołaniametodysąniedozwolone.<xref:System.Net.Sockets.SocketShutdown.Receive> <xref:System.Net.Sockets.Socket.Receive%2A></span><span class="sxs-lookup"><span data-stu-id="0ed15-3522">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Receive> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Receive%2A> are not allowed.</span></span> <span data-ttu-id="0ed15-3523">Nie ma to wpływu na niższe warstwy protokołu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3523">This has no effect on lower protocol layers.</span></span> <span data-ttu-id="0ed15-3524">Jeśli używasz protokołu zorientowanego na połączenia, połączenie jest przerywane, jeśli jeden z następujących warunków istnieje po wywołaniu <xref:System.Net.Sockets.Socket.Shutdown%2A> :</span><span class="sxs-lookup"><span data-stu-id="0ed15-3524">If you are using a connection-oriented protocol, the connection is terminated if either of the following conditions exist after a call to <xref:System.Net.Sockets.Socket.Shutdown%2A> :</span></span>  
  
-   <span data-ttu-id="0ed15-3525">Dane znajdujące się w przychodzącym buforze sieciowym oczekują na odebranie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3525">Data is in the incoming network buffer waiting to be received.</span></span>  
  
-   <span data-ttu-id="0ed15-3526">Osiągnięto więcej danych.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3526">More data has arrived.</span></span>  
  
 <span data-ttu-id="0ed15-3527">W przypadku korzystania z bezpołączeniowego protokołu datagramy są akceptowane i umieszczane w kolejce.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3527">If you are using a connectionless protocol, datagrams are accepted and queued.</span></span> <span data-ttu-id="0ed15-3528">Jeśli jednak żadne miejsce w buforze nie jest dostępne w przypadku dodatkowych datagramów przychodzących, zostaną odrzucone, a nadawca nie zwróci żadnego błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3528">However, if no buffer space is available for additional incoming datagrams, they will be discarded and no error will be returned to the sender.</span></span> <span data-ttu-id="0ed15-3529">Nie <xref:System.Net.Sockets.Socket.Shutdown%2A> zaleca się używania <xref:System.Net.Sockets.Socket> w przypadku bezpołączeniowego.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3529">Using <xref:System.Net.Sockets.Socket.Shutdown%2A> on a connectionless <xref:System.Net.Sockets.Socket> is not recommended.</span></span>  
  
 <span data-ttu-id="0ed15-3530">Ustawienie `how` do <xref:System.Net.Sockets.SocketShutdown.Both> wyłączania wysyłanych i odbieranych danych zgodnie z powyższym opisem.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3530">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Both> disables both sends and receives as described above.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3531">Jeśli podczas <xref:System.Net.Sockets.SocketException> <xref:System.Net.Sockets.Socket.Shutdown%2A> wywoływania metody zostanie wyświetlony komunikat o błędzie, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3531">If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-3532">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3532">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ed15-3533">Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3533">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="0ed15-3534">Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-3534">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-3535">Poniższy przykład kodu używa <xref:System.Net.Sockets.Socket.Shutdown%2A> do <xref:System.Net.Sockets.Socket>wyłączania.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3535">The following code example uses <xref:System.Net.Sockets.Socket.Shutdown%2A> to disable the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-3536">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3536">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-3537"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3537">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-3538">Pobiera typ <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3538">Gets the type of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="0ed15-3539">Jedna z <see cref="T:System.Net.Sockets.SocketType" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3539">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-3540"><xref:System.Net.Sockets.Socket.SocketType%2A>jest tylko do odczytu i jest ustawiana podczas <xref:System.Net.Sockets.Socket> tworzenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3540"><xref:System.Net.Sockets.Socket.SocketType%2A> is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-3541">Poniższy przykład kodu wyświetla <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, i <xref:System.Net.Sockets.ProtocolType> do konsoli programu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3541">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-3542">Pobiera wartość wskazującą, czy obsługa protokołu IPv4 jest dostępna i włączona na bieżącym hoście.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3542">Gets a value indicating whether IPv4 support is available and enabled on the current host.</span></span></summary>
        <value><span data-ttu-id="0ed15-3543"><see langword="true" />Jeśli bieżący Host obsługuje protokół IPv4; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="0ed15-3543"><see langword="true" /> if the current host supports the IPv4 protocol; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-3544">System operacyjny może obsługiwać zarówno Protokoły IPv4, jak i IPv6.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3544">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-3545">Pobiera wartość wskazującą, czy platforma obsługuje protokół IPv6 dla niektórych przestarzałych <see cref="T:System.Net.Dns" /> elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3545">Gets a value that indicates whether the Framework supports IPv6 for certain obsolete <see cref="T:System.Net.Dns" /> members.</span></span></summary>
        <value><span data-ttu-id="0ed15-3546"><see langword="true" />Jeśli struktura obsługuje protokół IPv6 dla niektórych przestarzałych <see cref="T:System.Net.Dns" /> metod; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3546"><see langword="true" /> if the Framework supports IPv6 for certain obsolete <see cref="T:System.Net.Dns" /> methods; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-3547">System operacyjny może obsługiwać zarówno Protokoły IPv4, jak i IPv6.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3547">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0ed15-3548">Zwalnia wszystkie zasoby używane przez <see cref="T:System.Net.Sockets.Socket" />program.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3548">Releases all resources used by the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="0ed15-3549">Wywołaj metodę IDisposable. Dispose po zakończeniu korzystania z <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3549">Call IDisposable.Dispose when you are finished using the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-3550">Metoda IDisposable. Dispose Pozostawia <xref:System.Net.Sockets.Socket> stan w stanie niezdatnym do użytku.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3550">The IDisposable.Dispose method leaves the <xref:System.Net.Sockets.Socket> in an unusable state.</span></span> <span data-ttu-id="0ed15-3551">Po wywołaniu metody IDisposable. Dispose należy wydać wszystkie odwołania do <xref:System.Net.Sockets.Socket> tak, aby moduł wyrzucania elementów bezużytecznych mógł odzyskiwać pamięć <xref:System.Net.Sockets.Socket> , która zajmuje.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3551">After calling IDisposable.Dispose, you must release all references to the <xref:System.Net.Sockets.Socket> so the garbage collector can reclaim the memory that the <xref:System.Net.Sockets.Socket> was occupying.</span></span> <span data-ttu-id="0ed15-3552">Aby uzyskać więcej informacji, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i implementowanie [metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="0ed15-3552">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>

> [!NOTE] 
> <span data-ttu-id="0ed15-3553">Zawsze Wywołaj metodę IDisposable. Dispose przed wydaniem ostatniego odwołania do <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3553">Always call IDisposable.Dispose before you release your last reference to the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="0ed15-3554">W przeciwnym razie używane zasoby nie zostaną zwolnione do momentu wywołania <xref:System.Net.Sockets.Socket> `Finalize` metody obiektu przez moduł zbierający elementy bezużyteczne.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3554">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Net.Sockets.Socket> object's `Finalize` method.</span></span>

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-3555">Pobiera lub ustawia wartość określającą wartość czasu wygaśnięcia (TTL) pakietów protokołu IP wysyłanych przez <see cref="T:System.Net.Sockets.Socket" />program.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3555">Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="0ed15-3556">Wartość TTL.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3556">The TTL value.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-3557">Wartość TTL wskazuje maksymalną liczbę routerów, które może przekroczyć pakiet, zanim router odrzuci pakiet i komunikat o błędzie "czas wygaśnięcia protokołu ICMP (Internet Control Message Protocol)" zostanie zwrócony do nadawcy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3557">The TTL value indicates the maximum number of routers the packet can traverse before the router discards the packet and an Internet Control Message Protocol (ICMP) "TTL exceeded" error message is returned to the sender.</span></span>  
  
 <span data-ttu-id="0ed15-3558">Wartość TTL może być ustawiona na wartość z przenoszącą od 0 do 255.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3558">The TTL value may be set to a value from 0 to 255.</span></span> <span data-ttu-id="0ed15-3559">Gdy ta właściwość nie jest ustawiona, domyślną wartością czasu wygaśnięcia dla gniazda jest 32.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3559">When this property is not set, the default TTL value for a socket is 32.</span></span>  
  
 <span data-ttu-id="0ed15-3560">Ustawienie tej właściwości w gnieździe Transmission Control Protocol (TCP) jest ignorowane przez stos TCP/IP, jeśli połączenie zostało nawiązane za pomocą gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3560">Setting this property on a Transmission Control Protocol (TCP) socket is ignored by the TCP/IP stack if a successful connection has been established using the socket.</span></span>  
  
 <span data-ttu-id="0ed15-3561">Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3561">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="0ed15-3562">Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3562">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ed15-3563">Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.Ttl%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3563">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.Ttl%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ed15-3564">Nie można ustawić ujemnej wartości parametru TTL.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3564">The TTL value can't be set to a negative number.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ed15-3565">Tę właściwość można ustawić tylko dla gniazd w <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> w rodzinach.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3565">This property can be set only for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="0ed15-3566">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3566">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="0ed15-3567">Ten błąd jest również zwracany, gdy podjęto próbę ustawienia czasu wygaśnięcia wartości większej niż 255.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3567">This error is also returned when an attempt was made to set TTL to a value higher than 255.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ed15-3568"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3568">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ed15-3569">Określa, czy gniazdo ma korzystać tylko z nakładających się trybów we/wy.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3569">Specifies whether the socket should only use Overlapped I/O mode.</span></span></summary>
        <value><span data-ttu-id="0ed15-3570"><see langword="true" />Jeśli używa <see cref="T:System.Net.Sockets.Socket" /> tylko nakładających się operacji we/wy; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3570"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> uses only overlapped I/O; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="0ed15-3571">Wartość domyślna to <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3571">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ed15-3572">Ustaw tę właściwość na `true` dla elementu <xref:System.Net.Sockets.Socket> , który ma być <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>wywoływany.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3572">Set this property to `true` for a <xref:System.Net.Sockets.Socket> you intend to call <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span></span> <span data-ttu-id="0ed15-3573">W przeciwnym razie Struktura może przypisywać do gniazda port uzupełniania, co uniemożliwi korzystanie z programu <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3573">Otherwise, the Framework may assign a completion port to the socket, which would prohibit the use of <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ed15-3574">Gniazdo zostało powiązane z portem ukończenia.</span><span class="sxs-lookup"><span data-stu-id="0ed15-3574">The socket has been bound to a completion port.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>

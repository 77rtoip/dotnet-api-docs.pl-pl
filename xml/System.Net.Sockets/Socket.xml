<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="39f8794ed1bbf6f55623532fd17b62795f17b32c" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48677699" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Implementuje interfejs Berkeley gniazda.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> Klasa udostępnia bogaty zestaw metod i właściwości dla komunikacji sieciowej. <xref:System.Net.Sockets.Socket> Klasy można wykonywać zarówno synchroniczne i transferu asynchronicznego danych przy użyciu dowolnej z protokołów komunikacyjnych na liście <xref:System.Net.Sockets.ProtocolType> wyliczenia.  
  
 <xref:System.Net.Sockets.Socket> Zgodna z wzorcem nazewnictwa .NET Framework, w przypadku metod asynchronicznych, klasy. Na przykład synchronicznego <xref:System.Net.Sockets.Socket.Receive%2A> metody odpowiada asynchroniczną <xref:System.Net.Sockets.Socket.BeginReceive%2A> i <xref:System.Net.Sockets.Socket.EndReceive%2A> metody.  
  
 Jeśli aplikacja wymaga tylko jednego wątku podczas wykonywania, należy użyć następujących metod, które są przeznaczone do trybu Operacja synchroniczna.  
  
-   Korzystając z protokołem połączeniowy, takich jak TCP, serwer może nasłuchiwać połączeń przy użyciu <xref:System.Net.Sockets.Socket.Listen%2A> metody. <xref:System.Net.Sockets.Socket.Accept%2A> Procesy metoda wszystkie połączenia przychodzące żądania i zwraca <xref:System.Net.Sockets.Socket> służącego do przekazywania danych z hostem zdalnym. Użyj tego zwracany <xref:System.Net.Sockets.Socket> do wywołania <xref:System.Net.Sockets.Socket.Send%2A> lub <xref:System.Net.Sockets.Socket.Receive%2A> metody. Wywołaj <xref:System.Net.Sockets.Socket.Bind%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.Listen%2A> metody, jeśli chcesz określić lokalny adres IP i port numer. Użyj numeru portu o wartości zero, jeśli chcesz, aby podstawowego dostawcy usług można przypisać wolny port dla Ciebie. Jeśli chcesz połączyć się z hostem nasłuchiwania wywołać <xref:System.Net.Sockets.Socket.Connect%2A> metody. Do przekazywania danych, należy wywołać <xref:System.Net.Sockets.Socket.Send%2A> lub <xref:System.Net.Sockets.Socket.Receive%2A> metody.  
  
-   Jeśli używasz przesyłanie protokołu, takie jak UDP nie musisz nasłuchiwać połączeń w ogóle. Wywołaj <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodę, aby zaakceptować datagramów przychodzących. Użyj <xref:System.Net.Sockets.Socket.SendTo%2A> metody do przesyłania datagramów na hosta zdalnego.  
  
 Aby przetwarzać komunikacji przy użyciu oddzielnych wątkach w czasie wykonywania, należy użyć następujących metod, które są przeznaczone do trybu operacji asynchronicznej.  
  
-   Jeśli używasz protokołem połączeniowy, takich jak TCP, użyj <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, i <xref:System.Net.Sockets.Socket.EndConnect%2A> metod nawiązywania połączenia z hostem nasłuchiwania. Użyj <xref:System.Net.Sockets.Socket.BeginSend%2A> i <xref:System.Net.Sockets.Socket.EndSend%2A> lub <xref:System.Net.Sockets.Socket.BeginReceive%2A> i <xref:System.Net.Sockets.Socket.EndReceive%2A> metody w celu przekazywania danych asynchronicznie. Przychodzące żądania połączenia, mogą być przetwarzane przy użyciu <xref:System.Net.Sockets.Socket.BeginAccept%2A> i <xref:System.Net.Sockets.Socket.EndAccept%2A>.  
  
-   Jeśli używasz przesyłanie protokołu, takie jak UDP, możesz użyć <xref:System.Net.Sockets.Socket.BeginSendTo%2A> i <xref:System.Net.Sockets.Socket.EndSendTo%2A> do przesyłania datagramów, i <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> i <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> do odbierania datagramów.  
  
 Jeśli możesz wykonać wiele operacji asynchronicznych na gniazdo, nie musi ukończyć w kolejności, w którym są uruchomione.  
  
 Gdy wszystko jest gotowe wysyłania i odbierania danych, użyj <xref:System.Net.Sockets.Socket.Shutdown%2A> metodę, aby wyłączyć <xref:System.Net.Sockets.Socket>. Po wywołaniu <xref:System.Net.Sockets.Socket.Shutdown%2A>, wywołaj <xref:System.Net.Sockets.Socket.Close%2A> metodę, aby zwolnić wszystkie zasoby skojarzone z <xref:System.Net.Sockets.Socket>.  
  
 <xref:System.Net.Sockets.Socket> Klasy pozwala na skonfigurowanie Twojego <xref:System.Net.Sockets.Socket> przy użyciu <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody. Pobierz te ustawienia przy użyciu <xref:System.Net.Sockets.Socket.GetSocketOption%2A> metody.  
  
> [!NOTE]
>  Jeśli piszesz stosunkowo prosta aplikacja i nie wymagają maksymalną wydajność, należy rozważyć użycie <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, i <xref:System.Net.Sockets.UdpClient>. Te klasy oferują prostszy i bardziej przyjazny dla użytkownika interfejs do <xref:System.Net.Sockets.Socket> komunikacji.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykładowy sposób, w jaki <xref:System.Net.Sockets.Socket> klasy może służyć do wysyłania danych do serwera HTTP i odbierania odpowiedzi. W tym przykładzie blokuje otrzymanie całej strony.  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Aby ustanowić połączenia wychodzącego, lub zaakceptuj żądanie przychodzące.</permission>
    <threadsafe>Wystąpienia tej klasy są bezpieczne dla wątków.</threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
    <related type="Article" href="~/docs/framework/network-programming/index.md">Programowanie dla sieci w .NET Framework</related>
    <related type="Article" href="~/docs/framework/network-programming/best-practices-for-system-net-classes.md">Najlepsze rozwiązania dotyczące klas System.Net</related>
    <related type="Article" href="~/docs/framework/network-programming/cache-management-for-network-applications.md">Zarządzanie pamięcią podręczną dla aplikacji sieciowych</related>
    <related type="Article" href="~/docs/framework/network-programming/internet-protocol-version-6.md">Protokół internetowy w wersji 6</related>
    <related type="Article" href="~/docs/framework/network-programming/network-programming-samples.md">Przykłady programowania sieciowego</related>
    <related type="Article" href="~/docs/framework/network-programming/network-tracing.md">Śledzenie sieci w .NET Framework</related>
    <related type="Article" href="~/docs/framework/network-programming/security-in-network-programming.md">Zabezpieczenia w programowaniu sieciowym</related>
    <related type="Article" href="~/docs/framework/network-programming/socket-performance-enhancements-in-version-3-5.md">Ulepszenia wydajności gniazda w wersji 3.5</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.Socket" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" />
      </Parameters>
      <Docs>
        <param name="socketInformation">Informacje o gniazda, zwrócone przez <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.Socket" /> klasy przy użyciu określonej wartości zwrócone w wyniku <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wywołasz <xref:System.Net.Sockets.Socket.%23ctor%2A> konstruktora wiele razy przy użyciu tej samej tablicy bajtów jako argument dla każdego wywołania spowoduje utworzenie wielu zarządzanych <xref:System.Net.Sockets.Socket>s przy użyciu tego samego podstawowego gniazda. Tej praktyką jest zdecydowanie odradzane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="socketType">Jedną z <see cref="T:System.Net.Sockets.SocketType" /> wartości.</param>
        <param name="protocolType">Jedną z <see cref="T:System.Net.Sockets.ProtocolType" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.Socket" /> przy użyciu podanego typu gniazda i protokołu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `socketType` Parametr określa typ <xref:System.Net.Sockets.Socket> klasy i `protocolType` parametr określa protokół używany przez <xref:System.Net.Sockets.Socket>. Dwa parametry są niezależne. Często <xref:System.Net.Sockets.Socket> typu jest niejawny w protokole. Jeśli połączenie <xref:System.Net.Sockets.Socket> typu i protokół wpisać wyniki nieprawidłową <xref:System.Net.Sockets.Socket>, Konstruktor ten wygeneruje <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Jeśli Konstruktor ten wygeneruje <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Kombinacja <paramref name="socketType" /> i <paramref name="protocolType" /> skutkuje nieprawidłowego gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily">Jedną z <see cref="T:System.Net.Sockets.AddressFamily" /> wartości.</param>
        <param name="socketType">Jedną z <see cref="T:System.Net.Sockets.SocketType" /> wartości.</param>
        <param name="protocolType">Jedną z <see cref="T:System.Net.Sockets.ProtocolType" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.Socket" /> przy użyciu określonego adresu rodziny, typ gniazda i protokołu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `addressFamily` Parametr określa schemat adresowania <xref:System.Net.Sockets.Socket> klasy zastosowań, `socketType` parametr określa typ <xref:System.Net.Sockets.Socket> klasy, a `protocolType` parametr określa protokół używany przez <xref:System.Net.Sockets.Socket>. Trzy parametry są niezależne. Niektóre rodziny adresów ograniczenia, których protokołów można używać z nimi, a także często <xref:System.Net.Sockets.Socket> typu jest niejawny w protokole. Jeśli kombinacja rodziny adresów <xref:System.Net.Sockets.Socket> typu, a następnie wpisz wyniki nieprawidłowy protokół <xref:System.Net.Sockets.Socket>, Konstruktor ten wygeneruje <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Jeśli Konstruktor ten wygeneruje <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wystąpienie <xref:System.Net.Sockets.Socket> klasy.  
  
 [!code-cpp[Socket_Send_Recieve#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Recieve#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#1)]
 [!code-vb[Socket_Send_Recieve#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Kombinacja <paramref name="addressFamily" />, <paramref name="socketType" />, i <paramref name="protocolType" /> skutkuje nieprawidłowego gniazda.</exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nową <see cref="T:System.Net.Sockets.Socket" /> dla nowo utworzone połączenie.</summary>
        <returns>Element <see cref="T:System.Net.Sockets.Socket" /> dla nowo utworzone połączenie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A> synchronicznie wyodrębnia pierwszego żądania oczekującego żądania połączenia z kolejki żądań połączenia nasłuchiwania gniazda, a następnie tworzy i zwraca nowy <xref:System.Net.Sockets.Socket>. Nie można użyć, to zwracane <xref:System.Net.Sockets.Socket> o zaakceptowanie dodatkowych połączeń z kolejki połączenia. Jednak można wywoływać <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> metoda zwracanego <xref:System.Net.Sockets.Socket> do identyfikowania hosta zdalnego sieci adres i numer portu.  
  
 W trybie blokowania <xref:System.Net.Sockets.Socket.Accept%2A> blokuje, dopóki próba połączenia przychodzące w kolejce. Po zaakceptowaniu to połączenie, oryginalnym <xref:System.Net.Sockets.Socket> kontynuuje kolejkowania połączenia przychodzącego żądania do momentu zamknij go.  
  
 Jeśli wywołanie tej metody za pomocą nieblokującej na poziomie <xref:System.Net.Sockets.Socket>i brak połączenia, żądania są umieszczane w kolejce, <xref:System.Net.Sockets.Socket.Accept%2A> zgłasza <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Przed wywołaniem <xref:System.Net.Sockets.Socket.Accept%2A> metody, należy najpierw wywołać <xref:System.Net.Sockets.Socket.Listen%2A> metody do nasłuchiwania i kolejki przychodzące żądania połączenia.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu akceptuje prostego <xref:System.Net.Sockets.Socket> połączenia.  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.InvalidOperationException">Przyjmuje gniazda nie nasłuchuje połączeń. Należy wywołać <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> i <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> przed wywołaniem <see cref="M:System.Net.Sockets.Socket.Accept" />.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Obiekt ma być używany dla tej operacji asynchronicznych gniazda.</param>
        <summary>Rozpoczyna operację asynchroniczną do akceptowania przychodzących próba połączenia.</summary>
        <returns>Zwraca <see langword="true" /> przypadku oczekujących operacji We/Wy. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie na <paramref name="e" /> parametr zostanie wygenerowany po zakończeniu operacji.  
  
Zwraca <see langword="false" /> Jeśli operacji We/Wy została zakończona synchronicznie. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie na <paramref name="e" /> parametr nie zostanie wygenerowany i <paramref name="e" /> przekazano obiekt jako parametr może zbadać, natychmiast po zakończeniu wywołania metody które zwraca wynik operacji pobierania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protokoły ukierunkowane na połączenia można użyć <xref:System.Net.Sockets.Socket.AcceptAsync%2A> próbuje metodę, aby asynchronicznie przetwarza przychodzące połączenie. Asynchronicznie akceptowanie połączeń daje możliwość wysyłania i odbierania danych w ramach oddzielnych wykonanie wątku. Przed wywołaniem <xref:System.Net.Sockets.Socket.AcceptAsync%2A> metody, należy wywołać <xref:System.Net.Sockets.Socket.Listen%2A> metody do nasłuchiwania i kolejki przychodzące żądania połączenia.  
  
 Aby otrzymywać powiadomienia o zakończeniu, należy utworzyć metody wywołania zwrotnego, która implementuje EventHandler\<SocketAsyncEventArgs > delegować i podłączyć ją do <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> zdarzeń.  
  
 Poniższe właściwości i zdarzenia <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiektu są wymagane:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Obiekt wywołujący można opcjonalnie określić istniejącą <xref:System.Net.Sockets.Socket> na potrzeby połączenia przychodzące, określając <xref:System.Net.Sockets.Socket> za pomocą <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> właściwość ma wartość null, nowe <xref:System.Net.Sockets.Socket> jest tworzony o takiej samej <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, i <xref:System.Net.Sockets.Socket.ProtocolType%2A> jako bieżący <xref:System.Net.Sockets.Socket> i Ustaw jako <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> właściwości.  
  
 Obiekt wywołujący może ustawiać <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość do każdego obiektu stanu użytkownika żądanego przed wywołaniem <xref:System.Net.Sockets.Socket.AcceptAsync%2A> metodę, tak, aby dane możliwe do pobierania w metody wywołania zwrotnego. Jeśli wywołanie zwrotne potrzebuje więcej informacji, niż jeden obiekt, mały klasy mogą być tworzone na potrzeby przechowywania inne wymagane informacje o stanie jako elementy członkowskie.  
  
 Opcjonalnie, bufor może być dostępna w taki sposób, w którym będą odbierane z początkowego bloku danych w gnieździe po <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metoda zakończy się pomyślnie. W tym przypadku <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> właściwość musi być ustawiona w buforze, zawierający dane do odbierania i <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> właściwość należy ustawić maksymalną liczbę bajtów danych do odbierania w buforze. Te właściwości można ustawić za pomocą <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> metody. Rozmiar buforu przekazanego w ramach zostanie wchłonięta wewnętrznie do użytku przez podstawowym wywołaniu funkcji Winsock AcceptEx. Oznacza to, że ilość danych zwracanych zawsze będzie mniejsza niż wartość <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> właściwość <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> podanego wystąpienia. Wielkość bufora używana wewnętrznie w zależności w rodzinie adresów gniazda. Rozmiar buforu minimalne wymagane jest 288 bajtów. Jeśli określono większy rozmiar buforu, a następnie <xref:System.Net.Sockets.Socket> będzie oczekiwać dodatkowe dane inne niż dane adresu odebrany przez wywołanie funkcji Winsock AcceptEx i będzie czekać do momentu otrzymania tego dodatkowe dane. Jeśli zostanie przekroczony limit czasu, połączenie jest resetowany. Więc jeśli dodatkowe dane z określoną ilością, to rozmiar buforu powinien być ustawiony na minimalny rozmiar buforu, a także tę kwotę.  
  
 Należy sprawdzić metody wywołania zwrotnego ukończenia <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> właściwości, aby określić, czy <xref:System.Net.Sockets.Socket.AcceptAsync%2A> operacja zakończyła się pomyślnie.  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Zdarzenia może wystąpić w niektórych przypadkach, gdy połączenie nie zostało zaakceptowane i <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> właściwość należy ustawić <xref:System.Net.Sockets.SocketError.ConnectionReset>. Taka sytuacja może wystąpić w wyniku skanowania za pomocą skanowania typu SYN połowicznie rozwarty (SYN -> potwierdzenia SYN-> sekwencji RST). Aplikacje przy użyciu <xref:System.Net.Sockets.Socket.AcceptAsync%2A> metoda powinna być przygotowana do obsługi tego warunku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Argument jest nieprawidłowy. Ten wyjątek występuje, gdy dostarczony bufor nie jest wystarczająco duży. Rozmiar buforu musi wynosić co najmniej 2 * (sizeof(SOCKADDR_STORAGE + 16) bajtów.  
  
Ten wyjątek ma miejsce, gdy określono kilka buforów, <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> właściwość nie ma wartości null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Argument jest spoza zakresu. Wyjątek występuje, gdy <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> jest mniejszy niż 0.</exception>
        <exception cref="T:System.InvalidOperationException">Zażądano nieprawidłowej operacji. Ten wyjątek występuje, gdy przyjmuje <see cref="T:System.Net.Sockets.Socket" /> nie nasłuchuje połączeń lub zaakceptowane gniazda jest powiązany.  
  
Należy wywołać <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> i <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> metoda przed wywołaniem <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> metody.  
  
Ten wyjątek ma miejsce, gdy jest już połączony gniazda lub operacji gniazdo zostało już w toku, przy użyciu określonego <paramref name="e" /> parametru.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP lub nowszy jest wymagany dla tej metody.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rodziny adresów <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Jedną z <see cref="T:System.Net.Sockets.AddressFamily" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.AddressFamily> Określa schemat adresowania, które wystąpienie <xref:System.Net.Sockets.Socket> można użyć klasy. Ta właściwość jest tylko do odczytu i jest ustawiona, gdy <xref:System.Net.Sockets.Socket> zostanie utworzony.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, i <xref:System.Net.Sockets.ProtocolType> do konsoli.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość danych, który otrzymał od sieci i jest dostępny do odczytu.</summary>
        <value>Liczba bajtów danych otrzymanych od sieci i dostępnych do odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz, bez blokowania <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> jest dobry sposób, aby ustalić, czy data jest kolejkowana dla czytelności przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. Łączna ilość danych w kolejce w buforze sieci do odczytu jest dostępnych danych. Jeśli żadne dane nie znajduje się w kolejce w buforze sieci <xref:System.Net.Sockets.Socket.Available%2A> zwraca wartość 0.  
  
 Jeśli host zdalny zamyka lub zamyka połączenia, <xref:System.Net.Sockets.Socket.Available%2A> może zgłosić <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu porównuje wyniki wywołania IOControl FIONREAD i dostępne właściwości.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna operację asynchroniczną do akceptowania przychodzących próba połączenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegować.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Rozpoczyna operację asynchroniczną do akceptowania przychodzących próba połączenia.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołuje się asynchroniczną <see cref="T:System.Net.Sockets.Socket" /> tworzenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protokoły ukierunkowane na połączenia można użyć <xref:System.Net.Sockets.Socket.BeginAccept%2A> próbuje metodę, aby asynchronicznie przetwarza przychodzące połączenie. Asynchronicznie akceptowanie połączeń daje możliwość wysyłania i odbierania danych w ramach oddzielnych wykonanie wątku. Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, należy wywołać <xref:System.Net.Sockets.Socket.Listen%2A> metody do nasłuchiwania i kolejki przychodzące żądania połączenia.  
  
 Należy utworzyć metody wywołania zwrotnego, która implementuje <xref:System.AsyncCallback> delegować, a następnie przekaż jego nazwę na <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody. Aby to zrobić, w bardzo minimalne, należy przekazać nasłuchiwania <xref:System.Net.Sockets.Socket> obiekt <xref:System.Net.Sockets.Socket.BeginAccept%2A> za pośrednictwem `state` parametru. Jeśli wywołanie zwrotne potrzebuje więcej informacji, możesz utworzyć małych klasy utrzymującej <xref:System.Net.Sockets.Socket> i inne wymagane informacje. Przekaż wystąpienie tej klasy, aby <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody za pomocą `state` parametru.  
  
 Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndAccept%2A> metody. Gdy Twoja aplikacja wywołuje <xref:System.Net.Sockets.Socket.BeginAccept%2A>, system zazwyczaj używa oddzielnego wątku w celu wykonania metodą określonego wywołania zwrotnego i blokuje na <xref:System.Net.Sockets.Socket.EndAccept%2A> do momentu pobrania jest oczekujące połączenie. <xref:System.Net.Sockets.Socket.EndAccept%2A> Zwraca nową <xref:System.Net.Sockets.Socket> obiektu służącego do wysyłania i odbierania danych z hostem zdalnym. Nie można użyć, to zwracane <xref:System.Net.Sockets.Socket> o zaakceptowanie dodatkowych połączeń z kolejki połączenia. Jeśli chcesz, oryginalnym wątku do blokowania po wywołaniu metody <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, użyj <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Wywołanie metody Set na <xref:System.Threading.ManualResetEvent> metody wywołania zwrotnego, jeśli chcesz, oryginalnym wątku w celu kontynuowania wykonywania.  
  
 System może również użyć wątku wywołującego do wywołania metody wywołania zwrotnego. W tym przypadku <xref:System.IAsyncResult.CompletedSynchronously%2A> właściwości zwracanego <xref:System.IAsyncResult> zostanie ustawiona w celu wskazania, że <xref:System.Net.Sockets.Socket.BeginAccept%2A> metoda została zakończona synchronicznie.  
  
 Aby uzyskać dodatkowe informacje na temat pisania metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, Zamknij <xref:System.Net.Sockets.Socket>. Gdy <xref:System.Net.Sockets.Socket.Close%2A> metoda jest wywoływana, gdy trwa operacja asynchroniczna, wywołanie zwrotne udostępniane <xref:System.Net.Sockets.Socket.BeginAccept%2A> metoda jest wywoływana.  Kolejne wywołanie <xref:System.Net.Sockets.Socket.EndAccept%2A> metoda zgłosi <xref:System.ObjectDisposedException> do wskazania, że operacja została anulowana.  
  
> [!NOTE]
>  Możesz użyć <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> właściwości zwracanego <xref:System.Net.Sockets.Socket> do identyfikowania hosta zdalnego sieci adres i numer portu.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (w kontekście zabezpieczeń spersonifikowanego użytkownika i kontekst wywołania) jest w pamięci podręcznej asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określonego asynchroniczne <xref:System.Net.Sockets.Socket> metody, określony <xref:System.Net.Sockets.Socket> wystąpienie i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą poprawę wydajności.  
  
   
  
## Examples  
 Poniższy kod próbuje asynchronicznie odbierać połączenia przychodzące.  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Windows NT jest wymagana dla tej metody.</exception>
        <exception cref="T:System.InvalidOperationException">Przyjmuje gniazda nie nasłuchuje połączeń. Należy wywołać <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> i <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> przed wywołaniem <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
—lub— 
Gniazda dopuszczalne jest powiązany.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> jest mniejsza niż 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="receiveSize">Liczba bajtów do akceptowania od nadawcy.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegować.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Rozpoczyna operację asynchroniczną do akceptowania przychodzących próba połączenia i odbiera pierwszy blok danych wysyłanych przez aplikację klienta.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołuje się asynchroniczną <see cref="T:System.Net.Sockets.Socket" /> tworzenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protokoły ukierunkowane na połączenia można użyć <xref:System.Net.Sockets.Socket.BeginAccept%2A> próbuje metodę, aby asynchronicznie przetwarza przychodzące połączenie. Akceptowanie połączeń asynchronicznie umożliwia wysyłać i odbierać dane w oddzielnych wykonanie wątku. To przeciążenie umożliwia określenie liczby bajtów, aby zaakceptować w transferu początkowego w `receiveSize` parametru.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, należy wywołać <xref:System.Net.Sockets.Socket.Listen%2A> metody do nasłuchiwania i kolejki przychodzące żądania połączenia.  
  
 Należy utworzyć metody wywołania zwrotnego, która implementuje <xref:System.AsyncCallback> delegować, a następnie przekaż jego nazwę na <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody. Aby to zrobić, w bardzo minimalne, należy przekazać nasłuchiwania <xref:System.Net.Sockets.Socket> obiekt <xref:System.Net.Sockets.Socket.BeginAccept%2A> za pośrednictwem `state` parametru. Jeśli wywołanie zwrotne potrzebuje więcej informacji, możesz utworzyć małych klasy utrzymującej <xref:System.Net.Sockets.Socket> i inne wymagane informacje. Przekaż wystąpienie tej klasy, aby <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody za pomocą `state` parametru.  
  
 Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndAccept%2A> metody. Gdy Twoja aplikacja wywołuje <xref:System.Net.Sockets.Socket.BeginAccept%2A>, system zazwyczaj używa oddzielnego wątku w celu wykonania metodą określonego wywołania zwrotnego i blokuje na <xref:System.Net.Sockets.Socket.EndAccept%2A> do momentu pobrania jest oczekujące połączenie.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Zwraca nowy <xref:System.Net.Sockets.Socket> służącego do wysyłania i odbierania danych z hostem zdalnym. Nie można użyć, to zwracane <xref:System.Net.Sockets.Socket> o zaakceptowanie dodatkowych połączeń z kolejki połączenia. Jeśli chcesz, oryginalnym wątku do blokowania po wywołaniu metody <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, użyj <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Wywołanie metody Set na <xref:System.Threading.ManualResetEvent> metody wywołania zwrotnego, jeśli chcesz, oryginalnym wątku w celu kontynuowania wykonywania.  
  
 System może również użyć wątku wywołującego do wywołania metody wywołania zwrotnego. W tym przypadku <xref:System.IAsyncResult.CompletedSynchronously%2A> właściwości zwracanego <xref:System.IAsyncResult> zostanie ustawiona w celu wskazania, że <xref:System.Net.Sockets.Socket.BeginAccept%2A> metoda została zakończona synchronicznie.  
  
 Aby uzyskać dodatkowe informacje na temat pisania metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, Zamknij <xref:System.Net.Sockets.Socket>.  Gdy <xref:System.Net.Sockets.Socket.Close%2A> metoda jest wywoływana, gdy trwa operacja asynchroniczna, wywołanie zwrotne udostępniane <xref:System.Net.Sockets.Socket.BeginAccept%2A> metoda jest wywoływana.  Kolejne wywołanie <xref:System.Net.Sockets.Socket.EndAccept%2A> metoda zgłosi <xref:System.ObjectDisposedException> do wskazania, że operacja została anulowana.  
  
> [!NOTE]
>  Możesz wywołać użyj <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> właściwości zwracanego <xref:System.Net.Sockets.Socket> obiektu do identyfikowania hosta zdalnego sieci adres i numer portu.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (w kontekście zabezpieczeń spersonifikowanego użytkownika i kontekst wywołania) jest w pamięci podręcznej asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określonego asynchroniczne <xref:System.Net.Sockets.Socket> metody, określony <xref:System.Net.Sockets.Socket> wystąpienie i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą poprawę wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera gniazdo i akceptuje połączenia asynchronicznego. W tym przykładzie gniazda akceptuje początkowej 10 bajtów danych. Liczba bajtów odebranych i dane są wyświetlane w konsoli przez delegata wywołania zwrotnego. Zobacz <xref:System.Net.Sockets.Socket.BeginReceive%2A> opis jak pozostałe dane są odebrane.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Windows NT jest wymagana dla tej metody.</exception>
        <exception cref="T:System.InvalidOperationException">Przyjmuje gniazda nie nasłuchuje połączeń. Należy wywołać <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> i <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> przed wywołaniem <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
—lub— 
Gniazda dopuszczalne jest powiązany.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> jest mniejsza niż 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">Zaakceptowane <see cref="T:System.Net.Sockets.Socket" /> obiektu. Ta wartość może być <see langword="null" />.</param>
        <param name="receiveSize">Maksymalna liczba bajtów do odebrania.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegować.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Rozpoczyna operację asynchroniczną do akceptowania przychodzących próba połączenia z określonym gniazda i odbiera pierwszy blok danych wysyłanych przez aplikację klienta.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiektu, który odwołuje się do asynchroniczną <see cref="T:System.Net.Sockets.Socket" /> tworzenia obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protokoły ukierunkowane na połączenia można użyć <xref:System.Net.Sockets.Socket.BeginAccept%2A> próbuje metodę, aby asynchronicznie przetwarza przychodzące połączenie. Asynchronicznie akceptowanie połączeń daje możliwość wysyłania i odbierania danych w ramach oddzielnych wykonanie wątku. To przeciążenie umożliwia określenie akceptowane gniazda `acceptSocket` parametru. Jeśli ten parametr jest `null`, gniazda dopuszczalne jest tworzony przez <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody. Można określić liczbę bajtów do akceptowania w transferu początkowego w `receiveSize` parametru.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, należy wywołać <xref:System.Net.Sockets.Socket.Listen%2A> metody do nasłuchiwania i kolejki przychodzące żądania połączenia.  
  
 Należy utworzyć metody wywołania zwrotnego, która implementuje <xref:System.AsyncCallback> delegować, a następnie przekaż jego nazwę na <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody. Aby to zrobić, w bardzo minimalne, należy przekazać nasłuchiwania <xref:System.Net.Sockets.Socket> obiekt <xref:System.Net.Sockets.Socket.BeginAccept%2A> za pośrednictwem `state` parametru. Jeśli wywołanie zwrotne potrzebuje więcej informacji, możesz utworzyć małych klasy utrzymującej <xref:System.Net.Sockets.Socket> i inne wymagane informacje. Przekaż wystąpienie tej klasy, aby <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody za pomocą `state` parametru.  
  
 Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndAccept%2A> metody. Gdy Twoja aplikacja wywołuje <xref:System.Net.Sockets.Socket.BeginAccept%2A>, system zazwyczaj używa oddzielnego wątku w celu wykonania metodą określonego wywołania zwrotnego i blokuje na <xref:System.Net.Sockets.Socket.EndAccept%2A> do momentu pobrania jest oczekujące połączenie.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Zwraca nowy <xref:System.Net.Sockets.Socket> obiektu służącego do wysyłania i odbierania danych z hostem zdalnym. Nie można użyć, to zwracane <xref:System.Net.Sockets.Socket> o zaakceptowanie dodatkowych połączeń z kolejki połączenia. Jeśli chcesz, oryginalnym wątku do blokowania po wywołaniu metody <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, użyj <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Wywołanie metody Set na <xref:System.Threading.ManualResetEvent> metody wywołania zwrotnego, jeśli chcesz, oryginalnym wątku w celu kontynuowania wykonywania.  
  
 System może również użyć wątku wywołującego do wywołania metody wywołania zwrotnego. W tym przypadku <xref:System.IAsyncResult.CompletedSynchronously%2A> właściwości zwracanego <xref:System.IAsyncResult> zostanie ustawiona w celu wskazania, że <xref:System.Net.Sockets.Socket.BeginAccept%2A> metoda została zakończona synchronicznie.  
  
 Aby uzyskać dodatkowe informacje na temat pisania metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, Zamknij <xref:System.Net.Sockets.Socket>. Gdy <xref:System.Net.Sockets.Socket.Close%2A> metoda jest wywoływana, gdy trwa operacja asynchroniczna, wywołanie zwrotne udostępniane <xref:System.Net.Sockets.Socket.BeginAccept%2A> metoda jest wywoływana.  Kolejne wywołanie <xref:System.Net.Sockets.Socket.EndAccept%2A> metoda zgłosi <xref:System.ObjectDisposedException> do wskazania, że operacja została anulowana.  
  
> [!NOTE]
>  Możesz użyć <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> właściwości zwracanego <xref:System.Net.Sockets.Socket> obiektu do identyfikowania hosta zdalnego sieci adres i numer portu.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (w kontekście zabezpieczeń spersonifikowanego użytkownika i kontekst wywołania) jest w pamięci podręcznej asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określonego asynchroniczne <xref:System.Net.Sockets.Socket> metody, określony <xref:System.Net.Sockets.Socket> wystąpienie i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą poprawę wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera gniazdo i akceptuje połączenia asynchronicznego. W tym przykładzie gniazda akceptuje początkowej 10 bajtów danych i `acceptSocket` parametr jest `null`, która wymusza <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodę, aby utworzyć akceptowane gniazda. Liczba bajtów odebranych i dane są wyświetlane w konsoli przez delegata wywołania zwrotnego. Zobacz <xref:System.Net.Sockets.Socket.BeginReceive%2A> opis jak pozostałe dane są odebrane.  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Windows NT jest wymagana dla tej metody.</exception>
        <exception cref="T:System.InvalidOperationException">Przyjmuje gniazda nie nasłuchuje połączeń. Należy wywołać <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> i <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> przed wywołaniem <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
—lub— 
Gniazda dopuszczalne jest powiązany.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> jest mniejsza niż 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna się asynchroniczne żądanie dla połączenia zdalnego hosta.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" />
        <Parameter Name="state" Type="System.Object" Index="2" />
      </Parameters>
      <Docs>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> Reprezentujący hosta zdalnego.</param>
        <param name="end_point">
          <see cref="T:System.Net.EndPoint" /> Reprezentujący hosta zdalnego.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegować.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Rozpoczyna się asynchroniczne żądanie dla połączenia zdalnego hosta.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołujący się połączenia asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz protokołu połączeniowy, <xref:System.Net.Sockets.Socket.BeginConnect%2A> metoda uruchamia asynchroniczne żądanie dla połączenia `remoteEP` parametru. Jeśli używasz protokołu przesyłanie, <xref:System.Net.Sockets.Socket.BeginConnect%2A> ustanawia domyślnego hosta zdalnego. Łączenie lub ustawianie domyślnego hosta zdalnego asynchronicznie daje możliwość wysyłania i odbierania danych w ramach oddzielnych wykonanie wątku.  
  
 Można utworzyć metody wywołania zwrotnego, która implementuje <xref:System.AsyncCallback> delegować, a następnie przekaż jego nazwę na <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody. W bardzo minimalny, należy przekazać <xref:System.Net.Sockets.Socket> do <xref:System.Net.Sockets.Socket.BeginConnect%2A> za pośrednictwem `state` parametru. Jeśli wywołanie zwrotne potrzebuje więcej informacji, możesz utworzyć małych klasy utrzymującej <xref:System.Net.Sockets.Socket>i inne wymagane informacje. Przekaż wystąpienie tej klasy, aby <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody za pomocą `state` parametru.  
  
 Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndConnect%2A> metody. Gdy Twoja aplikacja wywołuje <xref:System.Net.Sockets.Socket.BeginConnect%2A>, system użyje oddzielnego wątku w celu wykonania metodą określonego wywołania zwrotnego i spowoduje zablokowanie na <xref:System.Net.Sockets.Socket.EndConnect%2A> aż <xref:System.Net.Sockets.Socket> pomyślne połączenie z ani nie zgłasza wyjątku. Jeśli chcesz, oryginalnym wątku do blokowania po wywołaniu metody <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody, użyj <xref:System.Threading.WaitHandle.WaitOne%2A>. Wywołanie metody Set na <xref:System.Threading.ManualResetEvent> metody wywołania zwrotnego, jeśli chcesz, oryginalnym wątku w celu kontynuowania wykonywania. Aby uzyskać dodatkowe informacje na temat pisania metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Jeśli używasz bez połączenia protokołu UDP np. nie masz do wywołania <xref:System.Net.Sockets.Socket.BeginConnect%2A> przed wysyłania i odbierania danych. Możesz użyć <xref:System.Net.Sockets.Socket.BeginSendTo%2A> i <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> do komunikowania się z hostem zdalnym. Jeśli wywołasz <xref:System.Net.Sockets.Socket.BeginConnect%2A>, zostaną odrzucone datagramów i odbierane z adresu innego niż określoną wartość domyślną. Jeśli chcesz ustawić domyślnego hosta zdalnego na adres emisji, najpierw musisz wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> i równa emisji `true`. Jeśli nie możesz <xref:System.Net.Sockets.Socket.BeginConnect%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Jeśli używany jest protokół z nawiązaniem połączenia, a nie wywołuj <xref:System.Net.Sockets.Socket.Bind%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.BeginConnect%2A>, podstawowego dostawcy usług przypisze najbardziej odpowiedni adres i port numer sieci lokalnej. Jeśli używasz protokołu bez połączenia dostawcy usług nie spowoduje przypisanie sieci lokalnej adres i numer portu, dopóki nie zostanie wywołana <xref:System.Net.Sockets.Socket.BeginSend%2A> lub <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. Jeśli chcesz zmienić domyślnego hosta zdalnego wywołania <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody ponownie z żądanego punktu końcowego.  
  
 Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody, Zamknij <xref:System.Net.Sockets.Socket>. Gdy <xref:System.Net.Sockets.Socket.Close%2A> metoda jest wywoływana, gdy trwa operacja asynchroniczna, wywołanie zwrotne udostępniane <xref:System.Net.Sockets.Socket.BeginConnect%2A> metoda jest wywoływana.  Kolejne wywołanie <xref:System.Net.Sockets.Socket.EndConnect%2A> metoda zgłosi <xref:System.ObjectDisposedException> do wskazania, że operacja została anulowana.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Jeśli tego gniazda wcześniej został odłączony, następnie <xref:System.Net.Sockets.Socket.BeginConnect%2A> musi zostać wywołana w wątku, który nie zostanie zakończona, aż do zakończenia operacji. To ograniczenie źródłowego dostawcy.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (w kontekście zabezpieczeń spersonifikowanego użytkownika i kontekst wywołania) jest w pamięci podręcznej asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określonego asynchroniczne <xref:System.Net.Sockets.Socket> metody, określony <xref:System.Net.Sockets.Socket> wystąpienie i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą poprawę wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu inicjuje próba połączenia asynchronicznego.  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań ma uprawnienie dla żądanej operacji.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> Została umieszczona w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, lub trwa już operacja asynchroniczna.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="address">
          <see cref="T:System.Net.IPAddress" /> Hosta zdalnego.</param>
        <param name="port">Numer portu zdalnego hosta.</param>
        <param name="requestCallback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu operacji nawiązywania połączenia.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu operacji nawiązywania połączenia.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji nawiązywania połączenia. Ten obiekt jest przekazywany do <c>requestCallback</c> po zakończeniu operacji.</param>
        <summary>Rozpoczyna się asynchroniczne żądanie dla połączenia zdalnego hosta. Host jest określony przez <see cref="T:System.Net.IPAddress" /> i numer portu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołujący się połączenia asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.Socket.BeginConnect%2A> można ukończyć operacji, przez wywołanie metody <xref:System.Net.Sockets.Socket.EndConnect%2A> metody. Zazwyczaj metoda jest wywoływana przez `requestCallback` delegować.  
  
 Ta metoda nie blokuje, aż do zakończenia operacji. Aby zablokować, aż do zakończenia operacji, użyj jednej z <xref:System.Net.Sockets.Socket.Connect%2A> przeciążenia metody lub <xref:System.Net.Sockets.Socket.EndConnect%2A>.  
  
 Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody, Zamknij <xref:System.Net.Sockets.Socket>. Gdy <xref:System.Net.Sockets.Socket.Close%2A> metoda jest wywoływana, gdy trwa operacja asynchroniczna, wywołanie zwrotne udostępniane <xref:System.Net.Sockets.Socket.BeginConnect%2A> metoda jest wywoływana.  Kolejne wywołanie <xref:System.Net.Sockets.Socket.EndConnect%2A> metoda zgłosi <xref:System.ObjectDisposedException> do wskazania, że operacja została anulowana.  
  
 Aby uzyskać szczegółowe informacje dotyczące korzystania z modelu programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Jeśli tego gniazda wcześniej został odłączony, następnie <xref:System.Net.Sockets.Socket.BeginConnect%2A> musi zostać wywołana w wątku, który nie zostanie zakończona, aż do zakończenia operacji. To ograniczenie źródłowego dostawcy. Również <xref:System.Net.EndPoint> oznacza to używane muszą się różnić.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (w kontekście zabezpieczeń spersonifikowanego użytkownika i kontekst wywołania) jest w pamięci podręcznej asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określonego asynchroniczne <xref:System.Net.Sockets.Socket> metody, określony <xref:System.Net.Sockets.Socket> wystąpienie i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą poprawę wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu inicjuje próba połączenia asynchronicznego.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Net.Sockets.Socket" /> Nie znajduje się w rodzinie gniazda.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentException">Długość <paramref name="address" /> wynosi zero.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> Została umieszczona w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, lub trwa już operacja asynchroniczna.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="addresses">Co najmniej jeden <see cref="T:System.Net.IPAddress" />, wyznaczanie hosta zdalnego.</param>
        <param name="port">Numer portu zdalnego hosta.</param>
        <param name="requestCallback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu operacji nawiązywania połączenia.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu operacji nawiązywania połączenia.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji nawiązywania połączenia. Ten obiekt jest przekazywany do <c>requestCallback</c> po zakończeniu operacji.</param>
        <summary>Rozpoczyna się asynchroniczne żądanie dla połączenia zdalnego hosta. Host jest określona przez <see cref="T:System.Net.IPAddress" /> tablicy i numer portu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołujący się połączenia asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.Socket.BeginConnect%2A> można ukończyć operacji, przez wywołanie metody <xref:System.Net.Sockets.Socket.EndConnect%2A> metody. Zazwyczaj metoda jest wywoływana przez `requestCallback` delegować.  
  
 Ta metoda nie blokuje, aż do zakończenia operacji. Aby zablokować, aż do zakończenia operacji, użyj jednej z <xref:System.Net.Sockets.Socket.Connect%2A> przeciążenia metody.  
  
 Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody, Zamknij <xref:System.Net.Sockets.Socket>. Gdy <xref:System.Net.Sockets.Socket.Close%2A> metoda jest wywoływana, gdy trwa operacja asynchroniczna, wywołanie zwrotne udostępniane <xref:System.Net.Sockets.Socket.BeginConnect%2A> metoda jest wywoływana.  Kolejne wywołanie <xref:System.Net.Sockets.Socket.EndConnect%2A> metoda zgłosi <xref:System.ObjectDisposedException> do wskazania, że operacja została anulowana.  
  
 Aby uzyskać szczegółowe informacje dotyczące korzystania z modelu programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Jeśli tego gniazda wcześniej został odłączony, następnie <xref:System.Net.Sockets.Socket.BeginConnect%2A> musi zostać wywołana w wątku, który nie zostanie zakończona, aż do zakończenia operacji. To ograniczenie źródłowego dostawcy. Również <xref:System.Net.EndPoint> oznacza to używane muszą się różnić.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (w kontekście zabezpieczeń spersonifikowanego użytkownika i kontekst wywołania) jest w pamięci podręcznej asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określonego asynchroniczne <xref:System.Net.Sockets.Socket> metody, określony <xref:System.Net.Sockets.Socket> wystąpienie i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą poprawę wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu inicjuje próba połączenia asynchronicznego.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addresses" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda jest nieprawidłowa dla gniazda, które używają <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentException">Długość <paramref name="address" /> wynosi zero.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> Została umieszczona w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, lub trwa już operacja asynchroniczna.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="host">Nazwa hosta zdalnego.</param>
        <param name="port">Numer portu zdalnego hosta.</param>
        <param name="requestCallback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu operacji nawiązywania połączenia.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu operacji nawiązywania połączenia.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji nawiązywania połączenia. Ten obiekt jest przekazywany do <c>requestCallback</c> po zakończeniu operacji.</param>
        <summary>Rozpoczyna się asynchroniczne żądanie dla połączenia zdalnego hosta. Host jest określony przez nazwę hosta i numer portu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołujący się połączenia asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.Socket.BeginConnect%2A> można ukończyć operacji, przez wywołanie metody <xref:System.Net.Sockets.Socket.EndConnect%2A> metody. Zazwyczaj metoda jest wywoływana przez `requestCallback` delegować.  
  
 Ta metoda nie blokuje, aż do zakończenia operacji. Aby zablokować, aż do zakończenia operacji, użyj jednej z <xref:System.Net.Sockets.Socket.Connect%2A> przeciążenia metody.  
  
 Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody, Zamknij <xref:System.Net.Sockets.Socket>. Gdy <xref:System.Net.Sockets.Socket.Close%2A> metoda jest wywoływana, gdy trwa operacja asynchroniczna, wywołanie zwrotne udostępniane <xref:System.Net.Sockets.Socket.BeginConnect%2A> metoda jest wywoływana.  Kolejne wywołanie <xref:System.Net.Sockets.Socket.EndConnect%2A> metoda zgłosi <xref:System.ObjectDisposedException> do wskazania, że operacja została anulowana.  
  
 Aby uzyskać szczegółowe informacje dotyczące korzystania z modelu programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Jeśli tego gniazda wcześniej został odłączony, następnie <xref:System.Net.Sockets.Socket.BeginConnect%2A> musi zostać wywołana w wątku, który nie zostanie zakończona, aż do zakończenia operacji. To ograniczenie źródłowego dostawcy. Również <xref:System.Net.EndPoint> oznacza to używane muszą się różnić.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (w kontekście zabezpieczeń spersonifikowanego użytkownika i kontekst wywołania) jest w pamięci podręcznej asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określonego asynchroniczne <xref:System.Net.Sockets.Socket> metody, określony <xref:System.Net.Sockets.Socket> wystąpienie i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą poprawę wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu inicjuje próba połączenia asynchronicznego.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda jest nieprawidłowa dla gniazda w <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> rodziny.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> Została umieszczona w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, lub trwa już operacja asynchroniczna.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <see langword="true" /> Jeśli tego gniazda mogą zostać ponownie użyte po zamknięciu połączenia; w przeciwnym razie <see langword="false" />.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegować.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Rozpoczyna się żądania asynchronicznego, aby rozłączyć zdalnego punktu końcowego.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiektu, który odwołuje się operacja asynchroniczna.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz protokołu z nawiązaniem połączenia, można wywołać <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> metoda żądanie rozłączenia z zdalnego punktu końcowego. Jeśli `reuseSocket` jest `true`, można ponownie użyć gniazda.  
  
 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> Metoda używa oddzielnego wątku można wywołać metody określonego wywołania zwrotnego. <xref:System.Net.Sockets.Socket.EndDisconnect%2A> Bloki metody do momentu rozłączenia oczekujące zostało zakończone. Aby uzyskać dodatkowe informacje na temat pisania metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException> wyjątek, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy gniazdo dla komunikacji asynchronicznej i wysyła dane do hosta zdalnego. Po wysłaniu danych <xref:System.Net.Sockets.Socket.Shutdown%2A> jest wywoływana w celu zatrzymania wysyłania i odbierania działania. Następnie <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> jest wywoływana, aby rozpocząć żądanie rozłączenia. Po ukończeniu żądania <xref:System.Net.Sockets.Socket.Connected%2A> właściwość jest wysyłane zapytanie, aby sprawdzić, czy gniazdo jest odłączony.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">System operacyjny to Windows 2000 lub starszym. Ponadto ta metoda wymaga Windows XP.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zaczyna asynchronicznie odbieranie danych z połączonych <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizacja magazynu dla odebranych danych.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po ukończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje na temat operacji odbierania. Ten obiekt jest przekazywany do <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> po zakończeniu operacji.</param>
        <summary>Zaczyna asynchronicznie odbieranie danych z połączonych <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołujący się odczyt asynchroniczny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.Socket.BeginReceive%2A> można ukończyć operacji, przez wywołanie metody <xref:System.Net.Sockets.Socket.EndReceive%2A> metody. Zazwyczaj metoda jest wywoływana przez `callback` delegować.  
  
 Ta metoda nie blokuje, aż do zakończenia operacji. Aby zablokować, aż do zakończenia operacji, użyj jednej z <xref:System.Net.Sockets.Socket.Receive%2A> przeciążenia metody.  
  
 Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceive%2A>, wywołaj <xref:System.Net.Sockets.Socket.Close%2A> metody.  
  
 Aby uzyskać szczegółowe informacje dotyczące korzystania z modelu programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Wszystkie operacje We/Wy inicjowane przez dany wątku anulowany, gdy wątek która umożliwia zamknięcie. Istnieje oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek kończy działanie przed ukończeniem operacji.  
  
> [!NOTE]
>  `state` Umożliwia to tworzenie wystąpienia klasy zdefiniowanej przez użytkownika.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (w kontekście zabezpieczeń spersonifikowanego użytkownika i kontekst wywołania) jest w pamięci podręcznej asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określonego asynchroniczne <xref:System.Net.Sockets.Socket> metody, określony <xref:System.Net.Sockets.Socket> wystąpienie i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą poprawę wydajności.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> zostało zamknięte.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizacja magazynu dla odebranych danych.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> obiekt, który przechowuje błąd gniazda.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po ukończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje na temat operacji odbierania. Ten obiekt jest przekazywany do <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> po zakończeniu operacji.</param>
        <summary>Zaczyna asynchronicznie odbieranie danych z połączonych <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołujący się odczyt asynchroniczny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.Socket.BeginReceive%2A> można ukończyć operacji, przez wywołanie metody <xref:System.Net.Sockets.Socket.EndReceive%2A> metody. Zazwyczaj metoda jest wywoływana przez `callback` delegować.  
  
 Ta metoda nie blokuje, aż do zakończenia operacji. Aby zablokować, aż do zakończenia operacji, użyj jednej z <xref:System.Net.Sockets.Socket.Receive%2A> przeciążenia metody.  
  
 Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceive%2A>, wywołaj <xref:System.Net.Sockets.Socket.Close%2A> metody.  
  
 Aby uzyskać szczegółowe informacje dotyczące korzystania z modelu programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Wszystkie operacje We/Wy inicjowane przez dany wątku anulowany, gdy wątek która umożliwia zamknięcie. Istnieje oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek kończy działanie przed ukończeniem operacji.  
  
> [!NOTE]
>  `state` Umożliwia to tworzenie wystąpienia klasy zdefiniowanej przez użytkownika.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (w kontekście zabezpieczeń spersonifikowanego użytkownika i kontekst wywołania) jest w pamięci podręcznej asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określonego asynchroniczne <xref:System.Net.Sockets.Socket> metody, określony <xref:System.Net.Sockets.Socket> wystąpienie i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą poprawę wydajności.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> zostało zamknięte.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizacja magazynu dla odebranych danych.</param>
        <param name="offset">Liczony od zera pozycja w <c>buforu</c> parametru, w którym będzie przechowywany odebranych danych.</param>
        <param name="size">Liczba bajtów do odebrania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="socket_flags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po ukończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje na temat operacji odbierania. Ten obiekt jest przekazywany do <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> po zakończeniu operacji.</param>
        <summary>Zaczyna asynchronicznie odbieranie danych z połączonych <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołujący się odczyt asynchroniczny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.Socket.BeginReceive%2A> można ukończyć operacji, przez wywołanie metody <xref:System.Net.Sockets.Socket.EndReceive%2A> metody. Zazwyczaj metoda jest wywoływana przez `callback` delegować.  
  
 Ta metoda nie blokuje, aż do zakończenia operacji. Aby zablokować, aż do zakończenia operacji, użyj jednej z <xref:System.Net.Sockets.Socket.Receive%2A> przeciążenia metody.  
  
 Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceive%2A>, wywołaj <xref:System.Net.Sockets.Socket.Close%2A> metody.  
  
 Aby uzyskać szczegółowe informacje dotyczące korzystania z modelu programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Wszystkie operacje We/Wy inicjowane przez dany wątku anulowany, gdy wątek która umożliwia zamknięcie. Istnieje oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek kończy działanie przed ukończeniem operacji.  
  
> [!NOTE]
>  `state` Umożliwia to tworzenie wystąpienia klasy zdefiniowanej przez użytkownika.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (w kontekście zabezpieczeń spersonifikowanego użytkownika i kontekst wywołania) jest w pamięci podręcznej asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określonego asynchroniczne <xref:System.Net.Sockets.Socket> metody, określony <xref:System.Net.Sockets.Socket> wystąpienie i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą poprawę wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu zaczyna asynchronicznie odbieranie danych z połączonych <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> zostało zamknięte.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" /> jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość <paramref name="offset" /> parametru.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizacja magazynu dla odebranych danych.</param>
        <param name="offset">Lokalizacja w <c>buforu</c> do przechowywania odebranych danych.</param>
        <param name="size">Liczba bajtów do odebrania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="flags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> obiekt, który przechowuje błąd gniazda.</param>
        <param name="error">A <see cref="T:System.Net.Sockets.SocketError" /> obiekt, który przechowuje błąd gniazda.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po ukończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje na temat operacji odbierania. Ten obiekt jest przekazywany do <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> po zakończeniu operacji.</param>
        <summary>Zaczyna asynchronicznie odbieranie danych z połączonych <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołujący się odczyt asynchroniczny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.Socket.BeginReceive%2A> można ukończyć operacji, przez wywołanie metody <xref:System.Net.Sockets.Socket.EndReceive%2A> metody. Zazwyczaj metoda jest wywoływana przez `callback` delegować.  
  
 Ta metoda nie blokuje, aż do zakończenia operacji. Aby zablokować, aż do zakończenia operacji, użyj jednej z <xref:System.Net.Sockets.Socket.Receive%2A> przeciążenia metody.  
  
 Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceive%2A>, wywołaj <xref:System.Net.Sockets.Socket.Close%2A> metody.  
  
 Aby uzyskać szczegółowe informacje dotyczące korzystania z modelu programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Wszystkie operacje We/Wy inicjowane przez dany wątku anulowany, gdy wątek która umożliwia zamknięcie. Istnieje oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek kończy działanie przed ukończeniem operacji.  
  
> [!NOTE]
>  `state` Umożliwia to tworzenie wystąpienia klasy zdefiniowanej przez użytkownika.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (w kontekście zabezpieczeń spersonifikowanego użytkownika i kontekst wywołania) jest w pamięci podręcznej asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określonego asynchroniczne <xref:System.Net.Sockets.Socket> metody, określony <xref:System.Net.Sockets.Socket> wystąpienie i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą poprawę wydajności.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> zostało zamknięte.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" /> jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość <paramref name="offset" /> parametru.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizacja magazynu dla odebranych danych.</param>
        <param name="offset">Liczony od zera pozycja w <c>buforu</c> parametru, w którym do przechowywania danych.</param>
        <param name="size">Liczba bajtów do odebrania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="socket_flags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> Reprezentujący źródło danych.</param>
        <param name="remote_end">
          <see cref="T:System.Net.EndPoint" /> Reprezentujący źródło danych.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegować.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Zaczyna asynchronicznie odbieranie danych z określonego urządzenia sieciowego.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołujący się odczyt asynchroniczny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Metoda uruchamia asynchronicznie odczytu datagramy bez połączenia z hostem zdalnym. Wywoływanie <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody daje możliwość odbierania danych w oddzielnych wykonanie wątku.  
  
 Można utworzyć metody wywołania zwrotnego, która implementuje <xref:System.AsyncCallback> delegować, a następnie przekaż jego nazwę na <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody. Aby to zrobić, w bardzo minimalne swoje `state` parametr musi zawierać połączonym lub domyślna <xref:System.Net.Sockets.Socket> używanych na potrzeby komunikacji. Jeśli wywołanie zwrotne potrzebuje więcej informacji, możesz utworzyć małych klasy utrzymującej <xref:System.Net.Sockets.Socket> i inne wymagane informacje. Przekaż wystąpienie tej klasy, aby <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody za pomocą `state` parametru.  
  
 Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> metody. Gdy Twoja aplikacja wywołuje <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, system użyje oddzielnego wątku do wykonania metodą określonego wywołania zwrotnego i spowoduje zablokowanie na <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> aż <xref:System.Net.Sockets.Socket> odczytuje dane ani nie zgłasza wyjątku. Jeśli chcesz, oryginalnym wątku do blokowania po wywołaniu metody <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody, użyj <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Wywołać metody Set w T:System.Threading.ManualResetEvent metody wywołania zwrotnego, jeśli chcesz, oryginalnym wątku w celu kontynuowania wykonywania. Aby uzyskać dodatkowe informacje na temat pisania metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, musisz jawnie powiązać <xref:System.Net.Sockets.Socket> lokalny punkt końcowy za pomocą <xref:System.Net.Sockets.Socket.Bind%2A> metody lub <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Ta metoda odczytuje dane `buffer` parametr i przechwytywania host zdalny punkt końcowy, z którego dane są przesyłane. Aby uzyskać informacje dotyczące sposobu pobierania tego punktu końcowego, zapoznaj się <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. Ta metoda jest najbardziej użyteczne, jeśli zamierzasz asynchronicznie otrzymywać przesyłanie datagramy Nieznany host lub wielu hostów. W takich przypadkach <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> odczyta pierwszy datagram umieszczonych w kolejce, odbierane w buforze sieci lokalnej. Jeśli datagram otrzymasz jest większy niż rozmiar `buffer`, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metoda wypełni `buffer` o tyle komunikatu, ponieważ jest to możliwe i throw <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu zawodnych nadmiarowe dane zostaną utracone. Jeśli używasz niezawodny protokół, nadmiarowe dane będą przechowywane przez dostawcę usług i można go pobrać, wywołując <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody z buforu wystarczająco duży.  
  
 Aby zagwarantować, że zwracany jest zawsze hosta zdalnego punktu końcowego, aplikacja powinna być jawnie powiązana <xref:System.Net.Sockets.Socket> lokalny punkt końcowy za pomocą <xref:System.Net.Sockets.Socket.Bind%2A> metody i następnie wywołaniu <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody z `optionLevel` parametr wartość <xref:System.Net.Sockets.SocketOptionLevel.IP>lub <xref:System.Net.Sockets.SocketOptionLevel.IPv6> zgodnie z potrzebami `optionName` parametr <xref:System.Net.Sockets.SocketOptionName.PacketInformation>i `optionValue` parametru, aby włączyć tę opcję, przed wywołaniem <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody. W przeciwnym razie jest możliwe dla hosta zdalnego punktu końcowego nie będą zwracane, gdy nadawca wysłał liczbę datagramów przed odbiornik wywołał <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody.  
  
 Mimo że <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> jest przeznaczony dla protokołów bez połączenia, można użyć również protokół ukierunkowane na połączenia. Jeśli wybierzesz to zrobić, albo nawiązania połączenia z hostem zdalnym, wywołując <xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody lub zaakceptuj żądanie połączenia przychodzące, wywołując <xref:System.Net.Sockets.Socket.Accept%2A> lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody. Jeśli wywołasz <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody przed przystąpieniem do ustanawiania lub zaakceptowania połączenia, zostanie wyświetlony <xref:System.Net.Sockets.SocketException>. Możesz także udostępnić domyślnego hosta zdalnego bez połączenia protokołu przed wywołaniem <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody. W obu tych przypadkach <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metoda zignoruje `remoteEP` parametru i odbierać dane z połączonym lub domyślnego hosta zdalnego.  
  
 Z nawiązaniem połączenia gniazda <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> odczyta jak najwięcej danych, ponieważ jest dostępnych maksymalnie liczbę bajtów określoną przez `size` parametru.  
  
 Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, wywołaj <xref:System.Net.Sockets.Socket.Close%2A> metody.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (w kontekście zabezpieczeń spersonifikowanego użytkownika i kontekst wywołania) jest w pamięci podręcznej asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określonego asynchroniczne <xref:System.Net.Sockets.Socket> metody, określony <xref:System.Net.Sockets.Socket> wystąpienie i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą poprawę wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu asynchronicznie odbiera datagramy bez połączenia z hostem zdalnym.  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" /> jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań ma uprawnienie dla żądanej operacji.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizacja magazynu dla odebranych danych.</param>
        <param name="offset">Liczony od zera pozycja w <c>buforu</c> parametru, w którym do przechowywania danych.</param>
        <param name="size">Liczba bajtów do odebrania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> Reprezentujący źródło danych.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegować.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Rozpoczyna asynchronicznie odbieranie określoną liczbę bajtów danych do określonej lokalizacji bufor danych przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />i przechowuje informacje o punkcie końcowym i pakietów...</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołujący się odczyt asynchroniczny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchronicznego odbioru operacja musi zostać wykonane przez wywołanie <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> metody. Zazwyczaj metoda jest wywoływana przez `asyncCallback` delegować.  
  
 Ta metoda nie blokuje, aż do zakończenia operacji. Aby zablokować do momentu ukończenia operacji, należy użyć <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metody.  
  
 Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, wywołaj <xref:System.Net.Sockets.Socket.Close%2A> metody.  
  
 Aby uzyskać szczegółowe informacje dotyczące korzystania z modelu programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Ta metoda odczytuje dane `buffer` parametru i przechwytywania host zdalny punkt końcowy, z którego dane są przesyłane, a także informacje o odebranego pakietu. Aby uzyskać informacje dotyczące sposobu pobierania tego punktu końcowego, zapoznaj się <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. Ta metoda jest najbardziej użyteczne, jeśli zamierzasz asynchronicznie otrzymywać przesyłanie datagramy Nieznany host lub wielu hostów.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (w kontekście zabezpieczeń spersonifikowanego użytkownika i kontekst wywołania) jest w pamięci podręcznej asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określonego asynchroniczne <xref:System.Net.Sockets.Socket> metody, określony <xref:System.Net.Sockets.Socket> wystąpienie i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą poprawę wydajności.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" /> jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.NotSupportedException">System operacyjny to Windows 2000 lub starszym. Ponadto ta metoda wymaga Windows XP.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wysyła dane asynchronicznie do połączonej <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegować.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Wysyła dane asynchronicznie do połączonej <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołujący się asynchronicznego wysyłania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A> Metoda uruchamia operację asynchronicznego wysyłania do hosta zdalnego ustanowionych w <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody. <xref:System.Net.Sockets.Socket.BeginSend%2A> spowoduje zgłoszenie wyjątku, jeśli użytkownik nie należy wywoływać najpierw <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Wywoływanie <xref:System.Net.Sockets.Socket.BeginSend%2A> metoda daje możliwość wysyłania danych w ramach oddzielnych wykonanie wątku.  
  
 Można utworzyć metody wywołania zwrotnego, która implementuje <xref:System.AsyncCallback> delegować, a następnie przekaż jego nazwę na <xref:System.Net.Sockets.Socket.BeginSend%2A> metody. Aby to zrobić, w bardzo minimalne swoje `state` parametr musi zawierać połączonym lub domyślna <xref:System.Net.Sockets.Socket> używanych na potrzeby komunikacji. Jeśli wywołanie zwrotne potrzebuje więcej informacji, możesz utworzyć małych klasę lub strukturę do przechowywania <xref:System.Net.Sockets.Socket> i inne wymagane informacje. Przekaż wystąpienie tej klasy, aby <xref:System.Net.Sockets.Socket.BeginSend%2A> metody za pomocą `state` parametru.  
  
 Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndSend%2A> metody. Gdy Twoja aplikacja wywołuje <xref:System.Net.Sockets.Socket.BeginSend%2A>, system użyje oddzielnego wątku w celu wykonania metodą określonego wywołania zwrotnego i spowoduje zablokowanie na <xref:System.Net.Sockets.Socket.EndSend%2A> aż <xref:System.Net.Sockets.Socket> wysyła liczbę bajtów, ani nie zgłasza wyjątku. Jeśli chcesz, oryginalnym wątku do blokowania po wywołaniu metody <xref:System.Net.Sockets.Socket.BeginSend%2A> metody, użyj <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> metody. Wywołać metody Set w T:System.Threading.ManualResetEvent metody wywołania zwrotnego, jeśli chcesz, oryginalnym wątku w celu kontynuowania wykonywania. Aby uzyskać dodatkowe informacje na temat pisania metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Mimo że przeznaczone dla protokołów z nawiązaniem połączenia <xref:System.Net.Sockets.Socket.BeginSend%2A> działa również w przypadku protokołów bez połączenia, pod warunkiem, że pierwsze wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.BeginConnect%2A> metoda ustanowienie domyślnego hosta zdalnego. Jeśli używasz przesyłanie protokołu i plan do wysyłania danych do wielu różnych hostach, należy użyć <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Można użyć <xref:System.Net.Sockets.Socket.BeginSendTo%2A> mimo że ustanowiono domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSend%2A> , wprowadzając inne wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Za pomocą protokołów bez połączenia również należy się upewnić, że rozmiar buforu przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak jest, datagram nie będą wysyłane i <xref:System.Net.Sockets.Socket.BeginSend%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketflags` parametru, dane są wysyłane, nie będą kierowane.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Wszystkie operacje We/Wy inicjowane przez dany wątku anulowany, gdy wątek która umożliwia zamknięcie. Istnieje oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek kończy działanie przed ukończeniem operacji.  
  
> [!NOTE]
>  `state` Umożliwia to tworzenie wystąpienia klasy zdefiniowanej przez użytkownika.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie oznacza, że danych zostało pomyślnie dostarczone. Jeśli ilość miejsca w buforze jest dostępna w ramach systemu transportu do przechowywania danych, które mają być przekazywane, Wyślij zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (w kontekście zabezpieczeń spersonifikowanego użytkownika i kontekst wywołania) jest w pamięci podręcznej asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określonego asynchroniczne <xref:System.Net.Sockets.Socket> metody, określony <xref:System.Net.Sockets.Socket> wystąpienie i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą poprawę wydajności.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> jest pusty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz sekcję uwagi poniżej.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> obiekt, który przechowuje błąd gniazda.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegować.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Wysyła dane asynchronicznie do połączonej <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołujący się asynchronicznego wysyłania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A> Metoda uruchamia operację asynchronicznego wysyłania do hosta zdalnego ustanowionych w <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody. <xref:System.Net.Sockets.Socket.BeginSend%2A> spowoduje zgłoszenie wyjątku, jeśli użytkownik nie należy wywoływać najpierw <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Wywoływanie <xref:System.Net.Sockets.Socket.BeginSend%2A> metoda daje możliwość wysyłania danych w ramach oddzielnych wykonanie wątku.  
  
 Można utworzyć metody wywołania zwrotnego, która implementuje <xref:System.AsyncCallback> delegować, a następnie przekaż jego nazwę na <xref:System.Net.Sockets.Socket.BeginSend%2A> metody. Aby to zrobić, w bardzo minimalne swoje `state` parametr musi zawierać połączonym lub domyślna <xref:System.Net.Sockets.Socket> używanych na potrzeby komunikacji. Jeśli wywołanie zwrotne potrzebuje więcej informacji, możesz utworzyć małych klasę lub strukturę do przechowywania <xref:System.Net.Sockets.Socket> i inne wymagane informacje. Przekaż wystąpienie tej klasy, aby <xref:System.Net.Sockets.Socket.BeginSend%2A> metody za pomocą `state` parametru.  
  
 Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndSend%2A> metody. Gdy Twoja aplikacja wywołuje <xref:System.Net.Sockets.Socket.BeginSend%2A>, system użyje oddzielnego wątku w celu wykonania metodą określonego wywołania zwrotnego i spowoduje zablokowanie na <xref:System.Net.Sockets.Socket.EndSend%2A> aż <xref:System.Net.Sockets.Socket> wysyła liczbę bajtów, ani nie zgłasza wyjątku. Jeśli chcesz, oryginalnym wątku do blokowania po wywołaniu metody <xref:System.Net.Sockets.Socket.BeginSend%2A> metody, użyj <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> metody. Wywołanie metody Set na <xref:System.Threading.ManualResetEvent> metody wywołania zwrotnego, jeśli chcesz, oryginalnym wątku w celu kontynuowania wykonywania. Aby uzyskać dodatkowe informacje na temat pisania metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Mimo że przeznaczone dla protokołów z nawiązaniem połączenia <xref:System.Net.Sockets.Socket.BeginSend%2A> działa również w przypadku protokołów bez połączenia, pod warunkiem, że pierwsze wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.BeginConnect%2A> metoda ustanowienie domyślnego hosta zdalnego. Jeśli używasz przesyłanie protokołu i plan do wysyłania danych do wielu różnych hostach, należy użyć <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Można użyć <xref:System.Net.Sockets.Socket.BeginSendTo%2A> mimo że ustanowiono domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSend%2A> , wprowadzając inne wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Za pomocą protokołów bez połączenia również należy się upewnić, że rozmiar buforu przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak jest, datagram nie będą wysyłane i <xref:System.Net.Sockets.Socket.BeginSend%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketflags` parametru, dane są wysyłane, nie będą kierowane.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Wszystkie operacje We/Wy inicjowane przez dany wątku anulowany, gdy wątek która umożliwia zamknięcie. Istnieje oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek kończy działanie przed ukończeniem operacji.  
  
> [!NOTE]
>  `state` Umożliwia to tworzenie wystąpienia klasy zdefiniowanej przez użytkownika.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie oznacza, że danych zostało pomyślnie dostarczone. Jeśli ilość miejsca w buforze jest dostępna w ramach systemu transportu do przechowywania danych, które mają być przekazywane, Wyślij zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (w kontekście zabezpieczeń spersonifikowanego użytkownika i kontekst wywołania) jest w pamięci podręcznej asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określonego asynchroniczne <xref:System.Net.Sockets.Socket> metody, określony <xref:System.Net.Sockets.Socket> wystąpienie i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą poprawę wydajności.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> jest pusty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz sekcję uwagi poniżej.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="offset">Liczony od zera pozycja w <c>buforu</c> parametr, od którego należy rozpocząć wysyłanie danych.</param>
        <param name="size">Liczba bajtów do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> obiekt, który przechowuje błąd gniazda.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegować.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Wysyła dane asynchronicznie do połączonej <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołujący się asynchronicznego wysyłania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A> Metoda uruchamia operację asynchronicznego wysyłania do hosta zdalnego ustanowionych w <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody. <xref:System.Net.Sockets.Socket.BeginSend%2A> spowoduje zgłoszenie wyjątku, jeśli użytkownik nie należy wywoływać najpierw <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Wywoływanie <xref:System.Net.Sockets.Socket.BeginSend%2A> metoda daje możliwość wysyłania danych w ramach oddzielnych wykonanie wątku.  
  
 Można utworzyć metody wywołania zwrotnego, która implementuje <xref:System.AsyncCallback> delegować, a następnie przekaż jego nazwę na <xref:System.Net.Sockets.Socket.BeginSend%2A> metody. Aby to zrobić, w bardzo minimalne swoje `state` parametr musi zawierać połączonym lub domyślna <xref:System.Net.Sockets.Socket> używanych na potrzeby komunikacji. Jeśli wywołanie zwrotne potrzebuje więcej informacji, możesz utworzyć małych klasę lub strukturę do przechowywania <xref:System.Net.Sockets.Socket> i inne wymagane informacje. Przekaż wystąpienie tej klasy, aby <xref:System.Net.Sockets.Socket.BeginSend%2A> metody za pomocą `state` parametru.  
  
 Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndSend%2A> metody. Gdy Twoja aplikacja wywołuje <xref:System.Net.Sockets.Socket.BeginSend%2A>, system użyje oddzielnego wątku w celu wykonania metodą określonego wywołania zwrotnego i spowoduje zablokowanie na <xref:System.Net.Sockets.Socket.EndSend%2A> aż <xref:System.Net.Sockets.Socket> wysyła liczbę bajtów, ani nie zgłasza wyjątku. Jeśli chcesz, oryginalnym wątku do blokowania po wywołaniu metody <xref:System.Net.Sockets.Socket.BeginSend%2A> metody, użyj <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> metody. Wywołać metody Set w T:System.Threading.ManualResetEvent metody wywołania zwrotnego, jeśli chcesz, oryginalnym wątku w celu kontynuowania wykonywania. Aby uzyskać dodatkowe informacje na temat pisania metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Mimo że przeznaczone dla protokołów z nawiązaniem połączenia <xref:System.Net.Sockets.Socket.BeginSend%2A> działa również w przypadku protokołów bez połączenia, pod warunkiem, że pierwsze wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.BeginConnect%2A> metoda ustanowienie domyślnego hosta zdalnego. Jeśli używasz przesyłanie protokołu i plan do wysyłania danych do wielu różnych hostach, należy użyć <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Można użyć <xref:System.Net.Sockets.Socket.BeginSendTo%2A> mimo że ustanowiono domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSend%2A> , wprowadzając inne wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Za pomocą protokołów bez połączenia również należy się upewnić, że rozmiar buforu przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak jest, datagram nie będą wysyłane i <xref:System.Net.Sockets.Socket.BeginSend%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketflags` parametru, dane są wysyłane, nie będą kierowane.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Wszystkie operacje We/Wy inicjowane przez dany wątku anulowany, gdy wątek która umożliwia zamknięcie. Istnieje oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek kończy działanie przed ukończeniem operacji.  
  
> [!NOTE]
>  `state` Umożliwia to tworzenie wystąpienia klasy zdefiniowanej przez użytkownika.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie oznacza, że danych zostało pomyślnie dostarczone. Jeśli ilość miejsca w buforze jest dostępna w ramach systemu transportu do przechowywania danych, które mają być przekazywane, Wyślij zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (w kontekście zabezpieczeń spersonifikowanego użytkownika i kontekst wywołania) jest w pamięci podręcznej asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określonego asynchroniczne <xref:System.Net.Sockets.Socket> metody, określony <xref:System.Net.Sockets.Socket> wystąpienie i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą poprawę wydajności.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz sekcję uwagi poniżej.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" /> jest mniejsza niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="offset">Liczony od zera pozycja w <c>buforu</c> parametr, od którego należy rozpocząć wysyłanie danych.</param>
        <param name="size">Liczba bajtów do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="socket_flags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegować.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Wysyła dane asynchronicznie do połączonej <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołujący się asynchronicznego wysyłania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A> Metoda uruchamia operację asynchronicznego wysyłania do hosta zdalnego ustanowionych w <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody. <xref:System.Net.Sockets.Socket.BeginSend%2A> spowoduje zgłoszenie wyjątku, jeśli użytkownik nie należy wywoływać najpierw <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Wywoływanie <xref:System.Net.Sockets.Socket.BeginSend%2A> metoda daje możliwość wysyłania danych w ramach oddzielnych wykonanie wątku.  
  
 Można utworzyć metody wywołania zwrotnego, która implementuje <xref:System.AsyncCallback> delegować, a następnie przekaż jego nazwę na <xref:System.Net.Sockets.Socket.BeginSend%2A> metody. Aby to zrobić, w bardzo minimalne swoje `state` parametr musi zawierać połączonym lub domyślna <xref:System.Net.Sockets.Socket> używanych na potrzeby komunikacji. Jeśli wywołanie zwrotne potrzebuje więcej informacji, możesz utworzyć małych klasę lub strukturę do przechowywania <xref:System.Net.Sockets.Socket> i inne wymagane informacje. Przekaż wystąpienie tej klasy, aby <xref:System.Net.Sockets.Socket.BeginSend%2A> metody za pomocą `state` parametru.  
  
 Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndSend%2A> metody. Gdy Twoja aplikacja wywołuje <xref:System.Net.Sockets.Socket.BeginSend%2A>, system użyje oddzielnego wątku w celu wykonania metodą określonego wywołania zwrotnego i spowoduje zablokowanie na <xref:System.Net.Sockets.Socket.EndSend%2A> aż <xref:System.Net.Sockets.Socket> wysyła liczbę bajtów, ani nie zgłasza wyjątku. Jeśli chcesz, oryginalnym wątku do blokowania po wywołaniu metody <xref:System.Net.Sockets.Socket.BeginSend%2A> metody, użyj <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> metody. Wywołać metody Set w T:System.Threading.ManualResetEvent metody wywołania zwrotnego, jeśli chcesz, oryginalnym wątku w celu kontynuowania wykonywania. Aby uzyskać dodatkowe informacje na temat pisania metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Mimo że przeznaczone dla protokołów z nawiązaniem połączenia <xref:System.Net.Sockets.Socket.BeginSend%2A> działa również w przypadku protokołów bez połączenia, pod warunkiem, że pierwsze wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.BeginConnect%2A> metoda ustanowienie domyślnego hosta zdalnego. Jeśli używasz przesyłanie protokołu i plan do wysyłania danych do wielu różnych hostach, należy użyć <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Można użyć <xref:System.Net.Sockets.Socket.BeginSendTo%2A> mimo że ustanowiono domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSend%2A> , wprowadzając inne wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Za pomocą protokołów bez połączenia również należy się upewnić, że rozmiar buforu przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak jest, datagram nie będą wysyłane i <xref:System.Net.Sockets.Socket.BeginSend%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketflags` parametru, dane są wysyłane, nie będą kierowane.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Wszystkie operacje We/Wy inicjowane przez dany wątku anulowany, gdy wątek która umożliwia zamknięcie. Istnieje oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek kończy działanie przed ukończeniem operacji.  
  
> [!NOTE]
>  `state` Umożliwia to tworzenie wystąpienia klasy zdefiniowanej przez użytkownika.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie oznacza, że danych zostało pomyślnie dostarczone. Jeśli ilość miejsca w buforze jest dostępna w ramach systemu transportu do przechowywania danych, które mają być przekazywane, Wyślij zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (w kontekście zabezpieczeń spersonifikowanego użytkownika i kontekst wywołania) jest w pamięci podręcznej asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określonego asynchroniczne <xref:System.Net.Sockets.Socket> metody, określony <xref:System.Net.Sockets.Socket> wystąpienie i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą poprawę wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu rozpoczyna asynchronicznie wysyłania danych do hosta zdalnego.  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz sekcję uwagi poniżej.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" /> jest mniejsza niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Przykład asynchronicznego gniazda klienta</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Przykład asynchronicznego gniazda serwera</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asynchronicznie wysyła plik do połączonej <see cref="T:System.Net.Sockets.Socket" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">Ciąg, który zawiera ścieżkę i nazwę pliku do wysłania. Ten parametr może być <see langword="null" />.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegować.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Wysyła plik <paramref name="fileName" /> do połączonej <see cref="T:System.Net.Sockets.Socket" /> przy użyciu <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> flagi.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiekt, który reprezentuje asynchronicznego wysyłania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie wysyła plik `fileName` połączony gniazda. Jeśli `fileName` jest w katalogu lokalnym, może on zostać zidentyfikowany za pomocą tylko nazwę pliku; w przeciwnym razie należy określić pełną ścieżkę i nazwę pliku. Symbole wieloznaczne (".. \\\myfile.txt ") i nazwy udziałem UNC ("\\\\\\katalogu \shared\\\myfile.txt ") są obsługiwane. Jeśli plik nie zostanie znaleziony, wyjątek <xref:System.IO.FileNotFoundException> zgłaszany.  
  
 Ta metoda używa `TransmitFile` funkcja znalezione w interfejsie API Windows Sockets 2. Aby uzyskać więcej informacji na temat `TransmitFile` funkcji i jej flag, zobacz dokumentację Windows Sockets w bibliotece MSDN.  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Metoda uruchamia operację asynchronicznego wysyłania do hosta zdalnego ustanowionych w <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> zgłasza wyjątek, jeśli użytkownik nie należy wywoływać najpierw <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Wywoływanie <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metoda umożliwia wysyłanie do pliku w oddzielnych wykonanie wątku.  
  
 Aby zakończyć operację, należy utworzyć metodę wywołania zwrotnego, które jest wywoływane przez <xref:System.AsyncCallback> delegować parametru. Aby to zrobić, w bardzo minimalne `state` parametr musi zawierać <xref:System.Net.Sockets.Socket> obiekt używany do komunikacji. Jeśli wywołanie zwrotne potrzebuje więcej informacji, możesz utworzyć klasę lub strukturę do przechowywania <xref:System.Net.Sockets.Socket> i inne wymagane informacje. Przekaż wystąpienie tego obiektu niestandardowego w celu <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metody za pomocą `state` parametru.  
  
 Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndSendFile%2A> metody. Gdy Twoja aplikacja wywołuje <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, system używa oddzielnego wątku w celu wykonania metodą określonego wywołania zwrotnego i blokuje na <xref:System.Net.Sockets.Socket.EndSendFile%2A> aż <xref:System.Net.Sockets.Socket> wysyła cały plik ani nie zgłasza wyjątku. Aby uzyskać dodatkowe informacje na temat pisania metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Mimo że przeznaczone dla protokołów z nawiązaniem połączenia <xref:System.Net.Sockets.Socket.BeginSendFile%2A> działa również w przypadku protokołów bez połączenia, pod warunkiem, że pierwsze wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.BeginConnect%2A> metoda ustanowienie domyślnego hosta zdalnego. Z protokołami bez połączenia należy się upewnić, że rozmiar pliku przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak jest, datagram nie są wysyłane i <xref:System.Net.Sockets.Socket.BeginSendFile%2A> zgłasza <xref:System.Net.Sockets.SocketException> wyjątku.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException> wyjątek, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (w kontekście zabezpieczeń spersonifikowanego użytkownika i kontekst wywołania) jest w pamięci podręcznej asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określonego asynchroniczne <xref:System.Net.Sockets.Socket> metody, określony <xref:System.Net.Sockets.Socket> wystąpienie i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą poprawę wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy i łączy gniazda dla komunikacji asynchronicznej. Po pierwsze plik "text.txt" są wysyłane asynchronicznie do hosta zdalnego. Wywołanie zwrotne delegowanie wywołań <xref:System.Net.Sockets.Socket.EndSendFile%2A> można ukończyć przenoszenia.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Gniazda nie jest połączony z hostem zdalnym.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik <paramref name="fileName" /> nie został znaleziony.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz sekcję uwagi poniżej.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">Ciąg, który zawiera ścieżkę i nazwę pliku do wysłania. Ten parametr może być <see langword="null" />.</param>
        <param name="preBuffer">A <see cref="T:System.Byte" /> tablicę, która zawiera dane mają być wysyłane przed wysłaniem go. Ten parametr może być <see langword="null" />.</param>
        <param name="postBuffer">A <see cref="T:System.Byte" /> tablicę, która zawiera dane mają być wysyłane po przesłaniu pliku. Ten parametr może być <see langword="null" />.</param>
        <param name="flags">Bitowa kombinacja <see cref="T:System.Net.Sockets.TransmitFileOptions" /> wartości.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Pełnomocnika do wywołania po zakończeniu tej operacji. Ten parametr może być <see langword="null" />.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o stanie dla tego żądania. Ten parametr może być <see langword="null" />.</param>
        <summary>Przesyła plik i buforów danych asynchronicznie połączonej <see cref="T:System.Net.Sockets.Socket" /> obiektu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiekt, który reprezentuje operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie wymaga nazwy pliku, który chcesz wysłać oraz bitowa kombinacja <xref:System.Net.Sockets.TransmitFileOptions> wartości. `preBuffer` Parametr zawiera wszystkie dane, które mają się znajdować przed pliku. `postBuffer` zawiera dane, które chcesz obserwować pliku. Jeśli `fileName` jest w katalogu lokalnym, może on zostać zidentyfikowany za pomocą tylko nazwę pliku; w przeciwnym razie należy określić pełną ścieżkę i nazwę pliku. Symbole wieloznaczne (".. \\\myfile.txt ") i nazwy udziałem UNC ("\\\\\\katalogu \shared\\\myfile.txt ") są obsługiwane. Jeśli plik nie zostanie znaleziony, wyjątek <xref:System.IO.FileNotFoundException> zgłaszany.  
  
 `flags` Parametr zapewnia dostawcy usług Sockets okno z dodatkowymi informacjami dotyczącymi transferu plików. Aby uzyskać więcej informacji o tym, jak używać tego parametru, zobacz <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Ta metoda używa `TransmitFile` funkcja znalezione w interfejsie API Windows Sockets 2. Aby uzyskać więcej informacji na temat `TransmitFile` funkcji i jej flag, zobacz dokumentację Windows Sockets w bibliotece MSDN.  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Metoda uruchamia operację asynchronicznego wysyłania do hosta zdalnego ustanowionych w <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> zgłasza wyjątek, jeśli użytkownik nie należy wywoływać najpierw <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Wywoływanie <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metoda daje możliwość wysyłania do pliku w oddzielnych wykonanie wątku.  
  
 Aby zakończyć operację, należy utworzyć metodę wywołania zwrotnego, które jest wywoływane przez <xref:System.AsyncCallback> delegować parametru. Aby to zrobić, w bardzo minimalne `state` parametr musi zawierać <xref:System.Net.Sockets.Socket> obiekt używany do komunikacji. Jeśli wywołanie zwrotne potrzebuje więcej informacji, możesz utworzyć klasę lub strukturę do przechowywania <xref:System.Net.Sockets.Socket> i inne wymagane informacje. Przekaż wystąpienie tego obiektu niestandardowego w celu <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metody za pomocą `state` parametru.  
  
 Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndSendFile%2A> metody. Gdy Twoja aplikacja wywołuje <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, system używa oddzielnego wątku w celu wykonania metodą określonego wywołania zwrotnego i blokuje na <xref:System.Net.Sockets.Socket.EndSendFile%2A> aż <xref:System.Net.Sockets.Socket> wysyła cały plik ani nie zgłasza wyjątku. Aby uzyskać dodatkowe informacje na temat pisania metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Mimo że przeznaczone dla protokołów z nawiązaniem połączenia <xref:System.Net.Sockets.Socket.BeginSendFile%2A> działa również w przypadku protokołów bez połączenia, pod warunkiem, że pierwsze wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.BeginConnect%2A> metoda ustanowienie domyślnego hosta zdalnego. Za pomocą protokołów bez połączenia również należy się upewnić, że rozmiar pliku przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak jest, datagram nie są wysyłane i <xref:System.Net.Sockets.Socket.BeginSendFile%2A> zgłasza <xref:System.Net.Sockets.SocketException> wyjątku.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException> wyjątek, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (w kontekście zabezpieczeń spersonifikowanego użytkownika i kontekst wywołania) jest w pamięci podręcznej asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określonego asynchroniczne <xref:System.Net.Sockets.Socket> metody, określony <xref:System.Net.Sockets.Socket> wystąpienie i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą poprawę wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy i łączy gniazda dla komunikacji asynchronicznej i zaczynają wysyłać plik "text.txt" asynchronicznie do hosta zdalnego. W tym przykładzie `preBuffer` i `postBuffer` danych jest tworzona ma wysłać z pliku i domyślnego <xref:System.Net.Sockets.TransmitFileOptions> wartość jest używana. Wywołanie zwrotne delegowanie wywołań <xref:System.Net.Sockets.Socket.EndSendFile%2A> można ukończyć przenoszenia.  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz sekcję uwagi poniżej.</exception>
        <exception cref="T:System.NotSupportedException">System operacyjny nie jest częścią systemu Windows NT lub nowszego.  
  
\- lub — 
Gniazda nie jest połączony z hostem zdalnym.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik <paramref name="fileName" /> nie został znaleziony.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="offset">Liczony od zera pozycja w <c>buforu</c> od którego należy rozpocząć wysyłanie danych.</param>
        <param name="size">Liczba bajtów do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="socket_flags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> Reprezentujący urządzenie zdalne.</param>
        <param name="remote_end">
          <see cref="T:System.Net.EndPoint" /> Reprezentujący urządzenie zdalne.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegować.</param>
        <param name="state">Obiekt, który zawiera informacje o stanie dla tego żądania.</param>
        <summary>Asynchronicznie wysyła dane do określonego hosta zdalnego.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołujący się asynchronicznego wysyłania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Metoda uruchamia operację asynchronicznego wysyłania do hosta zdalnego, określony w `remoteEP` parametru. Wywoływanie <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metoda daje możliwość wysyłania danych w ramach oddzielnych wykonanie wątku. Mimo że przeznaczone dla protokołów przesyłanie <xref:System.Net.Sockets.Socket.BeginSendTo%2A> współpracuje z protokołami przesyłanie i ukierunkowane na połączenia.  
  
 Można utworzyć metody wywołania zwrotnego, która implementuje <xref:System.AsyncCallback> delegować, a następnie przekaż jego nazwę na <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metody. Aby to zrobić, w bardzo minimalne swoje `state` parametr musi zawierać połączonym lub domyślna <xref:System.Net.Sockets.Socket> używanych na potrzeby komunikacji. Jeśli wywołanie zwrotne potrzebuje więcej informacji, możesz utworzyć małych klasy utrzymującej <xref:System.Net.Sockets.Socket>i inne wymagane informacje. Przekaż wystąpienie tej klasy, aby <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metody za pomocą `state` parametru.  
  
 Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndSendTo%2A> metody. Gdy Twoja aplikacja wywołuje <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, system użyje oddzielnego wątku w celu wykonania metodą określonego wywołania zwrotnego i spowoduje zablokowanie na <xref:System.Net.Sockets.Socket.EndSendTo%2A> aż <xref:System.Net.Sockets.Socket> wysyła liczbę bajtów, ani nie zgłasza wyjątku. Jeśli chcesz, oryginalnym wątku do blokowania po wywołaniu metody <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metody, użyj <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> metody. Wywołać metody Set w T:System.Threading.ManualResetEvent metody wywołania zwrotnego, jeśli chcesz, oryginalnym wątku w celu kontynuowania wykonywania. Aby uzyskać dodatkowe informacje na temat pisania metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Jeśli używasz protokołu z nawiązaniem połączenia, najpierw musisz wywołać <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody lub <xref:System.Net.Sockets.Socket.BeginSendTo%2A> zgłosi <xref:System.Net.Sockets.SocketException>. <xref:System.Net.Sockets.Socket.BeginSendTo%2A> zignoruje `remoteEP` parametru i wysyła dane do <xref:System.Net.EndPoint> ustanowionych w <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody.  
  
 Jeśli używasz protokołu bez połączenia, nie trzeba ustanowienie domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.BeginConnect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>. Należy to zrobić, jeśli chcesz wywołać <xref:System.Net.Sockets.Socket.BeginSend%2A> metody. Jeśli wywołasz <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.BeginConnect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` parametru spowoduje przesłonięcie hosta zdalnego określoną wartość domyślną dla, które wysyłają tylko operacji. Ponadto nie należy wywoływać <xref:System.Net.Sockets.Socket.Bind%2A> metody. W tym przypadku podstawowego dostawcy usług przypisze najbardziej odpowiednia liczba adresów i portów sieci lokalnej. Użyj numeru portu o wartości zero, jeśli chcesz, aby podstawowego dostawcy usług do wybrania wolny port. Jeśli zachodzi potrzeba zidentyfikować adres i port numer przypisanej sieci lokalnej, możesz użyć <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwości po <xref:System.Net.Sockets.Socket.EndSendTo%2A> metoda się powiedzie.  
  
 Jeśli chcesz wysyłać dane do adres emisji, najpierw musisz wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody i ustaw gniazda opcję <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. -Należy się upewnić, że rozmiar buforu przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak jest, datagram nie będą wysyłane i <xref:System.Net.Sockets.Socket.EndSendTo%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketflags` parametru, dane są wysyłane, nie będą kierowane.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (w kontekście zabezpieczeń spersonifikowanego użytkownika i kontekst wywołania) jest w pamięci podręcznej asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określonego asynchroniczne <xref:System.Net.Sockets.Socket> metody, określony <xref:System.Net.Sockets.Socket> wystąpienie i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą poprawę wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu asynchronicznie wysyła dane do określonego hosta zdalnego.  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" /> jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań ma uprawnienie dla żądanej operacji.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshaling delegata jako metoda wywołania zwrotnego</related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">Lokalny <see cref="T:System.Net.EndPoint" /> do skojarzenia z <see cref="T:System.Net.Sockets.Socket" />.</param>
        <summary>Kojarzy <see cref="T:System.Net.Sockets.Socket" /> z lokalnym punktem końcowym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Net.Sockets.Socket.Bind%2A> metodę, jeśli musisz użyć określonego lokalnego punktu końcowego. Należy wywołać <xref:System.Net.Sockets.Socket.Bind%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.Listen%2A> metody. Nie trzeba wywoływać <xref:System.Net.Sockets.Socket.Bind%2A> przed użyciem <xref:System.Net.Sockets.Socket.Connect%2A> metoda o ile nie trzeba używać określonych lokalny punkt końcowy. Możesz użyć <xref:System.Net.Sockets.Socket.Bind%2A> metody protokołów przesyłanie i ukierunkowane na połączenia.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.Bind%2A>, należy najpierw utworzyć lokalnej <xref:System.Net.IPEndPoint> z którym zamierzasz przekazywania danych. Jeśli nie są istotne, który adres lokalny jest przypisany, można utworzyć <xref:System.Net.IPEndPoint> przy użyciu <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> jako parametr adres i usłudze podstawowej dostawcy przypisze najbardziej odpowiedni adres z sieci. Może to ułatwić, Uprość aplikacji, jeśli masz wiele interfejsów sieciowych. Jeśli nie są istotne, port lokalny, który jest używany, można utworzyć <xref:System.Net.IPEndPoint> przy użyciu 0 dla numeru portu. W tym przypadku dostawcy usług przypisze numeru portu dostępne od 1024 do 5000.  
  
 Jeśli używasz podejścia powyżej, można wykryć, jakie sieci lokalnej adres i numer portu przypisany przez wywołanie metody <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>. Jeśli używasz protokołu połączeniowy, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> nie zwróci adres sieci lokalnie przypisane do czasu, po dokonaniu wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.EndConnect%2A> metody. Jeśli używasz protokołu bez połączenia, nie masz dostęp do tych informacji do momentu zakończeniu wysyłania lub odbierania.  
  
 Jeśli gniazda UDP chce, aby uzyskiwać informacje o interfejsie dotyczące odebranych pakietów <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody powinny być jawnie wywołane z opcją gniazdo równa <xref:System.Net.Sockets.SocketOptionName.PacketInformation> natychmiast po wywołaniu <xref:System.Net.Sockets.Socket.Bind%2A> metody.  
  
> [!NOTE]
>  Jeśli zamierzasz odbierają datagramy multiemisji, należy wywołać <xref:System.Net.Sockets.Socket.Bind%2A> metody za pomocą numeru portu multiemisji.  
  
> [!NOTE]
>  Należy wywołać <xref:System.Net.Sockets.Socket.Bind%2A> metody, jeśli zamierzasz otrzymywać datagramy przesyłanie przy użyciu <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException> podczas wywoływania <xref:System.Net.Sockets.Socket.Bind%2A> metody, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy kod przykładowy tworzy powiązania <xref:System.Net.Sockets.Socket> przy użyciu określonego lokalny punkt końcowy.  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań ma uprawnienie dla żądanej operacji.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z hostem zdefiniowane przez <paramref name="localEP" />. Wyliczenie skojarzone: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Net.Sockets.Socket" /> jest w trybie blokowania.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.Socket" /> spowoduje zablokowanie; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Blocking%2A> Właściwość wskazuje, czy <xref:System.Net.Sockets.Socket> jest w trybie blokowania.  
  
 Jeśli jesteś w trybie blokowania i wprowadzić metody wywołania, która nie została zakończona natychmiast, aplikacja zablokuje wykonywanie aż do zakończenia żądanej operacji. Jeśli chcesz, aby wykonywania, aby kontynuować, nawet jeśli Żądana operacja nie została zakończona, zmień <xref:System.Net.Sockets.Socket.Blocking%2A> właściwość `false`. <xref:System.Net.Sockets.Socket.Blocking%2A> Właściwość nie ma wpływu na metod asynchronicznych. Jeśli są wysyłania i odbierania danych asynchronicznie i chcesz zablokować wykonywanie, użyj <xref:System.Threading.ManualResetEvent> klasy.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Obiekt używany do żądania połączenia z hostem zdalnym, wywołując jedną z <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> metody.</param>
        <summary>Anulowanie asynchroniczne żądanie dla połączenia zdalnego hosta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> Metoda anuluje żądanie asynchroniczne dla połączenia zdalnego hosta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> Parametr nie może mieć wartości null i <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> nie może mieć wartości null.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań ma uprawnienie dla żądanej operacji.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zamyka <see cref="T:System.Net.Sockets.Socket" /> połączenia i wersjach wszystkich skojarzonych zasobów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka <see cref="T:System.Net.Sockets.Socket" /> połączenia i wersjach wszystkich skojarzonych zasobów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A> Metoda zamyka połączenia zdalnego hosta i wydań, wszystkie zarządzane i niezarządzane zasoby skojarzone z <xref:System.Net.Sockets.Socket>. Przy zamykaniu <xref:System.Net.Sockets.Socket.Connected%2A> właściwość jest ustawiona na `false`.  
  
 Połączeniowy protokołów, zalecane jest, należy wywołać <xref:System.Net.Sockets.Socket.Shutdown%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.Close%2A> metody. Zapewnia to, że wszystkie dane wysyłany i odbierany na połączone gniazdo przed jego zamknięciem.  
  
 Jeśli potrzebne do wywoływania <xref:System.Net.Sockets.Socket.Close%2A> bez wywoływania pierwszy <xref:System.Net.Sockets.Socket.Shutdown%2A>, można upewnić się, że dane w kolejce dla wychodzącej transmisji zostanie wysłany przez ustawienie <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> opcję `false` i określić interwał limitu czasu różna od zera. <xref:System.Net.Sockets.Socket.Close%2A> następnie będzie blokować te dane są wysyłane do chwili lub upływem określonego limitu czasu. Jeśli ustawisz <xref:System.Net.Sockets.SocketOptionName.DontLinger> do `false` i określ zero interwał limitu czasu, <xref:System.Net.Sockets.Socket.Close%2A> zwalnia połączenie, a następnie automatycznie odrzuca umieszczonych w kolejce dane wychodzące.  
  
> [!NOTE]
>  Można ustawić <xref:System.Net.Sockets.SocketOptionName.DontLinger> gniazda możliwość `false`, Utwórz <xref:System.Net.Sockets.LingerOption>, ustaw właściwość włączone `true`i ustaw <xref:System.Net.Sockets.LingerOption.LingerTime%2A> właściwość okresowi żądany limit czasu. Użyj tego <xref:System.Net.Sockets.LingerOption> wraz z <xref:System.Net.Sockets.SocketOptionName.DontLinger> gniazda opcję, aby wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy kod przykładu zamyka <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">Poczekaj do <c>limitu czasu</c> sekund, aby wysłać pozostałe dane, a następnie zamknij gniazda.</param>
        <summary>Zamyka <see cref="T:System.Net.Sockets.Socket" /> połączenia i wersjach wszystkie zasoby skojarzone z określonego limitu czasu, aby umożliwić danych umieszczonych w kolejce do wysłania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A> Metoda zamyka połączenia zdalnego hosta i wydań, wszystkie zarządzane i niezarządzane zasoby skojarzone z <xref:System.Net.Sockets.Socket>. Przy zamykaniu <xref:System.Net.Sockets.Socket.Connected%2A> właściwość jest ustawiona na `false`.  
  
 Połączeniowy protokołów, zalecane jest, należy wywołać <xref:System.Net.Sockets.Socket.Shutdown%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.Close%2A>. Zapewnia to, że wszystkie dane wysyłany i odbierany na połączone gniazdo przed jego zamknięciem.  
  
 Jeśli potrzebne do wywoływania <xref:System.Net.Sockets.Socket.Close%2A> bez wywoływania pierwszy <xref:System.Net.Sockets.Socket.Shutdown%2A>, można upewnić się, że dane w kolejce dla wychodzącej transmisji zostanie wysłany przez ustawienie <xref:System.Net.Sockets.SocketOptionName.DontLinger> opcję `false` i określić interwał limitu czasu różna od zera. <xref:System.Net.Sockets.Socket.Close%2A> następnie będzie blokować te dane są wysyłane do chwili lub upływem określonego limitu czasu. Jeśli ustawisz <xref:System.Net.Sockets.SocketOptionName.DontLinger> do `false` i określ zero interwał limitu czasu, <xref:System.Net.Sockets.Socket.Close%2A> zwalnia połączenie, a następnie automatycznie odrzuca umieszczonych w kolejce dane wychodzące.  
  
> [!NOTE]
>  Można ustawić <xref:System.Net.Sockets.SocketOptionName.DontLinger> gniazda możliwość `false`, Utwórz <xref:System.Net.Sockets.LingerOption>, ustaw właściwość włączone `true`i ustaw <xref:System.Net.Sockets.LingerOption.LingerTime%2A> właściwość żądaną wartość limitu czasu. Użyj tego <xref:System.Net.Sockets.LingerOption> wraz z <xref:System.Net.Sockets.SocketOptionName.DontLinger> gniazda opcję, aby wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób zamknięcia <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustanawia połączenie z hostem zdalnym.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> Reprezentujący urządzenie zdalne.</param>
        <summary>Ustanawia połączenie z hostem zdalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz protokołu połączeniowy takich jak TCP, <xref:System.Net.Sockets.Socket.Connect%2A> metoda synchronicznie ustanawia połączenie sieciowe między <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> i określonego zdalnego punktu końcowego. Jeśli używasz protokołu przesyłanie, <xref:System.Net.Sockets.Socket.Connect%2A> ustanawia domyślnego hosta zdalnego. Po wywołaniu metody <xref:System.Net.Sockets.Socket.Connect%2A>, możesz wysłać danych na zdalnym urządzeniu za pomocą <xref:System.Net.Sockets.Socket.Send%2A> metody lub odbieranie danych z urządzenia zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Receive%2A> metody.  
  
 Jeśli używasz bez połączenia protokołu UDP np. nie masz do wywołania <xref:System.Net.Sockets.Socket.Connect%2A> przed wysyłania i odbierania danych. Możesz użyć <xref:System.Net.Sockets.Socket.SendTo%2A> i <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> synchroniczną komunikację z hostem zdalnym. Jeśli wywołasz <xref:System.Net.Sockets.Socket.Connect%2A>, zostaną odrzucone datagramów i odbierane z adresu innego niż określoną wartość domyślną. Jeśli chcesz ustawić domyślnego hosta zdalnego na adres emisji, najpierw musisz wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody i ustaw gniazda opcję <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, lub <xref:System.Net.Sockets.Socket.Connect%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> Metoda spowoduje zablokowanie, chyba że specjalnie <xref:System.Net.Sockets.Socket.Blocking%2A> właściwości `false` przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>. Jeśli używasz protokołu ukierunkowane na połączenia, takie jak TCP, jak i możesz wyłączyć blokowanie, <xref:System.Net.Sockets.Socket.Connect%2A> zgłosi <xref:System.Net.Sockets.SocketException> ponieważ wymaga czasu, aby nawiązać połączenie. Przesyłanie protokołów nie spowoduje zgłoszenie wyjątku, ponieważ są one po prostu ustanowienie domyślnego hosta zdalnego. Możesz użyć <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu. Jeśli WSAEWOULDBLOCK zwrócony błąd, połączenie z hostem zdalnym została zainicjowana przez połączeniowy <xref:System.Net.Sockets.Socket>, ale nie została jeszcze ukończona pomyślnie. Użyj <xref:System.Net.Sockets.Socket.Poll%2A> metodę, aby określić, kiedy <xref:System.Net.Sockets.Socket> zakończy połączenie.  
  
> [!NOTE]
>  Jeśli używany jest protokół z nawiązaniem połączenia, a nie wywołał <xref:System.Net.Sockets.Socket.Bind%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>, podstawowego dostawcy usług przypisze sieci lokalnej adres i numer portu. Jeśli używasz protokołu bez połączenia dostawcy usług nie przypisywać sieci lokalnej adres i numer portu, do momentu ukończenia wysyłania lub odbierania operacji. Jeśli chcesz zmienić domyślnego hosta zdalnego wywołania <xref:System.Net.Sockets.Socket.Connect%2A> ponownie przy użyciu żądanego punktu końcowego.  
  
> [!NOTE]
>  Jeśli wcześniej odłączono gniazda nie można użyć tej metody, aby przywrócić połączenie. Użyj jednej z asynchroniczną <xref:System.Net.Sockets.Socket.BeginConnect%2A> metod w celu ponownego nawiązania połączenia. To ograniczenie źródłowego dostawcy.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu łączy do zdalnego punktu końcowego, a następnie sprawdza połączenie.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań ma uprawnienie dla żądanej operacji.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> Została umieszczona w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
        <permission cref="T:System.Net.SocketPermission">do łączenia się z hostem zdalnym. Wyliczenie skojarzone: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">Adres IP hosta zdalnego.</param>
        <param name="port">Numer portu zdalnego hosta.</param>
        <summary>Ustanawia połączenie z hostem zdalnym. Host jest określany przez adres IP i numer portu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz protokołu połączeniowy takich jak TCP, <xref:System.Net.Sockets.Socket.Connect%2A> metoda synchronicznie ustanawia połączenie sieciowe między <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> i określonego zdalnego punktu końcowego. Jeśli używasz protokołu przesyłanie, <xref:System.Net.Sockets.Socket.Connect%2A> ustanawia domyślnego hosta zdalnego. Po wywołaniu metody <xref:System.Net.Sockets.Socket.Connect%2A> w przypadku wysłania danych na zdalnym urządzeniu za pomocą <xref:System.Net.Sockets.Socket.Send%2A> metody lub odbieranie danych z urządzenia zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Receive%2A> metody.  
  
 Jeśli używasz bez połączenia protokołu UDP np. nie masz do wywołania <xref:System.Net.Sockets.Socket.Connect%2A> przed wysyłania i odbierania danych. Możesz użyć <xref:System.Net.Sockets.Socket.SendTo%2A> i <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> synchroniczną komunikację z hostem zdalnym. Jeśli wywołasz <xref:System.Net.Sockets.Socket.Connect%2A> datagramów i odbierane z adresu innego niż określoną wartość domyślną, zostaną odrzucone. Jeśli chcesz ustawić domyślnego hosta zdalnego na adres emisji, najpierw musisz wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody i ustaw gniazda opcję <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, lub <xref:System.Net.Sockets.Socket.Connect%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> metoda spowoduje zablokowanie, chyba że specjalnie <xref:System.Net.Sockets.Socket.Blocking%2A> właściwości `false` przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>. Jeśli używasz protokołu ukierunkowane na połączenia, takie jak TCP, jak i możesz wyłączyć blokowanie, <xref:System.Net.Sockets.Socket.Connect%2A> zgłosi <xref:System.Net.Sockets.SocketException> ponieważ wymaga czasu, aby nawiązać połączenie. Przesyłanie protokołów nie spowoduje zgłoszenie wyjątku, ponieważ są one po prostu ustanowienie domyślnego hosta zdalnego. Możesz użyć <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu. Jeśli WSAEWOULDBLOCK zwrócony błąd, połączenie z hostem zdalnym została zainicjowana przez połączeniowy <xref:System.Net.Sockets.Socket>, ale nie została jeszcze ukończona pomyślnie. Użyj <xref:System.Net.Sockets.Socket.Poll%2A> metodę, aby określić, kiedy <xref:System.Net.Sockets.Socket> zakończy połączenie.  
  
> [!NOTE]
>  Jeśli używany jest protokół z nawiązaniem połączenia, a nie wywołał <xref:System.Net.Sockets.Socket.Bind%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>, podstawowego dostawcy usług przypisze sieci lokalnej adres i numer portu. Jeśli używasz protokołu bez połączenia dostawcy usług nie przypisywać sieci lokalnej adres i numer portu, do momentu ukończenia wysyłania lub odbierania operacji. Jeśli chcesz zmienić domyślnego hosta zdalnego wywołania <xref:System.Net.Sockets.Socket.Connect%2A> ponownie przy użyciu żądanego punktu końcowego.  
  
> [!NOTE]
>  Jeśli wcześniej odłączono gniazda nie można użyć tej metody, aby przywrócić połączenie. Użyj jednej z asynchroniczną <xref:System.Net.Sockets.Socket.BeginConnect%2A> metod w celu ponownego nawiązania połączenia. To ograniczenie źródłowego dostawcy.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu łączy do zdalnego punktu końcowego, a następnie sprawdza połączenie.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda jest nieprawidłowa dla gniazda w <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> rodziny.</exception>
        <exception cref="T:System.ArgumentException">Długość <paramref name="address" /> wynosi zero.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> Została umieszczona w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addresses">Adresy IP hosta zdalnego.</param>
        <param name="port">Numer portu zdalnego hosta.</param>
        <summary>Ustanawia połączenie z hostem zdalnym. Host jest określany przez tablicę adresów IP i numer portu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest zwykle używana natychmiast po wywołaniu <xref:System.Net.Dns.GetHostAddresses%2A>, która może zwrócić wiele adresów IP dla jednego hosta. Jeśli używasz protokołu połączeniowy takich jak TCP, <xref:System.Net.Sockets.Socket.Connect%2A> metoda synchronicznie ustanawia połączenie sieciowe między <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> i określonego zdalnego punktu końcowego. Jeśli używasz protokołu przesyłanie, <xref:System.Net.Sockets.Socket.Connect%2A> ustanawia domyślnego hosta zdalnego. Po wywołaniu metody <xref:System.Net.Sockets.Socket.Connect%2A> w przypadku wysłania danych na zdalnym urządzeniu za pomocą <xref:System.Net.Sockets.Socket.Send%2A> metody lub odbieranie danych z urządzenia zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Receive%2A> metody.  
  
 Jeśli używasz bez połączenia protokołu UDP np. nie masz do wywołania <xref:System.Net.Sockets.Socket.Connect%2A> przed wysyłania i odbierania danych. Możesz użyć <xref:System.Net.Sockets.Socket.SendTo%2A> i <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> synchroniczną komunikację z hostem zdalnym. Jeśli wywołasz <xref:System.Net.Sockets.Socket.Connect%2A> datagramów i odbierane z adresu innego niż określoną wartość domyślną, zostaną odrzucone. Jeśli chcesz ustawić domyślnego hosta zdalnego na adres emisji, najpierw musisz wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody i ustaw gniazda opcję <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, lub <xref:System.Net.Sockets.Socket.Connect%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> metoda spowoduje zablokowanie, chyba że specjalnie <xref:System.Net.Sockets.Socket.Blocking%2A> właściwości `false` przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>. Jeśli używasz protokołu ukierunkowane na połączenia, takie jak TCP, jak i możesz wyłączyć blokowanie, <xref:System.Net.Sockets.Socket.Connect%2A> zgłosi <xref:System.Net.Sockets.SocketException> ponieważ wymaga czasu, aby nawiązać połączenie. Przesyłanie protokołów nie spowoduje zgłoszenie wyjątku, ponieważ są one po prostu ustanowienie domyślnego hosta zdalnego. Możesz użyć <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu. Jeśli WSAEWOULDBLOCK zwrócony błąd, połączenie z hostem zdalnym została zainicjowana przez połączeniowy <xref:System.Net.Sockets.Socket>, ale nie została jeszcze ukończona pomyślnie. Użyj <xref:System.Net.Sockets.Socket.Poll%2A> metodę, aby określić, kiedy <xref:System.Net.Sockets.Socket> zakończy połączenie.  
  
> [!NOTE]
>  Jeśli używany jest protokół z nawiązaniem połączenia, a nie wywołał <xref:System.Net.Sockets.Socket.Bind%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>, podstawowego dostawcy usług przypisze sieci lokalnej adres i numer portu. Jeśli używasz protokołu bez połączenia dostawcy usług nie przypisywać sieci lokalnej adres i numer portu, do momentu ukończenia wysyłania lub odbierania operacji. Jeśli chcesz zmienić domyślnego hosta zdalnego wywołania <xref:System.Net.Sockets.Socket.Connect%2A> ponownie przy użyciu żądanego punktu końcowego.  
  
> [!NOTE]
>  Jeśli wcześniej odłączono gniazda nie można użyć tej metody, aby przywrócić połączenie. Użyj jednej z asynchroniczną <xref:System.Net.Sockets.Socket.BeginConnect%2A> metod w celu ponownego nawiązania połączenia. To ograniczenie źródłowego dostawcy.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu łączy do zdalnego punktu końcowego, a następnie sprawdza połączenie.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addresses" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda jest nieprawidłowa dla gniazda w <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> rodziny.</exception>
        <exception cref="T:System.ArgumentException">Długość <paramref name="address" /> wynosi zero.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> Została umieszczona w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">Nazwa hosta zdalnego.</param>
        <param name="port">Numer portu zdalnego hosta.</param>
        <summary>Ustanawia połączenie z hostem zdalnym. Host jest określony przez nazwę hosta i numer portu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz protokołu połączeniowy takich jak TCP, <xref:System.Net.Sockets.Socket.Connect%2A> metoda synchronicznie ustanawia połączenie sieciowe między <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> i określonego hosta zdalnego. Jeśli używasz protokołu przesyłanie, <xref:System.Net.Sockets.Socket.Connect%2A> ustanawia domyślnego hosta zdalnego. Po wywołaniu metody <xref:System.Net.Sockets.Socket.Connect%2A> w przypadku wysłania danych na zdalnym urządzeniu za pomocą <xref:System.Net.Sockets.Socket.Send%2A> metody lub odbieranie danych z urządzenia zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Receive%2A> metody.  
  
 Jeśli używasz bez połączenia protokołu UDP np. nie masz do wywołania <xref:System.Net.Sockets.Socket.Connect%2A> przed wysyłania i odbierania danych. Możesz użyć <xref:System.Net.Sockets.Socket.SendTo%2A> i <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> synchroniczną komunikację z hostem zdalnym. Jeśli wywołasz <xref:System.Net.Sockets.Socket.Connect%2A> datagramów i odbierane z adresu innego niż określoną wartość domyślną, zostaną odrzucone. Jeśli chcesz ustawić domyślnego hosta zdalnego na adres emisji, najpierw musisz wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody i ustaw gniazda opcję <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, lub <xref:System.Net.Sockets.Socket.Connect%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> metoda spowoduje zablokowanie, chyba że specjalnie <xref:System.Net.Sockets.Socket.Blocking%2A> właściwości `false` przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>. Jeśli używasz protokołu ukierunkowane na połączenia, takie jak TCP, jak i możesz wyłączyć blokowanie, <xref:System.Net.Sockets.Socket.Connect%2A> zgłosi <xref:System.Net.Sockets.SocketException> ponieważ wymaga czasu, aby nawiązać połączenie. Przesyłanie protokołów nie spowoduje zgłoszenie wyjątku, ponieważ są one po prostu ustanowienie domyślnego hosta zdalnego. Możesz użyć <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu. Jeśli WSAEWOULDBLOCK zwrócony błąd, połączenie z hostem zdalnym została zainicjowana przez połączeniowy <xref:System.Net.Sockets.Socket>, ale nie została jeszcze ukończona pomyślnie. Użyj <xref:System.Net.Sockets.Socket.Poll%2A> metodę, aby określić, kiedy <xref:System.Net.Sockets.Socket> zakończy połączenie.  
  
 Jeśli był włączony protokół IPv6 i <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> metoda jest wywoływana, aby połączyć się z hostem, który jest rozpoznawany jako IPv6 i adresów IPv4, połączenia protokołu IPv6 adres będzie próba przed adresem IPv4. Może to mieć wpływu opóźnienia czasu do nawiązania połączenia, jeśli host nie nasłuchuje na adres IPv6.  
  
> [!NOTE]
>  Jeśli używany jest protokół z nawiązaniem połączenia, a nie wywołał <xref:System.Net.Sockets.Socket.Bind%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>, podstawowego dostawcy usług przypisze sieci lokalnej adres i numer portu. Jeśli używasz protokołu bez połączenia dostawcy usług nie przypisywać sieci lokalnej adres i numer portu, do momentu ukończenia wysyłania lub odbierania operacji. Jeśli chcesz zmienić domyślnego hosta zdalnego wywołania <xref:System.Net.Sockets.Socket.Connect%2A> ponownie przy użyciu żądanego punktu końcowego.  
  
> [!NOTE]
>  Jeśli wcześniej odłączono gniazda nie można użyć tej metody, aby przywrócić połączenie. Użyj jednej z asynchroniczną <xref:System.Net.Sockets.Socket.BeginConnect%2A> metod w celu ponownego nawiązania połączenia. To ograniczenie źródłowego dostawcy.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu łączy do zdalnego punktu końcowego, a następnie sprawdza połączenie.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda jest nieprawidłowa dla gniazda w <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> rodziny.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> Została umieszczona w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna się asynchroniczne żądanie dla połączenia z hostem zdalnym.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Obiekt ma być używany dla tej operacji asynchronicznych gniazda.</param>
        <summary>Rozpoczyna się asynchroniczne żądanie dla połączenia z hostem zdalnym.</summary>
        <returns>Zwraca <see langword="true" /> przypadku oczekujących operacji We/Wy. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie na <paramref name="e" /> parametr zostanie wygenerowany po zakończeniu operacji.  
  
Zwraca <see langword="false" /> Jeśli operacji We/Wy została zakończona synchronicznie. W tym przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie na <paramref name="e" /> parametr nie zostanie wygenerowany i <paramref name="e" /> przekazano obiekt jako parametr może zbadać, natychmiast po zakończeniu wywołania metody które zwraca wynik operacji pobierania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz protokołu połączeniowy, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metoda uruchamia asynchroniczne żądanie dla połączenia z hostem zdalnym. Jeśli używasz protokołu przesyłanie, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> ustanawia domyślnego hosta zdalnego.  
  
 Aby otrzymywać powiadomienia o zakończeniu, należy utworzyć metody wywołania zwrotnego, która implementuje EventHandler\<SocketAsyncEventArgs > delegować i dołączyć wywołanie zwrotne w celu <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> zdarzeń.  
  
 Obiekt wywołujący musi być ustawiona <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> właściwość <xref:System.Net.IPEndPoint> zdalnego hosta, aby nawiązać połączenie.  
  
 Obiekt wywołujący może ustawiać <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość do każdego obiektu stanu użytkownika żądanego przed wywołaniem <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodę, tak, aby dane możliwe do pobierania w metody wywołania zwrotnego. Jeśli wywołanie zwrotne potrzebuje więcej informacji, niż jeden obiekt, mały klasy mogą być tworzone na potrzeby przechowywania inne wymagane informacje o stanie jako elementy członkowskie.  
  
 Jeśli używasz bez połączenia protokołu UDP np. nie masz do wywołania <xref:System.Net.Sockets.Socket.ConnectAsync%2A> przed wysyłania i odbierania danych. Możesz użyć <xref:System.Net.Sockets.Socket.SendToAsync%2A> i <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> do komunikowania się z hostem zdalnym. Jeśli wywołasz <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, zostaną odrzucone datagramów i odbierane z adresu innego niż określoną wartość domyślną. Jeśli chcesz zmienić domyślnego hosta zdalnego wywołania <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metody ponownie z żądanego punktu końcowego.  
  
 Jeśli chcesz ustawić domyślnego hosta zdalnego na adres emisji, najpierw musisz wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> i równa emisji `true`. Jeśli nie zostanie to zrobione, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metoda zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Poniższe właściwości i zdarzenia <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiektu są wymagane:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 Opcjonalnie, bufor może być podany, który niepodzielnie będą wysyłane na gniazdo po <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metoda zakończy się pomyślnie. W tym przypadku <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> właściwość musi być ustawiona w buforze, zawierający dane do wysyłania i <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> właściwość należy ustawić liczby bajtów danych do wysyłania z buforu. Po nawiązaniu połączenia tego buforu danych jest wysyłane.  
  
 Jeśli używany jest protokół z nawiązaniem połączenia, a nie wywołuj <xref:System.Net.Sockets.Socket.Bind%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, podstawowego dostawcy usług przypisze najbardziej odpowiedni adres i port numer sieci lokalnej.  
  
 Jeśli używasz protokołu bez połączenia dostawcy usług nie spowoduje przypisanie sieci lokalnej IP adres i numer portu, dopóki nie zostanie wywołana <xref:System.Net.Sockets.Socket.SendAsync%2A> lub <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> metody.  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Metoda zgłasza wyjątek <xref:System.NotSupportedException> Jeśli rodziny adresów <xref:System.Net.Sockets.Socket> i <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> nie są w tej samej rodziny adresów.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException> po wywołaniu tej metody należy użyć <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Argument jest nieprawidłowy. Ten wyjątek występuje, jeśli nie określono kilka buforów, <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> właściwość nie ma wartości null.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> Parametr nie może mieć wartości null i <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> nie może mieć wartości null.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> Jest nasłuchiwania lub operacji gniazdo zostało już w toku przy użyciu <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiekt określony w <paramref name="e" /> parametru.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP lub nowszy jest wymagany dla tej metody. Ten wyjątek ma miejsce, gdy lokalny punkt końcowy i <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> nie są w tej samej rodziny adresów.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań ma uprawnienie dla żądanej operacji.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="socketType">Jedną z <see cref="T:System.Net.Sockets.SocketType" /> wartości.</param>
        <param name="protocolType">Jedną z <see cref="T:System.Net.Sockets.ProtocolType" /> wartości.</param>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Obiekt ma być używany dla tej operacji asynchronicznych gniazda.</param>
        <summary>Rozpoczyna się asynchroniczne żądanie dla połączenia z hostem zdalnym.</summary>
        <returns>Zwraca <see langword="true" /> przypadku oczekujących operacji We/Wy. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie na <paramref name="e" /> parametr zostanie wygenerowany po zakończeniu operacji.  
  
Zwraca <see langword="false" /> Jeśli operacji We/Wy została zakończona synchronicznie. W tym przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie na <paramref name="e" /> parametr nie zostanie wygenerowany i <paramref name="e" /> przekazano obiekt jako parametr może zbadać, natychmiast po zakończeniu wywołania metody które zwraca wynik operacji pobierania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz protokołu połączeniowy metoda M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) uruchamia asynchroniczne żądanie dla połączenie z hostem zdalnym. Jeśli używasz protokołu przesyłanie, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> ustanawia domyślnego hosta zdalnego, określony przez `socketType` i `protocolType` parametrów.  
  
 Aby otrzymywać powiadomienia o zakończeniu, należy utworzyć metody wywołania zwrotnego, która implementuje EventHandler\<SocketAsyncEventArgs > delegować i dołączyć wywołanie zwrotne w celu <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> zdarzeń.  
  
 Obiekt wywołujący musi być ustawiona <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> właściwość <xref:System.Net.IPEndPoint> zdalnego hosta, aby nawiązać połączenie.  
  
 Obiekt wywołujący może ustawiać <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość do każdego obiektu stanu użytkownika żądanego przed wywołaniem <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodę, tak, aby dane możliwe do pobierania w metody wywołania zwrotnego. Jeśli wywołanie zwrotne potrzebuje więcej informacji, niż jeden obiekt, mały klasy mogą być tworzone na potrzeby przechowywania inne wymagane informacje o stanie jako elementy członkowskie.  
  
 Jeśli używasz bez połączenia protokołu UDP np. nie masz do wywołania <xref:System.Net.Sockets.Socket.ConnectAsync%2A> przed wysyłania i odbierania danych. Możesz użyć <xref:System.Net.Sockets.Socket.SendToAsync%2A> i <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> do komunikowania się z hostem zdalnym. Jeśli wywołasz <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, zostaną odrzucone datagramów i odbierane z adresu innego niż określoną wartość domyślną. Jeśli chcesz zmienić domyślnego hosta zdalnego wywołania <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metody ponownie z żądanego punktu końcowego.  
  
 Jeśli chcesz ustawić domyślnego hosta zdalnego na adres emisji, najpierw musisz wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> i równa emisji `true`. Jeśli nie zostanie to zrobione, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metoda zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Poniższe właściwości i zdarzenia <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiektu są wymagane:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 Opcjonalnie, bufor może być podany, który niepodzielnie będą wysyłane na gniazdo po <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metoda zakończy się pomyślnie. W tym przypadku <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> właściwość musi być ustawiona w buforze, zawierający dane do wysyłania i <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> właściwość należy ustawić liczby bajtów danych do wysyłania z buforu. Po nawiązaniu połączenia tego buforu danych jest wysyłane.  
  
 Jeśli używany jest protokół z nawiązaniem połączenia, a nie wywołuj <xref:System.Net.Sockets.Socket.Bind%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, podstawowego dostawcy usług przypisze najbardziej odpowiedni adres i port numer sieci lokalnej.  
  
 Jeśli używasz protokołu bez połączenia dostawcy usług nie spowoduje przypisanie sieci lokalnej IP adres i numer portu, dopóki nie zostanie wywołana <xref:System.Net.Sockets.Socket.SendAsync%2A> lub <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> metody.  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Metoda zgłasza wyjątek <xref:System.NotSupportedException> Jeśli rodziny adresów <xref:System.Net.Sockets.Socket> i <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> nie są w tej samej rodziny adresów.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException> po wywołaniu tej metody należy użyć <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Argument jest nieprawidłowy. Ten wyjątek występuje, jeśli nie określono kilka buforów, <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> właściwość nie ma wartości null.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> Parametr nie może mieć wartości null i <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> nie może mieć wartości null.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> Jest nasłuchiwania lub operacji gniazdo zostało już w toku przy użyciu <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiekt określony w <paramref name="e" /> parametru.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP lub nowszy jest wymagany dla tej metody. Ten wyjątek ma miejsce, gdy lokalny punkt końcowy i <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> nie są w tej samej rodziny adresów.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań ma uprawnienie dla żądanej operacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Net.Sockets.Socket" /> jest połączony z hostem zdalnym, począwszy od ostatniego <see cref="Overload:System.Net.Sockets.Socket.Send" /> lub <see cref="Overload:System.Net.Sockets.Socket.Receive" /> operacji.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.Socket" /> zostało podłączone do zdalnego zasobu, począwszy od najbardziej aktualną operacji; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Connected` Właściwości pobiera stan połączenia <xref:System.Net.Sockets.Socket> od ostatniej operacji We/Wy. Gdy zwraca `false`, <xref:System.Net.Sockets.Socket> nigdy nie był połączony lub nie jest już połączony.  
  
 Wartość <xref:System.Net.Sockets.Socket.Connected%2A> właściwość odzwierciedla stan połączenia od ostatnią czynność. Należy określić bieżący stan połączenia, aby wysyłaj nieblokujących, zero bajtów, wywołanie. Wywołanie zwraca pomyślnie lub zgłasza wyjątek, kod błędu WAEWOULDBLOCK (10035), następnie jest nadal połączony gniazda; w przeciwnym razie gniazda nie jest już połączony.  
  
 Jeśli wywołasz <xref:System.Net.Sockets.Socket.Connect%2A> na gniazdo protokołu UDP (User Datagram) <xref:System.Net.Sockets.Socket.Connected%2A> właściwość zawsze zwraca `true`; Jednakże, ta akcja nie powoduje zmiany nieprzerwaną pracę bez połączenia charakter UDP.  
  
   
  
## Examples  
 Poniższy kod łączy do zdalnego punktu końcowego kontroli <xref:System.Net.Sockets.Socket.Connected%2A> właściwości i sprawdza, czy bieżący stan połączenia.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <see langword="true" /> Jeśli tego gniazda mogą zostać ponownie użyte po zamknięciu bieżącego połączenia; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zamyka połączenie gniazda i umożliwia ponowne użycie gniazda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz protokołu ukierunkowane na połączenia można użyć tej metody zamknąć gniazda. Kończy się tej metody połączenia i zestawy <xref:System.Net.Sockets.Socket.Connected%2A> właściwość `false`. Jednak jeśli `reuseSocket` jest `true`, można ponownie użyć gniazda.  
  
 Aby upewnić się, że wszystkie dane wysyłany i odbierany przed zamknięciem gniazda, należy wywołać <xref:System.Net.Sockets.Socket.Shutdown%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.Disconnect%2A> metody.  
  
 Jeśli chcesz wywołać <xref:System.Net.Sockets.Socket.Disconnect%2A> bez wywoływania pierwszy <xref:System.Net.Sockets.Socket.Shutdown%2A>, można ustawić <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> opcję `false` i określ interwał limitu czasu wartość różną od zera, aby upewnić się, że dane w kolejce wychodzącej transmisji jest wysyłany. <xref:System.Net.Sockets.Socket.Disconnect%2A> następnie blokuje, dopóki dane są przesyłane lub do momentu wygaśnięcia ważności określony limit czasu. Jeśli ustawisz <xref:System.Net.Sockets.SocketOptionName.DontLinger> do `false` i określ zero interwał limitu czasu, <xref:System.Net.Sockets.Socket.Close%2A> zwalnia połączenie, a następnie automatycznie odrzuca umieszczonych w kolejce dane wychodzące.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy gniazdo dla Komunikacja synchroniczna i wysyła dane do hosta zdalnego. Następnie wywołuje <xref:System.Net.Sockets.Socket.Shutdown%2A>, aby zatrzymać wysyłania i odbierania działania i <xref:System.Net.Sockets.Socket.Disconnect%2A>, aby zamknąć połączenia gniazda.  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Ta metoda wymaga Windows 2000 lub starszym, lub zostanie zgłoszony wyjątek.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Obiekt ma być używany dla tej operacji asynchronicznych gniazda.</param>
        <summary>Rozpoczyna się żądania asynchronicznego, aby rozłączyć zdalnego punktu końcowego.</summary>
        <returns>Zwraca <see langword="true" /> przypadku oczekujących operacji We/Wy. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie na <paramref name="e" /> parametr zostanie wygenerowany po zakończeniu operacji.  
  
Zwraca <see langword="false" /> Jeśli operacji We/Wy została zakończona synchronicznie. W tym przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie na <paramref name="e" /> parametr nie zostanie wygenerowany i <paramref name="e" /> przekazano obiekt jako parametr może zbadać, natychmiast po zakończeniu wywołania metody które zwraca wynik operacji pobierania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystając z nawiązaniem połączenia protokołu podczas wywoływania <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> metoda żąda rozłączenie ze zdalnego punktu końcowego. Jeśli ustawisz <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> do `true` w `e` parametru gniazda mogą być ponownie używane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> Parametr nie może mieć wartości null.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja gniazda była już w toku przy użyciu <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiekt określony w <paramref name="e" /> parametru.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP lub nowszy jest wymagany dla tej metody.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Net.Sockets.Socket" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Net.Sockets.Socket" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj `Dispose` po zakończeniu przy użyciu <xref:System.Net.Sockets.Socket>. `Dispose` Pozostawia metoda <xref:System.Net.Sockets.Socket> w stanie uniemożliwiającym jego używanie. Po wywołaniu `Dispose`, trzeba zwolnić wszystkie odwołania do <xref:System.Net.Sockets.Socket> , moduł zbierający elementy bezużyteczne mógł odzyskać pamięć, <xref:System.Net.Sockets.Socket> zajmowaną przez wystąpienie.  
  
 Aby uzyskać więcej informacji, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) i [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Zawsze wywołuj `Dispose` przed publikacją swoje ostatnie odwołanie do <xref:System.Net.Sockets.Socket>. W przeciwnym razie zasobów jest przy użyciu nie zostanie zwolniona, dopóki moduł odśmiecania pamięci wywołuje <xref:System.Net.Sockets.Socket> obiektu `Finalize` metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do wersji tylko niezarządzane zasoby.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Net.Sockets.Socket" />i opcjonalnie usuwa zarządzane zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez publiczną `Dispose()` metody i <xref:System.Object.Finalize%2A> metody. `Dispose()` wywołuje chronioną metodę `Dispose(Boolean)` metody z `disposing` parametr `true`. <xref:System.Object.Finalize%2A> wywołuje `Dispose` z `disposing` równa `false`.  
  
 Gdy `disposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane że <xref:System.Net.Sockets.Socket> odwołania. Ta metoda wywołuje `Dispose()` metoda każdego obiektu, do którego istnieje odwołanie.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> może być wywoływana wiele razy przez inne obiekty. Podczas zastępowania <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, nie należy odwoływać się do obiektów, które zostały wcześniej zlikwidowane wcześniejszym wywołaniem do <see langword="Dispose" />. Aby uzyskać więcej informacji o sposobie wdrażania <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, zobacz [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Aby uzyskać więcej informacji na temat <see langword="Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) i [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określająca, czy <see cref="T:System.Net.Sockets.Socket" /> umożliwia datagramów protokołu internetowego (IP) do fragmentacji.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.Socket" /> umożliwia fragmentacji datagram; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Datagramy wymaga fragmentacji, gdy ich rozmiar przekracza maksymalny transferu jednostki (MTU) nośnika transmisji. Datagramy może fragmentacji przez hosta wysyłającego (wszystkie wersje Internet Protocol) lub router pośredni (tylko Internet Protocol wersja 4). Jeśli datagram musi fragmentacji i <xref:System.Net.Sockets.Socket.DontFragment%2A> opcja jest ustawiona, datagram jest odrzucana i komunikat o błędzie kontroli komunikat ICMP (Internet Protocol) są wysyłane do nadawcy datagram.  
  
 Ustawienie tej właściwości na gniazdo Transmission Control Protocol (TCP) odniesie żadnego skutku.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.DontFragment%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Tę właściwość można ustawić tylko dla gniazda w <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> rodziny.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określająca, czy <see cref="T:System.Net.Sockets.Socket" /> jest podwójnych gniazd używany dla IPv4 i IPv6.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.Socket" /> jest podwójnych gniazd; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">Identyfikator procesu docelowego, w którym zostanie utworzone zduplikowane odwołania do gniazda.</param>
        <summary>Duplikuje odwołanie gniazda do procesu docelowego i zamyka gniazda dla tego procesu.</summary>
        <returns>Odwołanie gniazda do przekazania do procesu docelowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Proces docelowy należy użyć <xref:System.Net.Sockets.Socket.%23ctor%2A> można utworzyć wystąpienia duplikat gniazda.  
  
 Jeśli wywołasz <xref:System.Net.Sockets.Socket.%23ctor%2A> konstruktora wiele razy przy użyciu tej samej tablicy bajtów jako argument dla każdego wywołania spowoduje utworzenie wielu zarządzanych <xref:System.Net.Sockets.Socket> wystąpień przy użyciu tego samego podstawowego gniazda. Tej praktyką jest zdecydowanie odradzane.  
  
 Jeśli proces tworzenia gniazda używa metod asynchronicznych (<xref:System.Net.Sockets.Socket.BeginReceive%2A> lub <xref:System.Net.Sockets.Socket.BeginSend%2A>), najpierw należy skonfigurować proces <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> właściwości wartość PRAWDA; w przeciwnym razie gniazda jest powiązany do portu ukończenia procesu tworzenia, który może spowodować, że <xref:System.ArgumentNullException> zostanie wygenerowany w procesie docelowym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="targetProcessID" /> nie jest prawidłową procesu o identyfikatorze. 
—lub— 
Duplikowanie odwołania gniazda nie powiodło się.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określająca, czy <see cref="T:System.Net.Sockets.Socket" /> można wysyłania lub odbierania pakietów emisji.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.Socket" /> umożliwia pakietów emisji; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Emisja jest ograniczona do określonej podsieci i użyć User Datagram Protocol (UDP). Dla protokołu internetowego w wersji 4 można emitować do podsieci lokalnej, wysyłając pakiet do 255.255.255.255; Możesz też adres ukierunkowanej emisji, czyli części sieci adres protokołu internetowego (IP) z wszystkie bity w części hosta. Na przykład, jeśli Twój adres IP jest 192.168.1.40 (adresu klasy C z maską sieci 255.255.255.0 — część sieci to pierwsze trzy oktety i fragment hosta jest ostatni oktet), adres ukierunkowanej emisji jest 192.168.1.255.  
  
 Ustawienie tej właściwości na gniazdo Transmission Control Protocol (TCP) odniesie żadnego skutku.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ta opcja jest prawidłowa dla gniazda datagramu, który jest tylko.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asynchronicznie akceptuje przychodzące próby połączenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający bajtów przesłanych.</param>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Danych zdefiniowane przez obiekt, który przechowuje informacje o stanie dla tej operacji asynchronicznej, a także dowolnego użytkownika.</param>
        <summary>Asynchronicznie akceptuje przychodzące próby połączenia i tworzy nową <see cref="T:System.Net.Sockets.Socket" /> obiektu do obsługi komunikacji z hostem zdalnym. Ta metoda zwraca buforu, który zawiera początkowej transferu danych.</summary>
        <returns>Element <see cref="T:System.Net.Sockets.Socket" /> obiektu do obsługi komunikacji z hostem zdalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> kończy wywołanie <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginAccept%2A>, musisz utworzyć metodę wywołania zwrotnego, które jest wywoływane przez <xref:System.AsyncCallback> delegować. Ta metoda wywołania zwrotnego jest wykonywany w oddzielnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginAccept%2A> metoda zwraca.  
  
 W ramach metody wywołania zwrotnego, należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody `asyncResult` parametru, aby uzyskać <xref:System.Net.Sockets.Socket> na której próba połączenia jest wykonywane. Po uzyskaniu <xref:System.Net.Sockets.Socket>, można wywołać <xref:System.Net.Sockets.Socket.EndAccept%2A> metodę, aby pomyślnie ukończyć próbę połączenia. `buffer` Parametr tego przeciążenia zawiera dane, które zostało odebrane w wywołaniu <xref:System.Net.Sockets.Socket.BeginAccept%2A> i `bytesTransferred` parametr zawiera liczbę bajtów, które zostały przeniesione w wywołaniu.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Metoda blokuje do momentu połączenia jest w stanie oczekiwania w kolejce połączeń przychodzących. <xref:System.Net.Sockets.Socket.EndAccept%2A> Metoda akceptuje połączenia przychodzącego i zwraca nowy <xref:System.Net.Sockets.Socket> który może służyć do wysyłania i odbierania danych z hosta zdalnego.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.Sockets.Socket.BeginAccept%2A> do tworzenia i połączenia gniazda i zaakceptuj początkowej 10 bajtów danych. Wywołanie zwrotne delegowanie wywołań <xref:System.Net.Sockets.Socket.EndAccept%2A> zakończenia żądania asynchronicznego. Liczba bajtów przesłanych i dane są zwracane w `buffer` i `bytesTransferred` parametrów tej metody i są wyświetlane w konsoli.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows NT jest wymagana dla tej metody.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest pusty.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie został utworzony przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> wcześniej wywołano metodę.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do <see cref="T:System.Net.Sockets.Socket" /></exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Który przechowuje informacje o stanie dla tej operacji asynchronicznej, a także wszystkie dane zdefiniowane przez użytkownika.</param>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Który przechowuje informacje o stanie dla tej operacji asynchronicznej, a także wszystkie dane zdefiniowane przez użytkownika.</param>
        <summary>Asynchronicznie akceptuje przychodzące próby połączenia i tworzy nową <see cref="T:System.Net.Sockets.Socket" /> do obsługi komunikacji z hostem zdalnym.</summary>
        <returns>A <see cref="T:System.Net.Sockets.Socket" /> do obsługi komunikacji z hostem zdalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> kończy wywołanie <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginAccept%2A>, musisz utworzyć metody wywołania zwrotnego, która implementuje <xref:System.AsyncCallback> delegować. Ta metoda wywołania zwrotnego jest wykonywany w oddzielnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginAccept%2A> metoda zwraca. Musi on zaakceptować `asyncResult` parametru zwróciło <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody.  
  
 W ramach metody wywołania zwrotnego, należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody `asyncResult` parametru, aby uzyskać <xref:System.Net.Sockets.Socket> na której próba połączenia jest wykonywane. Po uzyskaniu <xref:System.Net.Sockets.Socket>, można wywołać <xref:System.Net.Sockets.Socket.EndAccept%2A> metodę, aby pomyślnie ukończyć próbę połączenia.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Metoda blokuje do momentu połączenia jest w stanie oczekiwania w kolejce połączeń przychodzących. <xref:System.Net.Sockets.Socket.EndAccept%2A> Metoda akceptuje połączenia przychodzącego i zwraca nowy <xref:System.Net.Sockets.Socket> który może służyć do wysyłania i odbierania danych z hosta zdalnego.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu kończy żądanie asynchroniczne i tworzy nową <xref:System.Net.Sockets.Socket> do akceptowania żądań połączenia przychodzących. Aby uzyskać kompletny przykład, który demonstruje komunikacji asynchronicznej przy użyciu gniazd, zobacz [przykłady kodu gniazd](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie został utworzony przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz sekcję Spostrzeżenia, aby uzyskać więcej informacji.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> wcześniej wywołano metodę.</exception>
        <exception cref="T:System.NotSupportedException">Windows NT jest wymagana dla tej metody.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  *  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" />
        <Parameter Name="bytesTransferred" Type="System.Int32" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający bajtów przesłanych.</param>
        <param name="bytesTransferred">Liczba bajtów przesłanych.</param>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Danych zdefiniowane przez obiekt, który przechowuje informacje o stanie dla tej operacji asynchronicznej, a także dowolnego użytkownika.</param>
        <summary>Asynchronicznie akceptuje przychodzące próby połączenia i tworzy nową <see cref="T:System.Net.Sockets.Socket" /> obiektu do obsługi komunikacji z hostem zdalnym. Ta metoda zwraca buforu, który zawiera dane pierwotne oraz liczbę bajtów przesłanych.</summary>
        <returns>Element <see cref="T:System.Net.Sockets.Socket" /> obiektu do obsługi komunikacji z hostem zdalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> kończy wywołanie <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginAccept%2A>, musisz utworzyć metodę wywołania zwrotnego, które jest wywoływane przez <xref:System.AsyncCallback> delegować. Ta metoda wywołania zwrotnego jest wykonywany w oddzielnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginAccept%2A> metoda zwraca. Musi on zaakceptować `asyncResult` parametru zwróciło <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody.  
  
 W ramach metody wywołania zwrotnego, należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody `asyncResult` parametru, aby uzyskać <xref:System.Net.Sockets.Socket> na której próba połączenia jest wykonywane. Po uzyskaniu <xref:System.Net.Sockets.Socket>, można wywołać <xref:System.Net.Sockets.Socket.EndAccept%2A> metodę, aby pomyślnie ukończyć próbę połączenia. `buffer` Parametr tego przeciążenia zawiera dane, które zostało odebrane w wywołaniu <xref:System.Net.Sockets.Socket.BeginAccept%2A> i `bytesTransferred` parametr zawiera liczbę bajtów, które zostały przeniesione w wywołaniu.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Metoda blokuje do momentu połączenia jest w stanie oczekiwania w kolejce połączeń przychodzących. <xref:System.Net.Sockets.Socket.EndAccept%2A> Metoda akceptuje połączenia przychodzącego i zwraca nowy <xref:System.Net.Sockets.Socket> który może służyć do wysyłania i odbierania danych z hosta zdalnego.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.Sockets.Socket.BeginAccept%2A> do tworzenia i połączenia gniazda i zaakceptuj początkowej 10 bajtów danych. Wywołanie zwrotne delegowanie wywołań <xref:System.Net.Sockets.Socket.EndAccept%2A> zakończenia żądania asynchronicznego. Liczba bajtów przesłanych i dane są zwracane w `buffer` i `bytesTransferred` parametrów tej metody i są wyświetlane w konsoli.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows NT jest wymagana dla tej metody.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest pusty.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie został utworzony przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> wcześniej wywołano metodę.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Który przechowuje informacje o stanie i wszelkich danych zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</param>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Który przechowuje informacje o stanie i wszelkich danych zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</param>
        <summary>Kończy się żądania oczekujące połączenia asynchronicznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A> blokowanie metodę, która kończy żądanie połączenia asynchronicznego hosta zdalnego jest uruchamiany w <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginConnect%2A>, musisz utworzyć metody wywołania zwrotnego, która implementuje <xref:System.AsyncCallback> delegować. Ta metoda wywołania zwrotnego jest wykonywany w oddzielnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginConnect%2A> zwraca. Metoda wywołania zwrotnego musi zaakceptować <xref:System.IAsyncResult> zwrócone przez <xref:System.Net.Sockets.Socket.BeginConnect%2A> metoda jako parametr.  
  
 W ramach metody wywołania zwrotnego, należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody <xref:System.IAsyncResult> parametru, aby uzyskać <xref:System.Net.Sockets.Socket> na której próba połączenia jest wykonywane. Po uzyskaniu <xref:System.Net.Sockets.Socket>, można wywołać <xref:System.Net.Sockets.Socket.EndConnect%2A> metodę, aby pomyślnie ukończyć próbę połączenia.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu kończy się próba połączenia asynchronicznego. Aby uzyskać kompletny przykład, który demonstruje komunikacji asynchronicznej przy użyciu gniazd, zobacz [przykłady kodu gniazd](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie została zwrócona przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> był wcześniej nazywany programem dla połączenia asynchronicznego.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Obiekt, który przechowuje informacje o stanie i wszelkich danych zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</param>
        <summary>Kończy żądanie oczekiwanie asynchroniczne rozłączenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> kończy wywołanie <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>. <xref:System.Net.Sockets.Socket.EndDisconnect%2A> Metoda blokuje do momentu ukończenia Rozłącz. Aby uzyskać informacje o operacji asynchronicznych zobacz temat Asynchronous Programming Overview w bibliotece MSDN.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy gniazdo dla komunikacji asynchronicznej i wysyła dane do hosta zdalnego. Po wysłaniu danych <xref:System.Net.Sockets.Socket.Shutdown%2A> jest wywoływana w celu zatrzymania wysyłania i odbierania działania. Następnie <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> jest wywoływana, aby rozpocząć żądanie rozłączenia. Wywołanie zwrotne delegowanie wywołań <xref:System.Net.Sockets.Socket.EndDisconnect%2A> zakończenia żądania asynchronicznego. Po ukończeniu żądania <xref:System.Net.Sockets.Socket.Connected%2A> właściwość jest wysyłane zapytanie, aby sprawdzić, czy gniazdo jest odłączony.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">System operacyjny to Windows 2000 lub starszym. Ponadto ta metoda wymaga Windows XP.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie została zwrócona przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> był wcześniej nazywany programem dla połączenia asynchronicznego.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.Net.WebException">Upłynął limit czasu żądania rozłączenia.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kończy się oczekujące odczyt asynchroniczny.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Który przechowuje informacje o stanie i wszelkich danych zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</param>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Który przechowuje informacje o stanie i wszelkich danych zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</param>
        <summary>Kończy się oczekujące odczyt asynchroniczny.</summary>
        <returns>Liczba bajtów odebranych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> Metoda kończy pracę w operację odczytu asynchronicznego <xref:System.Net.Sockets.Socket.BeginReceive%2A> metody.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginReceive%2A>, musisz utworzyć metody wywołania zwrotnego, która implementuje <xref:System.AsyncCallback> delegować. Ta metoda wywołania zwrotnego jest wykonywany w oddzielnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginReceive%2A> zwraca. Metoda wywołania zwrotnego musi zaakceptować <xref:System.IAsyncResult> zwrócone przez <xref:System.Net.Sockets.Socket.BeginReceive%2A> metoda jako parametr.  
  
 W ramach metody wywołania zwrotnego, należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody <xref:System.IAsyncResult> można uzyskać stanu obiektu przekazanego do <xref:System.Net.Sockets.Socket.BeginReceive%2A> metody. Wyodrębnij odbieranie <xref:System.Net.Sockets.Socket> z tego obiektu stanu. Po uzyskaniu <xref:System.Net.Sockets.Socket>, można wywołać <xref:System.Net.Sockets.Socket.EndReceive%2A> metodę, aby pomyślnie wykonać operacji odczytu i zwracają liczbę odczytanych bajtów.  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> Metoda spowoduje zablokowanie, dopóki dane są dostępne. Jeśli używasz protokołu przesyłanie, <xref:System.Net.Sockets.Socket.EndReceive%2A> odczyta pierwszy dostępny w buforze przychodzącego sieci datagram umieszczonych w kolejce. Jeśli używasz protokołu nawiązaniem połączenia, <xref:System.Net.Sockets.Socket.EndReceive%2A> metoda odczyta tak dużej ilości danych, jest dostępny maksymalnie liczbę bajtów określoną w `size` parametru <xref:System.Net.Sockets.Socket.BeginReceive%2A> metody. Jeśli host zdalny zamknięcie <xref:System.Net.Sockets.Socket> połączenie z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano metody i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.EndReceive%2A> metoda będzie od razu zakończyć i powrócić zero bajtów.  
  
 Aby uzyskać odebrane dane, należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody <xref:System.IAsyncResult>i Wyodrębnij buforu zawartych w obiekcie wynikowym stanu.  
  
 Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceive%2A>, wywołaj <xref:System.Net.Sockets.Socket.Close%2A> metody.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Wszystkie operacje We/Wy inicjowane przez dany wątku anulowany, gdy wątek która umożliwia zamknięcie. Istnieje oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek kończy działanie przed ukończeniem operacji.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu zakończenia oczekujących odczyt asynchroniczny. Aby uzyskać kompletny przykład, który demonstruje komunikacji asynchronicznej przy użyciu gniazd, zobacz [przykłady kodu gniazd](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie została zwrócona przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> był wcześniej nazywany programem do asynchronicznego odczytu.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult *  -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Który przechowuje informacje o stanie i wszelkich danych zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> obiekt, który przechowuje błąd gniazda.</param>
        <summary>Kończy się oczekujące odczyt asynchroniczny.</summary>
        <returns>Liczba bajtów odebranych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> Metoda kończy pracę w operację odczytu asynchronicznego <xref:System.Net.Sockets.Socket.BeginReceive%2A> metody.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginReceive%2A>, musisz utworzyć metody wywołania zwrotnego, która implementuje <xref:System.AsyncCallback> delegować. Ta metoda wywołania zwrotnego jest wykonywany w oddzielnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginReceive%2A> zwraca. Metoda wywołania zwrotnego musi zaakceptować <xref:System.IAsyncResult> zwrócone przez <xref:System.Net.Sockets.Socket.BeginReceive%2A> metoda jako parametr.  
  
 W ramach metody wywołania zwrotnego, należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody <xref:System.IAsyncResult> można uzyskać stanu obiektu przekazanego do <xref:System.Net.Sockets.Socket.BeginReceive%2A> metody. Wyodrębnij odbieranie <xref:System.Net.Sockets.Socket> z tego obiektu stanu. Po uzyskaniu <xref:System.Net.Sockets.Socket>, można wywołać <xref:System.Net.Sockets.Socket.EndReceive%2A> metodę, aby pomyślnie wykonać operacji odczytu i zwracają liczbę odczytanych bajtów.  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> Metoda spowoduje zablokowanie, dopóki dane są dostępne. Jeśli używasz protokołu przesyłanie, <xref:System.Net.Sockets.Socket.EndReceive%2A> odczyta pierwszy dostępny w buforze przychodzącego sieci datagram umieszczonych w kolejce. Jeśli używasz protokołu nawiązaniem połączenia, <xref:System.Net.Sockets.Socket.EndReceive%2A> metoda odczyta tak dużej ilości danych, jest dostępny maksymalnie liczbę bajtów określoną w `size` parametru <xref:System.Net.Sockets.Socket.BeginReceive%2A> metody. Jeśli host zdalny zamknięcie <xref:System.Net.Sockets.Socket> połączenie z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano metody i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.EndReceive%2A> metoda będzie od razu zakończyć i powrócić zero bajtów.  
  
 Aby uzyskać odebrane dane, należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody <xref:System.IAsyncResult>i Wyodrębnij buforu zawartych w obiekcie wynikowym stanu.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Wszystkie operacje We/Wy inicjowane przez dany wątku anulowany, gdy wątek która umożliwia zamknięcie. Istnieje oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek kończy działanie przed ukończeniem operacji.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie została zwrócona przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> był wcześniej nazywany programem do asynchronicznego odczytu.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult *  -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Który przechowuje informacje o stanie i wszelkich danych zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</param>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Który przechowuje informacje o stanie i wszelkich danych zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</param>
        <param name="endPoint">Źródło <see cref="T:System.Net.EndPoint" />.</param>
        <param name="end_point">Źródło <see cref="T:System.Net.EndPoint" />.</param>
        <summary>Kończy się oczekujące asynchroniczny odczyt z określonego punktu końcowego.</summary>
        <returns>Jeśli to się powiedzie, liczba bajtów odebranych. W przypadku niepowodzenia zwraca wartość 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Metoda kończy pracę w operację odczytu asynchronicznego <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, musisz utworzyć metody wywołania zwrotnego, która implementuje <xref:System.AsyncCallback> delegować. Ta metoda wywołania zwrotnego jest wykonywany w oddzielnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> zwraca. Metoda wywołania zwrotnego musi zaakceptować <xref:System.IAsyncResult> zwrócone przez <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metoda jako parametr.  
  
 W ramach metody wywołania zwrotnego, należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody <xref:System.IAsyncResult> można uzyskać stanu obiektu przekazanego do <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody. Wyodrębnij odbieranie <xref:System.Net.Sockets.Socket> z tego obiektu stanu. Po uzyskaniu <xref:System.Net.Sockets.Socket>, można wywołać <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> metodę, aby pomyślnie wykonać operacji odczytu i zwracają liczbę odczytanych bajtów.  
  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Metoda spowoduje zablokowanie, dopóki dane są dostępne. Jeśli używasz protokołu przesyłanie, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> odczyta pierwszy dostępny w buforze przychodzącego sieci datagram umieszczonych w kolejce. Jeśli używasz protokołu nawiązaniem połączenia, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> metoda odczyta tak dużej ilości danych, jest dostępny maksymalnie liczbę bajtów określoną w `size` parametru <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody. Jeśli host zdalny zamknięcie <xref:System.Net.Sockets.Socket> połączenie z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano metody i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> metoda będzie od razu zakończyć i powrócić zero bajtów. Aby uzyskać odebrane dane, należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody <xref:System.IAsyncResult> obiektu i Wyodrębnij buforu zawartych w obiekcie wynikowym stanu. W przypadku identyfikowania hosta źródłowego, Wyodrębnij <xref:System.Net.EndPoint> i obsadź ją <xref:System.Net.IPEndPoint>. Użyj <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> metodę, aby uzyskać adres IP i <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> metodę, aby uzyskać numer portu.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu kończy oczekujące asynchroniczny odczyt z konkretną <xref:System.Net.EndPoint>.  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie została zwrócona przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> był wcześniej nazywany programem do asynchronicznego odczytu.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult *  *  *  -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Który przechowuje informacje o stanie i wszelkich danych zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości odebranego pakietu.</param>
        <param name="endPoint">Źródło <see cref="T:System.Net.EndPoint" />.</param>
        <param name="ipPacketInformation">
          <see cref="T:System.Net.IPAddress" /> i interfejs odebranego pakietu.</param>
        <summary>Kończy się oczekujące asynchroniczny odczyt z określonego punktu końcowego. Ta metoda również wskazuje więcej informacji na temat pakietów niż <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</summary>
        <returns>Jeśli to się powiedzie, liczba bajtów odebranych. W przypadku niepowodzenia zwraca wartość 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli operacja nie została ukończona, ta metoda blokuje, dopóki nie robi.  
  
 Aby wykonać tę operację synchronicznie, należy użyć <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metody.  
  
 Sprawdź `ipPacketInformation` Jeśli musisz wiedzieć, czy datagram została przesłana przy użyciu emisji pojedynczej, adres multiemisji lub emisji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />  
  
—lub— 
 <paramref name="endPoint" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie została zwrócona przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> był wcześniej nazywany programem do asynchronicznego odczytu.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kończy się oczekujące asynchronicznego wysyłania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Który przechowuje informacje o stanie dla tej operacji asynchronicznej.</param>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Który przechowuje informacje o stanie dla tej operacji asynchronicznej.</param>
        <summary>Kończy się oczekujące asynchronicznego wysyłania.</summary>
        <returns>Jeśli operacja się powiedzie, liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />; w przeciwnym razie nieprawidłową <see cref="T:System.Net.Sockets.Socket" /> błędu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> wykonuje operację asynchronicznego wysyłania pracę w <xref:System.Net.Sockets.Socket.BeginSend%2A>.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSend%2A>, musisz utworzyć metody wywołania zwrotnego, która implementuje <xref:System.AsyncCallback> delegować. Ta metoda wywołania zwrotnego jest wykonywany w oddzielnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginSend%2A> zwraca. Metoda wywołania zwrotnego musi zaakceptować <xref:System.IAsyncResult> zwrócone przez <xref:System.Net.Sockets.Socket.BeginSend%2A> metoda jako parametr.  
  
 W ramach metody wywołania zwrotnego, należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody <xref:System.IAsyncResult> parametru, aby uzyskać wysyłanie <xref:System.Net.Sockets.Socket>. Po uzyskaniu <xref:System.Net.Sockets.Socket>, można wywołać <xref:System.Net.Sockets.Socket.EndSend%2A> metodę, aby pomyślnie ukończyć operacji wysyłania i zwraca liczbę bajtów przesłanych.  
  
 Jeśli używasz protokołu przesyłanie, <xref:System.Net.Sockets.Socket.EndSend%2A> zablokuje do momentu wysłania jest datagram. Jeśli używasz protokołu połączeniowy, <xref:System.Net.Sockets.Socket.EndSend%2A> spowoduje zablokowanie aż niektóre buforu został wysłany. Jeśli wartość zwracana z <xref:System.Net.Sockets.Socket.EndSend%2A> wskazuje, że bufor nie jest całkowicie wysyłane, wywołaj <xref:System.Net.Sockets.Socket.BeginSend%2A> ponownie, metodą, modyfikując bufor do przechowywania danych niewysłanych.  
  
 Nie ma żadnej gwarancji, które dane, które wysyłasz pojawi się w sieci natychmiast. Aby zwiększyć wydajność sieci, podstawowy system może opóźnienie transmisji, dopóki nie znaczną ilość danych wychodzących są zbierane. Pomyślne wykonanie <xref:System.Net.Sockets.Socket.BeginSend%2A> metody oznacza, że zasadniczego systemu miał miejsce do buforu wysyłania danych do sieci.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Wszystkie operacje We/Wy inicjowane przez dany wątku anulowany, gdy wątek która umożliwia zamknięcie. Istnieje oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek kończy działanie przed ukończeniem operacji.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie oznacza, że danych zostało pomyślnie dostarczone. Jeśli ilość miejsca w buforze jest dostępna w ramach systemu transportu do przechowywania danych, które mają być przekazywane, Wyślij zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu kończy się oczekujące asynchronicznego wysyłania.  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie została zwrócona przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> był wcześniej nazywany programem dla asynchronicznego wysyłania.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult *  -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Który przechowuje informacje o stanie dla tej operacji asynchronicznej.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> obiekt, który przechowuje błąd gniazda.</param>
        <summary>Kończy się oczekujące asynchronicznego wysyłania.</summary>
        <returns>Jeśli operacja się powiedzie, liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />; w przeciwnym razie nieprawidłową <see cref="T:System.Net.Sockets.Socket" /> błędu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> wykonuje operację asynchronicznego wysyłania pracę w <xref:System.Net.Sockets.Socket.BeginSend%2A>.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSend%2A>, musisz utworzyć metody wywołania zwrotnego, która implementuje <xref:System.AsyncCallback> delegować. Ta metoda wywołania zwrotnego jest wykonywany w oddzielnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginSend%2A> zwraca. Metoda wywołania zwrotnego musi zaakceptować <xref:System.IAsyncResult> zwrócone przez <xref:System.Net.Sockets.Socket.BeginSend%2A> metoda jako parametr.  
  
 W ramach metody wywołania zwrotnego, należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody <xref:System.IAsyncResult> parametru, aby uzyskać wysyłanie <xref:System.Net.Sockets.Socket>. Po uzyskaniu <xref:System.Net.Sockets.Socket>, można wywołać <xref:System.Net.Sockets.Socket.EndSend%2A> metodę, aby pomyślnie ukończyć operacji wysyłania i zwraca liczbę bajtów przesłanych.  
  
 Jeśli używasz protokołu przesyłanie, <xref:System.Net.Sockets.Socket.EndSend%2A> zablokuje do momentu wysłania jest datagram. Jeśli używasz protokołu połączeniowy, <xref:System.Net.Sockets.Socket.EndSend%2A> spowoduje zablokowanie aż niektóre buforu został wysłany. Jeśli wartość zwracana z <xref:System.Net.Sockets.Socket.EndSend%2A> wskazuje, że bufor nie jest całkowicie wysyłane, wywołaj <xref:System.Net.Sockets.Socket.BeginSend%2A> ponownie, metodą, modyfikując bufor do przechowywania danych niewysłanych.  
  
 Nie ma żadnej gwarancji, które dane, które wysyłasz pojawi się w sieci natychmiast. Aby zwiększyć wydajność sieci, podstawowy system może opóźnienie transmisji, dopóki nie znaczną ilość danych wychodzących są zbierane. Pomyślne wykonanie <xref:System.Net.Sockets.Socket.BeginSend%2A> metody oznacza, że zasadniczego systemu miał miejsce do buforu wysyłania danych do sieci.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Wszystkie operacje We/Wy inicjowane przez dany wątku anulowany, gdy wątek która umożliwia zamknięcie. Istnieje oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek kończy działanie przed ukończeniem operacji.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie oznacza, że danych zostało pomyślnie dostarczone. Jeśli ilość miejsca w buforze jest dostępna w ramach systemu transportu do przechowywania danych, które mają być przekazywane, Wyślij zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie została zwrócona przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> był wcześniej nazywany programem dla asynchronicznego wysyłania.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Obiekt, który przechowuje informacje o stanie dla tej operacji asynchronicznej.</param>
        <summary>Kończy się oczekujące asynchronicznego wysyłania pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A> wykonuje operację asynchronicznego wysyłania pracę w <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, należy utworzyć metody wywołania zwrotnego, która implementuje <xref:System.AsyncCallback> delegować. Ta metoda wywołania zwrotnego jest wykonywany w oddzielnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginSendFile%2A> zwraca. Metoda wywołania zwrotnego musi zaakceptować <xref:System.IAsyncResult> obiektu zwróconego przez <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metoda jako parametr.  
  
 W ramach metody wywołania zwrotnego, należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody <xref:System.IAsyncResult> parametru, aby uzyskać wysyłanie <xref:System.Net.Sockets.Socket>. Po uzyskaniu <xref:System.Net.Sockets.Socket>, można wywołać <xref:System.Net.Sockets.Socket.EndSendFile%2A> metodę, aby pomyślnie ukończyć operacji wysyłania.  
  
 Jeśli używasz protokołu przesyłanie, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blokuje, aż datagram są wysyłane. Jeśli używasz protokołu połączeniowy, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blokuje, dopóki nie jest wysyłany cały plik. Nie ma żadnej gwarancji, które dane, które wysyłasz pojawi się w sieci natychmiast. Aby zwiększyć wydajność sieci, podstawowy system może opóźnienie transmisji, dopóki nie znaczną ilość danych wychodzących są zbierane. Pomyślne wykonanie <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metody oznacza, że zasadniczego systemu miał miejsce do buforu wysyłania danych do sieci.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy i łączy gniazda dla komunikacji asynchronicznej i zaczynają wysyłać plik "text.txt" asynchronicznie do hosta zdalnego. Wywołanie zwrotne delegowanie wywołań <xref:System.Net.Sockets.Socket.EndSendFile%2A> można ukończyć przenoszenia.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows NT jest wymagana dla tej metody.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest pusty.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie została zwrócona przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> był wcześniej nazywany programem dla asynchroniczną <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz sekcję uwagi poniżej.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Który przechowuje informacje o stanie i wszelkich danych zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</param>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> Który przechowuje informacje o stanie i wszelkich danych zdefiniowane przez użytkownika dla tej operacji asynchronicznej.</param>
        <summary>Kończy się oczekujące asynchronicznego wysyłania do określonej lokalizacji.</summary>
        <returns>Jeśli operacja się powiedzie, liczba bajtów wysłanych; w przeciwnym razie nieprawidłową <see cref="T:System.Net.Sockets.Socket" /> błędu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A> wykonuje operację asynchronicznego wysyłania pracę w <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, musisz utworzyć metody wywołania zwrotnego, która implementuje <xref:System.AsyncCallback> delegować. Ta metoda wywołania zwrotnego jest wykonywany w oddzielnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginReceive%2A> zwraca. Metoda wywołania zwrotnego musi zaakceptować <xref:System.IAsyncResult> zwrócone przez <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metoda jako parametr.  
  
 W ramach metody wywołania zwrotnego, należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody <xref:System.IAsyncResult> parametru, aby uzyskać wysyłanie <xref:System.Net.Sockets.Socket>. Po uzyskaniu <xref:System.Net.Sockets.Socket>, można wywołać <xref:System.Net.Sockets.Socket.EndSendTo%2A> metodę, aby pomyślnie ukończyć operacji wysyłania i zwraca liczbę bajtów przesłanych.  
  
 Jeśli używasz protokołu przesyłanie, <xref:System.Net.Sockets.Socket.EndSendTo%2A> zablokuje do momentu wysłania jest datagram. Jeśli używasz protokołu połączeniowy, <xref:System.Net.Sockets.Socket.EndSendTo%2A> blokuje, dopóki wysłaniem żądanej liczby bajtów. Nie ma żadnej gwarancji, które dane, które wysyłasz pojawi się w sieci natychmiast. Aby zwiększyć wydajność sieci, podstawowy system może opóźnienie transmisji, dopóki nie znaczną ilość danych wychodzących są zbierane. Pomyślne wykonanie <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metody oznacza, że zasadniczego systemu miał miejsce do buforu wysyłania danych do sieci.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu kończy się asynchronicznego wysyłania do określonej lokalizacji.  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie została zwrócona przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> był wcześniej nazywany programem dla asynchronicznego wysyłania.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określająca, czy <see cref="T:System.Net.Sockets.Socket" /> zezwala na tylko jeden proces do powiązania z portem.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.Socket" /> zezwala na tylko jeden gniazda, aby powiązać z określonego portu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" /> dla systemu Windows Server 2003 i Windows XP Service Pack 2 i <see langword="false" /> dla wszystkich innych wersji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> jest `false`, można użyć wielu sockets <xref:System.Net.Sockets.Socket.Bind%2A> metodę, aby powiązać z określonego portu; jednak tylko jeden z gniazdami mogą wykonywać operacje na ruch sieciowy, wysyłane do portu. Jeśli więcej niż jedno gniazdo podejmują próbę użycia <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> metodę można powiązać konkretnego portu, a następnie jeden z precyzyjniejszymi adres IP będzie obsługiwać ruch sieciowy, wysyłane do tego portu.  
  
 Jeśli <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> jest `true`, pierwsze użycie <xref:System.Net.Sockets.Socket.Bind%2A> metodę, aby podejmować próbę powiązania konkretnego portu, niezależnie od tego, adres protokołu internetowego (IP), zakończy się powodzeniem; wszystkie kolejne korzysta z <xref:System.Net.Sockets.Socket.Bind%2A> będzie metodę, aby podejmować próbę powiązania do tego portu niepowodzeniem do chwili oryginalnego gniazda powiązanej jest niszczona.  
  
 Ta właściwość musi być ustawiona przed <xref:System.Net.Sockets.Socket.Bind%2A> jest wywołany; w przeciwnym razie <xref:System.InvalidOperationException> zostanie zgłoszony.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> została wywołana dla tego <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.Net.Sockets.Socket" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> Klasy wywołuje finalizator <xref:System.Net.Sockets.Socket.Close%2A> metodę, aby zamknąć <xref:System.Net.Sockets.Socket> i bezpłatne zasoby skojarzone z <xref:System.Net.Sockets.Socket>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość <see cref="T:System.Net.Sockets.Socket" /> opcji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Jedną z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</param>
        <param name="optionName">Jedną z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</param>
        <summary>Zwraca wartość określonego <see cref="T:System.Net.Sockets.Socket" /> opcji reprezentowany przez obiekt.</summary>
        <returns>Obiekt, który reprezentuje wartość opcji. Gdy <paramref name="optionName" /> parametr ma wartość <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> wartość zwracana jest wystąpieniem <see cref="T:System.Net.Sockets.LingerOption" /> klasy. Gdy <paramref name="optionName" /> ustawiono <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> lub <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, wartość zwracana jest wystąpieniem <see cref="T:System.Net.Sockets.MulticastOption" /> klasy. Gdy <paramref name="optionName" /> ma jakąkolwiek inną wartość, wartość zwracana jest liczba całkowita.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> opcje określają zachowanie bieżącego <xref:System.Net.Sockets.Socket>. Użyj tego przeciążenia, aby pobrać <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, i <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> opcje. Aby uzyskać <xref:System.Net.Sockets.SocketOptionName.Linger> opcji, należy użyć <xref:System.Net.Sockets.Socket> dla `optionLevel` parametru. Aby uzyskać <xref:System.Net.Sockets.SocketOptionName.AddMembership> i <xref:System.Net.Sockets.SocketOptionName.DropMembership>, użyj <xref:System.Net.Sockets.SocketOptionLevel.IP>. Jeśli chcesz ustawić wartości opcji wymienionych powyżej, użyj <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy kod pobiera przykład <xref:System.Net.Sockets.LingerOption> i <xref:System.Net.Sockets.Socket.Send%2A> wartości limitu czasu i wyświetla je w konsoli.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.  
  
—lub— 
 <paramref name="optionName" /> Nieobsługiwana wartość ustawiono <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Jedną z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</param>
        <param name="optionName">Jedną z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</param>
        <param name="optionValue">Tablica typu <see cref="T:System.Byte" /> to do odbierania ustawienia opcji.</param>
        <summary>Zwraca określony <see cref="T:System.Net.Sockets.Socket" /> opcję Ustawienia, w postaci tablicy bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> opcje określają zachowanie bieżącego <xref:System.Net.Sockets.Socket>. Po pomyślnym zakończeniu tej metody tablicy określony przez `optionValue` parametr zawiera wartość określonego <xref:System.Net.Sockets.Socket> opcji.  
  
 Gdy długość `optionValue` tablica jest mniejszy niż liczba bajtów potrzebnych do przechowania wartość określonego <xref:System.Net.Sockets.Socket> opcji <xref:System.Net.Sockets.Socket.GetSocketOption%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu. Użyj tego przeciążenia dla dowolnego gniazd, które są reprezentowane przez wartości logicznych lub liczby całkowite.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy kod pobiera przykład <xref:System.Net.Sockets.LingerOption> i <xref:System.Net.Sockets.Socket.Send%2A> wartości limitu czasu i wyświetla je w konsoli.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.  
  
\- lub — 
W aplikacjach platformy .NET Compact Framework miejsca w buforze domyślne Windows CE jest równa 32768 bajtów. Możesz zmienić na gniazdo miejsca w buforze, wywołując <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Jedną z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</param>
        <param name="optionName">Jedną z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</param>
        <param name="optionLength">Długość, w bajtach, oczekiwana wartość zwracaną.</param>
        <summary>Zwraca wartość określonego <see cref="T:System.Net.Sockets.Socket" /> opcji w tablicy.</summary>
        <returns>Tablica typu <see cref="T:System.Byte" /> zawierający wartość opcji gniazda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `optionLength` Parametr ustawia maksymalny rozmiar tablicy bajtów zwrócona. Jeśli wartość opcji wymaga mniejszej liczby bajtów, tablica będzie zawierać tylko liczby bajtów. Jeśli wartość opcji wymaga większej liczby bajtów, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Użyj tego przeciążenia dla dowolnego gniazd, które są reprezentowane przez wartości logicznych lub liczby całkowite.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy kod pobiera przykład <xref:System.Net.Sockets.LingerOption> i <xref:System.Net.Sockets.Socket.Send%2A> wartości limitu czasu i wyświetla je w konsoli.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.  
  
\- lub — 
W aplikacjach platformy .NET Compact Framework miejsca w buforze domyślne Windows CE jest równa 32768 bajtów. Możesz zmienić na gniazdo miejsca w buforze, wywołując <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwyt systemu operacyjnego dla <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>
          <see cref="T:System.IntPtr" /> Reprezentujący dojście systemu operacyjnego dla <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia niskiego poziomu tryby działania <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">
          <see cref="T:System.Int32" /> Wartość, która określa kod sterujący operacji do wykonania.</param>
        <param name="optionInValue">A <see cref="T:System.Byte" /> tablicę, która zawiera dane wejściowe wymagane przez operację.</param>
        <param name="optionOutValue">A <see cref="T:System.Byte" /> tablicę, która zawiera dane wyjściowe zwracane przez operację.</param>
        <summary>Ustawia niskiego poziomu tryby działania <see cref="T:System.Net.Sockets.Socket" /> przy użyciu kodów liczbowe formantu.</summary>
        <returns>Liczba bajtów w <paramref name="optionOutValue" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.IOControl%2A> Metoda zapewnia niskiego poziomu dostępu do systemu operacyjnego <xref:System.Net.Sockets.Socket> bieżące wystąpienie klasy bazowe <xref:System.Net.Sockets.Socket> klasy. Aby uzyskać więcej informacji zobacz dokumentację Operacja WSAIoctl w bibliotece MSDN.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu porównuje wyniki FIONREAD i dostępne właściwości.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.InvalidOperationException">Próbowano zmienić tryb blokowania bez użycia <see cref="P:System.Net.Sockets.Socket.Blocking" /> właściwości.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący na stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do wykonywania kodu niezarządzanego. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">A <see cref="T:System.Net.Sockets.IOControlCode" /> wartość, która określa kod sterujący operacji do wykonania.</param>
        <param name="optionInValue">Tablica typu <see cref="T:System.Byte" /> zawierający dane wejściowe wymagane przez operację.</param>
        <param name="optionOutValue">Tablica typu <see cref="T:System.Byte" /> zawierający dane wyjściowe zwracane przez operację.</param>
        <summary>Ustawia niskiego poziomu tryby działania <see cref="T:System.Net.Sockets.Socket" /> przy użyciu <see cref="T:System.Net.Sockets.IOControlCode" /> wyliczenia kody sterujące.</summary>
        <returns>Liczba bajtów w <paramref name="optionOutValue" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zapewnia niskiego poziomu dostępu do systemu operacyjnego <xref:System.Net.Sockets.Socket> bieżące wystąpienie klasy bazowe <xref:System.Net.Sockets.Socket> klasy. Aby uzyskać więcej informacji zobacz dokumentację Operacja WSAIoctl w bibliotece MSDN.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu porównuje wyniki wywołania <xref:System.Net.Sockets.Socket.IOControl%2A> z <xref:System.Net.Sockets.IOControlCode.DataToRead> i <xref:System.Net.Sockets.Socket.Available%2A> właściwości.  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.InvalidOperationException">Próbowano zmienić tryb blokowania bez użycia <see cref="P:System.Net.Sockets.Socket.Blocking" /> właściwości.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do wykonywania kodu niezarządzanego. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Net.Sockets.Socket" /> jest powiązana z określonego portu lokalnego.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.Socket" /> jest powiązana z portu lokalnego; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gniazdo jest uważany za granicę do lokalnego portu, gdy jawnie jest powiązana przez wywołanie metody <xref:System.Net.Sockets.Socket.Bind%2A> metody i niejawnie powiązane, wywołując elementy, takie jak <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, lub <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, używających efemerycznego (wolny port większy niż port lokalny 1024, wybrana przez system operacyjny.) Serwery używają <xref:System.Net.Sockets.Socket.Bind%2A> metodę, aby powiązać dobrze znanym porcie, dzięki czemu klienci mogą połączyć się z nimi.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.IsBound%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy <see cref="T:System.Net.Sockets.Socket" /> zostanie opóźnione zamykanie gniazda w celu Wyślij wszystkie dane oczekujące.</summary>
        <value>Element <see cref="T:System.Net.Sockets.LingerOption" /> , który określa sposób linger podczas zamykania gniazda.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LingerState%2A> Właściwość zmienia sposób <xref:System.Net.Sockets.Socket.Close%2A> zachowanie metody. Tej właściwości, gdy zestaw modyfikuje warunki, na jakich połączenia można zresetować za Winsock. Resetuje połączenie może nadal występują w oparciu o zachowanie protokołu IP.  
  
 Ta właściwość określa długość czasu, przez jaki połączenie zorientowany na połączenie pozostanie otwarte po wywołaniu <xref:System.Net.Sockets.Socket.Close%2A> kiedy dane pozostają do wysłania.  
  
 Po wywołaniu metody służące do wysyłania danych do elementu równorzędnego tych danych jest umieszczany w wychodzących buforu sieci. Ta właściwość może służyć do zapewnienia, że te dane są wysyłane do hosta zdalnego przed <xref:System.Net.Sockets.TcpClient.Close%2A> metoda spada połączenia.  
  
 Aby włączyć lingering, Utwórz <xref:System.Net.Sockets.LingerOption> wystąpienia, zawierających odpowiednie wartości, a następnie ustaw <xref:System.Net.Sockets.Socket.LingerState%2A> właściwości dla tego wystąpienia.  
  
 W poniższej tabeli opisano zachowanie <xref:System.Net.Sockets.Socket.Close%2A> metodę dopuszczalne <xref:System.Net.Sockets.LingerOption.Enabled%2A> właściwości i <xref:System.Net.Sockets.LingerOption.LingerTime%2A> właściwości przechowywane w <xref:System.Net.Sockets.Socket.LingerState%2A> właściwości.  
  
|LingerState.Enabled|LingerState.LingerTime|Zachowanie|  
|-------------------------|----------------------------|--------------|  
|`false` (wyłączone), wartość domyślna|Nie jest to konieczne, limit czasu (domyślnie).|Próbuje wysłać oczekujących danych do momentu wygaśnięcia ważności domyślny limit czasu protokołu IP.|  
|`true` (włączone)|Wartość różną od zera limitu czasu|Próbuje wysłać oczekujących danych, aż określony limit czasu upłynie, a jeśli próba nie powiedzie się, następnie Winsock resetuje połączenie.|  
|`true` (włączone)|Zero przekroczenie limitu czasu.|Odrzuca wszystkie oczekujące dane. Dla ukierunkowane na połączenia gniazda (na przykład TCP) usługi Winsock resetuje połączenie.|  
  
 Stos IP oblicza domyślny okres limitu czasu protokołu IP do użycia na podstawie czasu komunikacji dwustronnej połączenia. W większości przypadków przekroczenia limitu czasu, obliczana przez stos jest większe znaczenie niż jeden zdefiniowany przez aplikację. Jest to domyślne zachowanie dla gniazda podczas <xref:System.Net.Sockets.Socket.LingerState%2A> nie ustawiono właściwości.  
  
 Gdy <xref:System.Net.Sockets.LingerOption.LingerTime%2A> właściwości przechowywane w <xref:System.Net.Sockets.Socket.LingerState%2A> właściwość ma wartość większą niż domyślny limit czasu protokołu IP, nadal zastosuje i przesłonić domyślny limit czasu protokołu IP.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.LingerState%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">Maksymalna długość kolejki oczekiwania połączenia.</param>
        <summary>Umieszcza <see cref="T:System.Net.Sockets.Socket" /> w stanie nasłuchiwania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A> powoduje, że połączeniowy <xref:System.Net.Sockets.Socket> nasłuchiwanie przychodzących prób nawiązania połączenia. `backlog` Parametr określa liczbę połączeń przychodzących, które można umieścić w kolejce do przyjęcia. Aby określić maksymalną liczbę połączeń, które można określić, należy pobrać <xref:System.Net.Sockets.SocketOptionName.MaxConnections> wartość. <xref:System.Net.Sockets.Socket.Listen%2A> nie są blokowane.  
  
 Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu. Użyj <xref:System.Net.Sockets.Socket.Accept%2A> lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> do akceptowania połączeń z kolejki.  
  
> [!NOTE]
>  Należy wywołać <xref:System.Net.Sockets.Socket.Bind%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.Listen%2A>, lub <xref:System.Net.Sockets.Socket.Listen%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Parametr zaległości jest ograniczona do różnych wartości w zależności od systemu operacyjnego. Można określić wyższej wartości, ale zaległości będą ograniczone na podstawie systemu operacyjnego.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.Sockets.Socket> do nasłuchiwania przychodzących połączeń.  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lokalny punkt końcowy.</summary>
        <value>
          <see cref="T:System.Net.EndPoint" /> , <see cref="T:System.Net.Sockets.Socket" /> Używa do komunikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Pobiera właściwość <xref:System.Net.EndPoint> zawierający IP adres i port numer lokalny do którego Twoja <xref:System.Net.Sockets.Socket> jest powiązany. Należy to rzutować <xref:System.Net.EndPoint> do <xref:System.Net.IPEndPoint> przed pobraniem jakichkolwiek informacji. Następnie możesz wywołać <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> metody do pobierania lokalnego <xref:System.Net.IPAddress>i <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> metodę, która pobierze numer portu lokalnego.  
  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Właściwość jest zwykle ustawiana po wprowadzeniu wywołanie <xref:System.Net.Sockets.Socket.Bind%2A> metody. Jeśli zezwolisz programowi system można przypisać z gniazda lokalny adres IP oraz numer portu <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwość zostanie ustawiona po wykonaniu pierwszej operacji We/Wy. Połączeniowy protokołów, w pierwszej operacji We/Wy będzie wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metody. Przesyłanie protokołów pierwszej operacji We/Wy może sytuować wysyłania lub odbieranie połączeń.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i wyświetla punkty końcowe lokalnych i zdalnych.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy wychodzących pakietów multiemisji są dostarczane do aplikacji wysyłającej.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.Socket" /> odbiera wychodzących pakietów multiemisji; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multiemisja to metoda skalowalne komunikacji wiele do wielu w Internecie. Proces subskrybuje adresu multiemisji; następnie pakiety wysyłane przez proces subskrybowanego są odbierane przez każdy inny proces subskrybuje adres multiemisji.  
  
 Ustawienie tej właściwości na gniazdo Transmission Control Protocol (TCP) odniesie żadnego skutku.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określająca, czy strumień <see cref="T:System.Net.Sockets.Socket" /> używa algorytmu Nagle'a.</summary>
        <value>
          <see langword="false" /> Jeśli <see cref="T:System.Net.Sockets.Socket" /> używa algorytmu Nagle'a; w przeciwnym razie <see langword="true" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algorytm Nagle'a zaprojektowano w celu zmniejszenie ruchu w sieci, powodując gniazda, aby buforować małe pakiety, a następnie połączyć i wysłać je w jednym pakiecie w pewnych okolicznościach. Pakiet TCP składa się z 40 bajtów nagłówka oraz wysyłanych danych. Gdy małe pakiety danych są wysyłane przy użyciu protokołu TCP, obciążenie wynikające z nagłówka TCP może stać się znaczna część ruchu sieciowego. W sieciach obciążonych przeciążenia wynikające z to obciążenie może powodować utraty datagramów oraz liczba retransmisji, a także czas propagacji nadmierne spowodowane przez przeciążenie. Algorytm Nagle'a powstrzymuje wysyłanie nowej segmentswhen TCP nowe dane wychodzące nadejściu od użytkownika, jeśli wszystkie dane previouslytransmitted połączenia pozostaje niepotwierdzonych.  
  
 Większość aplikacji sieciowych należy używać algorytm Nagle'a.  
  
 Ustawienie tej właściwości na gniazdo protokołu UDP (User Datagram) odniesie żadnego skutku.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.NoDelay%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy system operacyjny i karty sieciowe obsługują protokołu internetowego w wersji 4 (IPv4).</summary>
        <value>
          <see langword="true" /> Jeśli system operacyjny i karty sieciowe obsługują protokół IPv4; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 System operacyjny może obsługiwać protokoły IPv4 i IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy system operacyjny i karty sieciowe obsługują protokołu internetowego w wersji 6 (IPv6).</summary>
        <value>
          <see langword="true" /> Jeśli system operacyjny i karty sieciowe obsługują protokół IPv6; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 System operacyjny może obsługiwać protokoły IPv4 i IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" />
      </Parameters>
      <Docs>
        <param name="microSeconds">Czas oczekiwania na odpowiedź w mikrosekundach.</param>
        <param name="mode">Jedną z <see cref="T:System.Net.Sockets.SelectMode" /> wartości.</param>
        <summary>Określa stan <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Stan <see cref="T:System.Net.Sockets.Socket" /> na podstawie wartości tryb sondowania przekazanej <paramref name="mode" /> parametru.  
  
 <list type="table"><listheader><term> Tryb 
 </term><description> Wartość zwracana 
 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><see langword="true" /> Jeśli <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> została wywołana i oczekuje połączenia; 
—lub— 
 <see langword="true" /> Jeśli dane są dostępne do odczytu; 
—lub— 
 <see langword="true" /> Jeśli połączenie zostało zamknięte, resetowania lub przerwane; 
W przeciwnym razie zwraca <see langword="false" />.  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><see langword="true" />, jeśli przetwarzanie <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, i połączenia zakończyła się pomyślnie; 
—lub— 
 <see langword="true" /> Jeśli dane mogą być wysyłane; 
W przeciwnym razie zwraca <see langword="false" />.  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description><see langword="true" /> Jeśli przetwarzanie <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> , nie są blokowane, a połączenie nie powiodło się; 
—lub— 
 <see langword="true" /> Jeśli <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> nie jest zestawem i out-of-band dane są dostępne; 
W przeciwnym razie zwraca <see langword="false" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Poll%2A> Metoda będzie sprawdzać stan <xref:System.Net.Sockets.Socket>. Określ <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> dla `selectMode` parametru do określenia, czy <xref:System.Net.Sockets.Socket> jest czytelna. Określ <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> do określenia, czy <xref:System.Net.Sockets.Socket> jest zapisywalna. Użyj <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> wykryć warunek błędu. <xref:System.Net.Sockets.Socket.Poll%2A> Spowoduje to zablokowanie wykonywanie aż do określonego czasu, mierzony w `microseconds`, upływa. Ustaw `microSeconds` parametr ujemną liczbę całkowitą, jeśli chcesz czekać w nieskończoność na odpowiedź. Jeśli chcesz sprawdzić stan wielu gniazda, warto użyć <xref:System.Net.Sockets.Socket.Select%2A> metody.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ta metoda nie może wykryć niektórych rodzajów problemy z połączeniem, takie jak kabel sieciowy przerwane lub host zdalny został zamknięty, ungracefully. Należy próbować wysyłać ani odbierać dane, aby wykryć te rodzaje błędów.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy gniazdo nawiązuje połączenie z serwerem i używa <xref:System.Net.Sockets.Socket.Poll%2A> można sprawdzić stanu gniazda.  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="mode" /> Parametr nie jest jednym z <see cref="T:System.Net.Sockets.SelectMode" /> wartości.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ protokołu <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Jedną z <see cref="T:System.Net.Sockets.ProtocolType" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ProtocolType%2A> Właściwość jest ustawiona, gdy <xref:System.Net.Sockets.Socket> jest tworzony i określa protokół używany przez to <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, i <xref:System.Net.Sockets.ProtocolType> do konsoli.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odbiera dane z granicę <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizacja magazynu dla odebranych danych.</param>
        <summary>Odbiera dane z granicę <see cref="T:System.Net.Sockets.Socket" /> do buforu odbierania.</summary>
        <returns>Liczba bajtów odebranych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczytuje dane w parametrze buforu i zwraca liczbę bajtów odczytanych pomyślnie. Możesz wywołać <xref:System.Net.Sockets.Socket.Receive%2A> z nawiązaniem połączenia i bez połączenia gniazda.  
  
 To przeciążenie tylko wymaga podania bufor odbioru. Wartość domyślna to 0, rozmiary domyślne długość parametru buforu przesunięcia buforu i <xref:System.Net.Sockets.SocketFlags> wartością domyślną jest wartość <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Jeśli używasz protokołu z nawiązaniem połączenia, należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> do ustanowienia połączenia z hostem zdalnym lub <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenia przychodzące, przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczyta tylko danych, przychodzący z hostem zdalnym z tym <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli używasz protokołu bez połączenia można również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Umożliwia odbieranie danych przychodzących od dowolnego hosta.  
  
 Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> metoda spowoduje zablokowanie, dopóki dane są dostępne, chyba że wartość limitu czasu została ustawiona za pomocą <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Receive%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w w buforze stosu protokołu <xref:System.Net.Sockets.Socket.Receive%2A> metoda będzie od razu zakończyć i zgłosić <xref:System.Net.Sockets.SocketException>. Możesz użyć <xref:System.Net.Sockets.Socket.Available%2A> właściwości w celu określenia, czy data jest dostępna do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, ponów próbę wykonania operacji odbierania.  
  
 Jeśli używasz połączeniowy <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> metoda odczyta tak dużej ilości danych, jest dostępna, maksymalnie rozmiar buforu. Jeśli host zdalny zamknięcie <xref:System.Net.Sockets.Socket> połączenie z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano metody i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.Receive%2A> metoda będzie od razu zakończyć i powrócić zero bajtów.  
  
 Jeśli używasz przesyłanie <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> odczyta pierwszy datagram umieszczonych w kolejce z docelowego adresu określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metody. Jeśli datagram otrzymasz jest większy niż rozmiar `buffer` parametru `buffer` pobiera wypełnione z pierwszej części komunikatu nadmiarowe dane zostaną utracone i <xref:System.Net.Sockets.SocketException> zgłaszany.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu odbiera dane na połączonej <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący na stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z siecią. Powiązane wyliczenie: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">Lista <see cref="T:System.ArraySegment`1" />s typu <see cref="T:System.Byte" /> zawierający odebranych danych.</param>
        <summary>Odbiera dane z granicę <see cref="T:System.Net.Sockets.Socket" /> do listy buforów odbioru.</summary>
        <returns>Liczba bajtów odebranych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje dane w parametrze buforów i zwraca liczbę bajtów odczytanych pomyślnie. Możesz wywołać z nawiązaniem połączenia i bez połączenia gniazda.  
  
 To przeciążenie, musisz podać jedną lub więcej buforów odbioru.  
  
 Jeśli używasz protokołu z nawiązaniem połączenia, należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> do ustanowienia połączenia z hostem zdalnym lub <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenia przychodzące, przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczyta tylko danych, przychodzący z połączenia zdalnego hosta w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli używasz protokołu bez połączenia można również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Umożliwia odbieranie danych przychodzących od dowolnego hosta.  
  
 Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> metoda spowoduje zablokowanie, dopóki dane są dostępne, chyba że wartość limitu czasu została ustawiona za pomocą <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Receive%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w w buforze stosu protokołu <xref:System.Net.Sockets.Socket.Receive%2A> metoda będzie od razu zakończyć i zgłosić <xref:System.Net.Sockets.SocketException>. Możesz użyć <xref:System.Net.Sockets.Socket.Available%2A> właściwości w celu określenia, czy data jest dostępna do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, ponów próbę wykonania operacji odbierania.  
  
 Jeśli używasz połączeniowy <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> metoda odczyta tak dużej ilości danych, jest dostępna, maksymalnie rozmiar buforu. Jeśli host zdalny zamknięcie <xref:System.Net.Sockets.Socket> połączenie z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano metody i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.Receive%2A> metoda będzie od razu zakończyć i powrócić zero bajtów.  
  
 Jeśli używasz przesyłanie <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> odczyta pierwszy datagram umieszczonych w kolejce z docelowego adresu określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metody. Jeśli datagram otrzymasz jest większy niż rozmiar `buffers` parametru `buffers` pobiera wypełnione z pierwszej części komunikatu nadmiarowe dane zostaną utracone i <xref:System.Net.Sockets.SocketException> zgłaszany.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
 **Uwaga** ten element członkowski generuje informacje ze śledzenia, po włączeniu funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby dostęp do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizacja magazynu dla odebranych danych.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <summary>Odbiera dane z granicę <see cref="T:System.Net.Sockets.Socket" /> do buforu odbierania, przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba bajtów odebranych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczytuje dane w parametrze buforu i zwraca liczbę bajtów odczytanych pomyślnie. Możesz wywołać <xref:System.Net.Sockets.Socket.Receive%2A> z nawiązaniem połączenia i bez połączenia gniazda.  
  
 To przeciążenie tylko wymaga podania buforów odbioru i niezbędne <xref:System.Net.Sockets.SocketFlags>. Suma przesunięcia buforu wartość domyślna to 0, a rozmiar wartość domyślna to długość parametru bajtów.  
  
 Jeśli używasz protokołu z nawiązaniem połączenia, należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> do ustanowienia połączenia z hostem zdalnym lub <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenia przychodzące, przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczyta tylko danych, przychodzący z hostem zdalnym z tym <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli używasz protokołu bez połączenia można również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Umożliwia odbieranie danych przychodzących od dowolnego hosta.  
  
 Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> metoda spowoduje zablokowanie, dopóki dane są dostępne. Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w buforze stosu protokołu <xref:System.Net.Sockets.Socket.Receive%2A> metoda będzie od razu zakończyć i zgłosić <xref:System.Net.Sockets.SocketException>. Możesz użyć <xref:System.Net.Sockets.Socket.Available%2A> właściwości w celu określenia, czy data jest dostępna do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie z operacji odbioru.  
  
 Jeśli używasz połączeniowy <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> metoda odczyta tak dużej ilości danych jest dostępna do rozmiaru buforu. Jeśli host zdalny zamknięcie <xref:System.Net.Sockets.Socket> połączenie z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano metody i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.Receive%2A> metoda będzie od razu zakończyć i powrócić zero bajtów.  
  
 Jeśli używasz przesyłanie <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> odczyta pierwszy datagram umieszczonych w kolejce z docelowego adresu określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metody. Jeśli datagram otrzymasz jest większy niż rozmiar `buffer` parametru `buffer` pobiera wypełnione z pierwszej części komunikatu nadmiarowe dane zostaną utracone i <xref:System.Net.Sockets.SocketException> zgłaszany.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu określa bufor danych i <xref:System.Net.Sockets.SocketFlags> do odbierania danych na połączonych <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący na stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z siecią. Powiązane wyliczenie: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">Lista <see cref="T:System.ArraySegment`1" />s typu <see cref="T:System.Byte" /> zawierający odebranych danych.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <summary>Odbiera dane z granicę <see cref="T:System.Net.Sockets.Socket" /> do listy buforów odbioru przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba bajtów odebranych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje dane `buffers` parametr i zwraca liczbę bajtów odczytanych pomyślnie. Możesz wywołać z nawiązaniem połączenia i bez połączenia gniazda.  
  
 To przeciążenie, musisz podać jedną lub więcej buforów odbioru. <xref:System.Net.Sockets.SocketFlags> Wartością domyślną jest wartość <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Jeśli używasz protokołu z nawiązaniem połączenia, należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> do ustanowienia połączenia z hostem zdalnym lub <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenia przychodzące, przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczyta tylko danych, przychodzący z połączenia zdalnego hosta w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli używasz protokołu bez połączenia można również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Umożliwia odbieranie danych przychodzących od dowolnego hosta.  
  
 Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> metoda spowoduje zablokowanie, dopóki dane są dostępne, chyba że wartość limitu czasu została ustawiona za pomocą <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Receive%2A> wywołać zgłasza <xref:System.Net.Sockets.SocketException>. Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w w buforze stosu protokołu <xref:System.Net.Sockets.Socket.Receive%2A> metoda będzie od razu zakończyć i zgłosić <xref:System.Net.Sockets.SocketException>. Możesz użyć <xref:System.Net.Sockets.Socket.Available%2A> właściwości w celu określenia, czy data jest dostępna do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, ponów próbę wykonania operacji odbierania.  
  
 Jeśli używasz połączeniowy <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> metoda odczyta tak dużej ilości danych, jest dostępna, maksymalnie rozmiar buforu. Jeśli host zdalny zamknięcie <xref:System.Net.Sockets.Socket> połączenie z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano metody i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.Receive%2A> metoda będzie od razu zakończyć i powrócić zero bajtów.  
  
 Jeśli używasz przesyłanie <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> odczyta pierwszy datagram umieszczonych w kolejce z docelowego adresu określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metody. Jeśli datagram otrzymasz jest większy niż rozmiar `buffers` parametru `buffers` pobiera wypełnione z pierwszej części komunikatu nadmiarowe dane zostaną utracone i <xref:System.Net.Sockets.SocketException> zgłaszany.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak odbierać dane na połączonej <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="buffers" />. Liczba jest równa zero.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby dostęp do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z siecią. Powiązane wyliczenie: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizacja magazynu dla odebranych danych.</param>
        <param name="size">Liczba bajtów do odebrania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <summary>Odbiera określoną liczbę bajtów danych z granicę <see cref="T:System.Net.Sockets.Socket" /> do buforu odbierania, przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba bajtów odebranych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczytuje dane `buffer` parametr i zwraca liczbę bajtów odczytanych pomyślnie. Możesz wywołać <xref:System.Net.Sockets.Socket.Receive%2A> z nawiązaniem połączenia i bez połączenia gniazda.  
  
 To przeciążenie tylko wymaga podania bufor odbioru, liczba bajtów, które chcesz otrzymywać i niezbędne <xref:System.Net.Sockets.SocketFlags>.  
  
 Jeśli używasz protokołu z nawiązaniem połączenia, należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> do ustanowienia połączenia z hostem zdalnym lub <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenia przychodzące, przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczyta tylko danych, przychodzący z hostem zdalnym z tym <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli używasz protokołu bez połączenia można również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Umożliwia odbieranie danych przychodzących od dowolnego hosta.  
  
 Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> metoda spowoduje zablokowanie, dopóki dane są dostępne, chyba że wartość limitu czasu została ustawiona za pomocą <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Receive%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w w buforze stosu protokołu <xref:System.Net.Sockets.Socket.Receive%2A> metoda będzie od razu zakończyć i zgłosić <xref:System.Net.Sockets.SocketException>. Możesz użyć <xref:System.Net.Sockets.Socket.Available%2A> właściwości w celu określenia, czy data jest dostępna do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie z operacji odbioru.  
  
 Jeśli używasz połączeniowy <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> metoda odczyta tak dużej ilości danych, jest dostępna — maksymalnie liczbę bajtów określoną przez `size` parametru. Jeśli host zdalny zamknięcie <xref:System.Net.Sockets.Socket> połączenie z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano metody i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.Receive%2A> metoda będzie od razu zakończyć i powrócić zero bajtów.  
  
 Jeśli używasz przesyłanie <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> odczyta pierwszy datagram umieszczonych w kolejce z docelowego adresu określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metody. Jeśli datagram otrzymasz jest większy niż rozmiar `buffer` parametru `buffer` pobiera wypełnione z pierwszej części komunikatu nadmiarowe dane zostaną utracone i <xref:System.Net.Sockets.SocketException> zgłaszany.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Następujące odbiera dane znalezione do `buffer`i określa <xref:System.Net.Sockets.SocketFlags.None> dla <xref:System.Net.Sockets.SocketFlags>.  
  
 [!code-cpp[Socket_Send_Recieve#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Recieve#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#4)]
 [!code-vb[Socket_Send_Recieve#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> przekracza rozmiar okna <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący na stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z siecią. Powiązane wyliczenie: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">Lista <see cref="T:System.ArraySegment`1" />s typu <see cref="T:System.Byte" /> zawierający odebranych danych.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> obiekt, który przechowuje błąd gniazda.</param>
        <summary>Odbiera dane z granicę <see cref="T:System.Net.Sockets.Socket" /> do listy buforów odbioru przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba bajtów odebranych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje dane `buffers` parametr i zwraca liczbę bajtów odczytanych pomyślnie. Możesz wywołać z nawiązaniem połączenia i bez połączenia gniazda.  
  
 To przeciążenie, musisz podać jedną lub więcej buforów odbioru. <xref:System.Net.Sockets.SocketFlags> Wartością domyślną jest wartość <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Jeśli używasz protokołu z nawiązaniem połączenia, należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> do ustanowienia połączenia z hostem zdalnym lub <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenia przychodzące, przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczyta tylko danych, przychodzący z połączenia zdalnego hosta w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli używasz protokołu bez połączenia można również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Umożliwia odbieranie danych przychodzących od dowolnego hosta.  
  
 Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> metoda spowoduje zablokowanie, dopóki dane są dostępne, chyba że wartość limitu czasu została ustawiona za pomocą <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Receive%2A> wywołać zgłasza <xref:System.Net.Sockets.SocketException>. Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w w buforze stosu protokołu <xref:System.Net.Sockets.Socket.Receive%2A> metoda będzie od razu zakończyć i zgłosić <xref:System.Net.Sockets.SocketException>. Możesz użyć <xref:System.Net.Sockets.Socket.Available%2A> właściwości w celu określenia, czy data jest dostępna do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, ponów próbę wykonania operacji odbierania.  
  
 Jeśli używasz połączeniowy <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> metoda odczyta tak dużej ilości danych, jest dostępna, maksymalnie rozmiar buforu. Jeśli host zdalny zamknięcie <xref:System.Net.Sockets.Socket> połączenie z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano metody i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.Receive%2A> metoda będzie od razu zakończyć i powrócić zero bajtów.  
  
 Jeśli używasz przesyłanie <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> odczyta pierwszy datagram umieszczonych w kolejce z docelowego adresu określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metody. Jeśli datagram otrzymasz jest większy niż rozmiar `buffers` parametru `buffers` pobiera wypełnione z pierwszej części komunikatu nadmiarowe dane zostaną utracone i <xref:System.Net.Sockets.SocketException> zgłaszany.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="buffers" />. Liczba jest równa zero.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby dostęp do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z siecią. Powiązane wyliczenie: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizacja magazynu dla odebranych danych.</param>
        <param name="offset">Lokalizacja w <c>buforu</c> do przechowywania odebranych danych.</param>
        <param name="size">Liczba bajtów do odebrania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <summary>Odbiera określoną liczbę bajtów z granicę <see cref="T:System.Net.Sockets.Socket" /> w określonym położeniu przesunięcia buforu odbioru przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba bajtów odebranych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczytuje dane w parametrze buforu i zwraca liczbę bajtów odczytanych pomyślnie. Możesz wywołać <xref:System.Net.Sockets.Socket.Receive%2A> z nawiązaniem połączenia i bez połączenia gniazda.  
  
 Jeśli używasz protokołu z nawiązaniem połączenia, należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> do ustanowienia połączenia z hostem zdalnym lub <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenia przychodzące, przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczyta tylko danych, przychodzący z hostem zdalnym z tym <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli używasz protokołu bez połączenia można również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Umożliwia odbieranie danych przychodzących od dowolnego hosta.  
  
 Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> metoda spowoduje zablokowanie, dopóki dane są dostępne, chyba że wartość limitu czasu została ustawiona za pomocą <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Receive%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w w buforze stosu protokołu <xref:System.Net.Sockets.Socket.Receive%2A> metoda będzie od razu zakończyć i zgłosić <xref:System.Net.Sockets.SocketException>. Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej. Możesz użyć <xref:System.Net.Sockets.Socket.Available%2A> właściwości w celu określenia, czy data jest dostępna do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, ponów próbę wykonania operacji odbierania.  
  
 Jeśli używasz połączeniowy <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> metoda odczyta tak dużej ilości danych, jest dostępna — maksymalnie liczbę bajtów określoną przez parametr rozmiaru. Jeśli host zdalny zamknięcie <xref:System.Net.Sockets.Socket> połączenie z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano metody i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.Receive%2A> metoda będzie od razu zakończyć i powrócić zero bajtów.  
  
 Jeśli używasz przesyłanie <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> odczyta pierwszy datagram umieszczonych w kolejce z docelowego adresu określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metody. Jeśli datagram otrzymasz jest większy niż rozmiar `buffer` parametru `buffer` pobiera wypełnione z pierwszej części komunikatu nadmiarowe dane zostaną utracone i <xref:System.Net.Sockets.SocketException> zgłaszany.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu określa bufor danych, przesunięcie, rozmiar i Flaga Gniazdo przed rozpoczęciem odbierania danych na połączonych <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" /> jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> nie jest prawidłową kombinację wartości.  
  
—lub— 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> Nie można ustawić właściwości.  
  
—lub— 
Wystąpił błąd systemu operacyjnego wystąpi podczas uzyskiwania dostępu do <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący na stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z siecią. Powiązane wyliczenie: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizacja magazynu dla odebranych danych.</param>
        <param name="offset">Pozycja w <c>buforu</c> parametr do zapisania odebranych danych.</param>
        <param name="size">Liczba bajtów do odebrania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> obiekt, który przechowuje błąd gniazda.</param>
        <summary>Odbiera dane z granicę <see cref="T:System.Net.Sockets.Socket" /> do buforu odbierania, przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba bajtów odebranych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczytuje dane w parametrze buforu i zwraca liczbę bajtów odczytanych pomyślnie. Możesz wywołać <xref:System.Net.Sockets.Socket.Receive%2A> z nawiązaniem połączenia i bez połączenia gniazda.  
  
 Jeśli używasz protokołu z nawiązaniem połączenia, należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> do ustanowienia połączenia z hostem zdalnym lub <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenia przychodzące, przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczyta tylko danych, przychodzący z hostem zdalnym z tym <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli używasz protokołu bez połączenia można również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Umożliwia odbieranie danych przychodzących od dowolnego hosta.  
  
 Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> metoda spowoduje zablokowanie, dopóki dane są dostępne, chyba że wartość limitu czasu została ustawiona za pomocą <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Receive%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w w buforze stosu protokołu <xref:System.Net.Sockets.Socket.Receive%2A> metoda będzie od razu zakończyć i zgłosić <xref:System.Net.Sockets.SocketException>. Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej. Możesz użyć <xref:System.Net.Sockets.Socket.Available%2A> właściwości w celu określenia, czy data jest dostępna do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, ponów próbę wykonania operacji odbierania.  
  
 Jeśli używasz połączeniowy <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> metoda odczyta tak dużej ilości danych, jest dostępna — maksymalnie liczbę bajtów określoną przez parametr rozmiaru. Jeśli host zdalny zamknięcie <xref:System.Net.Sockets.Socket> połączenie z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano metody i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.Receive%2A> metoda będzie od razu zakończyć i powrócić zero bajtów.  
  
 Jeśli używasz przesyłanie <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> odczyta pierwszy datagram umieszczonych w kolejce z docelowego adresu określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metody. Jeśli datagram otrzymasz jest większy niż rozmiar `buffer` parametru `buffer` pobiera wypełnione z pierwszej części komunikatu nadmiarowe dane zostaną utracone i <xref:System.Net.Sockets.SocketException> zgłaszany.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" /> jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> nie jest prawidłową kombinację wartości.  
  
—lub— 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> Nie ustawiono właściwości.  
  
—lub— 
Wystąpił błąd systemu operacyjnego wystąpi podczas uzyskiwania dostępu do <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący na stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z siecią. Powiązane wyliczenie: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Obiekt ma być używany dla tej operacji asynchronicznych gniazda.</param>
        <summary>Rozpoczyna żądanie asynchroniczne na odbieranie danych z połączonych <see cref="T:System.Net.Sockets.Socket" /> obiektu.</summary>
        <returns>Zwraca <see langword="true" /> przypadku oczekujących operacji We/Wy. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie na <paramref name="e" /> parametr zostanie wygenerowany po zakończeniu operacji.  
  
Zwraca <see langword="false" /> Jeśli operacji We/Wy została zakończona synchronicznie. W tym przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie na <paramref name="e" /> parametr nie zostanie wygenerowany i <paramref name="e" /> przekazano obiekt jako parametr może zbadać, natychmiast po zakończeniu wywołania metody które zwraca wynik operacji pobierania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> Używana jest metoda połączony gniazda lub powiązanej bez połączenia gniazda i służy do odczytywania danych przychodzących. Adres lokalnego gniazda musi być znane.  
  
 Dla powiązanych bez połączenia gniazda ta funkcja ogranicza adresy, z których Odebrane komunikaty są akceptowane. Funkcja zwraca tylko komunikaty z adresu zdalnego przez połączenie. Komunikaty z innych adresów dyskretnie są odrzucane.  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> Właściwość `e` parametru zapewnia dostawcy usług Sockets okno z dodatkowymi informacjami dotyczącymi żądanie odczytu. Aby uzyskać więcej informacji o tym, jak używać tego parametru, zobacz <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.  
  
 Poniższe właściwości i zdarzenia <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiektu są wymagane do pomyślnego wywołania tej metody:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> lub <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Jeśli <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> ustawiono  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Jeśli <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> ustawiono  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Obiekt wywołujący może ustawiać <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość do każdego obiektu stanu użytkownika żądanego przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> metodę, tak, aby dane możliwe do pobierania w metody wywołania zwrotnego. Jeśli wywołanie zwrotne potrzebuje więcej informacji, niż jeden obiekt, mały klasy mogą być tworzone na potrzeby przechowywania inne wymagane informacje o stanie jako elementy członkowskie.  
  
 Dla gniazda stylu strumień bajtów danych przychodzących jest umieszczany w buforze, aż do zapełnienia buforu, połączenie jest zamknięte lub wyczerpania wewnętrznie buforowane dane.  
  
 Usługi przesyłania wiadomości Sockets wiadomości przychodzących jest umieszczana w buforu maksymalnie całkowity rozmiar buforu skojarzone z `e` parametru. Jeśli komunikat jest większe niż bufor, rozmiar buforu jest wypełniony pierwszej części wiadomości.  
  
 Dla połączeń gniazd <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> metoda może oznaczać łagodne przerwanie obwodu wirtualnego w jeden z dwóch sposobów, które są zależne od tego, czy gniazdo jest strumień bajtów lub zorientowany na komunikaty. W przypadku strumienie bajtów zero bajtów przeczytaną wskazuje łagodne zamknięcia i nie większą liczbę bajtów nigdy nie będzie można odczytać. Dla ukierunkowane gniazda, w której wiadomość zero bajtów często jest dozwolony, <xref:System.Net.Sockets.SocketException> z <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> zestaw natywny kod błędu Winsock WSAEDISCON (10101) jest używany do wskazania łagodne zamknięcia. W każdym przypadku <xref:System.Net.Sockets.SocketException> z <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> równa natywnych WSAECONNRESET Winsock kod błędu: (10054) wskazuje przerywające Zamknij.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Argument ten był nieprawidłowy. <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> Lub <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> właściwości <paramref name="e" /> parametru musi odwoływać się do buforów prawidłowe. Jedna z tych właściwości, może być zestaw, ale nie obu jednocześnie.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja gniazda była już w toku przy użyciu <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiekt określony w <paramref name="e" /> parametru.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP lub nowszy jest wymagany dla tej metody.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą rozmiar buforu odbioru z <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>
          <see cref="T:System.Int32" /> Zawierający rozmiar w bajtach buforu odbioru. Wartość domyślna to 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Większy rozmiar buforu potencjalnie zmniejsza liczbę potwierdzeń pusta (TCP pakietów przy użyciu fragmentów danych), ale może również opóźnić ujęcie trudności połączenia. Rozważ zwiększenie rozmiaru buforu transferu dużych plików, czy używasz dużej przepustowości, długom czasem oczekiwania połączenia (takiego jak dostawca satelitarnej połączenia szerokopasmowego użytkownika.)  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona dla operacji zestawu jest mniejszy niż 0.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odbiera datagram i przechowuje źródłowego punktu końcowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] *  -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizacja magazynu dla odebranych danych.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />, Przekazywany przez odwołanie, który reprezentuje serwer zdalny.</param>
        <summary>Odbiera datagram do bufora danych i zapisuje punkt końcowy.</summary>
        <returns>Liczba bajtów odebranych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda odczytuje dane `buffer` parametr zwraca liczbę bajtów odczytanych pomyślnie i przechwytuje hosta zdalnego punktu końcowego, z którego wysłano danych. Ta metoda jest przydatna, gdy będziesz otrzymywać przesyłanie datagramy Nieznany host lub wielu hostów.  
  
 To przeciążenie tylko wymaga podania receive `buffer`i <xref:System.Net.EndPoint> reprezentujący hosta zdalnego. Wartość domyślna to 0 przesunięcia buforu. Rozmiar wartość domyślna to długość `buffer` parametru i `socketFlags` wartością domyślną jest wartość <xref:System.Net.Sockets.SocketFlags.None>.  
  
> [!NOTE]
>  Przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, musisz jawnie powiązać <xref:System.Net.Sockets.Socket> lokalny punkt końcowy za pomocą <xref:System.Net.Sockets.Socket.Bind%2A> metody. W takim przypadku, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Za pomocą protokołów przesyłanie <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> odczyta pierwszy datagram umieszczonych w kolejce, odbierane w buforze sieci lokalnej. Jeśli datagram otrzymasz jest większy niż rozmiar `buffer`, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metoda wypełni `buffer` o tyle komunikatu, ponieważ jest to możliwe i throw <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu zawodnych nadmiarowe dane zostaną utracone. Jeśli używasz niezawodny protokół, nadmiarowe dane będą przechowywane przez dostawcę usług i można go pobrać, wywołując <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody z buforu wystarczająco duży.  
  
 Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metoda spowoduje zablokowanie, dopóki dane są dostępne. Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w w buforze stosu protokołu <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metoda będzie od razu zakończyć i zgłosić <xref:System.Net.Sockets.SocketException>. Możesz użyć <xref:System.Net.Sockets.Socket.Available%2A> właściwości w celu określenia, czy data jest dostępna do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, ponów próbę wykonania operacji odbierania.  
  
 Mimo że <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> jest przeznaczony dla protokołów bez połączenia, można użyć również protokół ukierunkowane na połączenia. Jeśli wybierzesz to zrobić, albo nawiązania połączenia z hostem zdalnym, wywołując <xref:System.Net.Sockets.Socket.Connect%2A> — metoda lub Zaakceptuj przychodzące zdalnego hosta połączenia, wywołując <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli nie ustanowienia lub zaakceptować połączenie przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodę, zostanie wyświetlony <xref:System.Net.Sockets.SocketException>. Możesz także udostępnić domyślnego hosta zdalnego bez połączenia protokołu przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. W obu tych przypadkach <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metoda zignoruje `remoteEP` parametru i odbierać dane z połączonym lub domyślnego hosta zdalnego.  
  
 Z nawiązaniem połączenia gniazda <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> odczyta jak najwięcej danych, ponieważ jest dostępna przy rozmiarze `buffer`. Jeśli host zdalny zamknięcie <xref:System.Net.Sockets.Socket> połączenie z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano metody i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metoda będzie od razu zakończyć i powrócić zero bajtów.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> z <xref:System.Net.EndPoint> używane w <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> musi być zgodna <xref:System.Net.Sockets.AddressFamily> z <xref:System.Net.EndPoint> używane w <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu odbiera wymiany datagramów z hosta zdalnego.  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący na stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z siecią. Powiązane wyliczenie: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizacja magazynu dla odebranych danych.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />, Przekazywany przez odwołanie, który reprezentuje serwer zdalny.</param>
        <summary>Odbiera datagram do bufora danych przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />i zapisuje punkt końcowy.</summary>
        <returns>Liczba bajtów odebranych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda odczytuje dane `buffer` parametr zwraca liczbę bajtów odczytanych pomyślnie i przechwytuje hosta zdalnego punktu końcowego, z którego wysłano danych. Ta metoda jest przydatna, gdy będziesz otrzymywać przesyłanie datagramy Nieznany host lub wielu hostów.  
  
 To przeciążenie tylko wymaga podania bufor odbioru, niezbędne <xref:System.Net.Sockets.SocketFlags>i <xref:System.Net.EndPoint> reprezentujący hosta zdalnego. Przesunięcia wartość domyślna to 0, a rozmiar wartości domyślne długości parametrze buforu.  
  
> [!NOTE]
>  Przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, musisz jawnie powiązać <xref:System.Net.Sockets.Socket> lokalny punkt końcowy za pomocą <xref:System.Net.Sockets.Socket.Bind%2A> metody. W takim przypadku, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Za pomocą protokołów przesyłanie <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> odczyta pierwszy datagram umieszczonych w kolejce, odbierane w buforze sieci lokalnej. Jeśli datagram otrzymasz jest większy niż rozmiar `buffer`, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metoda wypełni `buffer` o tyle komunikatu, ponieważ jest to możliwe i throw <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu zawodnych nadmiarowe dane zostaną utracone. Jeśli używasz niezawodny protokół, nadmiarowe dane będą przechowywane przez dostawcę usług i można go pobrać, wywołując <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody z buforu wystarczająco duży.  
  
 Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metoda spowoduje zablokowanie, dopóki dane są dostępne. Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w w buforze stosu protokołu <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metoda będzie od razu zakończyć i zgłosić <xref:System.Net.Sockets.SocketException>. Możesz użyć <xref:System.Net.Sockets.Socket.Available%2A> właściwości w celu określenia, czy data jest dostępna do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, ponów próbę wykonania operacji odbierania.  
  
 Mimo że <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> jest przeznaczony dla protokołów bez połączenia, można użyć również protokół ukierunkowane na połączenia. Jeśli wybierzesz to zrobić, albo nawiązania połączenia z hostem zdalnym, wywołując <xref:System.Net.Sockets.Socket.Connect%2A> — metoda lub Zaakceptuj przychodzące zdalnego hosta połączenia, wywołując <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli nie ustanowienia lub zaakceptować połączenie przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodę, zostanie wyświetlony <xref:System.Net.Sockets.SocketException>. Możesz także udostępnić domyślnego hosta zdalnego bez połączenia protokołu przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. W obu tych przypadkach <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metoda zignoruje `remoteEP` parametru i odbierać dane z połączonym lub domyślnego hosta zdalnego.  
  
 Z nawiązaniem połączenia gniazda <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> odczyta jak najwięcej danych, ponieważ jest dostępna przy rozmiarze `buffer`. Jeśli host zdalny zamknięcie <xref:System.Net.Sockets.Socket> połączenie z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano metody i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metoda będzie od razu zakończyć i powrócić zero bajtów.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> z <xref:System.Net.EndPoint> używane w <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> musi być zgodna <xref:System.Net.Sockets.AddressFamily> z <xref:System.Net.EndPoint> używane w <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu odbiera wymiany datagramów z hosta zdalnego. <xref:System.Net.Sockets.SocketFlags> są przekazywane do <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody.  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący na stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z siecią. Powiązane wyliczenie: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizacja magazynu dla odebranych danych.</param>
        <param name="size">Liczba bajtów do odebrania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />, Przekazywany przez odwołanie, który reprezentuje serwer zdalny.</param>
        <summary>Odbiera określoną liczbę bajtów do bufora danych przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />i zapisuje punkt końcowy.</summary>
        <returns>Liczba bajtów odebranych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda odczytuje dane `buffer` parametr zwraca liczbę bajtów odczytanych pomyślnie i przechwytuje hosta zdalnego punktu końcowego, z którego wysłano danych. Ta metoda jest przydatna, gdy będziesz otrzymywać przesyłanie datagramy Nieznany host lub wielu hostów.  
  
 To przeciążenie tylko wymaga podania bufor odbioru, liczba bajtów, które chcesz otrzymywać niezbędne <xref:System.Net.Sockets.SocketFlags>i <xref:System.Net.EndPoint> reprezentujący hosta zdalnego. Wartość domyślna to 0 przesunięcia buforu.  
  
 Za pomocą protokołów przesyłanie <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> odczyta pierwszy datagram umieszczonych w kolejce, odbierane w buforze sieci lokalnej. Jeśli datagram otrzymasz jest większy niż rozmiar `buffer`, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metoda wypełni `buffer` o tyle komunikatu, ponieważ jest to możliwe i throw <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu zawodnych nadmiarowe dane zostaną utracone. Jeśli używasz niezawodny protokół, nadmiarowe dane będą przechowywane przez dostawcę usług i można go pobrać, wywołując <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody z buforu wystarczająco duży.  
  
 Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metoda spowoduje zablokowanie, dopóki dane są dostępne. Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w w buforze stosu protokołu <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metoda będzie od razu zakończyć i zgłosić <xref:System.Net.Sockets.SocketException>. Możesz użyć <xref:System.Net.Sockets.Socket.Available%2A> właściwości w celu określenia, czy data jest dostępna do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, ponów próbę wykonania operacji odbierania.  
  
 Mimo że <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> jest przeznaczony dla protokołów bez połączenia, można użyć również protokół ukierunkowane na połączenia. Jeśli wybierzesz to zrobić, albo nawiązania połączenia z hostem zdalnym, wywołując <xref:System.Net.Sockets.Socket.Connect%2A> — metoda lub Zaakceptuj przychodzące zdalnego hosta połączenia, wywołując <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli nie ustanowienia lub zaakceptować połączenie przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodę, zostanie wyświetlony <xref:System.Net.Sockets.SocketException>. Możesz także udostępnić domyślnego hosta zdalnego bez połączenia protokołu przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. W obu tych przypadkach <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metoda zignoruje `remoteEP` parametru i odbierać dane z połączonym lub domyślnego hosta zdalnego.  
  
 Z nawiązaniem połączenia gniazda <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> odczyta jak najwięcej danych, ponieważ jest dostępnych maksymalnie liczbę bajtów określoną przez `size` parametru. Jeśli host zdalny zamknięcie <xref:System.Net.Sockets.Socket> połączenie z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano metody i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metoda będzie od razu zakończyć i powrócić zero bajtów.  
  
> [!NOTE]
>  Przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, musisz jawnie powiązać <xref:System.Net.Sockets.Socket> lokalny punkt końcowy za pomocą <xref:System.Net.Sockets.Socket.Bind%2A> metody. W takim przypadku, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> z <xref:System.Net.EndPoint> używane w <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> musi być zgodna <xref:System.Net.Sockets.AddressFamily> z <xref:System.Net.EndPoint> używane w <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu odbiera wymiany datagramów z hosta zdalnego. Rozmiar buforu i <xref:System.Net.Sockets.SocketFlags> są przekazywane do <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody.  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" /> jest większa niż długość <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> nie jest prawidłową kombinację wartości.  
  
—lub— 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> Nie można ustawić właściwości.  
  
—lub— 
Wystąpił błąd systemu operacyjnego wystąpi podczas uzyskiwania dostępu do <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący na stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z siecią. Powiązane wyliczenie: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizacja magazynu dla odebranych danych.</param>
        <param name="offset">Pozycja w <c>buforu</c> parametr do zapisania odebranych danych.</param>
        <param name="size">Liczba bajtów do odebrania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />, Przekazywany przez odwołanie, który reprezentuje serwer zdalny.</param>
        <summary>Odbiera określoną liczbę bajtów danych do określonej lokalizacji bufor danych przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />i zapisuje punkt końcowy.</summary>
        <returns>Liczba bajtów odebranych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda odczytuje dane `buffer` parametr zwraca liczbę bajtów odczytanych pomyślnie i przechwytuje hosta zdalnego punktu końcowego, z którego wysłano danych. Ta metoda jest przydatna, gdy będziesz otrzymywać przesyłanie datagramy Nieznany host lub wielu hostów.  
  
 Za pomocą protokołów przesyłanie <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> odczyta pierwszy datagram umieszczonych w kolejce, odbierane w buforze sieci lokalnej. Jeśli datagram otrzymasz jest większy niż rozmiar `buffer`, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metoda wypełni `buffer` o tyle komunikatu, ponieważ jest to możliwe i throw <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu zawodnych nadmiarowe dane zostaną utracone. Jeśli używasz niezawodny protokół, nadmiarowe dane będą przechowywane przez dostawcę usług i można go pobrać, wywołując <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody z buforu wystarczająco duży.  
  
 Jeśli żadne dane nie są dostępne do odczytu, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metoda spowoduje zablokowanie, dopóki dane są dostępne. Jeśli jesteś w trybie bez blokowania i nie ma żadnych danych w w buforze stosu protokołu <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metoda będzie od razu zakończyć i zgłosić <xref:System.Net.Sockets.SocketException>. Możesz użyć <xref:System.Net.Sockets.Socket.Available%2A> właściwości w celu określenia, czy data jest dostępna do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, ponów próbę wykonania operacji odbierania.  
  
 Mimo że <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> jest przeznaczony dla protokołów bez połączenia, można użyć również protokół ukierunkowane na połączenia. Jeśli wybierzesz to zrobić, albo nawiązania połączenia z hostem zdalnym, wywołując <xref:System.Net.Sockets.Socket.Connect%2A> — metoda lub Zaakceptuj przychodzące zdalnego hosta połączenia, wywołując <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli nie ustanowienia lub zaakceptować połączenie przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodę, zostanie wyświetlony <xref:System.Net.Sockets.SocketException>. Możesz także udostępnić domyślnego hosta zdalnego bez połączenia protokołu przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. W obu tych przypadkach <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metoda zignoruje `remoteEP` parametru i odbierać dane z połączonym lub domyślnego hosta zdalnego.  
  
 Z nawiązaniem połączenia gniazda <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> odczyta jak najwięcej danych, ponieważ jest dostępna do kwoty liczby bajtów określonej przez `size` parametru. Jeśli host zdalny zamknięcie <xref:System.Net.Sockets.Socket> połączenie z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano metody i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metoda będzie od razu zakończyć i powrócić zero bajtów.  
  
> [!NOTE]
>  Przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, musisz jawnie powiązać <xref:System.Net.Sockets.Socket> lokalny punkt końcowy za pomocą <xref:System.Net.Sockets.Socket.Bind%2A> metody. W takim przypadku, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> z <xref:System.Net.EndPoint> używane w <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> musi być zgodna <xref:System.Net.Sockets.AddressFamily> z <xref:System.Net.EndPoint> używane w <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu odbiera wymiany datagramów z hosta zdalnego. Przesunięcie, rozmiar buforu i <xref:System.Net.Sockets.SocketFlags> są przekazywane do <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody.  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" /> jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość parametru przesunięcia.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> nie jest prawidłową kombinację wartości.  
  
—lub— 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> Nie można ustawić właściwości.  
  
—lub— 
Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z siecią. Powiązane wyliczenie: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Obiekt ma być używany dla tej operacji asynchronicznych gniazda.</param>
        <summary>Zaczyna asynchronicznie odbieranie danych z określonego urządzenia sieciowego.</summary>
        <returns>Zwraca <see langword="true" /> przypadku oczekujących operacji We/Wy. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie na <paramref name="e" /> parametr zostanie wygenerowany po zakończeniu operacji.  
  
Zwraca <see langword="false" /> Jeśli operacji We/Wy została zakończona synchronicznie. W tym przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie na <paramref name="e" /> parametr nie zostanie wygenerowany i <paramref name="e" /> przekazano obiekt jako parametr może zbadać, natychmiast po zakończeniu wywołania metody które zwraca wynik operacji pobierania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> Metoda jest używana głównie w celu odbierania danych na gniazdo bez połączenia. Adres lokalnego gniazda musi być znane.  
  
 Obiekt wywołujący musi być ustawiona <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> właściwość <xref:System.Net.IPEndPoint> zdalnego hosta, z którego ma zostać odebrane dane.  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> Właściwość `e` parametru zapewnia dostawcy usług Sockets okno z dodatkowymi informacjami dotyczącymi żądanie odczytu. Aby uzyskać więcej informacji o tym, jak używać tego parametru, zobacz <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.  
  
 Poniższe właściwości i zdarzenia <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiektu są wymagane do pomyślnego wywołania tej metody:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Obiekt wywołujący może ustawiać <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość do każdego obiektu stanu użytkownika żądanego przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> metodę, tak, aby dane możliwe do pobierania w metody wywołania zwrotnego. Jeśli wywołanie zwrotne potrzebuje więcej informacji, niż jeden obiekt, mały klasy mogą być tworzone na potrzeby przechowywania inne wymagane informacje o stanie jako elementy członkowskie.  
  
 Usługi przesyłania wiadomości Sockets wiadomości przychodzących jest umieszczany w buforu maksymalnie całkowity rozmiar buforu. <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> i <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> właściwości określają, gdzie w buforze dane są wklejane i ilości danych.  
  
 Dla gniazda stylu strumień bajtów danych przychodzących jest umieszczany w buforze, aż do zapełnienia buforu, połączenie jest zamknięte lub wyczerpania wewnętrznie buforowane dane. <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> i <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> właściwości określają, gdzie w buforze dane są wklejane i ilości danych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> Nie może mieć wartości null.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja gniazda była już w toku przy użyciu <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiekt określony w <paramref name="e" /> parametru.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP lub nowszy jest wymagany dla tej metody.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int *  *  *  -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizacja magazynu dla odebranych danych.</param>
        <param name="offset">Pozycja w <c>buforu</c> parametr do zapisania odebranych danych.</param>
        <param name="size">Liczba bajtów do odebrania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />, Przekazywany przez odwołanie, który reprezentuje serwer zdalny.</param>
        <param name="ipPacketInformation">
          <see cref="T:System.Net.Sockets.IPPacketInformation" /> Zawierający informacje dotyczące adresów i interfejsu.</param>
        <summary>Odbiera określoną liczbę bajtów danych do określonej lokalizacji bufor danych przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />i przechowuje informacje o punkcie końcowym i pakietów.</summary>
        <returns>Liczba bajtów odebranych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Metoda odczytuje dane `buffer` parametr zwraca liczbę bajtów odczytanych pomyślnie i przechwytuje hosta zdalnego punktu końcowego, z którego wysłano dane, a także informacje o odebranego pakietu.  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Metoda jest używana głównie w celu odbierania danych wiadomości na gniazdo bez połączenia. Adres lokalnego gniazda musi być znane. Tej metody należy używać tylko z datagram i gniazd sieciowych. Gniazda musi zostać zainicjowany z typem gniazdo równa <xref:System.Net.Sockets.SocketType.Dgram> lub <xref:System.Net.Sockets.SocketType.Raw> przed wywołaniem tej metody. Można to zrobić, gdy gniazdo jest tworzony przy użyciu <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 Usługi przesyłania wiadomości Sockets przychodzący komunikat jest umieszczana w `buffer` parametru maksymalnie łączny rozmiar określonych w `size` parametru. `offset` Parametr określa, w którym miejscu `buffer` znajduje się dane. Rzeczywista ilość danych, o których umieszczane `buffer` jest zwracany przez <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metody.  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Metoda automatycznie ustawia metodę <xref:System.Net.Sockets.SocketOptionName.PacketInformation> gniazda możliwość `true` po raz pierwszy jest wywoływana dla danego <xref:System.Net.Sockets.Socket>. Jednak zwracanego <xref:System.Net.Sockets.IPPacketInformation> obiektu będzie obowiązywał tylko dla pakietów, które są odbierane na komputerze lokalnym po została ustawiona opcja gniazda. Jeśli gniazdo jest wysyłana pakietów między, gdy jest on powiązany z lokalnym punktem końcowym (jawnie przez <xref:System.Net.Sockets.Socket.Bind%2A> metody lub niejawnie za pomocą jednej z <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, lub <xref:System.Net.Sockets.Socket.SendToAsync%2A> metody) i jego pierwszym wywołaniu <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> wywołania metody <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metoda zwróci nieprawidłowy <xref:System.Net.Sockets.IPPacketInformation> obiektów dla tych pakietów.  
  
 Aby upewnić się, że wszystkie <xref:System.Net.Sockets.IPPacketInformation> obiekty są prawidłowe, aplikacja powinna być ustawiona <xref:System.Net.Sockets.SocketOptionName.PacketInformation> gniazda opcję, aby `true` przed jest powiązany z lokalny punkt końcowy przy użyciu <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> metody.  
  
 Aplikację można sprawdzić `ipPacketInformation` parametru, jeśli musi wiedzieć, czy datagram została przesłana przy użyciu emisji pojedynczej, adres multiemisji lub emisji.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> z <xref:System.Net.EndPoint> używane w <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> musi być zgodna <xref:System.Net.Sockets.AddressFamily> z <xref:System.Net.EndPoint> używane w <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.  
  
\- lub — 
 <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" /> jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość parametru przesunięcia.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> nie jest prawidłową kombinację wartości.  
  
—lub— 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> Nie można ustawić właściwości.  
  
—lub— 
.NET Framework jest uruchomiona na AMD 64-bitowy procesor.  
  
—lub— 
Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.NotSupportedException">System operacyjny to Windows 2000 lub starszym. Ponadto ta metoda wymaga Windows XP.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z siecią. Powiązane wyliczenie: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Obiekt ma być używany dla tej operacji asynchronicznych gniazda.</param>
        <summary>Rozpoczyna asynchronicznie odbieranie określoną liczbę bajtów danych do określonej lokalizacji w buforze danych przy użyciu określonego <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />i przechowuje informacje o punkcie końcowym i pakietów.</summary>
        <returns>Zwraca <see langword="true" /> przypadku oczekujących operacji We/Wy. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie na <paramref name="e" /> parametr zostanie wygenerowany po zakończeniu operacji.  
  
Zwraca <see langword="false" /> Jeśli operacji We/Wy została zakończona synchronicznie. W tym przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie na <paramref name="e" /> parametr nie zostanie wygenerowany i <paramref name="e" /> przekazano obiekt jako parametr może zbadać, natychmiast po zakończeniu wywołania metody które zwraca wynik operacji pobierania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> Metoda jest używana głównie w celu odbierania danych wiadomości na gniazdo bez połączenia. Adres lokalnego gniazda musi być znane. Tej metody należy używać tylko z datagram i gniazd sieciowych. Gniazda musi zostać zainicjowany z typem gniazdo równa <xref:System.Net.Sockets.SocketType.Dgram> lub <xref:System.Net.Sockets.SocketType.Raw> przed wywołaniem tej metody. Można to zrobić, gdy gniazdo jest tworzony przy użyciu <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 Obiekt wywołujący musi być ustawiona <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> właściwość <xref:System.Net.IPEndPoint> zdalnego hosta, z którego ma zostać odebrane dane.  
  
 Poniższe właściwości i zdarzenia <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiektu są wymagane do pomyślnego wywołania tej metody:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Obiekt wywołujący może ustawiać <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość do każdego obiektu stanu użytkownika żądanego przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> metodę, tak, aby dane możliwe do pobierania w metody wywołania zwrotnego. Jeśli wywołanie zwrotne potrzebuje więcej informacji, niż jeden obiekt, mały klasy mogą być tworzone na potrzeby przechowywania inne wymagane informacje o stanie jako elementy członkowskie.  
  
 Usługi przesyłania wiadomości Sockets wiadomości przychodzących jest umieszczany w buforu maksymalnie całkowity rozmiar buforu. <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> i <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> właściwości określają, gdzie w buforze dane są wklejane i ilości danych.  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> Metoda automatycznie ustawia <xref:System.Net.Sockets.SocketOptionName.PacketInformation> gniazda możliwość `true` po raz pierwszy jest wywoływana dla danego <xref:System.Net.Sockets.Socket>. Jednak <xref:System.Net.Sockets.IPPacketInformation> obiektu będzie obowiązywał tylko dla pakietów, które są odbierane na komputerze lokalnym po została ustawiona opcja gniazda. Jeśli gniazdo zostanie wysłany pakietów między, gdy gniazdo jest powiązana z lokalnym punktem końcowym (jawnie przez <xref:System.Net.Sockets.Socket.Bind%2A> metody lub niejawnie za pomocą jednej z <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, lub <xref:System.Net.Sockets.Socket.SendToAsync%2A> metody) i pierwsze wywołanie <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>wywołania metody <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> metoda spowoduje nieprawidłowe <xref:System.Net.Sockets.IPPacketInformation> obiektów dla tych pakietów.  
  
 Aby upewnić się, że wszystkie <xref:System.Net.Sockets.IPPacketInformation> obiekty są prawidłowe, aplikacja powinna być ustawiona <xref:System.Net.Sockets.SocketOptionName.PacketInformation> gniazda opcję, aby`true` przed jest powiązany z lokalny punkt końcowy przy użyciu <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> metody.  
  
 Aplikację można sprawdzić, wynikowy <xref:System.Net.Sockets.IPPacketInformation> obiekty, jeśli musi wiedzieć, czy datagram została przesłana przy użyciu emisji pojedynczej, adres multiemisji lub emisji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> Nie może mieć wartości null.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP lub nowszy jest wymagany dla tej metody.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, która określa czas, po którym synchronicznego <see cref="Overload:System.Net.Sockets.Socket.Receive" /> wywołanie przekroczy limit czasu.</summary>
        <value>Wartość limitu czasu w milisekundach. Wartość domyślna to 0, co oznacza nieskończony limit czasu. Określanie wartości -1 wskazuje także nieskończony limit czasu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta opcja ma zastosowanie do synchroniczne <xref:System.Net.Sockets.Socket.Receive%2A> tylko wywołania. Jeśli zostanie przekroczony limit czasu, <xref:System.Net.Sockets.Socket.Receive%2A> metoda zgłosi <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona dla operacji zestawu jest mniejsza niż -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zdalny punkt końcowy.</summary>
        <value>
          <see cref="T:System.Net.EndPoint" /> Za pomocą którego <see cref="T:System.Net.Sockets.Socket" /> komunikuje się.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz protokołu połączeniowy, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> pobiera właściwość <xref:System.Net.EndPoint> zawierający zdalnego adresu IP adres i numer portu do której <xref:System.Net.Sockets.Socket> jest połączony. Jeśli używasz protokołu przesyłanie, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> zawiera domyślne zdalny adres IP i numer portu za pomocą którego <xref:System.Net.Sockets.Socket> będą komunikować się. Należy to rzutować <xref:System.Net.EndPoint> do <xref:System.Net.IPEndPoint> przed pobraniem jakichkolwiek informacji. Następnie możesz wywołać <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> metodę, która pobierze zdalne <xref:System.Net.IPAddress>i <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> metodę, która pobierze numer portu zdalnego.  
  
 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> Ustawiono po wywołaniu albo <xref:System.Net.Sockets.Socket.Accept%2A> lub <xref:System.Net.Sockets.Socket.Connect%2A>. Jeśli zostanie podjęta próba wcześniej, dostęp do tej właściwości <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i wyświetla punkty końcowe lokalnych i zdalnych.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" />
        <Parameter Name="checkError" Type="System.Collections.IList" />
        <Parameter Name="microSeconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="checkRead">
          <see cref="T:System.Collections.IList" /> z <see cref="T:System.Net.Sockets.Socket" /> wystąpień pod kątem czytelności.</param>
        <param name="checkWrite">
          <see cref="T:System.Collections.IList" /> z <see cref="T:System.Net.Sockets.Socket" /> wystąpień, aby sprawdzić, czy obiekty.</param>
        <param name="checkError">
          <see cref="T:System.Collections.IList" /> z <see cref="T:System.Net.Sockets.Socket" /> wystąpień pod kątem błędów.</param>
        <param name="microSeconds">Wartość limitu czasu w mikrosekundach. Wartość-1 wskazuje nieskończony limit czasu.</param>
        <summary>Określa stan co najmniej jeden gniazda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A> jest metoda statyczna, który określa stan co najmniej jednego <xref:System.Net.Sockets.Socket> wystąpień. Należy umieścić przynajmniej jednego gniazda do <xref:System.Collections.IList> przed użyciem <xref:System.Net.Sockets.Socket.Select%2A> metody. Sprawdź, aby zwiększyć czytelność, wywołując <xref:System.Net.Sockets.Socket.Select%2A> z <xref:System.Collections.IList> jako `checkRead` parametru. Aby sprawdzić swoje gniazd obiekty, użyj `checkWrite` parametru. W przypadku wykrycia błędów, użyj `checkError`. Po wywołaniu <xref:System.Net.Sockets.Socket.Select%2A>, <xref:System.Collections.IList> zostaną wypełnione przy użyciu tych gniazd, które spełniają warunki.  
  
 Jeśli jesteś w stanie nasłuchiwania czytelność oznacza, że wywołanie <xref:System.Net.Sockets.Socket.Accept%2A> powiedzie się bez blokowania. Zaakceptował połączenia czytelność oznacza, że dane są dostępne do odczytu. W takich przypadkach wszystkich operacji odbioru powiedzie się bez blokowania. Czytelność można również określić, czy zdalny <xref:System.Net.Sockets.Socket> ma wyłączone połączenie; w takim przypadku wywołanie <xref:System.Net.Sockets.Socket.Receive%2A> zwróci natychmiast, za pomocą zero bajtów zwróconych.  
  
 <xref:System.Net.Sockets.Socket.Select%2A> Po co najmniej jedno z gniazd zainteresowania (gniazda w `checkRead`, `checkWrite`, i `checkError` Wyświetla) spełnia określone kryteria lub `microSeconds` parametr zostanie przekroczony, osiągnięta jako pierwsza. Ustawienie `microSeconds` na -1, określa nieskończony limit czasu.  
  
 Jeśli wprowadzisz nieblokujących wywołań do <xref:System.Net.Sockets.Socket.Connect%2A>, obiekty oznacza, że nawiązano połączenie pomyślnie. Jeśli masz już nawiązano połączenie, obiekty oznacza, że wszystkie Wyślij operacje będą kończą się pomyślnie bez blokowania.  
  
 Jeśli wprowadzono nieblokujące wywołania <xref:System.Net.Sockets.Socket.Connect%2A>, `checkerror` parametr identyfikuje gniazd, które nie połączyły się pomyślnie.  
  
> [!NOTE]
>  Użyj <xref:System.Net.Sockets.Socket.Poll%2A> metody, jeśli chcesz określić stan pojedynczego <xref:System.Net.Sockets.Socket>.  
  
> [!NOTE]
>  Ta metoda nie może wykryć niektórych rodzajów problemy z połączeniem, takie jak kabel sieciowy przerwane lub host zdalny został zamknięty, ungracefully. Należy próbować wysyłać ani odbierać dane, aby wykryć te rodzaje błędów.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.Sockets.Socket.Select%2A> do określenia, który nasłuchuje gniazda mają żądanie połączenia.  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="checkRead" /> Parametr jest <see langword="null" /> lub jest pusty.  
  
- i - 
<paramref name="checkWrite" /> Parametr jest <see langword="null" /> lub jest pusty 
- i - 
<paramref name="checkError" /> Parametr jest <see langword="null" /> lub jest pusty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wysyła dane do połączonej <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <summary>Wysyła dane do połączonej <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> synchronicznie wysyła dane do hosta zdalnego, określony w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metodę i zwraca liczbę bajtów pomyślnie wysłane. <xref:System.Net.Sockets.Socket.Send%2A> może służyć do protokołów połączeniowy i bez połączenia.  
  
 To przeciążenie wymaga bufora, który zawiera dane, które mają zostać wysłane. <xref:System.Net.Sockets.SocketFlags> Domyślne wartości na 0, wartością domyślną jest 0, a liczba bajtów do wysłania wartości domyślne do rozmiaru buforu przesunięcia buforu.  
  
 Jeśli używasz protokołu bez połączenia z tym należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu z nawiązaniem połączenia, należy używać <xref:System.Net.Sockets.Socket.Connect%2A> do nawiązania połączenia z hostem zdalnym lub użyj <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenia przychodzące.  
  
 Jeśli używasz przesyłanie protokołu i plan do wysyłania danych do wielu różnych hostach, należy użyć <xref:System.Net.Sockets.Socket.SendTo%2A> metody. Jeśli nie używasz <xref:System.Net.Sockets.Socket.SendTo%2A> metody, trzeba będzie wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed każdym wywołaniem do <xref:System.Net.Sockets.Socket.Send%2A>. Możesz użyć <xref:System.Net.Sockets.Socket.SendTo%2A> mimo że ustanowiono domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> , wprowadzając inne wywołanie <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Jeśli używasz protokołu połączeniowy, <xref:System.Net.Sockets.Socket.Send%2A> spowoduje zablokowanie aż wszystkich bajtów w buforze są wysyłane, jeśli nie ustawiono limit czasu za pomocą <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Send%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. W trybie nieblokujących <xref:System.Net.Sockets.Socket.Send%2A> może zakończyć się pomyślnie, nawet jeśli wysyła mniejsza niż liczba bajtów w buforze. Odpowiada aplikacji do śledzenia liczba bajtów wysłanych i spróbuj ponownie wykonać operację, aż aplikacja wysyła bajtów w buforze. Istnieje również ma gwarancji, że dane, które wysyłasz pojawi się w sieci natychmiast. Aby zwiększyć wydajność sieci, podstawowy system może opóźnienie transmisji, dopóki nie znaczną ilość danych wychodzących są zbierane. Pomyślne wykonanie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że zasadniczego systemu miał miejsce do buforu wysyłania danych do sieci.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie oznacza, że danych zostało pomyślnie dostarczone. Jeśli ilość miejsca w buforze jest dostępna w ramach systemu transportu do przechowywania danych, które mają być przekazywane, Wyślij zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wysyłania danych na połączonych <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">Lista <see cref="T:System.ArraySegment`1" />s typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <summary>Wysyła zbiór buforów na liście połączonej <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> może służyć do protokołów połączeniowy i bez połączenia.  
  
 To przeciążenie wymaga co najmniej jeden buforu, który zawiera dane, które mają zostać wysłane.  
  
 Jeśli używasz protokołu bez połączenia z tym należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu z nawiązaniem połączenia, należy używać <xref:System.Net.Sockets.Socket.Connect%2A> do nawiązania połączenia z hostem zdalnym lub użyj <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenia przychodzące.  
  
 Jeśli używasz przesyłanie protokołu i plan do wysyłania danych do wielu różnych hostach, należy użyć <xref:System.Net.Sockets.Socket.SendTo%2A> metody. Jeśli nie używasz <xref:System.Net.Sockets.Socket.SendTo%2A> metody, trzeba będzie wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed każdym wywołaniem do <xref:System.Net.Sockets.Socket.Send%2A>. Możesz użyć <xref:System.Net.Sockets.Socket.SendTo%2A> mimo że ustanowiono domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> , wprowadzając inne wywołanie <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Jeśli używasz protokołu połączeniowy, <xref:System.Net.Sockets.Socket.Send%2A> spowoduje zablokowanie aż wszystkich bajtów w buforze są wysyłane, jeśli nie ustawiono limit czasu za pomocą <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Send%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. W trybie nieblokujących <xref:System.Net.Sockets.Socket.Send%2A> może zakończyć się pomyślnie, nawet jeśli wysyła mniejsza niż liczba bajtów w buforze. Odpowiada aplikacji do śledzenia liczba bajtów wysłanych i spróbuj ponownie wykonać operację, aż aplikacja wysyła bajtów w buforze. Istnieje również ma gwarancji, że dane, które wysyłasz pojawi się w sieci natychmiast. Aby zwiększyć wydajność sieci, podstawowy system może opóźnienie transmisji, dopóki nie znaczną ilość danych wychodzących są zbierane. Pomyślne wykonanie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że zasadniczego systemu miał miejsce do buforu wysyłania danych do sieci.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie oznacza, że danych zostało pomyślnie dostarczone. Jeśli ilość miejsca w buforze jest dostępna w ramach systemu transportu do przechowywania danych, które mają być przekazywane, Wyślij zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> jest pusty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz sekcję uwagi poniżej.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <summary>Wysyła dane do połączonej <see cref="T:System.Net.Sockets.Socket" /> przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> synchronicznie wysyła dane do hosta zdalnego ustanowionych w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metodę i zwraca liczbę bajtów pomyślnie wysłane. <xref:System.Net.Sockets.Socket.Send%2A> Metoda może być używana dla protokołów połączeniowy i bez połączenia.  
  
 To przeciążenie wymaga bufora, który zawiera dane mają zostać wysłane i bitowa kombinacja <xref:System.Net.Sockets.SocketFlags>. Wartość domyślna to 0, a liczba bajtów do wysłania wartości domyślne do rozmiaru buforu przesunięcia buforu. Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketflags` wartość parametru, dane są wysyłane, nie będą kierowane.  
  
 Jeśli używasz protokołu bez połączenia z tym należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu z nawiązaniem połączenia, należy używać <xref:System.Net.Sockets.Socket.Connect%2A> do nawiązania połączenia z hostem zdalnym lub użyj <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenia przychodzące.  
  
 Jeśli używasz przesyłanie protokołu i plan do wysyłania danych do wielu różnych hostach, należy użyć <xref:System.Net.Sockets.Socket.SendTo%2A> metody. Jeśli nie używasz <xref:System.Net.Sockets.Socket.SendTo%2A> metody, trzeba będzie wywołać <xref:System.Net.Sockets.Socket.Connect%2A> metody przed każdym wywołaniu <xref:System.Net.Sockets.Socket.Send%2A>. Możesz użyć <xref:System.Net.Sockets.Socket.SendTo%2A> mimo że ustanowiono domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> , wprowadzając inne wywołanie <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Jeśli używasz protokołu połączeniowy, <xref:System.Net.Sockets.Socket.Send%2A> spowoduje zablokowanie aż wszystkich bajtów w buforze są wysyłane, jeśli nie ustawiono limit czasu za pomocą <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Send%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. W trybie nieblokujących <xref:System.Net.Sockets.Socket.Send%2A> może zakończyć się pomyślnie, nawet jeśli wysyła mniejsza niż liczba bajtów w buforze. Odpowiada aplikacji do śledzenia liczba bajtów wysłanych i spróbuj ponownie wykonać operację, aż aplikacja wysyła żądanej liczby bajtów. Istnieje również ma gwarancji, że dane, które wysyłasz pojawi się w sieci natychmiast. Aby zwiększyć wydajność sieci, podstawowy system może opóźnienie transmisji, dopóki nie znaczną ilość danych wychodzących są zbierane. Pomyślne wykonanie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że zasadniczego systemu miał miejsce do buforu wysyłania danych do sieci.  
  
> [!NOTE]
>  Należy się upewnić, że rozmiar buforu przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak jest, datagram nie będą wysyłane i <xref:System.Net.Sockets.Socket.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie oznacza, że danych zostało pomyślnie dostarczone. Jeśli ilość miejsca w buforze jest dostępna w ramach systemu transportu do przechowywania danych, które mają być przekazywane, Wyślij zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wysyłania danych na połączonych <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">Lista <see cref="T:System.ArraySegment`1" />s typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <summary>Wysyła zbiór buforów na liście połączonej <see cref="T:System.Net.Sockets.Socket" />, przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie wymaga co najmniej jeden buforu, który zawiera dane, które mają zostać wysłane. <xref:System.Net.Sockets.SocketFlags> Wartość wartość domyślna to 0. Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketFlags` parametru, dane są wysyłane, nie będą kierowane.  
  
 Jeśli używasz protokołu bez połączenia z tym należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu z nawiązaniem połączenia, należy używać <xref:System.Net.Sockets.Socket.Connect%2A> do nawiązania połączenia z hostem zdalnym lub użyj <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenia przychodzące.  
  
 Jeśli używasz przesyłanie protokołu i plan do wysyłania danych do wielu różnych hostach, należy użyć <xref:System.Net.Sockets.Socket.SendTo%2A> metody. Jeśli nie używasz <xref:System.Net.Sockets.Socket.SendTo%2A> metody, trzeba będzie wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed każdym wywołaniem do <xref:System.Net.Sockets.Socket.Send%2A>. Możesz użyć <xref:System.Net.Sockets.Socket.SendTo%2A> mimo że ustanowiono domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> , wprowadzając inne wywołanie <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Jeśli używasz protokołu połączeniowy, <xref:System.Net.Sockets.Socket.Send%2A> spowoduje zablokowanie aż wszystkich bajtów w buforze są wysyłane, jeśli nie ustawiono limit czasu za pomocą <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Send%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. W trybie bez blokowania <xref:System.Net.Sockets.Socket.Send%2A> może zakończyć się pomyślnie, nawet jeśli wysyła mniejsza niż liczba bajtów w buforze. Odpowiada aplikacji do śledzenia liczba bajtów wysłanych i spróbuj ponownie wykonać operację, aż aplikacja wysyła bajtów w buforze. Istnieje również ma gwarancji, że dane, które wysyłasz pojawi się w sieci natychmiast. Aby zwiększyć wydajność sieci, podstawowy system może opóźnienie transmisji, dopóki nie znaczną ilość danych wychodzących są zbierane. Pomyślne wykonanie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że zasadniczego systemu miał miejsce do buforu wysyłania danych do sieci.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie oznacza, że danych zostało pomyślnie dostarczone. Jeśli ilość miejsca w buforze jest dostępna w ramach systemu transportu do przechowywania danych, które mają być przekazywane, Wyślij zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> jest pusty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="size">Liczba bajtów do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <summary>Wysyła określoną liczbę bajtów danych do połączonej <see cref="T:System.Net.Sockets.Socket" />, przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> synchronicznie wysyła dane do hosta zdalnego ustanowionych w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metodę i zwraca liczbę bajtów pomyślnie wysłane. <xref:System.Net.Sockets.Socket.Send%2A> może służyć do protokołów połączeniowy i bez połączenia.  
  
 To przeciążenie wymaga bufora, który zawiera dane chcesz wysłać, liczba bajtów, które mają zostać wysłane i bitowa kombinacja dowolne <xref:System.Net.Sockets.SocketFlags>. Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketflags` parametru, dane są wysyłane, nie będą kierowane.  
  
 Jeśli używasz protokołu bez połączenia z tym należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu z nawiązaniem połączenia, należy używać <xref:System.Net.Sockets.Socket.Connect%2A> do nawiązania połączenia z hostem zdalnym lub użyj <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenia przychodzące.  
  
 Jeśli używasz przesyłanie protokołu i plan do wysyłania danych do wielu różnych hostach, należy użyć <xref:System.Net.Sockets.Socket.SendTo%2A> metody. Jeśli nie używasz <xref:System.Net.Sockets.Socket.SendTo%2A> metody, trzeba będzie wywołać <xref:System.Net.Sockets.Socket.Connect%2A> metody przed każdym wywołaniu <xref:System.Net.Sockets.Socket.Send%2A> metody. Możesz użyć <xref:System.Net.Sockets.Socket.SendTo%2A> mimo że ustanowiono domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> , wprowadzając inne wywołanie <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Za pomocą protokołu połączeniowy <xref:System.Net.Sockets.Socket.Send%2A> spowoduje zablokowanie aż żądanej liczby bajtów są wysyłane, jeśli nie ustawiono limit czasu za pomocą <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Send%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. W trybie nieblokujących <xref:System.Net.Sockets.Socket.Send%2A> może zakończyć się pomyślnie, nawet jeśli wysyła mniejsza niż liczba bajtów w przypadku żądania. Odpowiada aplikacji do śledzenia liczba bajtów wysłanych i spróbuj ponownie wykonać operację, aż aplikacja wysyła żądanej liczby bajtów. Istnieje również ma gwarancji, że dane, które wysyłasz pojawi się w sieci natychmiast. Aby zwiększyć wydajność sieci, podstawowy system może opóźnienie transmisji, dopóki nie znaczną ilość danych wychodzących są zbierane. Pomyślne wykonanie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że zasadniczego systemu miał miejsce do buforu wysyłania danych do sieci.  
  
> [!NOTE]
>  Należy się upewnić, że rozmiar przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak jest, datagram nie będą wysyłane i <xref:System.Net.Sockets.Socket.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie oznacza, że danych zostało pomyślnie dostarczone. Jeśli ilość miejsca w buforze jest dostępna w ramach systemu transportu do przechowywania danych, które mają być przekazywane, Wyślij zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod wysyła dane w buforze i określa <xref:System.Net.Sockets.SocketFlags.None> dla <xref:System.Net.Sockets.SocketFlags>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> jest mniejsza niż 0 lub przekracza rozmiar buforu.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> nie jest prawidłową kombinację wartości.  
  
—lub— 
Występuje błąd systemu operacyjnego, uzyskując dostęp do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">Lista <see cref="T:System.ArraySegment`1" />s typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> obiekt, który przechowuje błąd gniazda.</param>
        <summary>Wysyła zbiór buforów na liście połączonej <see cref="T:System.Net.Sockets.Socket" />, przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie wymaga co najmniej jeden buforu, który zawiera dane, które mają zostać wysłane. <xref:System.Net.Sockets.SocketFlags> Wartość wartość domyślna to 0. Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketFlags` parametru, dane są wysyłane, nie będą kierowane.  
  
 Jeśli używasz protokołu bez połączenia z tym należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu z nawiązaniem połączenia, należy używać <xref:System.Net.Sockets.Socket.Connect%2A> do nawiązania połączenia z hostem zdalnym lub użyj <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenia przychodzące.  
  
 Jeśli używasz przesyłanie protokołu i plan do wysyłania danych do wielu różnych hostach, należy użyć <xref:System.Net.Sockets.Socket.SendTo%2A> metody. Jeśli nie używasz <xref:System.Net.Sockets.Socket.SendTo%2A> metody, trzeba będzie wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed każdym wywołaniem do <xref:System.Net.Sockets.Socket.Send%2A>. Możesz użyć <xref:System.Net.Sockets.Socket.SendTo%2A> mimo że ustanowiono domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> , wprowadzając inne wywołanie <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Jeśli używasz protokołu połączeniowy, <xref:System.Net.Sockets.Socket.Send%2A> spowoduje zablokowanie aż wszystkich bajtów w buforze są wysyłane, jeśli nie ustawiono limit czasu za pomocą <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Send%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. W trybie bez blokowania <xref:System.Net.Sockets.Socket.Send%2A> może zakończyć się pomyślnie, nawet jeśli wysyła mniejsza niż liczba bajtów w buforze. Odpowiada aplikacji do śledzenia liczba bajtów wysłanych i spróbuj ponownie wykonać operację, aż aplikacja wysyła bajtów w buforze. Istnieje również ma gwarancji, że dane, które wysyłasz pojawi się w sieci natychmiast. Aby zwiększyć wydajność sieci, podstawowy system może opóźnienie transmisji, dopóki nie znaczną ilość danych wychodzących są zbierane. Pomyślne wykonanie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że zasadniczego systemu miał miejsce do buforu wysyłania danych do sieci.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie oznacza, że danych zostało pomyślnie dostarczone. Jeśli ilość miejsca w buforze jest dostępna w ramach systemu transportu do przechowywania danych, które mają być przekazywane, Wyślij zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> jest pusty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="offset">Pozycja w buforze danych, od którego należy rozpocząć wysyłanie danych.</param>
        <param name="size">Liczba bajtów do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <summary>Wysyła określoną liczbę bajtów danych do połączonej <see cref="T:System.Net.Sockets.Socket" />, rozpoczynając od określonego przesunięcia i przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> synchronicznie wysyła dane do hosta zdalnego, określony w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metodę i zwraca liczbę bajtów pomyślnie wysłane. <xref:System.Net.Sockets.Socket.Send%2A> może służyć do protokołów połączeniowy i bez połączenia.  
  
 W tego przeciążenia, jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketflags` parametru, dane są wysyłane, nie będą kierowane.  
  
 Jeśli używasz protokołu bez połączenia z tym należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu z nawiązaniem połączenia, należy używać <xref:System.Net.Sockets.Socket.Connect%2A> do nawiązania połączenia z hostem zdalnym lub użyj <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenia przychodzące.  
  
 Jeśli używasz przesyłanie protokołu i plan do wysyłania danych do wielu różnych hostach, należy użyć <xref:System.Net.Sockets.Socket.SendTo%2A>. Jeśli nie używasz <xref:System.Net.Sockets.Socket.SendTo%2A>, trzeba będzie wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed każdym wywołaniem do <xref:System.Net.Sockets.Socket.Send%2A>. Można użyć <xref:System.Net.Sockets.Socket.SendTo%2A> mimo że ustanowiono domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> , wprowadzając inne wywołanie <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Ponadto należy się upewnić, że rozmiar przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak jest, datagram nie będą wysyłane i <xref:System.Net.Sockets.Socket.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Jeśli używasz protokołu połączeniowy, <xref:System.Net.Sockets.Socket.Send%2A> spowoduje zablokowanie aż żądanej liczby bajtów są wysyłane, jeśli nie ustawiono limit czasu za pomocą <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Send%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. W trybie nieblokujących <xref:System.Net.Sockets.Socket.Send%2A> może zakończyć się pomyślnie, nawet jeśli wysyła mniejsza niż liczba bajtów w przypadku żądania. Odpowiada aplikacji do śledzenia liczba bajtów wysłanych i spróbuj ponownie wykonać operację, aż aplikacja wysyła żądanej liczby bajtów. Istnieje również ma gwarancji, że dane, które wysyłasz pojawi się w sieci natychmiast. Aby zwiększyć wydajność sieci, podstawowy system może opóźnienie transmisji, dopóki nie znaczną ilość danych wychodzących są zbierane. Pomyślne wykonanie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że zasadniczego systemu miał miejsce do buforu wysyłania danych do sieci.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie oznacza, że danych zostało pomyślnie dostarczone. Jeśli ilość miejsca w buforze jest dostępna w ramach systemu transportu do przechowywania danych, które mają być przekazywane, Wyślij zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu określa przesunięcie buforu danych, rozmiar i <xref:System.Net.Sockets.SocketFlags> do wysyłania danych do połączonej <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" /> jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> nie jest prawidłową kombinację wartości.  
  
—lub— 
Wystąpił błąd systemu operacyjnego wystąpi podczas uzyskiwania dostępu do <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="offset">Pozycja w buforze danych, od którego należy rozpocząć wysyłanie danych.</param>
        <param name="size">Liczba bajtów do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> obiekt, który przechowuje błąd gniazda.</param>
        <summary>Wysyła określoną liczbę bajtów danych do połączonej <see cref="T:System.Net.Sockets.Socket" />, rozpoczynając od określonego przesunięcia i przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" /></summary>
        <returns>Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> synchronicznie wysyła dane do hosta zdalnego, określony w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metodę i zwraca liczbę bajtów pomyślnie wysłane. <xref:System.Net.Sockets.Socket.Send%2A> może służyć do protokołów połączeniowy i bez połączenia.  
  
 W tego przeciążenia, jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketflags` parametru, dane są wysyłane, nie będą kierowane.  
  
 Jeśli używasz protokołu bez połączenia z tym należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu z nawiązaniem połączenia, należy używać <xref:System.Net.Sockets.Socket.Connect%2A> do nawiązania połączenia z hostem zdalnym lub użyj <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenia przychodzące.  
  
 Jeśli używasz przesyłanie protokołu i plan do wysyłania danych do wielu różnych hostach, należy użyć <xref:System.Net.Sockets.Socket.SendTo%2A>. Jeśli nie używasz <xref:System.Net.Sockets.Socket.SendTo%2A>, trzeba będzie wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed każdym wywołaniem do <xref:System.Net.Sockets.Socket.Send%2A>. Można użyć <xref:System.Net.Sockets.Socket.SendTo%2A> mimo że ustanowiono domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A>. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> , wprowadzając inne wywołanie <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Ponadto należy się upewnić, że rozmiar przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak jest, datagram nie będą wysyłane i <xref:System.Net.Sockets.Socket.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Jeśli używasz protokołu połączeniowy, <xref:System.Net.Sockets.Socket.Send%2A> spowoduje zablokowanie aż żądanej liczby bajtów są wysyłane, jeśli nie ustawiono limit czasu za pomocą <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Send%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. W trybie nieblokujących <xref:System.Net.Sockets.Socket.Send%2A> może zakończyć się pomyślnie, nawet jeśli wysyła mniejsza niż liczba bajtów w przypadku żądania. Odpowiada aplikacji do śledzenia liczba bajtów wysłanych i spróbuj ponownie wykonać operację, aż aplikacja wysyła żądanej liczby bajtów. Istnieje również ma gwarancji, że dane, które wysyłasz pojawi się w sieci natychmiast. Aby zwiększyć wydajność sieci, podstawowy system może opóźnienie transmisji, dopóki nie znaczną ilość danych wychodzących są zbierane. Pomyślne wykonanie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że zasadniczego systemu miał miejsce do buforu wysyłania danych do sieci.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie oznacza, że danych zostało pomyślnie dostarczone. Jeśli ilość miejsca w buforze jest dostępna w ramach systemu transportu do przechowywania danych, które mają być przekazywane, Wyślij zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu określa przesunięcie buforu danych, rozmiar i <xref:System.Net.Sockets.SocketFlags> do wysyłania danych do połączonej <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" /> jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> nie jest prawidłową kombinację wartości.  
  
—lub— 
Wystąpił błąd systemu operacyjnego wystąpi podczas uzyskiwania dostępu do <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Obiekt ma być używany dla tej operacji asynchronicznych gniazda.</param>
        <summary>Wysyła dane asynchronicznie do połączonej <see cref="T:System.Net.Sockets.Socket" /> obiektu.</summary>
        <returns>Zwraca <see langword="true" /> przypadku oczekujących operacji We/Wy. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie na <paramref name="e" /> parametr zostanie wygenerowany po zakończeniu operacji.  
  
Zwraca <see langword="false" /> Jeśli operacji We/Wy została zakończona synchronicznie. W tym przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie na <paramref name="e" /> parametr nie zostanie wygenerowany i <paramref name="e" /> przekazano obiekt jako parametr może zbadać, natychmiast po zakończeniu wywołania metody które zwraca wynik operacji pobierania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendAsync%2A> Metoda służy do zapisywania danych wychodzących z jednego lub więcej buforów na gniazdo ukierunkowane na połączenia. Ta metoda umożliwia także, jednak na przesyłanie gniazd, które określono hosta zdalnego na operację nawiązywania połączenia.  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A> Metoda uruchamia operację asynchronicznego wysyłania do hosta zdalnego ustanowionych w <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metody.  
  
 Poniższe właściwości i zdarzenia <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiektu są wymagane do pomyślnego wywołania tej metody:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> lub <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Jeśli <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> ustawiono  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Jeśli <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> ustawiono  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Obiekt wywołujący może ustawiać <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość do każdego obiektu stanu użytkownika żądanego przed wywołaniem <xref:System.Net.Sockets.Socket.SendAsync%2A> metodę, tak, aby dane możliwe do pobierania w metody wywołania zwrotnego. Jeśli wywołanie zwrotne potrzebuje więcej informacji, niż jeden obiekt, mały klasy mogą być tworzone na potrzeby przechowywania inne wymagane informacje o stanie jako elementy członkowskie.  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A> Metoda spowoduje zgłoszenie wyjątku, jeśli użytkownik nie należy wywoływać najpierw <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.  
  
 Wywoływanie <xref:System.Net.Sockets.Socket.SendAsync%2A> metoda daje możliwość wysyłania danych w ramach oddzielnych wykonanie wątku.  
  
 Usługi przesyłania wiadomości Sockets nie przekracza maksymalny rozmiar wiadomości podstawowego dostawcy usługi Windows sockets. Jeśli dane są zbyt długie, aby przekazać niepodzielne za pomocą podstawowego dostawcy usług, są przesyłane żadne dane i <xref:System.Net.Sockets.Socket.SendAsync%2A> metoda zgłasza wyjątek <xref:System.Net.Sockets.SocketException> z <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> Ustaw natywnego kodu błędu usługi Winsock WSAEMSGSIZE (10040).  
  
 Należy pamiętać, że pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendAsync%2A> metody nie wskazuje, że danych zostało pomyślnie dostarczone.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> Lub <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> właściwości <paramref name="e" /> parametru musi odwoływać się do buforów prawidłowe. Jedna z tych właściwości, może być zestaw, ale nie obu jednocześnie.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja gniazda była już w toku przy użyciu <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiekt określony w <paramref name="e" /> parametru.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP lub nowszy jest wymagany dla tej metody.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <see cref="T:System.Net.Sockets.Socket" /> Nie jest jeszcze połączony lub nie zostały pobrane za pośrednictwem <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />, lub <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />, metoda.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą rozmiar buforu wysyłania z <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>
          <see cref="T:System.Int32" /> Zawierający rozmiar w bajtach buforu wysyłania. Wartość domyślna to 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Większy rozmiar buforu może opóźnić ujęcie trudności połączenia. Rozważ zwiększenie rozmiaru buforu transferu dużych plików, czy używasz dużej przepustowości, długom czasem oczekiwania połączenia (takiego jak dostawca satelitarnej połączenia szerokopasmowego użytkownika.)  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.SendBufferSize%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona dla operacji zestawu jest mniejszy niż 0.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wysyła plik i opcjonalnymi danymi synchronicznie połączonej <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Element <see cref="T:System.String" /> zawierający ścieżkę i nazwę pliku do wysłania. Ten parametr może być <see langword="null" />.</param>
        <summary>Wysyła plik <paramref name="fileName" /> do połączonej <see cref="T:System.Net.Sockets.Socket" /> obiekt z <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> przekazuje flagę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie wysyła plik `fileName` połączony gniazda. `flags` Parametr <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0), a `preBuffer` i `postBuffer` domyślnie parametry `null`. Jeśli `fileName` jest w katalogu lokalnym, może on zostać zidentyfikowany za pomocą tylko nazwę pliku; w przeciwnym razie należy określić pełną ścieżkę i nazwę pliku. Symbole wieloznaczne (".. \\\myfile.txt ") i nazwy udziałem UNC ("\\\\\\katalogu \shared\\\myfile.txt ") są obsługiwane. Jeśli plik nie zostanie znaleziony, wyjątek <xref:System.IO.FileNotFoundException> zgłaszany.  
  
 Ta metoda używa `TransmitFile` funkcja znalezione w interfejsie API Windows Sockets 2. Aby uzyskać więcej informacji na temat `TransmitFile` funkcji i jej flag, zobacz dokumentację Windows Sockets w bibliotece MSDN.  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> synchronicznie wysyła plik do hosta zdalnego, określony w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metody. <xref:System.Net.Sockets.Socket.SendFile%2A> można dla obu połączeń i przesyłanie protokołów.  
  
 Jeśli używasz protokołu bez połączenia z tym należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody, w przeciwnym razie <xref:System.Net.Sockets.Socket.SendFile%2A> zgłasza <xref:System.Net.Sockets.SocketException> wyjątku. Jeśli używasz protokołu z nawiązaniem połączenia, należy używać <xref:System.Net.Sockets.Socket.Connect%2A> do nawiązania połączenia z hostem zdalnym lub użyj <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenia przychodzące.  
  
 Jeśli używasz protokołu połączeniowy, <xref:System.Net.Sockets.Socket.SendFile%2A> blokuje, dopóki nie są wysyłane w pliku. W trybie nieblokujących <xref:System.Net.Sockets.Socket.SendFile%2A> może zakończyć się powodzeniem przed cały plik został wysłany. Nie ma żadnej gwarancji, które dane, które wysyłasz pojawi się w sieci natychmiast. Aby zwiększyć wydajność sieci, podstawowy system może opóźnienie transmisji, dopóki nie znaczną ilość danych wychodzących są zbierane. Pomyślne wykonanie <xref:System.Net.Sockets.Socket.SendFile%2A> metody oznacza, że zasadniczego systemu miał miejsce do buforu wysyłania danych do sieci.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy i łączy gniazdo i następnie wysyła plik do hosta zdalnego. Plik "jako" znajduje się w katalogu głównym komputera lokalnego.  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Gniazda nie jest połączony z hostem zdalnym.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiektu nie jest w trybie blokowania i nie może zaakceptować tego wywołania synchroniczne.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik <paramref name="fileName" /> nie został znaleziony.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
      </Parameters>
      <Docs>
        <param name="fileName">Element <see cref="T:System.String" /> zawierający ścieżkę i nazwę pliku do wysłania. Ten parametr może być <see langword="null" />.</param>
        <param name="preBuffer">A <see cref="T:System.Byte" /> tablicę, która zawiera dane mają być wysyłane przed wysłaniem go. Ten parametr może być <see langword="null" />.</param>
        <param name="postBuffer">A <see cref="T:System.Byte" /> tablicę, która zawiera dane mają być wysyłane po przesłaniu pliku. Ten parametr może być <see langword="null" />.</param>
        <param name="flags">Co najmniej jeden <see cref="T:System.Net.Sockets.TransmitFileOptions" /> wartości.</param>
        <summary>Wysyła plik <paramref name="fileName" /> i bufory dane do połączonej <see cref="T:System.Net.Sockets.Socket" /> obiektu przy użyciu określonego <see cref="T:System.Net.Sockets.TransmitFileOptions" /> wartość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie wymaga nazwy pliku, który chcesz wysłać oraz bitowa kombinacja <xref:System.Net.Sockets.TransmitFileOptions> wartości. `preBuffer` Parametr zawiera wszystkie dane, które mają się znajdować przed pliku. `postBuffer` zawiera dane, które chcesz obserwować pliku. Jeśli `fileName` jest w bieżącym katalogu roboczym, mogą być określane przy użyciu tylko nazwy pliku; w przeciwnym razie należy określić pełną ścieżkę i nazwę pliku. Symbole wieloznaczne (".. \\\myfile.txt ") i nazwy udziałem UNC ("\\\\\\katalogu \shared\\\myfile.txt ") są obsługiwane.  
  
 `flags` Parametr zapewnia dostawcy usług Sockets okno z dodatkowymi informacjami dotyczącymi transferu plików. Aby uzyskać więcej informacji o tym, jak używać tego parametru, zobacz <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Ta metoda używa `TransmitFile` funkcja znalezione w interfejsie API Windows Sockets 2. Aby uzyskać więcej informacji na temat `TransmitFile` funkcji i jej flag, zobacz dokumentację Windows Sockets w bibliotece MSDN.  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> synchronicznie wysyła plik do hosta zdalnego, określony w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metody. <xref:System.Net.Sockets.Socket.SendFile%2A> można dla obu połączeń i przesyłanie protokołów.  
  
 Jeśli używasz protokołu bez połączenia z tym należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody; w przeciwnym razie <xref:System.Net.Sockets.Socket.SendFile%2A> zgłasza <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu z nawiązaniem połączenia, należy używać <xref:System.Net.Sockets.Socket.Connect%2A> do nawiązania połączenia z hostem zdalnym lub użyj <xref:System.Net.Sockets.Socket.Accept%2A> zaakceptować połączenia przychodzące.  
  
 Jeśli używasz protokołu połączeniowy, <xref:System.Net.Sockets.Socket.SendFile%2A> blokuje, dopóki nie jest wysyłany cały plik. W trybie nieblokujących <xref:System.Net.Sockets.Socket.SendFile%2A> może zakończyć się powodzeniem przed cały plik został wysłany. Nie ma żadnej gwarancji, które dane, które wysyłasz pojawi się w sieci natychmiast. Aby zwiększyć wydajność sieci, podstawowy system może opóźnienie transmisji, dopóki nie znaczną ilość danych wychodzących są zbierane. Pomyślne wykonanie <xref:System.Net.Sockets.Socket.SendFile%2A> metody oznacza, że zasadniczego systemu miał miejsce do buforu wysyłania danych do sieci.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy i łączy gniazda. Plik "jako" znajduje się w katalogu głównym komputera lokalnego. W tym przykładzie utworzymy prebuffer i postbuffer danych i wysyłać je do hosta zdalnego przy użyciu pliku. Wartość domyślna <xref:System.Net.Sockets.TransmitFileOptions> są używane.  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">System operacyjny nie jest częścią systemu Windows NT lub nowszego.  
  
\- lub — 
Gniazda nie jest połączony z hostem zdalnym.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiektu nie jest w trybie blokowania i nie może zaakceptować tego wywołania synchroniczne.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik <paramref name="fileName" /> nie został znaleziony.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Obiekt ma być używany dla tej operacji asynchronicznych gniazda.</param>
        <summary>Przesyła kolekcję plików lub w pamięci buforów danych asynchronicznie do połączonej <see cref="T:System.Net.Sockets.Socket" /> obiektu.</summary>
        <returns>Zwraca <see langword="true" /> przypadku oczekujących operacji We/Wy. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie na <paramref name="e" /> parametr zostanie wygenerowany po zakończeniu operacji.  
  
Zwraca <see langword="false" /> Jeśli operacji We/Wy została zakończona synchronicznie. W tym przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie na <paramref name="e" /> parametr nie zostanie wygenerowany i <paramref name="e" /> przekazano obiekt jako parametr może zbadać, natychmiast po zakończeniu wywołania metody które zwraca wynik operacji pobierania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Metoda jest używana do wysyłania buforów danych kolekcji plików lub w pamięci do hosta zdalnego. <xref:System.Net.Sockets.Socket> Musi być podłączony do hosta zdalnego.  
  
 Jeśli <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> odwołuje się do pliku w katalogu roboczym, mogą być określane przy użyciu tylko nazwy pliku; w przeciwnym razie należy określić pełną ścieżkę i nazwę pliku. Obsługiwane są symbole wieloznaczne i nazwy udziału UNC. Jeśli plik nie zostanie znaleziony, <xref:System.IO.FileNotFoundException> zgłaszany.  
  
 Aby otrzymywać powiadomienia o zakończeniu, należy utworzyć metody wywołania zwrotnego, która implementuje EventHandler\<SocketAsyncEventArgs > delegować i dołączyć wywołanie zwrotne w celu <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> zdarzeń.  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> Właściwość `e` parametru zapewnia dostawcy usług Sockets okno z dodatkowymi informacjami dotyczącymi transferu plików. Aby uzyskać więcej informacji o tym, jak używać tego parametru, zobacz <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Poniższe właściwości i zdarzenia <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiektu są wymagane do pomyślnego wywołania tej metody:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Obiekt wywołujący może ustawiać <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość do każdego obiektu stanu użytkownika żądanego przed wywołaniem <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> metodę, tak, aby dane możliwe do pobierania w metody wywołania zwrotnego. Jeśli wywołanie zwrotne potrzebuje więcej informacji, niż jeden obiekt, mały klasy mogą być tworzone na potrzeby przechowywania inne wymagane informacje o stanie jako elementy członkowskie.  
  
 Ta metoda używa funkcji TransmitPackets znalezione w interfejsie API Windows Sockets 2. Aby uzyskać więcej informacji o funkcji TransmitPackets i jej flag zobacz dokumentację Windows Sockets w bibliotece MSDN.  
  
 Mimo że przeznaczone dla protokołów z nawiązaniem połączenia <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> metoda działa również w przypadku protokołów bez połączenia, pod warunkiem, że pierwsze wywołanie <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metoda ustanowienie domyślnego hosta zdalnego. Za pomocą protokołów bez połączenia również należy się upewnić, że rozmiar pliku przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak jest, datagram nie są wysyłane i <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> zgłasza <xref:System.Net.Sockets.SocketException> wyjątku.  
  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Metody jest zoptymalizowany pod kątem wybranego systemu operacyjnego, na którym jest używany. W przypadku wersji serwera Windows <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> metody jest zoptymalizowany pod kątem wysokiej wydajności.  
  
 W przypadku wersji klienta Windows <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> metoda zoptymalizowana pod kątem minimalne wykorzystanie pamięci i zasobów.  
  
 Korzystanie z <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> znacznik w <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> właściwość `e` parametru może dostarczać korzystny wydajności. Jeśli inicjowanie wątku <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> wywołania metody jest używana dla dużych obliczeń, jest to możliwe, chociaż jest to mało prawdopodobne, że APCs może uniemożliwić uruchamianie. Należy pamiętać, że istnieje różnica pomiędzy APCs jądra i trybu użytkownika. Jądra APCs uruchamia się, gdy wątek jest w stanie oczekiwania. Uruchamia się APCs trybu użytkownika, gdy wątek jest w stanie oczekiwania dla  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony w <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> właściwość nie została znaleziona.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja gniazda była już w toku przy użyciu <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiekt określony w <paramref name="e" /> parametru.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP lub nowszy jest wymagany dla tej metody. Ten wyjątek ma miejsce, gdy <see cref="T:System.Net.Sockets.Socket" /> nie jest połączony z hostem zdalnym.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Przesyłanie <see cref="T:System.Net.Sockets.Socket" /> jest używany i czy plik wysyłanych przekracza maksymalny rozmiar pakietu bazowego transportu.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, która określa czas, po którym synchronicznego <see cref="Overload:System.Net.Sockets.Socket.Send" /> wywołanie przekroczy limit czasu.</summary>
        <value>Wartość limitu czasu w milisekundach. Jeśli ustawisz właściwość z wartością z zakresu od 1 do 499, wartość zostanie zmieniona na 500. Wartość domyślna to 0, co oznacza nieskończony limit czasu. Określanie wartości -1 wskazuje także nieskończony limit czasu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta opcja ma zastosowanie do synchroniczne <xref:System.Net.Sockets.Socket.Send%2A> tylko wywołania. Jeśli zostanie przekroczony limit czasu, <xref:System.Net.Sockets.Socket.Send%2A> metoda zgłosi <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.SendTimeout%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona dla operacji zestawu jest mniejsza niż -1.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wysyła dane do określonego punktu końcowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> Reprezentujący obiekt docelowy danych.</param>
        <summary>Wysyła dane do określonego punktu końcowego.</summary>
        <returns>Liczba wysłanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W tym przeciążenia przesunięcia wartość domyślna to 0, liczba bajtów do wysłania wartości domyślne do rozmiaru buforu `buffer` parametru i <xref:System.Net.Sockets.SocketFlags> wartość wartość domyślna to 0.  
  
 Jeśli używasz protokołu bez połączenia, nie trzeba ustanowienie domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>. Należy to zrobić, jeśli chcesz wywołać <xref:System.Net.Sockets.Socket.Send%2A> metody. Jeśli wywołasz <xref:System.Net.Sockets.Socket.Connect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` parametru spowoduje przesłonięcie hosta zdalnego określoną wartość domyślną dla, które wysyłają tylko operacji. Ponadto nie należy wywoływać <xref:System.Net.Sockets.Socket.Bind%2A> metody, ponieważ źródłowy dostawca usługi przypisze najbardziej odpowiedni adres i port numer sieci lokalnej. Jeśli zachodzi potrzeba zidentyfikować adres i port numer przypisanej sieci lokalnej, możesz użyć <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwości po <xref:System.Net.Sockets.Socket.SendTo%2A> metoda się powiedzie.  
  
 Mimo że przeznaczone dla protokołów przesyłanie <xref:System.Net.Sockets.Socket.SendTo%2A> współpracuje również z nawiązaniem połączenia protokołów. Jeśli używasz protokołu połączeniowy nawiązania połączenia zdalnego hosta przez wywołanie metody <xref:System.Net.Sockets.Socket.Connect%2A> — metoda lub Zaakceptuj przychodzące połączenia żądanie, używając <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli nie ustanowienia lub zaakceptować połączenie zdalnego hosta <xref:System.Net.Sockets.Socket.SendTo%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Możesz także udostępnić domyślnego hosta zdalnego bez połączenia protokołu przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A> metody. W obu tych przypadkach <xref:System.Net.Sockets.Socket.SendTo%2A> zignoruje `remoteEP` parametru i tylko wysłać dane do połączonym lub domyślnego hosta zdalnego.  
  
 Blokuje gniazda spowoduje zablokowanie, dopóki wszystkie bajtów w buforze są wysyłane. Ponieważ nieblokujących <xref:System.Net.Sockets.Socket> kończy natychmiast, jego może nie wysyłać wszystkich bajtów `buffer`. Odpowiada aplikacji do śledzenia liczba bajtów wysłanych i spróbuj ponownie wykonać operację, aż aplikacja wysyła wszystkie bajty `buffer`. Istnieje również ma gwarancji, że dane, które wysyłasz pojawi się w sieci natychmiast. Aby zwiększyć wydajność sieci, podstawowy system może opóźnienie transmisji, dopóki nie znaczną ilość danych wychodzących są zbierane. Pomyślne wykonanie <xref:System.Net.Sockets.Socket.SendTo%2A> metody oznacza, że zasadniczego systemu miał miejsce do buforu wysyłania danych do sieci.  
  
 Jeśli używasz protokołu bez połączenia w trybie blokowania <xref:System.Net.Sockets.Socket.SendTo%2A> zablokuje do momentu wysłania jest datagram. Jeśli chcesz wysyłać dane do adres emisji, najpierw musisz wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody i ustaw gniazda opcję <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Ponadto należy się upewnić, że liczba bajtów wysłanych nie przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak jest, datagram nie będą wysyłane i <xref:System.Net.Sockets.Socket.SendTo%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod wysyła wymiany datagramów na określony host zdalny.  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> Reprezentujący lokalizację docelową dla danych.</param>
        <summary>Wysyła dane do określonego punktu końcowego przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba wysłanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W tym przeciążenia przesunięcia wartość domyślna to 0, a liczba bajtów do wysłania wartości domyślne do rozmiaru buforu `buffer`. Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketflags` parametru, dane są wysyłane, nie będą kierowane.  
  
 Jeśli używasz protokołu bez połączenia, nie trzeba ustanowienie domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>. Należy to zrobić, jeśli chcesz wywołać <xref:System.Net.Sockets.Socket.Send%2A> metody. Jeśli wywołasz <xref:System.Net.Sockets.Socket.Connect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` parametru spowoduje przesłonięcie hosta zdalnego określoną wartość domyślną dla, które wysyłają tylko operacji. Ponadto nie należy wywoływać <xref:System.Net.Sockets.Socket.Bind%2A> metody, ponieważ źródłowy dostawca usługi przypisze najbardziej odpowiedni adres i port numer sieci lokalnej. Jeśli zachodzi potrzeba zidentyfikować adres i port numer przypisanej sieci lokalnej, możesz użyć <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwości po <xref:System.Net.Sockets.Socket.SendTo%2A> metoda się powiedzie.  
  
 Mimo że przeznaczone dla protokołów przesyłanie <xref:System.Net.Sockets.Socket.SendTo%2A> współpracuje również z nawiązaniem połączenia protokołów. Jeśli używasz protokołu połączeniowy nawiązania połączenia zdalnego hosta przez wywołanie metody <xref:System.Net.Sockets.Socket.Connect%2A> — metoda lub Zaakceptuj przychodzące połączenia żądanie, używając <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli nie ustanowienia lub zaakceptować połączenie zdalnego hosta <xref:System.Net.Sockets.Socket.SendTo%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Możesz także udostępnić domyślnego hosta zdalnego bez połączenia protokołu przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A> metody. W obu tych przypadkach <xref:System.Net.Sockets.Socket.SendTo%2A> zignoruje `remoteEP` parametru i tylko wysłać dane do połączonym lub domyślnego hosta zdalnego.  
  
 Blokuje sockets zablokuje aż do żądanej wszystkich bajtów `buffer` są wysyłane. Ponieważ nieblokujących <xref:System.Net.Sockets.Socket> kończy natychmiast, jego może nie wysyłać wszystkich bajtów `buffer`. Odpowiada aplikacji do śledzenia liczba bajtów wysłanych i spróbuj ponownie wykonać operację, aż aplikacja wysyła wszystkie bajty `buffer`. Istnieje również ma gwarancji, że dane, które wysyłasz pojawi się w sieci natychmiast. Aby zwiększyć wydajność sieci, podstawowy system może opóźnienie transmisji, dopóki nie znacznej ilości wyjściowego przerywaj dane są zbierane. Pomyślne wykonanie <xref:System.Net.Sockets.Socket.SendTo%2A> metody oznacza, że zasadniczego systemu miał miejsce do buforu wysyłania danych do sieci.  
  
 Jeśli używasz protokołu bez połączenia w trybie blokowania <xref:System.Net.Sockets.Socket.SendTo%2A> zablokuje do momentu wysłania jest datagram. Jeśli chcesz wysyłać dane do adres emisji, najpierw musisz wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody i ustaw gniazda opcję <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Ponadto należy się upewnić, że liczba bajtów wysłanych nie przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak jest, datagram nie będą wysyłane i <xref:System.Net.Sockets.Socket.SendTo%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod wysyła wymiany datagramów na określony host zdalny. <xref:System.Net.Sockets.SocketFlags> są przekazywane do <xref:System.Net.Sockets.Socket.SendTo%2A> metody.  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="size">Liczba bajtów do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> Reprezentujący lokalizację docelową dla danych.</param>
        <summary>Wysyła określoną liczbę bajtów danych do określonego punktu końcowego przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba wysłanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W tym przeciążenia buforu przesunięcia wartość domyślna to 0. Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketflags` parametru, dane są wysyłane, nie będą kierowane.  
  
 Jeśli używasz protokołu bez połączenia, nie trzeba ustanowienie domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>. Należy to zrobić, jeśli chcesz wywołać <xref:System.Net.Sockets.Socket.Send%2A> metody. Jeśli wywołasz <xref:System.Net.Sockets.Socket.Connect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` parametru spowoduje przesłonięcie hosta zdalnego określoną wartość domyślną dla, które wysyłają tylko operacji. Ponadto nie należy wywoływać <xref:System.Net.Sockets.Socket.Bind%2A> metody, ponieważ źródłowy dostawca usługi przypisze najbardziej odpowiedni adres i port numer sieci lokalnej. Jeśli zachodzi potrzeba zidentyfikować adres i port numer przypisanej sieci lokalnej, możesz użyć <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwości po <xref:System.Net.Sockets.Socket.SendTo%2A> metoda się powiedzie.  
  
 Mimo że przeznaczone dla protokołów przesyłanie <xref:System.Net.Sockets.Socket.SendTo%2A> współpracuje również z nawiązaniem połączenia protokołów. Jeśli używasz protokołu połączeniowy nawiązania połączenia zdalnego hosta przez wywołanie metody <xref:System.Net.Sockets.Socket.Connect%2A> — metoda lub Zaakceptuj przychodzące połączenia żądanie, używając <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli nie ustanowienia lub zaakceptować połączenie zdalnego hosta <xref:System.Net.Sockets.Socket.SendTo%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Możesz także udostępnić domyślnego hosta zdalnego bez połączenia protokołu przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A> metody. W obu tych przypadkach <xref:System.Net.Sockets.Socket.SendTo%2A> zignoruje `remoteEP` parametru i tylko wysłać dane do połączonym lub domyślnego hosta zdalnego.  
  
 Blokowanie sockets zablokuje aż wysłaniem żądanej liczby bajtów. Ponieważ nieblokujących <xref:System.Net.Sockets.Socket> kończy natychmiast, jego mogą nie wysyłać wszystkich bajtów wymaganych w ramach jednej operacji. Odpowiada aplikacji do śledzenia liczba bajtów wysłanych i spróbuj ponownie wykonać operację, aż aplikacja wysyła żądanej liczby bajtów. Istnieje również ma gwarancji, że dane, które wysyłasz pojawi się w sieci natychmiast. Aby zwiększyć wydajność sieci, podstawowy system może opóźnienie transmisji, dopóki nie znacznej ilości wyjściowego przerywaj dane są zbierane. Pomyślne wykonanie <xref:System.Net.Sockets.Socket.SendTo%2A> metody oznacza, że zasadniczego systemu miał miejsce do buforu wysyłania danych do sieci.  
  
 Jeśli używasz protokołu bez połączenia w trybie blokowania <xref:System.Net.Sockets.Socket.SendTo%2A> zablokuje do momentu wysłania jest datagram. Jeśli chcesz wysyłać dane do adres emisji, najpierw musisz wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody i ustaw gniazda opcję <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Ponadto należy się upewnić, że liczba bajtów wysłanych nie przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak jest, datagram nie będą wysyłane i <xref:System.Net.Sockets.Socket.SendTo%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod wysyła wymiany datagramów na określony host zdalny. Rozmiar i <xref:System.Net.Sockets.SocketFlags> są przekazywane do <xref:System.Net.Sockets.Socket.SendTo%2A> metody.  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Określony <paramref name="size" /> przekracza rozmiar okna <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="offset">Pozycja w buforze danych, od którego należy rozpocząć wysyłanie danych.</param>
        <param name="size">Liczba bajtów do wysłania.</param>
        <param name="socketFlags">Bitowa kombinacja <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> Reprezentujący lokalizację docelową dla danych.</param>
        <summary>Wysyła określoną liczbę bajtów danych do określonego punktu końcowego, zaczynając od określonej lokalizacji w buforze i przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba wysłanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W tego przeciążenia, jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketflags` parametru, dane są wysyłane, nie będą kierowane.  
  
 Jeśli używasz protokołu bez połączenia, nie trzeba ustanowienie domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.Connect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>. Należy to zrobić, jeśli chcesz wywołać <xref:System.Net.Sockets.Socket.Send%2A> metody. Jeśli wywołasz <xref:System.Net.Sockets.Socket.Connect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` parametru spowoduje przesłonięcie hosta zdalnego określoną wartość domyślną dla, które wysyłają tylko operacji. Ponadto nie należy wywoływać <xref:System.Net.Sockets.Socket.Bind%2A> metody, ponieważ źródłowy dostawca usługi przypisze najbardziej odpowiedni adres i port numer sieci lokalnej. Jeśli zachodzi potrzeba zidentyfikować adres i port numer przypisanej sieci lokalnej, możesz użyć <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwości po <xref:System.Net.Sockets.Socket.SendTo%2A> metoda się powiedzie.  
  
 Mimo że przeznaczone dla protokołów przesyłanie <xref:System.Net.Sockets.Socket.SendTo%2A> współpracuje również z nawiązaniem połączenia protokołów. Jeśli używasz protokołu połączeniowy nawiązania połączenia zdalnego hosta przez wywołanie metody <xref:System.Net.Sockets.Socket.Connect%2A> — metoda lub Zaakceptuj przychodzące połączenia żądanie, używając <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli nie ustanowienia lub zaakceptować połączenie zdalnego hosta <xref:System.Net.Sockets.Socket.SendTo%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Możesz także udostępnić domyślnego hosta zdalnego bez połączenia protokołu przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A> metody. W obu tych przypadkach <xref:System.Net.Sockets.Socket.SendTo%2A> zignoruje `remoteEP` parametru i tylko wysłać dane do połączonym lub domyślnego hosta zdalnego.  
  
 Blokowanie sockets zablokuje aż wysłaniem żądanej liczby bajtów. Ponieważ nieblokującej na poziomie <xref:System.Net.Sockets.Socket> kończy natychmiast, jego mogą nie wysyłać wszystkich bajtów wymaganych w ramach jednej operacji. Odpowiada za swoje aplikacje do śledzenia liczba bajtów wysłanych i spróbuj ponownie wykonać operację, aż aplikacja wysyła żądanej liczby bajtów. Istnieje również ma gwarancji, że dane, które wysyłasz pojawi się w sieci natychmiast. Aby zwiększyć wydajność sieci, podstawowy system może opóźnienie transmisji, dopóki nie znacznej ilości wyjściowego przerywaj dane są zbierane. Pomyślne wykonanie <xref:System.Net.Sockets.Socket.SendTo%2A> metody oznacza, że zasadniczego systemu miał miejsce do buforu wysyłania danych do sieci.  
  
 Jeśli używasz protokołu bez połączenia w trybie blokowania <xref:System.Net.Sockets.Socket.SendTo%2A> zablokuje do momentu wysłania jest datagram. Jeśli chcesz wysyłać dane do adres emisji, najpierw musisz wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody i ustaw gniazda opcję <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Ponadto należy się upewnić, że rozmiar przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak jest, datagram nie będą wysyłane i <xref:System.Net.Sockets.Socket.SendTo%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod wysyła wymiany datagramów na określony host zdalny. Przesunięcie, rozmiar, a <xref:System.Net.Sockets.SocketFlags> są przekazywane do <xref:System.Net.Sockets.Socket.SendTo%2A> metody.  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" /> jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="size" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> nie jest prawidłową kombinację wartości.  
  
—lub— 
Wystąpił błąd systemu operacyjnego wystąpi podczas uzyskiwania dostępu do <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący na stosie wywołań nie ma wymaganych uprawnień.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Obiekt ma być używany dla tej operacji asynchronicznych gniazda.</param>
        <summary>Asynchronicznie wysyła dane do określonego hosta zdalnego.</summary>
        <returns>Zwraca <see langword="true" /> przypadku oczekujących operacji We/Wy. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenie na <paramref name="e" /> parametr zostanie wygenerowany po zakończeniu operacji.  
  
Zwraca <see langword="false" /> Jeśli operacji We/Wy została zakończona synchronicznie. W tym przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenie na <paramref name="e" /> parametr nie zostanie wygenerowany i <paramref name="e" /> przekazano obiekt jako parametr może zbadać, natychmiast po zakończeniu wywołania metody które zwraca wynik operacji pobierania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendToAsync%2A> Metoda uruchamia operację asynchronicznego wysyłania do hosta zdalnego, określony w <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> właściwość `e` parametru. Wywoływanie <xref:System.Net.Sockets.Socket.SendToAsync%2A> metoda daje możliwość wysyłania danych w ramach oddzielnych wykonanie wątku. Chociaż ta metoda jest przeznaczona dla protokołów przesyłanie <xref:System.Net.Sockets.Socket.SendToAsync%2A> współpracuje z protokołami przesyłanie i ukierunkowane na połączenia.  
  
 Aby otrzymywać powiadomienia o zakończeniu, należy utworzyć metody wywołania zwrotnego, która implementuje EventHandler\<SocketAsyncEventArgs > delegować i dołączyć wywołanie zwrotne w celu <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> zdarzeń.  
  
 Poniższe właściwości i zdarzenia <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiektu są wymagane do pomyślnego wywołania tej metody:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Obiekt wywołujący może ustawiać <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwość do każdego obiektu stanu użytkownika żądanego przed wywołaniem <xref:System.Net.Sockets.Socket.SendToAsync%2A> metodę, tak, aby dane możliwe do pobierania w metody wywołania zwrotnego. Jeśli wywołanie zwrotne potrzebuje więcej informacji, niż jeden obiekt, mały klasy mogą być tworzone na potrzeby przechowywania inne wymagane informacje o stanie jako elementy członkowskie.  
  
 Jeśli używasz protokołu z nawiązaniem połączenia, najpierw musisz wywołać <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metody. W przeciwnym razie <xref:System.Net.Sockets.Socket.SendToAsync%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Korzystając z protokołem połączeniowy <xref:System.Net.Sockets.Socket.SendToAsync%2A> metoda zignoruje <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> właściwości i wysyła dane do <xref:System.Net.EndPoint?displayProperty=nameWithType> ustanowionych w <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A> , lub <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metody.  
  
 Jeśli używasz protokołu bez połączenia, nie trzeba ustanowienie domyślnego hosta zdalnego przy użyciu <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.SendToAsync%2A>. Należy to zrobić, jeśli chcesz wywołać <xref:System.Net.Sockets.Socket.BeginSend%2A> lub <xref:System.Net.Sockets.Socket.SendAsync%2A> metody. Jeśli wywołasz <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.SendToAsync%2A>, <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> właściwość spowoduje przesłonięcie hosta zdalnego określoną wartość domyślną dla, które wysyłają tylko operacji. Ponadto nie należy wywoływać <xref:System.Net.Sockets.Socket.Bind%2A> metody. W tym przypadku podstawowego dostawcy usług przypisze najodpowiedniejsze lokalnej sieci IP adres i numer portu. Użyj numeru portu o wartości zero, jeśli chcesz, aby podstawowego dostawcy usług do wybrania wolny port. Jeśli zachodzi potrzeba zidentyfikować przypisanej sieci lokalnej IP adres i numer portu, możesz użyć <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwości po <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> zasygnalizowania zdarzenia i skojarzone obiekty delegowane są wywoływane.  
  
 Jeśli chcesz wysyłać dane do adres emisji, najpierw musisz wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody i ustaw gniazda opcja dla <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> na wartość true. Ponadto należy się upewnić, że rozmiar buforu przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak jest, datagram nie będą wysyłane i <xref:System.Net.Sockets.Socket.SendToAsync%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Jeśli określono flagę DontRoute <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> właściwość, dane są wysyłane, nie będą kierowane.  
  
 Usługi przesyłania wiadomości Sockets należy uważać aby nie przekracza maksymalny rozmiar komunikatu transportu źródłowego. Jeśli rozmiar buforu przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług, nie są wysyłane datagram i <xref:System.Net.Sockets.Socket.SendToAsync%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendToAsync%2A> metody nie wskazuje, że danych zostało pomyślnie dostarczone.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> Nie może mieć wartości null.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja gniazda była już w toku przy użyciu <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiekt określony w <paramref name="e" /> parametru.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP lub nowszy jest wymagany dla tej metody.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Protokół określony jest ukierunkowane na połączenia, ale <see cref="T:System.Net.Sockets.Socket" /> nie jest jeszcze podłączony.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" />
      </Parameters>
      <Docs>
        <param name="level">Poziom ochrony IP można ustawić w tym gnieździe.</param>
        <summary>Ustaw poziom ochrony adresów IP dla gniazda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> Metoda umożliwia ograniczenie gniazdo IPv6 lub adres IP do nasłuchiwania w określonym zakresie, takie jak adresy z takimi samymi link lokalny lub lokacji lokalnej prefiks. Ta opcja gniazda umożliwia aplikacjom ograniczają dostęp do gniazda IPv6 lub adres IP. Takie ograniczenia, Włącz aplikacji uruchomionej w prywatnej sieci lokalnej po prostu i niezawodnie zabezpieczyć się przed atakami zewnętrznych. Ta opcja gniazda można również usunąć ograniczenia dostępu, jeśli `level` parametr ma wartość <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>. Ta opcja gniazda rozszerza się lub umożliwia zawężenie zakresu nasłuchiwania gniazda, dzięki czemu nieograniczonego dostępu z publicznych i prywatnych użytkowników, gdy jest to konieczne, lub ograniczać dostęp tylko do tej samej lokacji, zgodnie z wymaganiami.  
  
 Ta opcja gniazda zdefiniował poziomów ochrony, określone w <xref:System.Net.Sockets.IPProtectionLevel> wyliczenia.  
  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> Metoda jest używana do włączania lub wyłączania przechodzenie adresów sieciowych (NAT) dla <xref:System.Net.Sockets.Socket> wystąpienia. Przechodzenie translatora adresów Sieciowych, mogą być udostępniane przy użyciu protokołu Teredo, 6to4 lub tunel protokołu ISATAP.  
  
 Gdy `level` parametr ma wartość <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, lub <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, jawnie wyłącza Przechodzenie translatora adresów Sieciowych dla <xref:System.Net.Sockets.Socket> wystąpienia.  
  
 Gdy `level` parametr ma wartość <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, może to umożliwić Przechodzenie translatora adresów Sieciowych dla <xref:System.Net.Sockets.Socket> w zależności od reguły zapory w miejscu w systemie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="level" /> Parametr nie może być <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />. Poziom ochrony IP nie można ustawić nieokreślony.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Net.Sockets.AddressFamily" /> Gniazda musi być albo <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zestawy <see cref="T:System.Net.Sockets.Socket" /> opcji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Jedną z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</param>
        <param name="optionName">Jedną z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</param>
        <param name="optionValue">Wartość tej opcji, reprezentowane jako <see cref="T:System.Boolean" />.</param>
        <summary>Ustawia określony <see cref="T:System.Net.Sockets.Socket" /> opcji określonej <see cref="T:System.Boolean" /> wartość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> opcje określają zachowanie bieżącego <xref:System.Net.Sockets.Socket>. Ustaw `optionValue` do `true` Aby włączyć opcję lub `false` wyłączyć opcję.  
  
 <xref:System.Net.Sockets.Socket> opcje są pogrupowane według poziomu wsparcia protokołu.  
  
 Poniżej wymieniono różne <xref:System.Net.Sockets.Socket> opcje, które można ustawić za pomocą tego przeciążenia. Te opcje są pogrupowane według odpowiednie <xref:System.Net.Sockets.SocketOptionLevel> wartość. Jeśli planujesz skonfigurowania któregokolwiek z tych opcji, należy użyć odpowiedniej <xref:System.Net.Sockets.SocketOptionLevel> wartość `optionLevel` parametru. Opcja wybrana zostanie opcja musi być określona w `optionName` parametru. Jeśli chcesz odczytać bieżące wartości któregokolwiek z opcji na liście, użyj <xref:System.Net.Sockets.Socket.GetSocketOption%2A> metody.  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 Aby uzyskać więcej informacji na temat tych opcji, zobacz <xref:System.Net.Sockets.SocketOptionName> wyliczenia.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException> wyjątek, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera gniazdo i umożliwia `DontLinger` i `OutOfBandInline` gniazda opcje.  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Jedną z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</param>
        <param name="optionName">Jedną z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</param>
        <param name="optionValue">Tablica typu <see cref="T:System.Byte" /> reprezentujący wartość opcji.</param>
        <summary>Ustawia określony <see cref="T:System.Net.Sockets.Socket" /> opcji z podaną wartością w postaci tablicy bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> opcje określają zachowanie bieżącego <xref:System.Net.Sockets.Socket>. Użyj tego przeciążenia, aby ustawić te <xref:System.Net.Sockets.Socket> opcje, które wymagają tablicy typu byte jako wartość opcji.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy kod ustawia przykład <xref:System.Net.Sockets.LingerOption> i <xref:System.Net.Sockets.Socket.Send%2A> wartości limitu czasu.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Jedną z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</param>
        <param name="optionName">Jedną z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</param>
        <param name="optionValue">Wartość opcji.</param>
        <summary>Ustawia określony <see cref="T:System.Net.Sockets.Socket" /> możliwość określonej liczby całkowitej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> opcje określają zachowanie bieżącego <xref:System.Net.Sockets.Socket>. Za pomocą skorzystać z opcji <xref:System.Boolean> typ danych, określ wartość różną od zera, aby włączyć opcję i zero wartość, aby wyłączyć opcję. Z opcji z typem danych integer określ odpowiednią wartość. <xref:System.Net.Sockets.Socket> opcje są pogrupowane według poziomu wsparcia protokołu.  
  
 Poniżej wymieniono różne <xref:System.Net.Sockets.Socket> opcje, które można ustawić za pomocą tego przeciążenia. Te opcje są pogrupowane według odpowiednie <xref:System.Net.Sockets.SocketOptionLevel>. Jeśli planujesz skonfigurowania któregokolwiek z tych opcji, należy użyć odpowiedniej <xref:System.Net.Sockets.SocketOptionLevel> dla `optionLevel` parametru. Opcja wybrana zostanie opcja musi być określona w `optionName` parametru. Jeśli chcesz odczytać bieżące wartości któregokolwiek z opcji na liście, użyj <xref:System.Net.Sockets.Socket.GetSocketOption%2A> metody.  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 Aby uzyskać więcej informacji na temat tych opcji, zobacz <xref:System.Net.Sockets.SocketOptionName> wyliczenia.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy kod ustawia przykład <xref:System.Net.Sockets.LingerOption> i <xref:System.Net.Sockets.Socket.Send%2A> wartości limitu czasu.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Jedną z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</param>
        <param name="optionName">Jedną z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</param>
        <param name="optionValue">A <see cref="T:System.Net.Sockets.LingerOption" /> lub <see cref="T:System.Net.Sockets.MulticastOption" /> zawierający wartość opcji.</param>
        <summary>Ustawia określony <see cref="T:System.Net.Sockets.Socket" /> możliwość określonej wartości, reprezentowany przez obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> opcje określają zachowanie bieżącego <xref:System.Net.Sockets.Socket>. Użyj tego przeciążenia, aby ustawić <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, i <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> opcje. Aby uzyskać <xref:System.Net.Sockets.SocketOptionName.Linger> opcji, należy użyć <xref:System.Net.Sockets.Socket> dla `optionLevel` parametru. Aby uzyskać <xref:System.Net.Sockets.SocketOptionName.AddMembership> i <xref:System.Net.Sockets.SocketOptionName.DropMembership>, użyj <xref:System.Net.Sockets.SocketOptionLevel.IP>. Jeśli chcesz uzyskać bieżącą wartość żadnej z powyższych opcji, należy użyć <xref:System.Net.Sockets.Socket.GetSocketOption%2A> metody.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
   
  
## Examples  
 Poniższy kod ustawia przykład <xref:System.Net.Sockets.LingerOption> i <xref:System.Net.Sockets.Socket.Send%2A> wartości limitu czasu.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="optionValue" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">Jedną z <see cref="T:System.Net.Sockets.SocketShutdown" /> wartości, które określa operację, nie jest już dozwolona.</param>
        <summary>Wyłącza wysyła i odbiera na <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystając z nawiązaniem połączenia <xref:System.Net.Sockets.Socket>, zawsze wywołuj <xref:System.Net.Sockets.Socket.Shutdown%2A> metoda przed zamknięciem <xref:System.Net.Sockets.Socket>. Zapewnia to, że wszystkie dane wysyłany i odbierany na połączone gniazdo przed jego zamknięciem.  
  
 Wywołaj <xref:System.Net.Sockets.Socket.Close%2A> metody, aby zwolnić wszystkie zasoby zarządzane i niezarządzane skojarzone z <xref:System.Net.Sockets.Socket>. Nie należy podejmować próby ponownego użycia <xref:System.Net.Sockets.Socket> po zamknięciu.  
  
 W poniższej tabeli przedstawiono <xref:System.Net.Sockets.SocketShutdown> wartości wyliczenia, które są prawidłowe dla `how` parametru.  
  
|Wartość|Opis|  
|-----------|-----------------|  
|Wyślij|Wyłączyć funkcję wysyłania w tym <xref:System.Net.Sockets.Socket>.|  
|Odbieranie|Wyłącz odbieranie w tym <xref:System.Net.Sockets.Socket>.|  
|Oba|Wyłącz zarówno wysyłanie i odbieranie w tym <xref:System.Net.Sockets.Socket>.|  
  
 Ustawienie `how` do <xref:System.Net.Sockets.SocketShutdown.Send> Określa, że kolejne wywołania <xref:System.Net.Sockets.Socket.Send%2A> nie są dozwolone. Jeśli używasz przesyłanie <xref:System.Net.Sockets.Socket>, określanie <xref:System.Net.Sockets.SocketShutdown.Send> odniesie żadnego skutku.  
  
 Ustawienie `how` do <xref:System.Net.Sockets.SocketShutdown.Receive> Określa, że kolejne wywołania <xref:System.Net.Sockets.Socket.Receive%2A> nie są dozwolone. To nie ma wpływu na niższych warstwach protokołu. Jeśli używasz protokołu z nawiązaniem połączenia, połączenie zostanie przerwane, jeśli istnieje jeden z następujących warunków po wywołaniu <xref:System.Net.Sockets.Socket.Shutdown%2A> :  
  
-   Dane są przychodzące buforu sieci oczekiwania do odbioru.  
  
-   Większej ilości danych jest już dostępna.  
  
 Jeśli używasz protokołu przesyłanie datagramy są zaakceptowane i Zakolejkowane. Jednak jeśli ilość miejsca w buforze jest dostępna w dodatkowych datagramy przychodzące, zostaną odrzucone i żaden błąd nie zostanie zwrócony przez nadawcę. Za pomocą <xref:System.Net.Sockets.Socket.Shutdown%2A> na przesyłanie <xref:System.Net.Sockets.Socket> nie jest zalecane.  
  
 Ustawienie `how` do <xref:System.Net.Sockets.SocketShutdown.Both> wyłącza zarówno wysyła i odbiera zgodnie z powyższym opisem.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException> podczas wywoływania <xref:System.Net.Sockets.Socket.Shutdown%2A> metody, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.Sockets.Socket.Shutdown%2A> wyłączyć <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Jedną z <see cref="T:System.Net.Sockets.SocketType" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SocketType%2A> jest tylko do odczytu i jest ustawiona, gdy <xref:System.Net.Sockets.Socket> zostanie utworzony.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, i <xref:System.Net.Sockets.ProtocolType> do konsoli.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy obsługa protokołu IPv4 jest dostępna i włączona na bieżącym hoście.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący host obsługuje protokół IPv4; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 System operacyjny może obsługiwać protokoły IPv4 i IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy platforma obsługuje protokół IPv6 dla niektórych przestarzałych <see cref="T:System.Net.Dns" /> elementów członkowskich.</summary>
        <value>
          <see langword="true" /> Jeśli w ramach obsługuje protokół IPv6 dla niektórych przestarzałych <see cref="T:System.Net.Dns" /> metod; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 System operacyjny może obsługiwać protokoły IPv4 i IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą wartość czasu wygaśnięcia (TTL) protokołu internetowego (IP) pakiety wysłane przez <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Wartość czasu wygaśnięcia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość TTL wskazuje maksymalną liczbę routerów, które mogą przechodzić przez pakiet, zanim routera odrzuca pakiet i kontroli komunikat ICMP (Internet Protocol) "Przekroczono czas wygaśnięcia" komunikat o błędzie jest zwracany przez nadawcę.  
  
 Wartość TTL może być równa wartości z zakresu od 0 do 255. Gdy ta właściwość nie jest ustawiona, wartość domyślna TTL dla gniazda wynosi 32.  
  
 Ustawienie tej właściwości na gniazdo Transmission Control Protocol (TCP) jest ignorowana przez stos TCP/IP, jeśli pomyślnie połączenie zostało ustanowione przy użyciu gniazda.  
  
 Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć Windows Sockets w wersji 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Net.Sockets.Socket.Ttl%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Nie można ustawić wartości TTL liczbą ujemną.</exception>
        <exception cref="T:System.NotSupportedException">Tę właściwość można ustawić tylko dla gniazda w <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> rodziny.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Ten błąd jest także zwracany, jeśli nastąpiła próba można ustawić czasu wygaśnięcia do wartości większej niż 255.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy gniazda należy używać tylko trybu nakładających się operacji We/Wy.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.Socket" /> używa tylko nakładających się operacji We/Wy; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw tę właściwość na `true` dla <xref:System.Net.Sockets.Socket> zamierzasz wywołać <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>. W przeciwnym razie struktura może przydzielić do portu ukończenia gniazda, w której będzie zabraniają używania <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Gniazda została powiązana do portu ukończenia.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
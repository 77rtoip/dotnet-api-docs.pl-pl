<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cd8d44e0c7c90628715e33486e5644cee71c5205" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34254805" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Implementuje interfejs Berkeley gniazda.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> Klasa zawiera bogaty zestaw metod i właściwości dla komunikacji sieciowej. <xref:System.Net.Sockets.Socket> Klasa umożliwia wykonywanie zarówno synchroniczne i transferu asynchronicznego danych przy użyciu dowolnej z protokołów komunikacyjnych na liście <xref:System.Net.Sockets.ProtocolType> wyliczenia.  
  
 <xref:System.Net.Sockets.Socket> Klasy następuje wzorzec nazewnictwa .NET Framework dla metod asynchronicznych. Na przykład synchroniczne <xref:System.Net.Sockets.Socket.Receive%2A> metody odpowiada asynchroniczną <xref:System.Net.Sockets.Socket.BeginReceive%2A> i <xref:System.Net.Sockets.Socket.EndReceive%2A> metody.  
  
 Jeśli aplikacja wymaga tylko jednego wątku podczas wykonywania, należy użyć następujących metod, które są przeznaczone dla trybu operacji synchronicznych.  
  
-   Jeśli korzystasz z nawiązaniem połączenia protokołu takiego, jak TCP, serwer może nasłuchiwać połączeń za pomocą <xref:System.Net.Sockets.Socket.Listen%2A> metody. <xref:System.Net.Sockets.Socket.Accept%2A> Procesów metody wszystkie połączenia przychodzące żądania i zwraca <xref:System.Net.Sockets.Socket> można nawiązać połączenia z hostem zdalnym danych. Użyj tej zwrócił <xref:System.Net.Sockets.Socket> do wywołania <xref:System.Net.Sockets.Socket.Send%2A> lub <xref:System.Net.Sockets.Socket.Receive%2A> metody. Wywołanie <xref:System.Net.Sockets.Socket.Bind%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.Listen%2A> metodę, jeśli chcesz określić lokalny adres IP i port numer. Numer portu równą zero, należy użyć, jeśli źródłowy dostawca usługi można przypisać portu wolne dla Ciebie. Jeśli chcesz połączyć się z hostem nasłuchiwania wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> metody. Do przekazywania danych, należy wywołać <xref:System.Net.Sockets.Socket.Send%2A> lub <xref:System.Net.Sockets.Socket.Receive%2A> metody.  
  
-   Jeśli używasz przesyłanie protokołu, takie jak UDP, nie należy do nasłuchiwania na wszystkich połączeń. Wywołanie <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodę, aby zaakceptować datagramów przychodzących. Użyj <xref:System.Net.Sockets.Socket.SendTo%2A> metody do przesyłania datagramów z hostem zdalnym.  
  
 Aby przetwarzać komunikacji przy użyciu oddzielnych wątkach podczas wykonywania, należy użyć następujących metod, które są przeznaczone dla trybu operacji asynchronicznej.  
  
-   Jeśli korzystasz z nawiązaniem połączenia protokołu takiego, jak TCP, użyj <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, i <xref:System.Net.Sockets.Socket.EndConnect%2A> metody nawiązać połączenia z hostem nasłuchiwania. Użyj <xref:System.Net.Sockets.Socket.BeginSend%2A> i <xref:System.Net.Sockets.Socket.EndSend%2A> lub <xref:System.Net.Sockets.Socket.BeginReceive%2A> i <xref:System.Net.Sockets.Socket.EndReceive%2A> metody do przekazywania danych asynchronicznie. Przychodzące żądania połączenia mogą być przetwarzane przy użyciu <xref:System.Net.Sockets.Socket.BeginAccept%2A> i <xref:System.Net.Sockets.Socket.EndAccept%2A>.  
  
-   Jeśli używasz przesyłanie protokołu, takie jak UDP, możesz użyć <xref:System.Net.Sockets.Socket.BeginSendTo%2A> i <xref:System.Net.Sockets.Socket.EndSendTo%2A> do przesyłania datagramów, i <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> i <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> do odbierania datagramów.  
  
 Jeśli wykonania wielu operacji asynchronicznych na gnieździe, nie zawsze są wykonywane w kolejności, w którym są uruchomione.  
  
 Po zakończeniu wysyłania i odbierania danych, użyj <xref:System.Net.Sockets.Socket.Shutdown%2A> metodę, aby wyłączyć <xref:System.Net.Sockets.Socket>. Po wywołaniu <xref:System.Net.Sockets.Socket.Shutdown%2A>, wywołaj <xref:System.Net.Sockets.Socket.Close%2A> metodę, aby zwolnić wszystkie zasoby skojarzone z <xref:System.Net.Sockets.Socket>.  
  
 <xref:System.Net.Sockets.Socket> Klasa pozwala na skonfigurowanie Twojego <xref:System.Net.Sockets.Socket> przy użyciu <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody. Pobrać te ustawienia przy użyciu <xref:System.Net.Sockets.Socket.GetSocketOption%2A> metody.  
  
> [!NOTE]
>  Jeśli pisania aplikacji stosunkowo proste i nie wymagają maksymalną wydajność, należy rozważyć użycie <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, i <xref:System.Net.Sockets.UdpClient>. Te klasy udostępniają interfejs prostszy i bardziej przyjazny dla użytkownika do <xref:System.Net.Sockets.Socket> komunikacji.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład sposobu <xref:System.Net.Sockets.Socket> klasa może być używana do wysyłania danych do serwera HTTP i odbierania odpowiedzi. W tym przykładzie blokuje do momentu otrzymania całej strony.  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Do nawiązywania połączenia wychodzącego, lub zaakceptować żądania przychodzącego.</permission>
    <threadsafe>Wystąpienia tej klasy są bezpieczne dla wątków.</threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.Socket" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" />
      </Parameters>
      <Docs>
        <param name="socketInformation">Informacje dotyczące gniazda zwracane przez <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.Socket" /> przy użyciu określonego wartość zwracana z <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli należy wywołać <xref:System.Net.Sockets.Socket.%23ctor%2A> konstruktora wiele razy przy użyciu tej samej tablicy bajtów jako argument dla każdego wywołania, spowoduje utworzenie wielu zarządzanych <xref:System.Net.Sockets.Socket>s z tym samym gnieździe podstawowej. Takie rozwiązanie jest zalecane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="socketType">Jeden z <see cref="T:System.Net.Sockets.SocketType" /> wartości.</param>
        <param name="protocolType">Jeden z <see cref="T:System.Net.Sockets.ProtocolType" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.Socket" /> przy użyciu podanego typu gniazda i protokołu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `socketType` Parametr określa typ <xref:System.Net.Sockets.Socket> klasy i `protocolType` parametr określa protokół używany przez <xref:System.Net.Sockets.Socket>. Dwa parametry nie są niezależne. Często <xref:System.Net.Sockets.Socket> typu jest niejawnie w protokole. Jeśli połączenie <xref:System.Net.Sockets.Socket> typu i protokół typu wyniki w nieprawidłowy <xref:System.Net.Sockets.Socket>, zgłasza ten konstruktor <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Jeśli ten konstruktor zgłasza <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Kombinacja <paramref name="socketType" /> i <paramref name="protocolType" /> powoduje nieprawidłowego gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily">Jeden z <see cref="T:System.Net.Sockets.AddressFamily" /> wartości.</param>
        <param name="socketType">Jeden z <see cref="T:System.Net.Sockets.SocketType" /> wartości.</param>
        <param name="protocolType">Jeden z <see cref="T:System.Net.Sockets.ProtocolType" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.Socket" /> przy użyciu określonego adresu rodziny, typ gniazda i protokołu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `addressFamily` Parametr określa schemat adresowania <xref:System.Net.Sockets.Socket> klasy zastosowań, `socketType` parametr określa typ <xref:System.Net.Sockets.Socket> klasy, a `protocolType` parametr określa protokół używany przez <xref:System.Net.Sockets.Socket>. Trzy parametry nie są niezależne. Ogranicz niektórych rodzin adresów protokołów można używać z nimi i często <xref:System.Net.Sockets.Socket> typu jest niejawnie w protokole. Jeśli kombinacja rodziny adresów, <xref:System.Net.Sockets.Socket> typu i wpisz wyniki w nieprawidłowy protokół <xref:System.Net.Sockets.Socket>, zwraca ten konstruktor <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Jeśli ten konstruktor zgłasza <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia wystąpienia <xref:System.Net.Sockets.Socket> klasy.  
  
 [!code-cpp[Socket_Send_Recieve#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Recieve#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#1)]
 [!code-vb[Socket_Send_Recieve#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Kombinacja <paramref name="addressFamily" />, <paramref name="socketType" />, i <paramref name="protocolType" /> powoduje nieprawidłowego gniazda.</exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nową <see cref="T:System.Net.Sockets.Socket" /> dla nowo utworzone połączenie.</summary>
        <returns>A <see cref="T:System.Net.Sockets.Socket" /> dla nowo utworzone połączenie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A> synchronicznie wyodrębnia pierwszy oczekujące żądanie połączenia z kolejki żądań połączenia gniazda nasłuchiwania, a następnie tworzy i zwraca nowy <xref:System.Net.Sockets.Socket>. Nie można użyć tego zwrócił <xref:System.Net.Sockets.Socket> do akceptowania wszelkich dodatkowych połączeń z kolejki połączenia. Jednak możesz wywołać <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> metody zwracana <xref:System.Net.Sockets.Socket> do identyfikowania hosta zdalnego sieci adres i numer portu.  
  
 W trybie blokowania <xref:System.Net.Sockets.Socket.Accept%2A> blokuje dopóki próba połączenia przychodzące w kolejce. Po zaakceptowaniu połączenie oryginalnej <xref:System.Net.Sockets.Socket> nadal kolejkowania połączenia przychodzącego żądania aż do zamknięcia.  
  
 Jeśli wywołanie tej metody za pomocą nieblokujące <xref:System.Net.Sockets.Socket>i żadne żądania są umieszczane w kolejce, połączenie <xref:System.Net.Sockets.Socket.Accept%2A> zgłasza <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Przed wywołaniem <xref:System.Net.Sockets.Socket.Accept%2A> metody, należy najpierw wywołać <xref:System.Net.Sockets.Socket.Listen%2A> metody do nasłuchiwania i kolejka żądań połączenia przychodzących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu akceptuje prostą <xref:System.Net.Sockets.Socket> połączenia.  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Odbierać gniazda nie nasłuchuje połączeń. Należy wywołać <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> i <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> przed wywołaniem <see cref="M:System.Net.Sockets.Socket.Accept" />.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Obiekt ma być używany dla tej operacji asynchronicznej gniazda.</param>
        <summary>Rozpoczyna operację asynchroniczną do akceptowania przychodzących próba połączenia.</summary>
        <returns>Zwraca <see langword="true" /> przypadku oczekujących operacji We/Wy. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenia w <paramref name="e" /> parametr zostanie wygenerowany, po zakończeniu operacji.  Zwraca <see langword="false" /> Jeśli synchronicznie wykonać operacji We/Wy. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenia w <paramref name="e" /> parametr nie zostanie wygenerowany i <paramref name="e" /> przekazano obiekt jako parametr może być zbadana natychmiast po wywołaniu metody zwraca można pobrać wyniku operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protokoły nawiązaniem połączenia można użyć <xref:System.Net.Sockets.Socket.AcceptAsync%2A> metoda do asynchronicznego przetwarzania połączenia przychodzącego. Akceptowanie połączeń asynchronicznie daje możliwość wysyłania i odbierania danych w ramach oddzielnego wykonanie wątku. Przed wywołaniem <xref:System.Net.Sockets.Socket.AcceptAsync%2A> metody należy wywołać <xref:System.Net.Sockets.Socket.Listen%2A> metody do nasłuchiwania i kolejka żądań połączenia przychodzących.  
  
 Ma być powiadamiany o zakończeniu, należy utworzyć metody wywołania zwrotnego, który implementuje EventHandler\<obiektu SocketAsyncEventArgs > delegować i podłącz go do <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> zdarzeń.  
  
 Poniższe właściwości i zdarzeń w <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiektu są wymagane:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Obiekt wywołujący można opcjonalnie określić istniejącą <xref:System.Net.Sockets.Socket> do użycia na potrzeby połączenia przychodzące, określając <xref:System.Net.Sockets.Socket> do użycia z <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> właściwości.  
  
 Jeśli <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> właściwość ma wartość null, nowy <xref:System.Net.Sockets.Socket> jest tworzony z takimi samymi <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, i <xref:System.Net.Sockets.Socket.ProtocolType%2A> jako bieżący <xref:System.Net.Sockets.Socket> i Ustaw jako <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> właściwości.  
  
 Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwości do każdego obiektu stanu użytkownika potrzebne przed wywołaniem <xref:System.Net.Sockets.Socket.AcceptAsync%2A> metodę, tak, aby informacje pobieranie metody wywołania zwrotnego. Jeśli wywołanie zwrotne wymaga informacji więcej niż jeden obiekt, aby pomieścić inne wymagane informacje o stanie jako elementy członkowskie można tworzyć małych klasy.  
  
 Opcjonalnie buforu muszą zostać udostępnione w taki sposób, w których chcesz otrzymywać początkowej bloku danych w gnieździe po <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metoda zakończy się powodzeniem. W takim przypadku <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> właściwości musi być ustawiona w buforze zawierającego dane do odbierania i <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> właściwości musi być ustawiona maksymalnej liczby bajtów danych do odbierania w buforze. Te właściwości można ustawić za pomocą <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> metody. Część Bufor przekazany będą używane wewnętrznie w do użytku przez podstawowe wywołanie funkcji Winsock AcceptEx. Oznacza to, że ilość danych zwróconych zawsze będzie mniejsza niż wartość <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> właściwość <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> podane wystąpienie. Wielkość bufora używana wewnętrznie w zależności w rodzinie adres gniazda. Rozmiar buforu minimalne wymagane jest 288 bajtów. Jeśli określono większy rozmiar buforu, a następnie <xref:System.Net.Sockets.Socket> będzie oczekiwać na dodatkowe dane inne niż dane otrzymane przez wywołanie funkcji Winsock AcceptEx i będzie czekać do momentu otrzymania tego dodatkowe dane. Jeśli zostanie przekroczony limit czasu, połączenie zostanie zresetowany. Dlatego jeśli określonej kwoty jest oczekiwane dane dodatkowe, następnie rozmiar buforu powinien mieć ustawioną minimalny rozmiar buforu plus tę wartość.  
  
 Metoda wywołania zwrotnego uzupełniania należy zbadać <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> właściwości, aby określić, czy <xref:System.Net.Sockets.Socket.AcceptAsync%2A> operacja zakończyła się pomyślnie.  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Zdarzeń może wystąpić w niektórych przypadkach, gdy brak połączenia została zaakceptowana i <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> można ustawić dla właściwości <xref:System.Net.Sockets.SocketError.ConnectionReset>. Taka sytuacja może wystąpić wyniku skanowanie za pomocą skanowania typu open połowie SYN portów (SYN ACK-> SYN -> RST sekwencji). Aplikacje używające <xref:System.Net.Sockets.Socket.AcceptAsync%2A> metoda powinna być przygotowana do obsługi tego warunku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Argument jest nieprawidłowy. Ten wyjątek występuje, gdy nie jest wystarczająco duży dostarczonego buforu. Rozmiar buforu musi wynosić co najmniej 2 * (sizeof(SOCKADDR_STORAGE + 16) bajtów.  Ten wyjątek ma miejsce, gdy określono kilka buforów, <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> właściwość nie jest zerowa.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Argument jest spoza zakresu. Wyjątek występuje, gdy <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> jest mniejszy niż 0.</exception>
        <exception cref="T:System.InvalidOperationException">Zażądano nieprawidłowej operacji. Ten wyjątek występuje, gdy akceptowanie <see cref="T:System.Net.Sockets.Socket" /> nie nasłuchuje zaakceptowane lub połączenia gniazda jest powiązany.  Należy wywołać <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> i <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> metoda przed wywołaniem <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> metody.  Ten wyjątek ma miejsce, gdy gniazdo jest już połączony lub Operacja gniazda zostało już w toku przy użyciu określonego <paramref name="e" /> parametru.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP lub nowszy jest wymagany dla tej metody.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera adres rodziny <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Jeden z <see cref="T:System.Net.Sockets.AddressFamily" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.AddressFamily> Określa schemat adresowania wystąpienia <xref:System.Net.Sockets.Socket> można użyć klasy. Ta właściwość jest tylko do odczytu i jest ustawiana w przypadku <xref:System.Net.Sockets.Socket> jest tworzony.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, i <xref:System.Net.Sockets.ProtocolType> do konsoli.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość danych, które zostały odebrane od sieci i jest dostępny do odczytu.</summary>
        <value>Liczba bajtów danych odebranych z sieci i dostępny do odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz nieblokujące <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> jest dobry sposób, aby określić, czy data jest przechowywane w kolejce do odczytu, przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. Całkowita ilość danych w kolejce w buforze sieciowej dla odczytu jest dostępnych danych. Jeśli żadne dane przechowywane w kolejce w buforze sieci <xref:System.Net.Sockets.Socket.Available%2A> zwraca wartość 0.  
  
 Jeśli host zdalny zamyka lub zamyka połączenie, <xref:System.Net.Sockets.Socket.Available%2A> może zgłosić <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu porównuje wyniki wywołania IOControl FIONREAD i dostępnych właściwości.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna operację asynchroniczną do akceptowania przychodzących próba połączenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegowanie.</param>
        <param name="state">Obiekt zawierający informacje o stanie dla tego żądania.</param>
        <summary>Rozpoczyna operację asynchroniczną do akceptowania przychodzących próba połączenia.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołuje się asynchroniczną <see cref="T:System.Net.Sockets.Socket" /> tworzenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protokoły nawiązaniem połączenia można użyć <xref:System.Net.Sockets.Socket.BeginAccept%2A> metoda do asynchronicznego przetwarzania połączenia przychodzącego. Akceptowanie połączeń asynchronicznie daje możliwość wysyłania i odbierania danych w ramach oddzielnego wykonanie wątku. Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody należy wywołać <xref:System.Net.Sockets.Socket.Listen%2A> metody do nasłuchiwania i kolejka żądań połączenia przychodzących.  
  
 Należy utworzyć metody wywołania zwrotnego, który implementuje <xref:System.AsyncCallback> delegować i przekaż jej nazwę, aby <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody. Aby to zrobić, w bardzo minimalne, trzeba przekazać nasłuchiwania <xref:System.Net.Sockets.Socket> do obiektu <xref:System.Net.Sockets.Socket.BeginAccept%2A> za pośrednictwem `state` parametru. Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć klasę mała do przechowywania <xref:System.Net.Sockets.Socket> i inne wymagane informacje. Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginAccept%2A> formę `state` parametru.  
  
 Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndAccept%2A> metody. Jeśli aplikacja wymaga <xref:System.Net.Sockets.Socket.BeginAccept%2A>, system zazwyczaj używa oddzielnym wątku wykonania metody wywołania zwrotnego określonego i blokuje na <xref:System.Net.Sockets.Socket.EndAccept%2A> do momentu pobrania oczekujących połączeń. <xref:System.Net.Sockets.Socket.EndAccept%2A> Zwraca nowy <xref:System.Net.Sockets.Socket> obiekt, czy służy do wysyłania i odbierania danych z hosta zdalnego. Nie można użyć tego zwrócił <xref:System.Net.Sockets.Socket> do akceptowania wszelkich dodatkowych połączeń z kolejki połączenia. Jeśli chcesz, aby oryginalnego wątku, aby zablokować po wywołaniu metody <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, użyj <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Wywołanie metody Set na <xref:System.Threading.ManualResetEvent> w metody wywołania zwrotnego, jeśli chcesz oryginalnego wątku, aby kontynuować wykonywanie.  
  
 System może również użyć wątek wywołujący można wywołać metody wywołania zwrotnego. W takim przypadku <xref:System.IAsyncResult.CompletedSynchronously%2A> właściwość zwrócona <xref:System.IAsyncResult> zostanie ustawiona tak, aby wskazać, że <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody ukończone synchronicznie.  
  
 Aby uzyskać dodatkowe informacje o pisaniu metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, Zamknij <xref:System.Net.Sockets.Socket>. Gdy <xref:System.Net.Sockets.Socket.Close%2A> metoda jest wywoływana, gdy operacja asynchroniczna jest w toku, wywołanie zwrotne przekazane do <xref:System.Net.Sockets.Socket.BeginAccept%2A> metoda jest wywoływana.  Kolejne wywołania <xref:System.Net.Sockets.Socket.EndAccept%2A> metoda zgłosi <xref:System.ObjectDisposedException> aby wskazać, że operacja została anulowana.  
  
> [!NOTE]
>  Można użyć <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> właściwości zwracana <xref:System.Net.Sockets.Socket> do identyfikowania hosta zdalnego sieci adres i numer portu.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod, zapoznaj się z usługi Windows Sockets w wersji 2 interfejsu API błąd kodu dokumentacją w witrynie MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekstu zabezpieczeń, nazwa personifikowanego użytkownika i kontekst wywołania) jest buforowany asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określony asynchroniczne <xref:System.Net.Sockets.Socket> metoda, określony <xref:System.Net.Sockets.Socket> wystąpienia i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu próbuje asynchronicznie otrzymywać połączenia przychodzącego.  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Windows NT jest wymagany dla tej metody.</exception>
        <exception cref="T:System.InvalidOperationException">Odbierać gniazda nie nasłuchuje połączeń. Należy wywołać <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> i <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> przed wywołaniem <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  - lub - zaakceptowane gniazda jest powiązany.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> jest mniejsza niż 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="receiveSize">Liczba bajtów do akceptowania od nadawcy.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegowanie.</param>
        <param name="state">Obiekt zawierający informacje o stanie dla tego żądania.</param>
        <summary>Rozpoczyna operację asynchroniczną do akceptowania przychodzących próba połączenia i odbiera pierwszy blok danych przesyłanych przez aplikację klienta.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odwołuje się asynchroniczną <see cref="T:System.Net.Sockets.Socket" /> tworzenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protokoły nawiązaniem połączenia można użyć <xref:System.Net.Sockets.Socket.BeginAccept%2A> metoda do asynchronicznego przetwarzania połączenia przychodzącego. Asynchronicznie akceptować połączenia można wysyłać i odbierać dane w oddzielnych wykonanie wątku. To przeciążenie umożliwia określenie liczby bajtów do akceptowania w początkowej transfer w `receiveSize` parametru.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody należy wywołać <xref:System.Net.Sockets.Socket.Listen%2A> metody do nasłuchiwania i kolejka żądań połączenia przychodzących.  
  
 Należy utworzyć metody wywołania zwrotnego, który implementuje <xref:System.AsyncCallback> delegować i przekaż jej nazwę, aby <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody. Aby to zrobić, w bardzo minimalne, trzeba przekazać nasłuchiwania <xref:System.Net.Sockets.Socket> do obiektu <xref:System.Net.Sockets.Socket.BeginAccept%2A> za pośrednictwem `state` parametru. Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć klasę mała do przechowywania <xref:System.Net.Sockets.Socket> i inne wymagane informacje. Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginAccept%2A> formę `state` parametru.  
  
 Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndAccept%2A> metody. Jeśli aplikacja wymaga <xref:System.Net.Sockets.Socket.BeginAccept%2A>, system zazwyczaj używa oddzielnym wątku wykonania metody wywołania zwrotnego określonego i blokuje na <xref:System.Net.Sockets.Socket.EndAccept%2A> do momentu pobrania oczekujących połączeń.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Zwraca nowy <xref:System.Net.Sockets.Socket> czy służy do wysyłania i odbierania danych z hosta zdalnego. Nie można użyć tego zwrócił <xref:System.Net.Sockets.Socket> do akceptowania wszelkich dodatkowych połączeń z kolejki połączenia. Jeśli chcesz, aby oryginalnego wątku, aby zablokować po wywołaniu metody <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, użyj <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Wywołanie metody Set na <xref:System.Threading.ManualResetEvent> w metody wywołania zwrotnego, jeśli chcesz oryginalnego wątku, aby kontynuować wykonywanie.  
  
 System może również użyć wątek wywołujący można wywołać metody wywołania zwrotnego. W takim przypadku <xref:System.IAsyncResult.CompletedSynchronously%2A> właściwość zwrócona <xref:System.IAsyncResult> zostanie ustawiona tak, aby wskazać, że <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody ukończone synchronicznie.  
  
 Aby uzyskać dodatkowe informacje o pisaniu metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, Zamknij <xref:System.Net.Sockets.Socket>.  Gdy <xref:System.Net.Sockets.Socket.Close%2A> metoda jest wywoływana, gdy operacja asynchroniczna jest w toku, wywołanie zwrotne przekazane do <xref:System.Net.Sockets.Socket.BeginAccept%2A> metoda jest wywoływana.  Kolejne wywołania <xref:System.Net.Sockets.Socket.EndAccept%2A> metoda zgłosi <xref:System.ObjectDisposedException> aby wskazać, że operacja została anulowana.  
  
> [!NOTE]
>  Możesz wywołać użyj <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> właściwości zwracana <xref:System.Net.Sockets.Socket> obiektem w celu identyfikacji hosta zdalnego sieci adres i numer portu.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekstu zabezpieczeń, nazwa personifikowanego użytkownika i kontekst wywołania) jest buforowany asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określony asynchroniczne <xref:System.Net.Sockets.Socket> metoda, określony <xref:System.Net.Sockets.Socket> wystąpienia i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera gniazda i akceptuje połączenia asynchronicznego. W tym przykładzie gniazda akceptuje początkowej 10 bajtów danych. Liczba bajtów odebranych i dane są wyświetlane w konsoli przez delegata wywołania zwrotnego. Zobacz <xref:System.Net.Sockets.Socket.BeginReceive%2A> opis sposobu pozostałe dane są odebrane.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Windows NT jest wymagany dla tej metody.</exception>
        <exception cref="T:System.InvalidOperationException">Odbierać gniazda nie nasłuchuje połączeń. Należy wywołać <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> i <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> przed wywołaniem <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  - lub - zaakceptowane gniazda jest powiązany.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> jest mniejsza niż 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">Zaakceptowane <see cref="T:System.Net.Sockets.Socket" /> obiektu. Ta wartość może być <see langword="null" />.</param>
        <param name="receiveSize">Maksymalna liczba bajtów do odbierania.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegowanie.</param>
        <param name="state">Obiekt zawierający informacje o stanie dla tego żądania.</param>
        <summary>Rozpoczyna operację asynchroniczną do akceptowania przychodzących próby połączenia z określonym gniazda i odbiera pierwszy blok danych przesyłanych przez aplikację klienta.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiektu, który odwołuje się do asynchroniczną <see cref="T:System.Net.Sockets.Socket" /> tworzenia obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protokoły nawiązaniem połączenia można użyć <xref:System.Net.Sockets.Socket.BeginAccept%2A> metoda do asynchronicznego przetwarzania połączenia przychodzącego. Akceptowanie połączeń asynchronicznie daje możliwość wysyłania i odbierania danych w ramach oddzielnego wykonanie wątku. To przeciążenie umożliwia określenie zaakceptowane gniazda w `acceptSocket` parametru. Jeśli ten parametr ma `null`, zaakceptowane gniazda jest tworzony przez <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody. Można określić liczbę bajtów do akceptowania w początkowej transfer w `receiveSize` parametru.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody należy wywołać <xref:System.Net.Sockets.Socket.Listen%2A> metody do nasłuchiwania i kolejka żądań połączenia przychodzących.  
  
 Należy utworzyć metody wywołania zwrotnego, który implementuje <xref:System.AsyncCallback> delegować i przekaż jej nazwę, aby <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody. Aby to zrobić, w bardzo minimalne, trzeba przekazać nasłuchiwania <xref:System.Net.Sockets.Socket> do obiektu <xref:System.Net.Sockets.Socket.BeginAccept%2A> za pośrednictwem `state` parametru. Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć klasę mała do przechowywania <xref:System.Net.Sockets.Socket> i inne wymagane informacje. Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginAccept%2A> formę `state` parametru.  
  
 Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndAccept%2A> metody. Jeśli aplikacja wymaga <xref:System.Net.Sockets.Socket.BeginAccept%2A>, system zazwyczaj używa oddzielnym wątku wykonania metody wywołania zwrotnego określonego i blokuje na <xref:System.Net.Sockets.Socket.EndAccept%2A> do momentu pobrania oczekujących połączeń.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Zwraca nowy <xref:System.Net.Sockets.Socket> obiekt, czy służy do wysyłania i odbierania danych z hosta zdalnego. Nie można użyć tego zwrócił <xref:System.Net.Sockets.Socket> do akceptowania wszelkich dodatkowych połączeń z kolejki połączenia. Jeśli chcesz, aby oryginalnego wątku, aby zablokować po wywołaniu metody <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, użyj <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Wywołanie metody Set na <xref:System.Threading.ManualResetEvent> w metody wywołania zwrotnego, jeśli chcesz oryginalnego wątku, aby kontynuować wykonywanie.  
  
 System może również użyć wątek wywołujący można wywołać metody wywołania zwrotnego. W takim przypadku <xref:System.IAsyncResult.CompletedSynchronously%2A> właściwość zwrócona <xref:System.IAsyncResult> zostanie ustawiona tak, aby wskazać, że <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody ukończone synchronicznie.  
  
 Aby uzyskać dodatkowe informacje o pisaniu metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, Zamknij <xref:System.Net.Sockets.Socket>. Gdy <xref:System.Net.Sockets.Socket.Close%2A> metoda jest wywoływana, gdy operacja asynchroniczna jest w toku, wywołanie zwrotne przekazane do <xref:System.Net.Sockets.Socket.BeginAccept%2A> metoda jest wywoływana.  Kolejne wywołania <xref:System.Net.Sockets.Socket.EndAccept%2A> metoda zgłosi <xref:System.ObjectDisposedException> aby wskazać, że operacja została anulowana.  
  
> [!NOTE]
>  Można użyć <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> właściwości zwracana <xref:System.Net.Sockets.Socket> obiektem w celu identyfikacji hosta zdalnego sieci adres i numer portu.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekstu zabezpieczeń, nazwa personifikowanego użytkownika i kontekst wywołania) jest buforowany asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określony asynchroniczne <xref:System.Net.Sockets.Socket> metoda, określony <xref:System.Net.Sockets.Socket> wystąpienia i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera gniazda i akceptuje połączenia asynchronicznego. W tym przykładzie gniazda akceptuje początkowej 10 bajtów danych i `acceptSocket` parametr jest `null`, która wymusza <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodę w celu utworzenia zaakceptowane gniazda. Liczba bajtów odebranych i dane są wyświetlane w konsoli przez delegata wywołania zwrotnego. Zobacz <xref:System.Net.Sockets.Socket.BeginReceive%2A> opis sposobu pozostałe dane są odebrane.  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Windows NT jest wymagany dla tej metody.</exception>
        <exception cref="T:System.InvalidOperationException">Odbierać gniazda nie nasłuchuje połączeń. Należy wywołać <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> i <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> przed wywołaniem <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  - lub - zaakceptowane gniazda jest powiązany.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> jest mniejsza niż 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna się asynchroniczne żądanie dla połączenia zdalnego hosta.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" />
        <Parameter Name="state" Type="System.Object" Index="2" />
      </Parameters>
      <Docs>
        <param name="remoteEP">To be added.</param>
        <param name="end_point">To be added.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegowanie.</param>
        <param name="state">Obiekt zawierający informacje o stanie dla tego żądania.</param>
        <summary>Rozpoczyna się asynchroniczne żądanie dla połączenia zdalnego hosta.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się połączenia asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz protokołu nawiązaniem połączenia, <xref:System.Net.Sockets.Socket.BeginConnect%2A> metoda uruchamia asynchroniczne żądanie połączenia z `remoteEP` parametru. Jeśli używasz protokołu bez połączenia, <xref:System.Net.Sockets.Socket.BeginConnect%2A> ustanawia domyślnego hosta zdalnego. Łączenie lub asynchronicznie ustawienie domyślnego hosta zdalnego daje możliwość wysyłania i odbierania danych w ramach oddzielnego wykonanie wątku.  
  
 Można utworzyć metody wywołania zwrotnego, który implementuje <xref:System.AsyncCallback> delegować i przekaż jej nazwę, aby <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody. W bardzo minimalny, trzeba przekazać <xref:System.Net.Sockets.Socket> do <xref:System.Net.Sockets.Socket.BeginConnect%2A> za pośrednictwem `state` parametru. Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć klasę mała do przechowywania <xref:System.Net.Sockets.Socket>i inne wymagane informacje. Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginConnect%2A> formę `state` parametru.  
  
 Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndConnect%2A> metody. Jeśli aplikacja wymaga <xref:System.Net.Sockets.Socket.BeginConnect%2A>, system użyje oddzielnym wątku wykonania metody wywołania zwrotnego określonego i blokuje na <xref:System.Net.Sockets.Socket.EndConnect%2A> do momentu <xref:System.Net.Sockets.Socket> pomyślnie nawiąże połączenie lub zgłasza wyjątek. Jeśli chcesz, aby oryginalnego wątku, aby zablokować po wywołaniu metody <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody, użyj <xref:System.Threading.WaitHandle.WaitOne%2A>. Wywołanie metody Set na <xref:System.Threading.ManualResetEvent> w metody wywołania zwrotnego, jeśli chcesz oryginalnego wątku, aby kontynuować wykonywanie. Aby uzyskać dodatkowe informacje o pisaniu metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Jeśli używasz przesyłanie protokołu, takie jak protokół UDP jest konieczne wywołać <xref:System.Net.Sockets.Socket.BeginConnect%2A> przed wysyłania i odbierania danych. Można użyć <xref:System.Net.Sockets.Socket.BeginSendTo%2A> i <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> do komunikowania się z hostem zdalnym. Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.BeginConnect%2A>, zostaną odrzucone datagramów odbierane z adresu innego niż określoną wartość domyślną. Jeśli chcesz ustawić domyślnego hosta zdalnego na adres emisji, należy najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> ustawiono emisji `true`. Jeśli nie możesz <xref:System.Net.Sockets.Socket.BeginConnect%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Jeśli używasz protokołu nawiązaniem połączenia i nie należy wywoływać <xref:System.Net.Sockets.Socket.Bind%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.BeginConnect%2A>, podstawowego dostawcy usług przypisze najbardziej odpowiedni adres i port numer sieci lokalnej. Jeśli używasz protokołu bez połączenia dostawcy usług nie przypisze adres i port numer sieci lokalnej do czasu wywołania <xref:System.Net.Sockets.Socket.BeginSend%2A> lub <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. Jeśli chcesz zmienić domyślnego hosta zdalnego wywołania <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody ponownie z żądanego punktu końcowego.  
  
 Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody, Zamknij <xref:System.Net.Sockets.Socket>. Gdy <xref:System.Net.Sockets.Socket.Close%2A> metoda jest wywoływana, gdy operacja asynchroniczna jest w toku, wywołanie zwrotne przekazane do <xref:System.Net.Sockets.Socket.BeginConnect%2A> metoda jest wywoływana.  Kolejne wywołania <xref:System.Net.Sockets.Socket.EndConnect%2A> metoda zgłosi <xref:System.ObjectDisposedException> aby wskazać, że operacja została anulowana.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Jeśli tego gniazda wcześniej został odłączony, następnie <xref:System.Net.Sockets.Socket.BeginConnect%2A> musi być wywołany w wątku, który nie zostanie zakończony przed zakończeniem operacji. Jest to ograniczenie źródłowego dostawcy.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekstu zabezpieczeń, nazwa personifikowanego użytkownika i kontekst wywołania) jest buforowany asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określony asynchroniczne <xref:System.Net.Sockets.Socket> metoda, określony <xref:System.Net.Sockets.Socket> wystąpienia i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu inicjuje próba połączenia asynchronicznego.  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań nie ma uprawnienia dla żądanej operacji.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> Została umieszczona w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, lub trwa już operacja asynchroniczna.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="address">
          <see cref="T:System.Net.IPAddress" /> Hosta zdalnego.</param>
        <param name="port">Numer portu hosta zdalnego.</param>
        <param name="requestCallback">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">Obiekt zdefiniowane przez użytkownika, który zawiera informacje o operacji połączenia. Ten obiekt jest przekazywany do <c>requestCallback</c> delegować po zakończeniu operacji.</param>
        <summary>Rozpoczyna się asynchroniczne żądanie dla połączenia zdalnego hosta. Host jest określona przez <see cref="T:System.Net.IPAddress" /> i numer portu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się połączenia asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.Socket.BeginConnect%2A> musi być zakończona, wywołując <xref:System.Net.Sockets.Socket.EndConnect%2A> metody. Zazwyczaj metoda jest wywoływana przez `requestCallback` delegowanie.  
  
 Ta metoda nie blokuje przed zakończeniem operacji. Aby zablokować do czasu tej operacji, użyj jednej z <xref:System.Net.Sockets.Socket.Connect%2A> przeciążenia metody lub <xref:System.Net.Sockets.Socket.EndConnect%2A>.  
  
 Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody, Zamknij <xref:System.Net.Sockets.Socket>. Gdy <xref:System.Net.Sockets.Socket.Close%2A> metoda jest wywoływana, gdy operacja asynchroniczna jest w toku, wywołanie zwrotne przekazane do <xref:System.Net.Sockets.Socket.BeginConnect%2A> metoda jest wywoływana.  Kolejne wywołania <xref:System.Net.Sockets.Socket.EndConnect%2A> metoda zgłosi <xref:System.ObjectDisposedException> aby wskazać, że operacja została anulowana.  
  
 Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Jeśli tego gniazda wcześniej został odłączony, następnie <xref:System.Net.Sockets.Socket.BeginConnect%2A> musi być wywołany w wątku, który nie zostanie zakończony przed zakończeniem operacji. Jest to ograniczenie źródłowego dostawcy. Również <xref:System.Net.EndPoint> który jest używany muszą się różnić.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekstu zabezpieczeń, nazwa personifikowanego użytkownika i kontekst wywołania) jest buforowany asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określony asynchroniczne <xref:System.Net.Sockets.Socket> metoda, określony <xref:System.Net.Sockets.Socket> wystąpienia i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu inicjuje próba połączenia asynchronicznego.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Net.Sockets.Socket" /> Nie znajduje się w rodzinie gniazda.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentException">Długość <paramref name="address" /> wynosi zero.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> Została umieszczona w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, lub trwa już operacja asynchroniczna.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="addresses">Co najmniej jeden <see cref="T:System.Net.IPAddress" />, wyznaczanie hosta zdalnego.</param>
        <param name="port">Numer portu hosta zdalnego.</param>
        <param name="requestCallback">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">Obiekt zdefiniowane przez użytkownika, który zawiera informacje o operacji połączenia. Ten obiekt jest przekazywany do <c>requestCallback</c> delegować po zakończeniu operacji.</param>
        <summary>Rozpoczyna się asynchroniczne żądanie dla połączenia zdalnego hosta. Host jest określona przez <see cref="T:System.Net.IPAddress" /> tablicy i numer portu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się połączenia asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.Socket.BeginConnect%2A> musi być zakończona, wywołując <xref:System.Net.Sockets.Socket.EndConnect%2A> metody. Zazwyczaj metoda jest wywoływana przez `requestCallback` delegowanie.  
  
 Ta metoda nie blokuje przed zakończeniem operacji. Aby zablokować do czasu tej operacji, użyj jednej z <xref:System.Net.Sockets.Socket.Connect%2A> przeciążenia metody.  
  
 Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody, Zamknij <xref:System.Net.Sockets.Socket>. Gdy <xref:System.Net.Sockets.Socket.Close%2A> metoda jest wywoływana, gdy operacja asynchroniczna jest w toku, wywołanie zwrotne przekazane do <xref:System.Net.Sockets.Socket.BeginConnect%2A> metoda jest wywoływana.  Kolejne wywołania <xref:System.Net.Sockets.Socket.EndConnect%2A> metoda zgłosi <xref:System.ObjectDisposedException> aby wskazać, że operacja została anulowana.  
  
 Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Jeśli tego gniazda wcześniej został odłączony, następnie <xref:System.Net.Sockets.Socket.BeginConnect%2A> musi być wywołany w wątku, który nie zostanie zakończony przed zakończeniem operacji. Jest to ograniczenie źródłowego dostawcy. Również <xref:System.Net.EndPoint> który jest używany muszą się różnić.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekstu zabezpieczeń, nazwa personifikowanego użytkownika i kontekst wywołania) jest buforowany asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określony asynchroniczne <xref:System.Net.Sockets.Socket> metoda, określony <xref:System.Net.Sockets.Socket> wystąpienia i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu inicjuje próba połączenia asynchronicznego.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addresses" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda jest prawidłowa dla gniazda, które używają <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentException">Długość <paramref name="address" /> wynosi zero.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> Została umieszczona w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, lub trwa już operacja asynchroniczna.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="host">Nazwa hosta zdalnego.</param>
        <param name="port">Numer portu hosta zdalnego.</param>
        <param name="requestCallback">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">Obiekt zdefiniowane przez użytkownika, który zawiera informacje o operacji połączenia. Ten obiekt jest przekazywany do <c>requestCallback</c> delegować po zakończeniu operacji.</param>
        <summary>Rozpoczyna się asynchroniczne żądanie dla połączenia zdalnego hosta. Host jest określony przez nazwę hosta i numer portu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się połączenia asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.Socket.BeginConnect%2A> musi być zakończona, wywołując <xref:System.Net.Sockets.Socket.EndConnect%2A> metody. Zazwyczaj metoda jest wywoływana przez `requestCallback` delegowanie.  
  
 Ta metoda nie blokuje przed zakończeniem operacji. Aby zablokować do czasu tej operacji, użyj jednej z <xref:System.Net.Sockets.Socket.Connect%2A> przeciążenia metody.  
  
 Aby anulować oczekujące wywołanie <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody, Zamknij <xref:System.Net.Sockets.Socket>. Gdy <xref:System.Net.Sockets.Socket.Close%2A> metoda jest wywoływana, gdy operacja asynchroniczna jest w toku, wywołanie zwrotne przekazane do <xref:System.Net.Sockets.Socket.BeginConnect%2A> metoda jest wywoływana.  Kolejne wywołania <xref:System.Net.Sockets.Socket.EndConnect%2A> metoda zgłosi <xref:System.ObjectDisposedException> aby wskazać, że operacja została anulowana.  
  
 Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Jeśli tego gniazda wcześniej został odłączony, następnie <xref:System.Net.Sockets.Socket.BeginConnect%2A> musi być wywołany w wątku, który nie zostanie zakończony przed zakończeniem operacji. Jest to ograniczenie źródłowego dostawcy. Również <xref:System.Net.EndPoint> który jest używany muszą się różnić.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekstu zabezpieczeń, nazwa personifikowanego użytkownika i kontekst wywołania) jest buforowany asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określony asynchroniczne <xref:System.Net.Sockets.Socket> metoda, określony <xref:System.Net.Sockets.Socket> wystąpienia i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu inicjuje próba połączenia asynchronicznego.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda jest prawidłowa dla gniazda w <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> rodziny.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> Została umieszczona w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, lub trwa już operacja asynchroniczna.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <see langword="true" /> Jeśli tego gniazda można ponownie użyć po zamknięciu połączenia; w przeciwnym razie <see langword="false" />.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegowanie.</param>
        <param name="state">Obiekt zawierający informacje o stanie dla tego żądania.</param>
        <summary>Rozpoczyna się asynchroniczne żądanie rozłączenia ze zdalnego punktu końcowego.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiekt, który odwołuje się do operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz protokołu nawiązaniem połączenia należy wywołać <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> metody żądanie rozłączenia ze zdalnego punktu końcowego. Jeśli `reuseSocket` jest `true`, można użyć ponownie gniazda.  
  
 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> Metoda używa oddzielnym wątku można wywołać metody określonej wywołania zwrotnego. <xref:System.Net.Sockets.Socket.EndDisconnect%2A> Bloki metoda przed rozłączeniem oczekujące została ukończona. Aby uzyskać dodatkowe informacje o pisaniu metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException> wyjątek, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy gniazda dla komunikacji asynchronicznej i wysyła określone dane z hostem zdalnym. Po wysłaniu danych <xref:System.Net.Sockets.Socket.Shutdown%2A> jest wywoływana w celu zatrzymania wysyłania i odbierania działania. Następnie <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> jest wywoływana, aby rozpocząć żądanie rozłączenia. Po zakończeniu wykonywania żądania <xref:System.Net.Sockets.Socket.Connected%2A> właściwości jest poddawany kwerendzie, aby sprawdzić, czy gniazda jest odłączony.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">System operacyjny jest system Windows 2000 lub starszym, a ta metoda wymaga systemu Windows XP.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zaczyna asynchronicznie odbieranie danych z połączonych <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizację przechowywania dla odebranych danych.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowane przez użytkownika, który zawiera informacje na temat operacji odbioru. Ten obiekt jest przekazywany do <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegować po zakończeniu operacji.</param>
        <summary>Zaczyna asynchronicznie odbieranie danych z połączonych <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się odczyt asynchroniczny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.Socket.BeginReceive%2A> musi być zakończona, wywołując <xref:System.Net.Sockets.Socket.EndReceive%2A> metody. Zazwyczaj metoda jest wywoływana przez `callback` delegowanie.  
  
 Ta metoda nie blokuje przed zakończeniem operacji. Aby zablokować do czasu tej operacji, użyj jednej z <xref:System.Net.Sockets.Socket.Receive%2A> przeciążenia metody.  
  
 Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceive%2A>, wywołaj <xref:System.Net.Sockets.Socket.Close%2A> metody.  
  
 Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Wszystkie operacje We/Wy inicjowane przez danego wątku jest anulowany, gdy który wątku wyjścia. Istnieje oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek kończy się przed zakończeniem operacji.  
  
> [!NOTE]
>  `state` jest utworzenie wystąpienia klasy zdefiniowanej przez użytkownika.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekstu zabezpieczeń, nazwa personifikowanego użytkownika i kontekst wywołania) jest buforowany asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określony asynchroniczne <xref:System.Net.Sockets.Socket> metoda, określony <xref:System.Net.Sockets.Socket> wystąpienia i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą zwiększenie wydajności.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizację przechowywania dla odebranych danych.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> obiekt zawierający błąd gniazda.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowane przez użytkownika, który zawiera informacje na temat operacji odbioru. Ten obiekt jest przekazywany do <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegować po zakończeniu operacji.</param>
        <summary>Zaczyna asynchronicznie odbieranie danych z połączonych <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się odczyt asynchroniczny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.Socket.BeginReceive%2A> musi być zakończona, wywołując <xref:System.Net.Sockets.Socket.EndReceive%2A> metody. Zazwyczaj metoda jest wywoływana przez `callback` delegowanie.  
  
 Ta metoda nie blokuje przed zakończeniem operacji. Aby zablokować do czasu tej operacji, użyj jednej z <xref:System.Net.Sockets.Socket.Receive%2A> przeciążenia metody.  
  
 Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceive%2A>, wywołaj <xref:System.Net.Sockets.Socket.Close%2A> metody.  
  
 Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Wszystkie operacje We/Wy inicjowane przez danego wątku jest anulowany, gdy który wątku wyjścia. Istnieje oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek kończy się przed zakończeniem operacji.  
  
> [!NOTE]
>  `state` jest utworzenie wystąpienia klasy zdefiniowanej przez użytkownika.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekstu zabezpieczeń, nazwa personifikowanego użytkownika i kontekst wywołania) jest buforowany asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określony asynchroniczne <xref:System.Net.Sockets.Socket> metoda, określony <xref:System.Net.Sockets.Socket> wystąpienia i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą zwiększenie wydajności.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizację przechowywania dla odebranych danych.</param>
        <param name="offset">Liczony od zera pozycja w <c>buforu</c> parametru, w którym będą przechowywane odebranych danych.</param>
        <param name="size">Liczba bajtów do odbierania.</param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowane przez użytkownika, który zawiera informacje na temat operacji odbioru. Ten obiekt jest przekazywany do <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegować po zakończeniu operacji.</param>
        <summary>Zaczyna asynchronicznie odbieranie danych z połączonych <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się odczyt asynchroniczny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.Socket.BeginReceive%2A> musi być zakończona, wywołując <xref:System.Net.Sockets.Socket.EndReceive%2A> metody. Zazwyczaj metoda jest wywoływana przez `callback` delegowanie.  
  
 Ta metoda nie blokuje przed zakończeniem operacji. Aby zablokować do czasu tej operacji, użyj jednej z <xref:System.Net.Sockets.Socket.Receive%2A> przeciążenia metody.  
  
 Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceive%2A>, wywołaj <xref:System.Net.Sockets.Socket.Close%2A> metody.  
  
 Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Wszystkie operacje We/Wy inicjowane przez danego wątku jest anulowany, gdy który wątku wyjścia. Istnieje oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek kończy się przed zakończeniem operacji.  
  
> [!NOTE]
>  `state` jest utworzenie wystąpienia klasy zdefiniowanej przez użytkownika.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekstu zabezpieczeń, nazwa personifikowanego użytkownika i kontekst wywołania) jest buforowany asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określony asynchroniczne <xref:System.Net.Sockets.Socket> metoda, określony <xref:System.Net.Sockets.Socket> wystąpienia i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu zaczyna asynchronicznie odbieranie danych z połączonych <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  - lub - <paramref name="offset" /> jest większa niż długość <paramref name="buffer" />.  - lub - <paramref name="size" /> jest mniejszy niż 0.  - lub - <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość <paramref name="offset" /> parametru.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError&amp;" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizację przechowywania dla odebranych danych.</param>
        <param name="offset">Lokalizacja w <c>buforu</c> do przechowywania odebranych danych.</param>
        <param name="size">Liczba bajtów do odbierania.</param>
        <param name="socketFlags">To be added.</param>
        <param name="flags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <param name="error">To be added.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowane przez użytkownika, który zawiera informacje na temat operacji odbioru. Ten obiekt jest przekazywany do <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegować po zakończeniu operacji.</param>
        <summary>Zaczyna asynchronicznie odbieranie danych z połączonych <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się odczyt asynchroniczny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.Socket.BeginReceive%2A> musi być zakończona, wywołując <xref:System.Net.Sockets.Socket.EndReceive%2A> metody. Zazwyczaj metoda jest wywoływana przez `callback` delegowanie.  
  
 Ta metoda nie blokuje przed zakończeniem operacji. Aby zablokować do czasu tej operacji, użyj jednej z <xref:System.Net.Sockets.Socket.Receive%2A> przeciążenia metody.  
  
 Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceive%2A>, wywołaj <xref:System.Net.Sockets.Socket.Close%2A> metody.  
  
 Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Wszystkie operacje We/Wy inicjowane przez danego wątku jest anulowany, gdy który wątku wyjścia. Istnieje oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek kończy się przed zakończeniem operacji.  
  
> [!NOTE]
>  `state` jest utworzenie wystąpienia klasy zdefiniowanej przez użytkownika.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekstu zabezpieczeń, nazwa personifikowanego użytkownika i kontekst wywołania) jest buforowany asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określony asynchroniczne <xref:System.Net.Sockets.Socket> metoda, określony <xref:System.Net.Sockets.Socket> wystąpienia i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą zwiększenie wydajności.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  - lub - <paramref name="offset" /> jest większa niż długość <paramref name="buffer" />.  - lub - <paramref name="size" /> jest mniejszy niż 0.  - lub - <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość <paramref name="offset" /> parametru.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint&amp;" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizację przechowywania dla odebranych danych.</param>
        <param name="offset">Liczony od zera pozycja w <c>buforu</c> parametru, w którym mają być zapisane dane.</param>
        <param name="size">Liczba bajtów do odbierania.</param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="remoteEP">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegowanie.</param>
        <param name="state">Obiekt zawierający informacje o stanie dla tego żądania.</param>
        <summary>Zaczyna asynchronicznie odbieranie danych z określonego urządzenia sieciowego.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się odczyt asynchroniczny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Metoda uruchamia asynchronicznie odczytu datagramy bez połączenia z hostem zdalnym. Wywoływanie <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody daje możliwość odbierania danych w oddzielnych wykonanie wątku.  
  
 Można utworzyć metody wywołania zwrotnego, który implementuje <xref:System.AsyncCallback> delegować i przekaż jej nazwę, aby <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody. Aby to zrobić, w bardzo minimalna sieci `state` parametr musi zawierać połączenia lub domyślna <xref:System.Net.Sockets.Socket> używany do komunikacji. Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć klasę mała do przechowywania <xref:System.Net.Sockets.Socket> i inne wymagane informacje. Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> formę `state` parametru.  
  
 Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> metody. Jeśli aplikacja wymaga <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, będą używane przez system oddzielnym wątku wykonania metody wywołania zwrotnego określonego i będzie blokować na <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> do momentu <xref:System.Net.Sockets.Socket> odczytuje dane lub zgłasza wyjątek. Jeśli chcesz, aby oryginalnego wątku, aby zablokować po wywołaniu metody <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody, użyj <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Wywołać metody Set T:System.Threading.ManualResetEvent metody wywołania zwrotnego w oryginalnym wątku w celu kontynuowania wykonywania. Aby uzyskać dodatkowe informacje o pisaniu metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, należy jawnie powiązać <xref:System.Net.Sockets.Socket> do lokalnego punktu końcowego za pomocą <xref:System.Net.Sockets.Socket.Bind%2A> metody, lub <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Ta metoda odczytuje dane do `buffer` parametr i przechwytywania zdalnego hosta punktu końcowego, z którego dane są przesyłane. Aby uzyskać informacje dotyczące pobierania tego punktu końcowego, zapoznaj się <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. Ta metoda jest najbardziej przydatne, jeśli zamierzasz asynchronicznie otrzymywać przesyłanie datagramy Nieznany host lub na wielu hostach. W takich przypadkach <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> odczyta pierwszy datagram umieszczonych w kolejce odebrane w buforze sieci lokalnej. Jeśli pojawi się datagram jest większy niż rozmiar `buffer`, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody spowoduje wypełnienie `buffer` z tyle komunikatu, ponieważ jest to możliwe, a throw <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu zawodnych nadmiarowe dane zostaną utracone. Jeśli używasz protokołu niezawodnych, nadmiarowe dane będą przechowywane przez dostawcę usług i mogą być pobierane przez wywołanie metody <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody z dostatecznie dużego buforu.  
  
 Aby zagwarantować, że host zdalny punkt końcowy zawsze jest zwracany, aplikacji należy jawnie powiązać <xref:System.Net.Sockets.Socket> do lokalnego punktu końcowego za pomocą <xref:System.Net.Sockets.Socket.Bind%2A> metody, a następnie wywołania <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody z `optionLevel` ustawiona <xref:System.Net.Sockets.SocketOptionLevel.IP>lub <xref:System.Net.Sockets.SocketOptionLevel.IPv6> zgodnie z potrzebami, `optionName` ustawiona <xref:System.Net.Sockets.SocketOptionName.PacketInformation>i `optionValue` parametr, aby włączyć tę opcję, przed wywołaniem <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody. W przeciwnym razie jest możliwe w dla hosta zdalnego punktu końcowego nie będą zwracane, gdy nadawca wysłał liczbę datagramów przed odbiornik wywołał <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody.  
  
 Mimo że <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> jest przeznaczony dla protokołów bez połączenia, można użyć również protokół nawiązaniem połączenia. Jeśli wybierzesz to zrobić, albo nawiązania połączenia zdalnego hosta przez wywołanie metody <xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A> — metoda lub zaakceptuj żądanie połączenia przychodzące, wywołując <xref:System.Net.Sockets.Socket.Accept%2A> lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody. Jeśli należy wywołać <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody przed ustanawianie lub zaakceptowania połączenia, otrzymasz <xref:System.Net.Sockets.SocketException>. Możesz także udostępnić domyślnego hosta zdalnego bez połączenia protokołu przed wywołaniem <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody. W tych przypadkach <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> zignoruje metody `remoteEP` parametru i odbierać dane z połączonych lub domyślnego hosta zdalnego.  
  
 Z nawiązaniem połączenia gniazda <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> odczyta jak najwięcej danych, ponieważ są dostępne do liczby bajtów określona przez `size` parametru.  
  
 Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, wywołaj <xref:System.Net.Sockets.Socket.Close%2A> metody.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekstu zabezpieczeń, nazwa personifikowanego użytkownika i kontekst wywołania) jest buforowany asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określony asynchroniczne <xref:System.Net.Sockets.Socket> metoda, określony <xref:System.Net.Sockets.Socket> wystąpienia i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu asynchronicznie odbiera datagramy bez połączenia z hostem zdalnym.  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.  - lub - <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  - lub - <paramref name="offset" /> jest większa niż długość <paramref name="buffer" />.  - lub - <paramref name="size" /> jest mniejszy niż 0.  - lub - <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań nie ma uprawnienia dla żądanej operacji.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizację przechowywania dla odebranych danych.</param>
        <param name="offset">Liczony od zera pozycja w <c>buforu</c> parametru, w którym mają być zapisane dane.</param>
        <param name="size">Liczba bajtów do odbierania.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> Reprezentujący źródło danych.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegowanie.</param>
        <param name="state">Obiekt zawierający informacje o stanie dla tego żądania.</param>
        <summary>Rozpoczyna asynchronicznie otrzymywać określoną liczbę bajtów danych do określonej lokalizacji buforu danych przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />i przechowuje informacje dotyczące punktu końcowego i pakietów.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się odczyt asynchroniczny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną operację odbierania muszą być wypełnione przez wywołanie metody <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> metody. Zazwyczaj metoda jest wywoływana przez `asyncCallback` delegowanie.  
  
 Ta metoda nie blokuje przed zakończeniem operacji. Aby zablokować przed zakończeniem operacji, należy użyć <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metody.  
  
 Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, wywołaj <xref:System.Net.Sockets.Socket.Close%2A> metody.  
  
 Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Ta metoda odczytuje dane do `buffer` parametru i przechwytywania zdalnego hosta punktu końcowego, z którego dane są przesyłane, a także informacje o odebrany pakiet. Aby uzyskać informacje dotyczące pobierania tego punktu końcowego, zapoznaj się <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. Ta metoda jest najbardziej przydatne, jeśli zamierzasz asynchronicznie otrzymywać przesyłanie datagramy Nieznany host lub na wielu hostach.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekstu zabezpieczeń, nazwa personifikowanego użytkownika i kontekst wywołania) jest buforowany asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określony asynchroniczne <xref:System.Net.Sockets.Socket> metoda, określony <xref:System.Net.Sockets.Socket> wystąpienia i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą zwiększenie wydajności.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.  - lub - <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  - lub - <paramref name="offset" /> jest większa niż długość <paramref name="buffer" />.  - lub - <paramref name="size" /> jest mniejszy niż 0.  - lub - <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">System operacyjny jest system Windows 2000 lub starszym, a ta metoda wymaga systemu Windows XP.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wysyła dane asynchronicznie do połączonych <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegowanie.</param>
        <param name="state">Obiekt zawierający informacje o stanie dla tego żądania.</param>
        <summary>Wysyła dane asynchronicznie do połączonych <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się asynchronicznego wysyłania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A> Metody rozpoczyna się operacja asynchronicznego wysyłania do zdalnego hosta w <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody. <xref:System.Net.Sockets.Socket.BeginSend%2A> Zgłoś wyjątek, jeśli użytkownik nie należy wywoływać najpierw <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Wywoływanie <xref:System.Net.Sockets.Socket.BeginSend%2A> metody daje możliwość wysyłania danych w ramach oddzielnego wykonanie wątku.  
  
 Można utworzyć metody wywołania zwrotnego, który implementuje <xref:System.AsyncCallback> delegować i przekaż jej nazwę, aby <xref:System.Net.Sockets.Socket.BeginSend%2A> metody. Aby to zrobić, w bardzo minimalna sieci `state` parametr musi zawierać połączenia lub domyślna <xref:System.Net.Sockets.Socket> używany do komunikacji. Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małych klasę lub strukturę do przechowywania <xref:System.Net.Sockets.Socket> i inne wymagane informacje. Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginSend%2A> formę `state` parametru.  
  
 Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndSend%2A> metody. Jeśli aplikacja wymaga <xref:System.Net.Sockets.Socket.BeginSend%2A>, system użyje oddzielnym wątku wykonania metody wywołania zwrotnego określonego i blokuje na <xref:System.Net.Sockets.Socket.EndSend%2A> do momentu <xref:System.Net.Sockets.Socket> wysyła żądana liczba bajtów lub zgłasza wyjątek. Jeśli chcesz, aby oryginalnego wątku, aby zablokować po wywołaniu metody <xref:System.Net.Sockets.Socket.BeginSend%2A> metody, użyj <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> metody. Wywołać metody Set T:System.Threading.ManualResetEvent metody wywołania zwrotnego w oryginalnym wątku w celu kontynuowania wykonywania. Aby uzyskać dodatkowe informacje o pisaniu metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Mimo że przeznaczonych dla połączeń protokołów <xref:System.Net.Sockets.Socket.BeginSend%2A> działa także dla protokołów bez połączenia, pod warunkiem, że pierwsze wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodę ustanawiania domyślnego hosta zdalnego. Jeśli korzystasz z protokołu przesyłanie i plan do wysyłania danych do wielu różnych hostach, należy użyć <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Można użyć <xref:System.Net.Sockets.Socket.BeginSendTo%2A> nawet po ustaleniu domyślna zdalnego hosta z <xref:System.Net.Sockets.Socket.Connect%2A>. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSend%2A> przez inne wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Przy użyciu protokołów przesyłanie również należy się upewnić, że rozmiar buforu przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie zostaną wysłane i <xref:System.Net.Sockets.Socket.BeginSend%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketflags` parametru, dane są wysyłane, nie zostaną przesłane.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Wszystkie operacje We/Wy inicjowane przez danego wątku jest anulowany, gdy który wątku wyjścia. Istnieje oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek kończy się przed zakończeniem operacji.  
  
> [!NOTE]
>  `state` jest utworzenie wystąpienia klasy zdefiniowanej przez użytkownika.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że danych zostało pomyślnie dostarczone. Jeśli nie ma przestrzeni buforu w systemie transportu do przechowywania danych, które mają być przekazywane, wysyłania zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekstu zabezpieczeń, nazwa personifikowanego użytkownika i kontekst wywołania) jest buforowany asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określony asynchroniczne <xref:System.Net.Sockets.Socket> metoda, określony <xref:System.Net.Sockets.Socket> wystąpienia i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą zwiększenie wydajności.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> jest pusty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> obiekt zawierający błąd gniazda.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegowanie.</param>
        <param name="state">Obiekt zawierający informacje o stanie dla tego żądania.</param>
        <summary>Wysyła dane asynchronicznie do połączonych <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się asynchronicznego wysyłania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A> Metody rozpoczyna się operacja asynchronicznego wysyłania do zdalnego hosta w <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody. <xref:System.Net.Sockets.Socket.BeginSend%2A> Zgłoś wyjątek, jeśli użytkownik nie należy wywoływać najpierw <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Wywoływanie <xref:System.Net.Sockets.Socket.BeginSend%2A> metody daje możliwość wysyłania danych w ramach oddzielnego wykonanie wątku.  
  
 Można utworzyć metody wywołania zwrotnego, który implementuje <xref:System.AsyncCallback> delegować i przekaż jej nazwę, aby <xref:System.Net.Sockets.Socket.BeginSend%2A> metody. Aby to zrobić, w bardzo minimalna sieci `state` parametr musi zawierać połączenia lub domyślna <xref:System.Net.Sockets.Socket> używany do komunikacji. Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małych klasę lub strukturę do przechowywania <xref:System.Net.Sockets.Socket> i inne wymagane informacje. Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginSend%2A> formę `state` parametru.  
  
 Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndSend%2A> metody. Jeśli aplikacja wymaga <xref:System.Net.Sockets.Socket.BeginSend%2A>, system użyje oddzielnym wątku wykonania metody wywołania zwrotnego określonego i blokuje na <xref:System.Net.Sockets.Socket.EndSend%2A> do momentu <xref:System.Net.Sockets.Socket> wysyła żądana liczba bajtów lub zgłasza wyjątek. Jeśli chcesz, aby oryginalnego wątku, aby zablokować po wywołaniu metody <xref:System.Net.Sockets.Socket.BeginSend%2A> metody, użyj <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> metody. Wywołanie metody Set na <xref:System.Threading.ManualResetEvent> w metody wywołania zwrotnego, jeśli chcesz oryginalnego wątku, aby kontynuować wykonywanie. Aby uzyskać dodatkowe informacje o pisaniu metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Mimo że przeznaczonych dla połączeń protokołów <xref:System.Net.Sockets.Socket.BeginSend%2A> działa także dla protokołów bez połączenia, pod warunkiem, że pierwsze wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodę ustanawiania domyślnego hosta zdalnego. Jeśli korzystasz z protokołu przesyłanie i plan do wysyłania danych do wielu różnych hostach, należy użyć <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Można użyć <xref:System.Net.Sockets.Socket.BeginSendTo%2A> nawet po ustaleniu domyślna zdalnego hosta z <xref:System.Net.Sockets.Socket.Connect%2A>. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSend%2A> przez inne wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Przy użyciu protokołów przesyłanie również należy się upewnić, że rozmiar buforu przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie zostaną wysłane i <xref:System.Net.Sockets.Socket.BeginSend%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketflags` parametru, dane są wysyłane, nie zostaną przesłane.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Wszystkie operacje We/Wy inicjowane przez danego wątku jest anulowany, gdy który wątku wyjścia. Istnieje oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek kończy się przed zakończeniem operacji.  
  
> [!NOTE]
>  `state` jest utworzenie wystąpienia klasy zdefiniowanej przez użytkownika.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że danych zostało pomyślnie dostarczone. Jeśli nie ma przestrzeni buforu w systemie transportu do przechowywania danych, które mają być przekazywane, wysyłania zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekstu zabezpieczeń, nazwa personifikowanego użytkownika i kontekst wywołania) jest buforowany asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określony asynchroniczne <xref:System.Net.Sockets.Socket> metoda, określony <xref:System.Net.Sockets.Socket> wystąpienia i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą zwiększenie wydajności.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> jest pusty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="offset">Liczony od zera pozycja w <c>buforu</c> parametru, w którym należy rozpocząć wysyłanie danych.</param>
        <param name="size">Liczba bajtów do wysłania.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> obiekt zawierający błąd gniazda.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegowanie.</param>
        <param name="state">Obiekt zawierający informacje o stanie dla tego żądania.</param>
        <summary>Wysyła dane asynchronicznie do połączonych <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się asynchronicznego wysyłania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A> Metody rozpoczyna się operacja asynchronicznego wysyłania do zdalnego hosta w <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody. <xref:System.Net.Sockets.Socket.BeginSend%2A> Zgłoś wyjątek, jeśli użytkownik nie należy wywoływać najpierw <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Wywoływanie <xref:System.Net.Sockets.Socket.BeginSend%2A> metody daje możliwość wysyłania danych w ramach oddzielnego wykonanie wątku.  
  
 Można utworzyć metody wywołania zwrotnego, który implementuje <xref:System.AsyncCallback> delegować i przekaż jej nazwę, aby <xref:System.Net.Sockets.Socket.BeginSend%2A> metody. Aby to zrobić, w bardzo minimalna sieci `state` parametr musi zawierać połączenia lub domyślna <xref:System.Net.Sockets.Socket> używany do komunikacji. Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małych klasę lub strukturę do przechowywania <xref:System.Net.Sockets.Socket> i inne wymagane informacje. Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginSend%2A> formę `state` parametru.  
  
 Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndSend%2A> metody. Jeśli aplikacja wymaga <xref:System.Net.Sockets.Socket.BeginSend%2A>, system użyje oddzielnym wątku wykonania metody wywołania zwrotnego określonego i blokuje na <xref:System.Net.Sockets.Socket.EndSend%2A> do momentu <xref:System.Net.Sockets.Socket> wysyła żądana liczba bajtów lub zgłasza wyjątek. Jeśli chcesz, aby oryginalnego wątku, aby zablokować po wywołaniu metody <xref:System.Net.Sockets.Socket.BeginSend%2A> metody, użyj <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> metody. Wywołać metody Set T:System.Threading.ManualResetEvent metody wywołania zwrotnego w oryginalnym wątku w celu kontynuowania wykonywania. Aby uzyskać dodatkowe informacje o pisaniu metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Mimo że przeznaczonych dla połączeń protokołów <xref:System.Net.Sockets.Socket.BeginSend%2A> działa także dla protokołów bez połączenia, pod warunkiem, że pierwsze wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodę ustanawiania domyślnego hosta zdalnego. Jeśli korzystasz z protokołu przesyłanie i plan do wysyłania danych do wielu różnych hostach, należy użyć <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Można użyć <xref:System.Net.Sockets.Socket.BeginSendTo%2A> nawet po ustaleniu domyślna zdalnego hosta z <xref:System.Net.Sockets.Socket.Connect%2A>. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSend%2A> przez inne wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Przy użyciu protokołów przesyłanie również należy się upewnić, że rozmiar buforu przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie zostaną wysłane i <xref:System.Net.Sockets.Socket.BeginSend%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketflags` parametru, dane są wysyłane, nie zostaną przesłane.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Wszystkie operacje We/Wy inicjowane przez danego wątku jest anulowany, gdy który wątku wyjścia. Istnieje oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek kończy się przed zakończeniem operacji.  
  
> [!NOTE]
>  `state` jest utworzenie wystąpienia klasy zdefiniowanej przez użytkownika.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że danych zostało pomyślnie dostarczone. Jeśli nie ma przestrzeni buforu w systemie transportu do przechowywania danych, które mają być przekazywane, wysyłania zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekstu zabezpieczeń, nazwa personifikowanego użytkownika i kontekst wywołania) jest buforowany asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określony asynchroniczne <xref:System.Net.Sockets.Socket> metoda, określony <xref:System.Net.Sockets.Socket> wystąpienia i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą zwiększenie wydajności.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  - lub - <paramref name="offset" /> jest mniejsza niż długość <paramref name="buffer" />.  - lub - <paramref name="size" /> jest mniejszy niż 0.  - lub - <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="offset">Liczony od zera pozycja w <c>buforu</c> parametru, w którym należy rozpocząć wysyłanie danych.</param>
        <param name="size">Liczba bajtów do wysłania.</param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegowanie.</param>
        <param name="state">Obiekt zawierający informacje o stanie dla tego żądania.</param>
        <summary>Wysyła dane asynchronicznie do połączonych <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się asynchronicznego wysyłania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A> Metody rozpoczyna się operacja asynchronicznego wysyłania do zdalnego hosta w <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody. <xref:System.Net.Sockets.Socket.BeginSend%2A> Zgłoś wyjątek, jeśli użytkownik nie należy wywoływać najpierw <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Wywoływanie <xref:System.Net.Sockets.Socket.BeginSend%2A> metody daje możliwość wysyłania danych w ramach oddzielnego wykonanie wątku.  
  
 Można utworzyć metody wywołania zwrotnego, który implementuje <xref:System.AsyncCallback> delegować i przekaż jej nazwę, aby <xref:System.Net.Sockets.Socket.BeginSend%2A> metody. Aby to zrobić, w bardzo minimalna sieci `state` parametr musi zawierać połączenia lub domyślna <xref:System.Net.Sockets.Socket> używany do komunikacji. Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małych klasę lub strukturę do przechowywania <xref:System.Net.Sockets.Socket> i inne wymagane informacje. Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginSend%2A> formę `state` parametru.  
  
 Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndSend%2A> metody. Jeśli aplikacja wymaga <xref:System.Net.Sockets.Socket.BeginSend%2A>, system użyje oddzielnym wątku wykonania metody wywołania zwrotnego określonego i blokuje na <xref:System.Net.Sockets.Socket.EndSend%2A> do momentu <xref:System.Net.Sockets.Socket> wysyła żądana liczba bajtów lub zgłasza wyjątek. Jeśli chcesz, aby oryginalnego wątku, aby zablokować po wywołaniu metody <xref:System.Net.Sockets.Socket.BeginSend%2A> metody, użyj <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> metody. Wywołać metody Set T:System.Threading.ManualResetEvent metody wywołania zwrotnego w oryginalnym wątku w celu kontynuowania wykonywania. Aby uzyskać dodatkowe informacje o pisaniu metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Mimo że przeznaczonych dla połączeń protokołów <xref:System.Net.Sockets.Socket.BeginSend%2A> działa także dla protokołów bez połączenia, pod warunkiem, że pierwsze wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodę ustanawiania domyślnego hosta zdalnego. Jeśli korzystasz z protokołu przesyłanie i plan do wysyłania danych do wielu różnych hostach, należy użyć <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Można użyć <xref:System.Net.Sockets.Socket.BeginSendTo%2A> nawet po ustaleniu domyślna zdalnego hosta z <xref:System.Net.Sockets.Socket.Connect%2A>. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSend%2A> przez inne wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Przy użyciu protokołów przesyłanie również należy się upewnić, że rozmiar buforu przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie zostaną wysłane i <xref:System.Net.Sockets.Socket.BeginSend%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketflags` parametru, dane są wysyłane, nie zostaną przesłane.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Wszystkie operacje We/Wy inicjowane przez danego wątku jest anulowany, gdy który wątku wyjścia. Istnieje oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek kończy się przed zakończeniem operacji.  
  
> [!NOTE]
>  `state` jest utworzenie wystąpienia klasy zdefiniowanej przez użytkownika.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że danych zostało pomyślnie dostarczone. Jeśli nie ma przestrzeni buforu w systemie transportu do przechowywania danych, które mają być przekazywane, wysyłania zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekstu zabezpieczeń, nazwa personifikowanego użytkownika i kontekst wywołania) jest buforowany asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określony asynchroniczne <xref:System.Net.Sockets.Socket> metoda, określony <xref:System.Net.Sockets.Socket> wystąpienia i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu rozpoczyna asynchronicznie wysyłania danych do hosta zdalnego.  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  - lub - <paramref name="offset" /> jest mniejsza niż długość <paramref name="buffer" />.  - lub - <paramref name="size" /> jest mniejszy niż 0.  - lub - <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asynchronicznie wysyła plik do połączonych <see cref="T:System.Net.Sockets.Socket" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">Ciąg, który zawiera ścieżkę i nazwę pliku do wysłania. Ten parametr może być <see langword="null" />.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegowanie.</param>
        <param name="state">Obiekt zawierający informacje o stanie dla tego żądania.</param>
        <summary>Wysyła pliku <paramref name="fileName" /> do połączonych <see cref="T:System.Net.Sockets.Socket" /> przy użyciu <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> flagi.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiekt, który reprezentuje asynchronicznego wysyłania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie wysyła plik `fileName` do połączenia gniazda. Jeśli `fileName` jest w katalogu lokalnego może zostać zidentyfikowane na nazwę pliku; w przeciwnym razie należy określić pełną ścieżkę i nazwę pliku. Symbole wieloznaczne ("... \\\myfile.txt ") i nazwy udziału UNC ("\\\\\\katalogu \shared\\\myfile.txt ") są obsługiwane. Jeśli plik nie zostanie znaleziony, wyjątek <xref:System.IO.FileNotFoundException> jest generowany.  
  
 Ta metoda używa `TransmitFile` funkcja znaleziono w interfejsie API Windows Sockets 2. Aby uzyskać więcej informacji na temat `TransmitFile` funkcji i jej flag, można znaleźć w dokumentacji systemu Windows Sockets w bibliotece MSDN.  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Metody rozpoczyna się operacja asynchronicznego wysyłania do zdalnego hosta w <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> zgłasza wyjątek, jeśli użytkownik nie należy wywoływać najpierw <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Wywoływanie <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metody umożliwia wysyłanie plików w oddzielnych wykonanie wątku.  
  
 Aby ukończyć operację, można utworzyć metody wywołania zwrotnego, który jest wywoływany przez <xref:System.AsyncCallback> delegować parametru. Aby to zrobić, w bardzo minimalne `state` musi zawierać parametr <xref:System.Net.Sockets.Socket> obiekt używany do komunikacji. Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć klasę lub strukturę do przechowywania <xref:System.Net.Sockets.Socket> i inne wymagane informacje. Przekaż wystąpienie tego obiektu niestandardowych w celu <xref:System.Net.Sockets.Socket.BeginSendFile%2A> formę `state` parametru.  
  
 Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndSendFile%2A> metody. Jeśli aplikacja wymaga <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, system używa oddzielnym wątku wykonania metody wywołania zwrotnego określonego i blokuje na <xref:System.Net.Sockets.Socket.EndSendFile%2A> do momentu <xref:System.Net.Sockets.Socket> wysyła cały plik lub zgłasza wyjątek. Aby uzyskać dodatkowe informacje o pisaniu metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Mimo że przeznaczonych dla połączeń protokołów <xref:System.Net.Sockets.Socket.BeginSendFile%2A> działa także dla protokołów bez połączenia, pod warunkiem, że pierwsze wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodę ustanawiania domyślnego hosta zdalnego. Z protokołami bez połączenia należy się upewnić, że rozmiar pliku przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie są wysyłane i <xref:System.Net.Sockets.Socket.BeginSendFile%2A> zgłasza <xref:System.Net.Sockets.SocketException> wyjątku.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException> wyjątek, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekstu zabezpieczeń, nazwa personifikowanego użytkownika i kontekst wywołania) jest buforowany asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określony asynchroniczne <xref:System.Net.Sockets.Socket> metoda, określony <xref:System.Net.Sockets.Socket> wystąpienia i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy i łączy gniazda dla komunikacji asynchronicznej. Po pierwsze plik "text.txt" są wysyłane asynchronicznie do hosta zdalnego. Wywołuje delegata wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndSendFile%2A> aby zakończyć przekazywanie.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Gniazda nie jest połączony z hostem zdalnym.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik <paramref name="fileName" /> nie został znaleziony.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">Ciąg, który zawiera ścieżkę i nazwę pliku do wysłania. Ten parametr może być <see langword="null" />.</param>
        <param name="preBuffer">A <see cref="T:System.Byte" /> tablicy, która zawiera dane mają być wysyłane przed wysłaniem pliku. Ten parametr może być <see langword="null" />.</param>
        <param name="postBuffer">A <see cref="T:System.Byte" /> tablicy, która zawiera dane mają być wysyłane po wysłaniu pliku. Ten parametr może być <see langword="null" />.</param>
        <param name="flags">Bitowe połączenie <see cref="T:System.Net.Sockets.TransmitFileOptions" /> wartości.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegata do wywołania po zakończeniu tej operacji. Ten parametr może być <see langword="null" />.</param>
        <param name="state">Obiekt użytkownika, który zawiera informacje o stanie dla tego żądania. Ten parametr może być <see langword="null" />.</param>
        <summary>Wysyła asynchronicznie pliku i buforów danych do połączonych <see cref="T:System.Net.Sockets.Socket" /> obiektu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiekt reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie wymaga nazwy pliku, który chcesz wysłać i bitowe połączenie <xref:System.Net.Sockets.TransmitFileOptions> wartości. `preBuffer` Parametr zawiera wszystkie dane poprzedzającą pliku. `postBuffer` zawiera dane, które chcesz wykonać pliku. Jeśli `fileName` jest w katalogu lokalnego może zostać zidentyfikowane na nazwę pliku; w przeciwnym razie należy określić pełną ścieżkę i nazwę pliku. Symbole wieloznaczne ("... \\\myfile.txt ") i nazwy udziału UNC ("\\\\\\katalogu \shared\\\myfile.txt ") są obsługiwane. Jeśli plik nie zostanie znaleziony, wyjątek <xref:System.IO.FileNotFoundException> jest generowany.  
  
 `flags` Parametru zapewnia dostawcę usługi Windows Sockets o dodatkowe informacje dotyczące transferu plików. Aby uzyskać więcej informacji na temat używania tego parametru, zobacz <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Ta metoda używa `TransmitFile` funkcja znaleziono w interfejsie API Windows Sockets 2. Aby uzyskać więcej informacji na temat `TransmitFile` funkcji i jej flag, można znaleźć w dokumentacji systemu Windows Sockets w bibliotece MSDN.  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Metody rozpoczyna się operacja asynchronicznego wysyłania do zdalnego hosta w <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> zgłasza wyjątek, jeśli użytkownik nie należy wywoływać najpierw <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Wywoływanie <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metody daje możliwość wysyłania pliku w oddzielnych wykonanie wątku.  
  
 Aby ukończyć operację, można utworzyć metody wywołania zwrotnego, który jest wywoływany przez <xref:System.AsyncCallback> delegować parametru. Aby to zrobić, w bardzo minimalne `state` musi zawierać parametr <xref:System.Net.Sockets.Socket> obiekt używany do komunikacji. Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć klasę lub strukturę do przechowywania <xref:System.Net.Sockets.Socket> i inne wymagane informacje. Przekaż wystąpienie tego obiektu niestandardowych w celu <xref:System.Net.Sockets.Socket.BeginSendFile%2A> formę `state` parametru.  
  
 Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndSendFile%2A> metody. Jeśli aplikacja wymaga <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, system używa oddzielnym wątku wykonania metody wywołania zwrotnego określonego i blokuje na <xref:System.Net.Sockets.Socket.EndSendFile%2A> do momentu <xref:System.Net.Sockets.Socket> wysyła cały plik lub zgłasza wyjątek. Aby uzyskać dodatkowe informacje o pisaniu metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Mimo że przeznaczonych dla połączeń protokołów <xref:System.Net.Sockets.Socket.BeginSendFile%2A> działa także dla protokołów bez połączenia, pod warunkiem, że pierwsze wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodę ustanawiania domyślnego hosta zdalnego. Przy użyciu protokołów przesyłanie również należy się upewnić, że rozmiar pliku przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie są wysyłane i <xref:System.Net.Sockets.Socket.BeginSendFile%2A> zgłasza <xref:System.Net.Sockets.SocketException> wyjątku.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException> wyjątek, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekstu zabezpieczeń, nazwa personifikowanego użytkownika i kontekst wywołania) jest buforowany asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określony asynchroniczne <xref:System.Net.Sockets.Socket> metoda, określony <xref:System.Net.Sockets.Socket> wystąpienia i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy i połączenie gniazda dla komunikacji asynchronicznej i rozpoczyna wysyłanie pliku "text.txt" asynchronicznie do hosta zdalnego. W tym przykładzie `preBuffer` i `postBuffer` danych jest utworzony w celu wysłania z pliku oraz domyślną <xref:System.Net.Sockets.TransmitFileOptions> wartość jest używana. Wywołuje delegata wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndSendFile%2A> aby zakończyć przekazywanie.  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej.</exception>
        <exception cref="T:System.NotSupportedException">System operacyjny nie jest systemu Windows NT lub nowszego.  \- lub - gniazda nie jest połączony z hostem zdalnym.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik <paramref name="fileName" /> nie został znaleziony.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="offset">Liczony od zera pozycja w <c>buforu</c> w którym należy rozpocząć wysyłanie danych.</param>
        <param name="size">Liczba bajtów do wysłania.</param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="remoteEP">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Delegowanie.</param>
        <param name="state">Obiekt zawierający informacje o stanie dla tego żądania.</param>
        <summary>Wysyła dane asynchronicznie do określonego hosta zdalnego.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Która odwołuje się asynchronicznego wysyłania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Metody rozpoczyna się operacja asynchronicznego wysyłania do hosta zdalnego określono w `remoteEP` parametru. Wywoływanie <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metody daje możliwość wysyłania danych w ramach oddzielnego wykonanie wątku. Mimo że przeznaczonych dla protokołów przesyłanie <xref:System.Net.Sockets.Socket.BeginSendTo%2A> współpracuje z protokołami przesyłanie i nawiązaniem połączenia.  
  
 Można utworzyć metody wywołania zwrotnego, który implementuje <xref:System.AsyncCallback> delegować i przekaż jej nazwę, aby <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metody. Aby to zrobić, w bardzo minimalna sieci `state` parametr musi zawierać połączenia lub domyślna <xref:System.Net.Sockets.Socket> używany do komunikacji. Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć klasę mała do przechowywania <xref:System.Net.Sockets.Socket>i inne wymagane informacje. Przekaż wystąpienie tej klasy do <xref:System.Net.Sockets.Socket.BeginSendTo%2A> formę `state` parametru.  
  
 Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndSendTo%2A> metody. Jeśli aplikacja wymaga <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, system użyje oddzielnym wątku wykonania metody wywołania zwrotnego określonego i blokuje na <xref:System.Net.Sockets.Socket.EndSendTo%2A> do momentu <xref:System.Net.Sockets.Socket> wysyła żądana liczba bajtów lub zgłasza wyjątek. Jeśli chcesz, aby oryginalnego wątku, aby zablokować po wywołaniu metody <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metody, użyj <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> metody. Wywołać metody Set T:System.Threading.ManualResetEvent metody wywołania zwrotnego w oryginalnym wątku w celu kontynuowania wykonywania. Aby uzyskać dodatkowe informacje na temat pisania metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Jeśli korzystasz z nawiązaniem połączenia protokołu, należy najpierw wywołać <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody, lub <xref:System.Net.Sockets.Socket.BeginSendTo%2A> zgłosi <xref:System.Net.Sockets.SocketException>. <xref:System.Net.Sockets.Socket.BeginSendTo%2A> zignoruje `remoteEP` parametr i wysyłania danych do <xref:System.Net.EndPoint> w <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody.  
  
 Jeśli używasz protokołu bez połączenia, nie należy ustanowić domyślnego hosta zdalnego z <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.BeginConnect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>. Należy to zrobić, jeśli zamierzasz wywołać <xref:System.Net.Sockets.Socket.BeginSend%2A> metody. Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.BeginConnect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` parametru spowoduje zastąpienie hosta zdalnego określoną wartość domyślną, dla którego tylko operacji wysyłania. Ponadto nie należy wywołać <xref:System.Net.Sockets.Socket.Bind%2A> metody. W takim przypadku podstawowego dostawcy usług przypisze najbardziej odpowiednia sieci lokalnej adres i numer portu. Numer portu równą zero, należy użyć, jeśli do wyboru portu wolne podstawowego dostawcy usług. Jeśli trzeba będzie zidentyfikować przypisaną sieci lokalnej adres i numer portu, możesz użyć <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwości po <xref:System.Net.Sockets.Socket.EndSendTo%2A> pomyślnym zakończeniu metody.  
  
 Jeśli chcesz wysyłać dane do adresu emisji, należy najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> — metoda i gniazda zestaw opcji w celu <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. -Również należy się upewnić, że rozmiar buforu przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie zostaną wysłane i <xref:System.Net.Sockets.Socket.EndSendTo%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketflags` parametru, dane są wysyłane, nie zostaną przesłane.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Kontekst wykonywania (kontekstu zabezpieczeń, nazwa personifikowanego użytkownika i kontekst wywołania) jest buforowany asynchroniczną <xref:System.Net.Sockets.Socket> metody. Po pierwszym użyciu określonego kontekstu (określony asynchroniczne <xref:System.Net.Sockets.Socket> metoda, określony <xref:System.Net.Sockets.Socket> wystąpienia i wywołania zwrotnego), kolejne używa tego kontekstu zobaczą zwiększenie wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu asynchronicznie wysyła dane do określonego hosta zdalnego.  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.  - lub - <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  - lub - <paramref name="offset" /> jest większa niż długość <paramref name="buffer" />.  - lub - <paramref name="size" /> jest mniejszy niż 0.  - lub - <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań nie ma uprawnienia dla żądanej operacji.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">Lokalna <see cref="T:System.Net.EndPoint" /> do skojarzenia z <see cref="T:System.Net.Sockets.Socket" />.</param>
        <summary>Kojarzy <see cref="T:System.Net.Sockets.Socket" /> z lokalnego punktu końcowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Net.Sockets.Socket.Bind%2A> metodę, jeśli należy użyć określonej lokalnego punktu końcowego. Należy wywołać <xref:System.Net.Sockets.Socket.Bind%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.Listen%2A> metody. Nie należy wywołać <xref:System.Net.Sockets.Socket.Bind%2A> przed użyciem <xref:System.Net.Sockets.Socket.Connect%2A> metody o ile nie trzeba używać określonego lokalnego punktu końcowego. Można użyć <xref:System.Net.Sockets.Socket.Bind%2A> metody na protokołach przesyłanie i nawiązaniem połączenia.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.Bind%2A>, należy najpierw utworzyć lokalnej <xref:System.Net.IPEndPoint> z którym zamierzasz przekazywania danych. Jeśli nie interesują, których adres lokalny jest przypisany, można utworzyć <xref:System.Net.IPEndPoint> przy użyciu <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> jako parametr adres i podległej usłudze dostawcy przypisze najbardziej odpowiedniego adresu sieciowego. Może to ułatwić uprościć aplikacji, jeśli masz wiele interfejsów sieciowych. Jeśli nie interesują port lokalny, który jest używany, można utworzyć <xref:System.Net.IPEndPoint> przy użyciu 0 numeru portu. W takim przypadku dostawcy usług przypisze numeru portu dostępna od 1024 do 5000.  
  
 Jeśli używasz powyższe podejście, użytkownik stwierdzi, jakie sieci lokalnej adres i numer portu przypisany przez wywołanie metody <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>. Jeśli używasz protokołu nawiązaniem połączenia, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> nie zwróci adres sieciowy lokalnie przypisanej do po dokonaniu wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.EndConnect%2A> metody. Jeśli używasz protokołu przesyłanie zostanie nie masz dostęp do tych informacji do momentu ukończenia wysyłanie lub odbieranie.  
  
 Jeśli gniazda UDP chce otrzymywać informacje o interfejsie na odebrane pakiety <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metoda powinna być jawnie wywołana z ustawioną opcją gniazda <xref:System.Net.Sockets.SocketOptionName.PacketInformation> natychmiast po wywołaniu <xref:System.Net.Sockets.Socket.Bind%2A> metody.  
  
> [!NOTE]
>  Jeśli zamierzasz odbierają datagramy multiemisji, należy wywołać <xref:System.Net.Sockets.Socket.Bind%2A> metody za pomocą numeru portu multiemisji.  
  
> [!NOTE]
>  Należy wywołać <xref:System.Net.Sockets.Socket.Bind%2A> metodę, jeśli chcesz otrzymywać datagramy bez połączenia przy użyciu <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException> podczas wywoływania metody <xref:System.Net.Sockets.Socket.Bind%2A> metody, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy kod przykładowy wiązania <xref:System.Net.Sockets.Socket> przy użyciu określonego lokalnego punktu końcowego.  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań nie ma uprawnienia dla żądanej operacji.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z zdefiniowanego przez hosta <paramref name="localEP" />. Wyliczenie skojarzone: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Net.Sockets.Socket" /> jest w trybie blokowania.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.Socket" /> zablokuje; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Blocking%2A> Właściwość wskazuje, czy <xref:System.Net.Sockets.Socket> jest w trybie blokowania.  
  
 Jeśli jesteś w trybie blokowania i wprowadzeniu metodę wywołania, które nie zakończy się natychmiast, aplikacja będzie blokował wykonywania aż do zakończenia żądanej operacji. Jeśli chcesz, aby wykonywania, aby kontynuować, mimo że żądana operacja nie jest pełną, zmień <xref:System.Net.Sockets.Socket.Blocking%2A> właściwości `false`. <xref:System.Net.Sockets.Socket.Blocking%2A> Właściwość nie ma wpływu na metod asynchronicznych. Jeśli są wysyłania i odbierania danych asynchronicznie i chcesz zablokować wykonywanie, użyj <xref:System.Threading.ManualResetEvent> klasy.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Obiekt używany do żądania połączenia z hostem zdalnym przez wywoływanie jednej z <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> metody.</param>
        <summary>Anuluje żądanie asynchroniczne dla połączenia zdalnego hosta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> Metody anuluje żądanie asynchroniczne dla połączenia zdalnego hosta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> Parametr nie może mieć wartości null i <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> nie może mieć wartości null.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań nie ma uprawnienia dla żądanej operacji.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zamyka <see cref="T:System.Net.Sockets.Socket" /> połączenia i wersje wszystkich skojarzonych zasobów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka <see cref="T:System.Net.Sockets.Socket" /> połączenia i wersje wszystkich skojarzonych zasobów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A> Metody zamyka połączenie z hostem zdalnym i zwalnia wszystkie zarządzane i niezarządzane zasoby skojarzone z <xref:System.Net.Sockets.Socket>. Przy zamykaniu <xref:System.Net.Sockets.Socket.Connected%2A> właściwość jest ustawiona na `false`.  
  
 Protokoły oparte na połączeniu, zalecane jest telefoniczne skontaktowanie się z <xref:System.Net.Sockets.Socket.Shutdown%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.Close%2A> metody. Dzięki temu, że wszystkie dane są wysyłane i odbierane na połączone gniazdo, przed jego zamknięciem.  
  
 Jeśli należy wywołać <xref:System.Net.Sockets.Socket.Close%2A> bez wywoływania pierwszego elementu <xref:System.Net.Sockets.Socket.Shutdown%2A>, można zapewnić, że dane w kolejce dla transmisji wychodzących będą wysyłane przez ustawienie <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> opcji w celu `false` i określając interwał limitu czasu inną niż zero. <xref:System.Net.Sockets.Socket.Close%2A> następnie będzie blokował te dane są wysyłane do chwili lub upływem określonego limitu czasu. Jeśli ustawisz <xref:System.Net.Sockets.SocketOptionName.DontLinger> do `false` i określ zero interwał limitu czasu, <xref:System.Net.Sockets.Socket.Close%2A> zwalnia połączenia i automatycznie odrzuca wszystkie dane w kolejce wychodzącej.  
  
> [!NOTE]
>  Aby ustawić <xref:System.Net.Sockets.SocketOptionName.DontLinger> gniazda opcję, aby `false`, utworzyć <xref:System.Net.Sockets.LingerOption>, ustawioną właściwość enabled `true`i ustaw <xref:System.Net.Sockets.LingerOption.LingerTime%2A> właściwości do okresu żądany limit czasu. Użyj tej <xref:System.Net.Sockets.LingerOption> wraz z <xref:System.Net.Sockets.SocketOptionName.DontLinger> gniazda opcję, aby wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy kod zamyka przykład <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">Poczekaj do <c>limitu czasu</c> sekund, aby wysłać pozostałe dane, a następnie zamknij gniazda.</param>
        <summary>Zamyka <see cref="T:System.Net.Sockets.Socket" /> połączenia i zwalnia wszystkie zasoby skojarzone z określonego limitu czasu, aby umożliwić danych umieszczonych w kolejce do wysłania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A> Metody zamyka połączenie z hostem zdalnym i zwalnia wszystkie zarządzane i niezarządzane zasoby skojarzone z <xref:System.Net.Sockets.Socket>. Przy zamykaniu <xref:System.Net.Sockets.Socket.Connected%2A> właściwość jest ustawiona na `false`.  
  
 Protokoły oparte na połączeniu, zalecane jest telefoniczne skontaktowanie się z <xref:System.Net.Sockets.Socket.Shutdown%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.Close%2A>. Dzięki temu, że wszystkie dane są wysyłane i odbierane na połączone gniazdo, przed jego zamknięciem.  
  
 Jeśli należy wywołać <xref:System.Net.Sockets.Socket.Close%2A> bez wywoływania pierwszego elementu <xref:System.Net.Sockets.Socket.Shutdown%2A>, można zapewnić, że dane w kolejce dla transmisji wychodzących będą wysyłane przez ustawienie <xref:System.Net.Sockets.SocketOptionName.DontLinger> opcji w celu `false` i określając interwał limitu czasu inną niż zero. <xref:System.Net.Sockets.Socket.Close%2A> następnie będzie blokował te dane są wysyłane do chwili lub upływem określonego limitu czasu. Jeśli ustawisz <xref:System.Net.Sockets.SocketOptionName.DontLinger> do `false` i określ zero interwał limitu czasu, <xref:System.Net.Sockets.Socket.Close%2A> zwalnia połączenia i automatycznie odrzuca wszystkie dane w kolejce wychodzącej.  
  
> [!NOTE]
>  Aby ustawić <xref:System.Net.Sockets.SocketOptionName.DontLinger> gniazda opcję, aby `false`, utworzyć <xref:System.Net.Sockets.LingerOption>, ustawioną właściwość enabled `true`i ustaw <xref:System.Net.Sockets.LingerOption.LingerTime%2A> właściwości żądany limit czasu. Użyj tej <xref:System.Net.Sockets.LingerOption> wraz z <xref:System.Net.Sockets.SocketOptionName.DontLinger> gniazda opcję, aby wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób zamknięcia <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustanawia połączenie z hostem zdalnym.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> Reprezentujący urządzenia zdalnego.</param>
        <summary>Ustanawia połączenie z hostem zdalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz nawiązaniem połączenia protokołu TCP, np. <xref:System.Net.Sockets.Socket.Connect%2A> metody synchronicznie ustanawia połączenie sieciowe między <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> i zdalny punkt końcowy określony. Jeśli używasz protokołu bez połączenia, <xref:System.Net.Sockets.Socket.Connect%2A> ustanawia domyślnego hosta zdalnego. Po wywołaniu metody <xref:System.Net.Sockets.Socket.Connect%2A>, może wysyłać dane do urządzenia zdalnego z <xref:System.Net.Sockets.Socket.Send%2A> metody, lub odbieranie danych z urządzenia zdalnego z <xref:System.Net.Sockets.Socket.Receive%2A> metody.  
  
 Jeśli używasz przesyłanie protokołu, takie jak protokół UDP jest konieczne wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wysyłania i odbierania danych. Można użyć <xref:System.Net.Sockets.Socket.SendTo%2A> i <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> synchroniczną komunikację z hostem zdalnym. Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.Connect%2A>, zostaną odrzucone datagramów odbierane z adresu innego niż określoną wartość domyślną. Jeśli chcesz ustawić domyślnego hosta zdalnego na adres emisji, należy najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> — metoda i gniazda zestaw opcji w celu <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, lub <xref:System.Net.Sockets.Socket.Connect%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> Zablokuje metody, chyba że użytkownik <xref:System.Net.Sockets.Socket.Blocking%2A> właściwości `false` przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>. Jeśli używasz protokołu nawiązaniem połączenia, np. TCP i możesz wyłączyć blokowanie, <xref:System.Net.Sockets.Socket.Connect%2A> zgłosi <xref:System.Net.Sockets.SocketException> ponieważ wymaga czasu do nawiązania połączenia. Przesyłanie protokołów nie spowoduje zgłoszenie wyjątku, ponieważ po prostu nawiązaniu domyślnego hosta zdalnego. Można użyć <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu. Jeśli ten błąd jest zwracany WSAEWOULDBLOCK, połączenie z hostem zdalnym została zainicjowana przez nawiązaniem połączenia <xref:System.Net.Sockets.Socket>, ale nie zostało jeszcze ukończone pomyślnie. Użyj <xref:System.Net.Sockets.Socket.Poll%2A> metody do określenia, kiedy <xref:System.Net.Sockets.Socket> zakończy połączenie.  
  
> [!NOTE]
>  Jeśli jest używany protokół nawiązaniem połączenia, a nie wywołał <xref:System.Net.Sockets.Socket.Bind%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>, podstawowego dostawcy usług przypisze adres i port numer sieci lokalnej. Jeśli używasz protokołu bez połączenia dostawcy usług nie przypisze adres i port numer sieci lokalnej do czasu ukończenia wysyłania lub operacji odbierania. Jeśli chcesz zmienić domyślnego hosta zdalnego wywołania <xref:System.Net.Sockets.Socket.Connect%2A> ponownie, podając żądanego punktu końcowego.  
  
> [!NOTE]
>  Jeśli wcześniej rozłączeniu gniazda nie można użyć tej metody, aby przywrócić połączenie. Użyj jednej z asynchroniczną <xref:System.Net.Sockets.Socket.BeginConnect%2A> metod w celu ponownego nawiązania połączenia. Jest to ograniczenie źródłowego dostawcy.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu łączy do zdalnego punktu końcowego i następnie sprawdza, czy połączenie.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań nie ma uprawnienia dla żądanej operacji.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> Została umieszczona w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
        <permission cref="T:System.Net.SocketPermission">do łączenia się z hostem zdalnym. Wyliczenie skojarzone: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">Adres IP hosta zdalnego.</param>
        <param name="port">Numer portu hosta zdalnego.</param>
        <summary>Ustanawia połączenie z hostem zdalnym. Host jest określany przez adres IP i numer portu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz nawiązaniem połączenia protokołu TCP, np. <xref:System.Net.Sockets.Socket.Connect%2A> metody synchronicznie ustanawia połączenie sieciowe między <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> i zdalny punkt końcowy określony. Jeśli używasz protokołu bez połączenia, <xref:System.Net.Sockets.Socket.Connect%2A> ustanawia domyślnego hosta zdalnego. Po wywołaniu metody <xref:System.Net.Sockets.Socket.Connect%2A> może wysyłać dane do urządzenia zdalnego z <xref:System.Net.Sockets.Socket.Send%2A> metody, lub odbieranie danych z urządzenia zdalnego z <xref:System.Net.Sockets.Socket.Receive%2A> metody.  
  
 Jeśli używasz przesyłanie protokołu, takie jak protokół UDP jest konieczne wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wysyłania i odbierania danych. Można użyć <xref:System.Net.Sockets.Socket.SendTo%2A> i <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> synchroniczną komunikację z hostem zdalnym. Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.Connect%2A> datagramów odbierane z adresu innego niż określoną wartość domyślną zostaną odrzucone. Jeśli chcesz ustawić domyślnego hosta zdalnego na adres emisji, należy najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> — metoda i gniazda zestaw opcji w celu <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, lub <xref:System.Net.Sockets.Socket.Connect%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> Metoda zablokuje, chyba że użytkownik <xref:System.Net.Sockets.Socket.Blocking%2A> właściwości `false` przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>. Jeśli używasz protokołu nawiązaniem połączenia, np. TCP i możesz wyłączyć blokowanie, <xref:System.Net.Sockets.Socket.Connect%2A> zgłosi <xref:System.Net.Sockets.SocketException> ponieważ wymaga czasu do nawiązania połączenia. Przesyłanie protokołów nie spowoduje zgłoszenie wyjątku, ponieważ po prostu nawiązaniu domyślnego hosta zdalnego. Można użyć <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu. Jeśli ten błąd jest zwracany WSAEWOULDBLOCK, połączenie z hostem zdalnym została zainicjowana przez nawiązaniem połączenia <xref:System.Net.Sockets.Socket>, ale nie zostało jeszcze ukończone pomyślnie. Użyj <xref:System.Net.Sockets.Socket.Poll%2A> metody do określenia, kiedy <xref:System.Net.Sockets.Socket> zakończy połączenie.  
  
> [!NOTE]
>  Jeśli jest używany protokół nawiązaniem połączenia, a nie wywołał <xref:System.Net.Sockets.Socket.Bind%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>, podstawowego dostawcy usług przypisze adres i port numer sieci lokalnej. Jeśli używasz protokołu bez połączenia dostawcy usług nie przypisze adres i port numer sieci lokalnej do czasu ukończenia wysyłania lub operacji odbierania. Jeśli chcesz zmienić domyślnego hosta zdalnego wywołania <xref:System.Net.Sockets.Socket.Connect%2A> ponownie, podając żądanego punktu końcowego.  
  
> [!NOTE]
>  Jeśli wcześniej rozłączeniu gniazda nie można użyć tej metody, aby przywrócić połączenie. Użyj jednej z asynchroniczną <xref:System.Net.Sockets.Socket.BeginConnect%2A> metod w celu ponownego nawiązania połączenia. Jest to ograniczenie źródłowego dostawcy.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu łączy do zdalnego punktu końcowego i następnie sprawdza, czy połączenie.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda jest prawidłowa dla gniazda w <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> rodziny.</exception>
        <exception cref="T:System.ArgumentException">Długość <paramref name="address" /> wynosi zero.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> Została umieszczona w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addresses">Adresy IP hosta zdalnego.</param>
        <param name="port">Numer portu hosta zdalnego.</param>
        <summary>Ustanawia połączenie z hostem zdalnym. Host jest określany przez tablicę adresów IP i numer portu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest zwykle używana bezpośrednio po wywołaniu <xref:System.Net.Dns.GetHostAddresses%2A>, które może zwracać wiele adresów IP dla jednego hosta. Jeśli używasz nawiązaniem połączenia protokołu TCP, np. <xref:System.Net.Sockets.Socket.Connect%2A> metody synchronicznie ustanawia połączenie sieciowe między <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> i zdalny punkt końcowy określony. Jeśli używasz protokołu bez połączenia, <xref:System.Net.Sockets.Socket.Connect%2A> ustanawia domyślnego hosta zdalnego. Po wywołaniu metody <xref:System.Net.Sockets.Socket.Connect%2A> może wysyłać dane do urządzenia zdalnego z <xref:System.Net.Sockets.Socket.Send%2A> metody, lub odbieranie danych z urządzenia zdalnego z <xref:System.Net.Sockets.Socket.Receive%2A> metody.  
  
 Jeśli używasz przesyłanie protokołu, takie jak protokół UDP jest konieczne wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wysyłania i odbierania danych. Można użyć <xref:System.Net.Sockets.Socket.SendTo%2A> i <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> synchroniczną komunikację z hostem zdalnym. Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.Connect%2A> datagramów odbierane z adresu innego niż określoną wartość domyślną zostaną odrzucone. Jeśli chcesz ustawić domyślnego hosta zdalnego na adres emisji, należy najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> — metoda i gniazda zestaw opcji w celu <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, lub <xref:System.Net.Sockets.Socket.Connect%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> Metoda zablokuje, chyba że użytkownik <xref:System.Net.Sockets.Socket.Blocking%2A> właściwości `false` przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>. Jeśli używasz protokołu nawiązaniem połączenia, np. TCP i możesz wyłączyć blokowanie, <xref:System.Net.Sockets.Socket.Connect%2A> zgłosi <xref:System.Net.Sockets.SocketException> ponieważ wymaga czasu do nawiązania połączenia. Przesyłanie protokołów nie spowoduje zgłoszenie wyjątku, ponieważ po prostu nawiązaniu domyślnego hosta zdalnego. Można użyć <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu. Jeśli ten błąd jest zwracany WSAEWOULDBLOCK, połączenie z hostem zdalnym została zainicjowana przez nawiązaniem połączenia <xref:System.Net.Sockets.Socket>, ale nie zostało jeszcze ukończone pomyślnie. Użyj <xref:System.Net.Sockets.Socket.Poll%2A> metody do określenia, kiedy <xref:System.Net.Sockets.Socket> zakończy połączenie.  
  
> [!NOTE]
>  Jeśli jest używany protokół nawiązaniem połączenia, a nie wywołał <xref:System.Net.Sockets.Socket.Bind%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>, podstawowego dostawcy usług przypisze adres i port numer sieci lokalnej. Jeśli używasz protokołu bez połączenia dostawcy usług nie przypisze adres i port numer sieci lokalnej do czasu ukończenia wysyłania lub operacji odbierania. Jeśli chcesz zmienić domyślnego hosta zdalnego wywołania <xref:System.Net.Sockets.Socket.Connect%2A> ponownie, podając żądanego punktu końcowego.  
  
> [!NOTE]
>  Jeśli wcześniej rozłączeniu gniazda nie można użyć tej metody, aby przywrócić połączenie. Użyj jednej z asynchroniczną <xref:System.Net.Sockets.Socket.BeginConnect%2A> metod w celu ponownego nawiązania połączenia. Jest to ograniczenie źródłowego dostawcy.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu łączy do zdalnego punktu końcowego i następnie sprawdza, czy połączenie.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addresses" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda jest prawidłowa dla gniazda w <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> rodziny.</exception>
        <exception cref="T:System.ArgumentException">Długość <paramref name="address" /> wynosi zero.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> Została umieszczona w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">Nazwa hosta zdalnego.</param>
        <param name="port">Numer portu hosta zdalnego.</param>
        <summary>Ustanawia połączenie z hostem zdalnym. Host jest określony przez nazwę hosta i numer portu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz nawiązaniem połączenia protokołu TCP, np. <xref:System.Net.Sockets.Socket.Connect%2A> metody synchronicznie ustanawia połączenie sieciowe między <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> i określonego hosta zdalnego. Jeśli używasz protokołu bez połączenia, <xref:System.Net.Sockets.Socket.Connect%2A> ustanawia domyślnego hosta zdalnego. Po wywołaniu metody <xref:System.Net.Sockets.Socket.Connect%2A> może wysyłać dane do urządzenia zdalnego z <xref:System.Net.Sockets.Socket.Send%2A> metody, lub odbieranie danych z urządzenia zdalnego z <xref:System.Net.Sockets.Socket.Receive%2A> metody.  
  
 Jeśli używasz przesyłanie protokołu, takie jak protokół UDP jest konieczne wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wysyłania i odbierania danych. Można użyć <xref:System.Net.Sockets.Socket.SendTo%2A> i <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> synchroniczną komunikację z hostem zdalnym. Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.Connect%2A> datagramów odbierane z adresu innego niż określoną wartość domyślną zostaną odrzucone. Jeśli chcesz ustawić domyślnego hosta zdalnego na adres emisji, należy najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> — metoda i gniazda zestaw opcji w celu <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, lub <xref:System.Net.Sockets.Socket.Connect%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> Metoda zablokuje, chyba że użytkownik <xref:System.Net.Sockets.Socket.Blocking%2A> właściwości `false` przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>. Jeśli używasz protokołu nawiązaniem połączenia, np. TCP i możesz wyłączyć blokowanie, <xref:System.Net.Sockets.Socket.Connect%2A> zgłosi <xref:System.Net.Sockets.SocketException> ponieważ wymaga czasu do nawiązania połączenia. Przesyłanie protokołów nie spowoduje zgłoszenie wyjątku, ponieważ po prostu nawiązaniu domyślnego hosta zdalnego. Można użyć <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu. Jeśli ten błąd jest zwracany WSAEWOULDBLOCK, połączenie z hostem zdalnym została zainicjowana przez nawiązaniem połączenia <xref:System.Net.Sockets.Socket>, ale nie zostało jeszcze ukończone pomyślnie. Użyj <xref:System.Net.Sockets.Socket.Poll%2A> metody do określenia, kiedy <xref:System.Net.Sockets.Socket> zakończy połączenie.  
  
 Jeśli włączony jest protokół IPv6 i <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> metoda jest wywoływana, aby połączyć się z hostem, który jest rozpoznawany jako IPv6 i adresy IPv4, połączenia protokołu IPv6, adres zostanie podjęto pierwszej przed adresem IPv4. Może to mieć wpływ opóźnienie czasu do nawiązania połączenia, jeśli host nie nasłuchuje na adresie IPv6.  
  
> [!NOTE]
>  Jeśli jest używany protokół nawiązaniem połączenia, a nie wywołał <xref:System.Net.Sockets.Socket.Bind%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.Connect%2A>, podstawowego dostawcy usług przypisze adres i port numer sieci lokalnej. Jeśli używasz protokołu bez połączenia dostawcy usług nie przypisze adres i port numer sieci lokalnej do czasu ukończenia wysyłania lub operacji odbierania. Jeśli chcesz zmienić domyślnego hosta zdalnego wywołania <xref:System.Net.Sockets.Socket.Connect%2A> ponownie, podając żądanego punktu końcowego.  
  
> [!NOTE]
>  Jeśli wcześniej rozłączeniu gniazda nie można użyć tej metody, aby przywrócić połączenie. Użyj jednej z asynchroniczną <xref:System.Net.Sockets.Socket.BeginConnect%2A> metod w celu ponownego nawiązania połączenia. Jest to ograniczenie źródłowego dostawcy.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu łączy do zdalnego punktu końcowego i następnie sprawdza, czy połączenie.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda jest prawidłowa dla gniazda w <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> rodziny.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> Została umieszczona w stanie nasłuchiwania przez wywołanie metody <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna się asynchroniczne żądanie dla połączenia z hostem zdalnym.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Obiekt ma być używany dla tej operacji asynchronicznej gniazda.</param>
        <summary>Rozpoczyna się asynchroniczne żądanie dla połączenia z hostem zdalnym.</summary>
        <returns>Zwraca <see langword="true" /> przypadku oczekujących operacji We/Wy. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenia w <paramref name="e" /> parametr zostanie wygenerowany, po zakończeniu operacji.  Zwraca <see langword="false" /> Jeśli synchronicznie wykonać operacji We/Wy. W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenia w <paramref name="e" /> parametr nie zostanie wygenerowany i <paramref name="e" /> przekazano obiekt jako parametr może być zbadana natychmiast po wywołaniu metody zwraca można pobrać wyniku operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz protokołu nawiązaniem połączenia, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metoda uruchamia asynchroniczne żądanie dla połączenia z hostem zdalnym. Jeśli używasz protokołu bez połączenia, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> ustanawia domyślnego hosta zdalnego.  
  
 Ma być powiadamiany o zakończeniu, należy utworzyć metody wywołania zwrotnego, który implementuje EventHandler\<obiektu SocketAsyncEventArgs > delegować i Dołącz do wywołania zwrotnego <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> zdarzeń.  
  
 Obiekt wywołujący musi ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> właściwości <xref:System.Net.IPEndPoint> zdalnego hosta, aby nawiązać połączenie.  
  
 Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwości do każdego obiektu stanu użytkownika potrzebne przed wywołaniem <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodę, tak, aby informacje pobieranie metody wywołania zwrotnego. Jeśli wywołanie zwrotne wymaga informacji więcej niż jeden obiekt, aby pomieścić inne wymagane informacje o stanie jako elementy członkowskie można tworzyć małych klasy.  
  
 Jeśli używasz przesyłanie protokołu, takie jak protokół UDP jest konieczne wywołać <xref:System.Net.Sockets.Socket.ConnectAsync%2A> przed wysyłania i odbierania danych. Można użyć <xref:System.Net.Sockets.Socket.SendToAsync%2A> i <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> do komunikowania się z hostem zdalnym. Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, zostaną odrzucone datagramów odbierane z adresu innego niż określoną wartość domyślną. Jeśli chcesz zmienić domyślnego hosta zdalnego wywołania <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metody ponownie z żądanego punktu końcowego.  
  
 Jeśli chcesz ustawić domyślnego hosta zdalnego na adres emisji, należy najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> ustawiono emisji `true`. Jeśli nie zostanie to zrobione, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metoda zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Poniższe właściwości i zdarzeń w <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiektu są wymagane:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 Opcjonalnie buforu można podać którego atomowo będą wysyłane w gnieździe po <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metoda zakończy się powodzeniem. W takim przypadku <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> właściwości musi być ustawiona w buforze zawierającego dane do wysłania i <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> właściwości musi być ustawiona liczba bajtów danych do wysyłania z buforu. Po nawiązaniu połączenia tego buforu danych są wysyłane.  
  
 Jeśli używasz protokołu nawiązaniem połączenia i nie należy wywoływać <xref:System.Net.Sockets.Socket.Bind%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, podstawowego dostawcy usług przypisze najbardziej odpowiedni adres i port numer sieci lokalnej.  
  
 Jeśli używasz protokołu bez połączenia dostawcy usług nie przypisze sieci lokalnej IP adres i numer portu do czasu wywołania <xref:System.Net.Sockets.Socket.SendAsync%2A> lub <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> metody.  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Metoda zgłasza <xref:System.NotSupportedException> Jeśli rodziny adres <xref:System.Net.Sockets.Socket> i <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> nie są ta sama Rodzina adresów.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException> podczas wywoływania tej metody, należy użyć <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Argument jest nieprawidłowy. Ten wyjątek występuje, gdy określono kilka buforów, <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> właściwość nie jest zerowa.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> Parametr nie może mieć wartości null i <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> nie może mieć wartości null.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> Jest nasłuchiwania lub Operacja gniazda zostało już w toku, używając <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiektu określonego w <paramref name="e" /> parametru.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP lub nowszy jest wymagany dla tej metody. Ten wyjątek występuje także w przypadku lokalnego punktu końcowego i <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> nie są ta sama Rodzina adresów.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań nie ma uprawnienia dla żądanej operacji.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="socketType">Jeden z <see cref="T:System.Net.Sockets.SocketType" /> wartości.</param>
        <param name="protocolType">Jeden z <see cref="T:System.Net.Sockets.ProtocolType" /> wartości.</param>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Obiekt ma być używany dla tej operacji asynchronicznej gniazda.</param>
        <summary>Rozpoczyna się asynchroniczne żądanie dla połączenia z hostem zdalnym.</summary>
        <returns>Zwraca <see langword="true" /> przypadku oczekujących operacji We/Wy. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenia w <paramref name="e" /> parametr zostanie wygenerowany, po zakończeniu operacji.  Zwraca <see langword="false" /> Jeśli synchronicznie wykonać operacji We/Wy. W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenia w <paramref name="e" /> parametr nie zostanie wygenerowany i <paramref name="e" /> przekazano obiekt jako parametr może być zbadana natychmiast po wywołaniu metody zwraca można pobrać wyniku operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli korzystasz z nawiązaniem połączenia protokołu, metoda M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) uruchamia dla żądania asynchronicznego połączenie z hostem zdalnym. Jeśli używasz protokołu bez połączenia, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> ustanawia domyślnego hosta zdalnego określone przez `socketType` i `protocolType` parametrów.  
  
 Ma być powiadamiany o zakończeniu, należy utworzyć metody wywołania zwrotnego, który implementuje EventHandler\<obiektu SocketAsyncEventArgs > delegować i Dołącz do wywołania zwrotnego <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> zdarzeń.  
  
 Obiekt wywołujący musi ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> właściwości <xref:System.Net.IPEndPoint> zdalnego hosta, aby nawiązać połączenie.  
  
 Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwości do każdego obiektu stanu użytkownika potrzebne przed wywołaniem <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodę, tak, aby informacje pobieranie metody wywołania zwrotnego. Jeśli wywołanie zwrotne wymaga informacji więcej niż jeden obiekt, aby pomieścić inne wymagane informacje o stanie jako elementy członkowskie można tworzyć małych klasy.  
  
 Jeśli używasz przesyłanie protokołu, takie jak protokół UDP jest konieczne wywołać <xref:System.Net.Sockets.Socket.ConnectAsync%2A> przed wysyłania i odbierania danych. Można użyć <xref:System.Net.Sockets.Socket.SendToAsync%2A> i <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> do komunikowania się z hostem zdalnym. Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, zostaną odrzucone datagramów odbierane z adresu innego niż określoną wartość domyślną. Jeśli chcesz zmienić domyślnego hosta zdalnego wywołania <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metody ponownie z żądanego punktu końcowego.  
  
 Jeśli chcesz ustawić domyślnego hosta zdalnego na adres emisji, należy najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> ustawiono emisji `true`. Jeśli nie zostanie to zrobione, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metoda zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Poniższe właściwości i zdarzeń w <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiektu są wymagane:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 Opcjonalnie buforu można podać którego atomowo będą wysyłane w gnieździe po <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metoda zakończy się powodzeniem. W takim przypadku <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> właściwości musi być ustawiona w buforze zawierającego dane do wysłania i <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> właściwości musi być ustawiona liczba bajtów danych do wysyłania z buforu. Po nawiązaniu połączenia tego buforu danych są wysyłane.  
  
 Jeśli używasz protokołu nawiązaniem połączenia i nie należy wywoływać <xref:System.Net.Sockets.Socket.Bind%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, podstawowego dostawcy usług przypisze najbardziej odpowiedni adres i port numer sieci lokalnej.  
  
 Jeśli używasz protokołu bez połączenia dostawcy usług nie przypisze sieci lokalnej IP adres i numer portu do czasu wywołania <xref:System.Net.Sockets.Socket.SendAsync%2A> lub <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> metody.  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Metoda zgłasza <xref:System.NotSupportedException> Jeśli rodziny adres <xref:System.Net.Sockets.Socket> i <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> nie są ta sama Rodzina adresów.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException> podczas wywoływania tej metody, należy użyć <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Argument jest nieprawidłowy. Ten wyjątek występuje, gdy określono kilka buforów, <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> właściwość nie jest zerowa.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> Parametr nie może mieć wartości null i <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> nie może mieć wartości null.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> Jest nasłuchiwania lub Operacja gniazda zostało już w toku, używając <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiektu określonego w <paramref name="e" /> parametru.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP lub nowszy jest wymagany dla tej metody. Ten wyjątek występuje także w przypadku lokalnego punktu końcowego i <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> nie są ta sama Rodzina adresów.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań nie ma uprawnienia dla żądanej operacji.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Net.Sockets.Socket" /> jest połączony z hostem zdalnym od ostatniego <see cref="Overload:System.Net.Sockets.Socket.Send" /> lub <see cref="Overload:System.Net.Sockets.Socket.Receive" /> operacji.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.Socket" /> został połączony z zasobem zdalnym, począwszy od ostatniej operacji, a w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Connected` Właściwości pobiera stan połączenia <xref:System.Net.Sockets.Socket> od ostatniej operacji We/Wy. Gdy zwraca `false`, <xref:System.Net.Sockets.Socket> nigdy nie był połączony lub nie jest już połączony.  
  
 Wartość <xref:System.Net.Sockets.Socket.Connected%2A> właściwość odzwierciedla stan połączenia od ostatniej operacji. Musisz określić bieżący stan połączenia, aby wywołać Send nieblokujących, zero bajtów. Jeśli wywołanie zwraca pomyślnie lub zgłasza wyjątek, kod błędu WAEWOULDBLOCK (10035), gniazda nadal jest połączony; w przeciwnym razie gniazda nie jest już połączony.  
  
 Jeśli wywołujesz <xref:System.Net.Sockets.Socket.Connect%2A> na gnieździe protokołu UDP (User Datagram), <xref:System.Net.Sockets.Socket.Connected%2A> właściwość zawsze zwraca `true`, jednak ta akcja nie powoduje zmiany właściwej natury przesyłanie UDP.  
  
   
  
## Examples  
 Poniższy przykładowy kod łączy się zdalny punkt końcowy kontroli <xref:System.Net.Sockets.Socket.Connected%2A> właściwości oraz sprawdza bieżący stan połączenia.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <see langword="true" /> Jeśli tego gniazda można ponownie użyć po zamknięciu bieżącego połączenia; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zamyka połączenie gniazda i umożliwia ponowne użycie gniazda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz protokołu nawiązaniem połączenia służy tej metody można zamknąć gniazda. Ta metoda kończy połączenia i zestawy <xref:System.Net.Sockets.Socket.Connected%2A> właściwości `false`. Jednak jeśli `reuseSocket` jest `true`, można użyć ponownie gniazda.  
  
 Aby upewnić się, że wszystkie dane są wysyłane i odbierane przed zamknięciem gniazda, należy wywołać <xref:System.Net.Sockets.Socket.Shutdown%2A> przed wywołaniem <xref:System.Net.Sockets.Socket.Disconnect%2A> metody.  
  
 Jeśli należy wywołać <xref:System.Net.Sockets.Socket.Disconnect%2A> bez wywoływania pierwszego elementu <xref:System.Net.Sockets.Socket.Shutdown%2A>, można ustawić <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> opcji w celu `false` i określ czas wygaśnięcia różna od zera, aby upewnić się, że dane w kolejce dla transmisji wychodzących są wysyłane. <xref:System.Net.Sockets.Socket.Disconnect%2A> następnie blokuje dane są przesyłane do chwili lub upływem określonego limitu czasu. Jeśli ustawisz <xref:System.Net.Sockets.SocketOptionName.DontLinger> do `false` i określ zero interwał limitu czasu, <xref:System.Net.Sockets.Socket.Close%2A> zwalnia połączenia i automatycznie odrzuca wszystkie dane w kolejce wychodzącej.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy gniazda komunikacji synchroniczne i wysyła określone dane do hosta zdalnego. Następnie wywołuje <xref:System.Net.Sockets.Socket.Shutdown%2A>, aby zatrzymać wysyłania i odbierania działania, a <xref:System.Net.Sockets.Socket.Disconnect%2A>, aby zamknąć połączenia gniazda.  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Ta metoda wymaga systemu Windows 2000 lub starszym, lub zostanie wygenerowany wyjątek.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Obiekt ma być używany dla tej operacji asynchronicznej gniazda.</param>
        <summary>Rozpoczyna się asynchroniczne żądanie rozłączenia ze zdalnego punktu końcowego.</summary>
        <returns>Zwraca <see langword="true" /> przypadku oczekujących operacji We/Wy. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenia w <paramref name="e" /> parametr zostanie wygenerowany, po zakończeniu operacji.  Zwraca <see langword="false" /> Jeśli synchronicznie wykonać operacji We/Wy. W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenia w <paramref name="e" /> parametr nie zostanie wygenerowany i <paramref name="e" /> przekazano obiekt jako parametr może być zbadana natychmiast po wywołaniu metody zwraca można pobrać wyniku operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas korzystania z połączeń protokołu, wywoływania <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> metoda żąda rozłączenia ze zdalnego punktu końcowego. Jeśli ustawisz <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> do `true` w `e` parametru gniazda mogą być ponownie używane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> Parametr nie może mieć wartości null.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja gniazda zostało już w toku, używając <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiektu określonego w <paramref name="e" /> parametru.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP lub nowszy jest wymagany dla tej metody.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie klasy <see cref="T:System.Net.Sockets.Socket" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie klasy <see cref="T:System.Net.Sockets.Socket" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie `Dispose` po zakończeniu przy użyciu <xref:System.Net.Sockets.Socket>. `Dispose` Pozostawia metody <xref:System.Net.Sockets.Socket> w stanie uniemożliwiającym jego używanie. Po wywołaniu `Dispose`, konieczne jest zwolnienie wszystkich odwołań do <xref:System.Net.Sockets.Socket> , moduł zbierający elementy bezużyteczne mógł odzyskać pamięć który <xref:System.Net.Sockets.Socket> klasy.  
  
 Aby uzyskać więcej informacji, zobacz [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [implementacja metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Wywoływanie zawsze `Dispose` przed zwolnieniem ostatniego odwołania do <xref:System.Net.Sockets.Socket>. W przeciwnym razie używa zasobów nie zostanie zwolniona do wywołania modułu zbierającego elementy bezużyteczne <xref:System.Net.Sockets.Socket> obiektu `Finalize` metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> powoduje zwolnienie tylko niezarządzane zasoby.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Net.Sockets.Socket" />i opcjonalnie usuwa zarządzane zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną `Dispose()` — metoda i <xref:System.Object.Finalize%2A> metody. `Dispose()` wywołuje chronioną metodę `Dispose(Boolean)` metody z `disposing` ustawiono parametr `true`. <xref:System.Object.Finalize%2A> wywołuje `Dispose` z `disposing` ustawioną `false`.  
  
 Gdy `disposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.Net.Sockets.Socket> odwołania. Ta metoda wywołuje `Dispose()` metody każdego odwołuje się do obiektu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> można wywoływać wielokrotnie przez inne obiekty. W przypadku przesłaniania <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, nie odwołują się obiekty, które zostały wcześniej zlikwidowane w wywołaniu wcześniejszych <see langword="Dispose" />. Aby uzyskać więcej informacji na temat sposobu wdrażania <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, zobacz [implementacja Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.  Aby uzyskać więcej informacji na temat <see langword="Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [czyszczenia Resources](~/docs/standard/garbage-collection/unmanaged.md) niezarządzane i [zastąpienie metody Finalize] (http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określająca, czy <see cref="T:System.Net.Sockets.Socket" /> umożliwia datagramów protokołu internetowego (IP) do fragmentacji.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.Socket" /> zezwala na fragmentację datagram; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Datagramy wymagają fragmentacji, gdy ich rozmiar przekracza maksymalny Transfer jednostki (MTU) nośnika transmisji. Datagramy może fragmentacji przez hosta wysyłania (wszystkie wersje Internet Protocol) lub router pośredniego (tylko Internet Protocol wersja 4). Jeśli datagram musi być pofragmentowane i <xref:System.Net.Sockets.Socket.DontFragment%2A> opcja jest ustawiona, datagram zostaną odrzucone i komunikat o błędzie komunikat protokołu sterowania Internetem (ICMP) są wysyłane do nadawcy datagram.  
  
 Ustawienie tej właściwości na gnieździe Transmission Control Protocol (TCP) nie odniesie żadnego skutku.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.Socket.DontFragment%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Tej właściwości można ustawić tylko dla gniazda w <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> rodziny.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określająca, czy <see cref="T:System.Net.Sockets.Socket" /> jest gniazda podwójne używany dla protokołów IPv4 i IPv6.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.Socket" /> jest gniazda podwójne; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">Identyfikator procesu docelowego, na których tworzone jest duplikatem odwołanie do gniazda.</param>
        <summary>Duplikaty odwołanie do gniazda dla procesu docelowego i zamyka gniazdo dla tego procesu.</summary>
        <returns>Odwołanie gniazda do przekazania do procesu docelowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Proces docelowy należy użyć <xref:System.Net.Sockets.Socket.%23ctor%2A> można utworzyć wystąpienia zduplikowane gniazda.  
  
 Jeśli należy wywołać <xref:System.Net.Sockets.Socket.%23ctor%2A> konstruktora wiele razy przy użyciu tej samej tablicy bajtów jako argument dla każdego wywołania, spowoduje utworzenie wielu zarządzanych <xref:System.Net.Sockets.Socket> wystąpień z tym samym gnieździe podstawowej. Takie rozwiązanie jest zalecane.  
  
 Jeśli proces tworzenia gniazda używa metod asynchronicznych (<xref:System.Net.Sockets.Socket.BeginReceive%2A> lub <xref:System.Net.Sockets.Socket.BeginSend%2A>), proces, należy najpierw ustawić <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> właściwości na wartość PRAWDA; w przeciwnym razie gniazda jest powiązany z portem ukończenia procesu tworzenia, co może spowodować <xref:System.ArgumentNullException> zostanie wygenerowany w procesie docelowym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="targetProcessID" /> nie jest prawidłową procesu o identyfikatorze.  - lub - dublowania odwołanie do gniazda nie powiodło się.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określająca, czy <see cref="T:System.Net.Sockets.Socket" /> może wysyłać i odbierać pakietów emisji.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.Socket" /> umożliwia pakietów emisji; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Emisja jest ograniczona do określonej podsieci i musi być User Datagram Protocol (UDP). Dla protokołu IP w wersji 4 można emitować do podsieci lokalnej, wysyłając pakiet do 255.255.255.255; lub może używać adres ukierunkowanej emisji, co jest częścią sieci adresu Internet Protocol (IP) z wszystkie bity w części dotyczącej hosta. Na przykład, jeśli adres IP jest 192.168.1.40 (klasy C adresu, maski podsieci 255.255.255.0 — część sieci jest pierwsze trzy oktety i część hosta jest ostatni oktet), adres ukierunkowanej emisji jest 192.168.1.255.  
  
 Ustawienie tej właściwości na gnieździe Transmission Control Protocol (TCP) nie odniesie żadnego skutku.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ta opcja dotyczy wyłącznie gniazdo datagramu.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asynchronicznie akceptuje przychodzące próba połączenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający bajtów przesłanych.</param>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Danych zdefiniowane przez obiekt zawierający informacje o stanie dla tej operacji asynchronicznej, a także dowolnego użytkownika.</param>
        <summary>Asynchronicznie akceptuje przychodzące próba połączenia i tworzy nowy <see cref="T:System.Net.Sockets.Socket" /> obiektu do obsługi komunikacji hosta zdalnego. Ta metoda zwraca buforu, który zawiera początkowe dane przesyłane.</summary>
        <returns>A <see cref="T:System.Net.Sockets.Socket" /> obiektu do obsługi komunikacji z hostem zdalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> wykonuje wywołanie <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginAccept%2A>, należy utworzyć metody wywołania zwrotnego, który jest wywoływany przez <xref:System.AsyncCallback> delegowanie. Ta metoda wywołania zwrotnego wykonuje w oddzielnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginAccept%2A> zwraca metody.  
  
 W ramach metody wywołania zwrotnego należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody `asyncResult` parametr, aby uzyskać <xref:System.Net.Sockets.Socket> , na którym odbywa się próba nawiązania połączenia. Po uzyskaniu <xref:System.Net.Sockets.Socket>, można wywołać <xref:System.Net.Sockets.Socket.EndAccept%2A> metody do pomyślnego ukończenia próba nawiązania połączenia. `buffer` Parametru tego przeciążenia zawiera dane, które zostało odebrane w wywołaniu <xref:System.Net.Sockets.Socket.BeginAccept%2A> i `bytesTransferred` parametr zawiera liczbę bajtów, które zostały przeniesione w wywołaniu.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Blokuje metody do momentu połączenia jest w stanie oczekiwania w kolejce połączeń przychodzących. <xref:System.Net.Sockets.Socket.EndAccept%2A> Metoda akceptuje połączenia przychodzące i zwraca nowy <xref:System.Net.Sockets.Socket> który może służyć do wysyłania i odbierania danych z hosta zdalnego.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.Sockets.Socket.BeginAccept%2A> do tworzenia i połączenia gniazda i zaakceptować początkowej 10 bajtów danych. Wywołuje delegata wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndAccept%2A> do zakończenia żądania asynchronicznego. Liczba bajtów wysłanych i dane są zwracane w `buffer` i `bytesTransferred` parametry tej metody i są wyświetlane w konsoli.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows NT jest wymagany dla tej metody.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest pusty.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie została utworzona przez wywołanie do <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> wcześniej wywołano metodę.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do <see cref="T:System.Net.Sockets.Socket" /></exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>Asynchronicznie akceptuje przychodzące próba połączenia i tworzy nowy <see cref="T:System.Net.Sockets.Socket" /> do obsługi komunikacji hosta zdalnego.</summary>
        <returns>A <see cref="T:System.Net.Sockets.Socket" /> do obsługi komunikacji z hostem zdalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> wykonuje wywołanie <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginAccept%2A>, należy utworzyć metody wywołania zwrotnego, który implementuje <xref:System.AsyncCallback> delegowanie. Ta metoda wywołania zwrotnego wykonuje w oddzielnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginAccept%2A> zwraca metody. Musi on zaakceptować `asyncResult` parametru zwrócony z <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody.  
  
 W ramach metody wywołania zwrotnego należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody `asyncResult` parametr, aby uzyskać <xref:System.Net.Sockets.Socket> , na którym odbywa się próba nawiązania połączenia. Po uzyskaniu <xref:System.Net.Sockets.Socket>, można wywołać <xref:System.Net.Sockets.Socket.EndAccept%2A> metody do pomyślnego ukończenia próba nawiązania połączenia.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Blokuje metody do momentu połączenia jest w stanie oczekiwania w kolejce połączeń przychodzących. <xref:System.Net.Sockets.Socket.EndAccept%2A> Metoda akceptuje połączenia przychodzące i zwraca nowy <xref:System.Net.Sockets.Socket> który może służyć do wysyłania i odbierania danych z hosta zdalnego.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu kończy żądanie asynchroniczne i tworzy nowy <xref:System.Net.Sockets.Socket> do akceptowania żądań połączenia przychodzących. Pełny przykład przedstawiający asynchroniczną komunikację z gniazda, zobacz [przykłady kodu gniazda](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie została utworzona przez wywołanie do <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz sekcję Spostrzeżenia, aby uzyskać więcej informacji.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> wcześniej wywołano metodę.</exception>
        <exception cref="T:System.NotSupportedException">Windows NT jest wymagany dla tej metody.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="bytesTransferred" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający bajtów przesłanych.</param>
        <param name="bytesTransferred">Liczba bajtów przesłanych.</param>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Danych zdefiniowane przez obiekt zawierający informacje o stanie dla tej operacji asynchronicznej, a także dowolnego użytkownika.</param>
        <summary>Asynchronicznie akceptuje przychodzące próba połączenia i tworzy nowy <see cref="T:System.Net.Sockets.Socket" /> obiektu do obsługi komunikacji hosta zdalnego. Ta metoda zwraca buforu, który zawiera dane pierwotne oraz liczbę bajtów przesłanych.</summary>
        <returns>A <see cref="T:System.Net.Sockets.Socket" /> obiektu do obsługi komunikacji z hostem zdalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> wykonuje wywołanie <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginAccept%2A>, należy utworzyć metody wywołania zwrotnego, który jest wywoływany przez <xref:System.AsyncCallback> delegowanie. Ta metoda wywołania zwrotnego wykonuje w oddzielnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginAccept%2A> zwraca metody. Musi on zaakceptować `asyncResult` parametru zwrócony z <xref:System.Net.Sockets.Socket.BeginAccept%2A> metody.  
  
 W ramach metody wywołania zwrotnego należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody `asyncResult` parametr, aby uzyskać <xref:System.Net.Sockets.Socket> , na którym odbywa się próba nawiązania połączenia. Po uzyskaniu <xref:System.Net.Sockets.Socket>, można wywołać <xref:System.Net.Sockets.Socket.EndAccept%2A> metody do pomyślnego ukończenia próba nawiązania połączenia. `buffer` Parametru tego przeciążenia zawiera dane, które zostało odebrane w wywołaniu <xref:System.Net.Sockets.Socket.BeginAccept%2A> i `bytesTransferred` parametr zawiera liczbę bajtów, które zostały przeniesione w wywołaniu.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Blokuje metody do momentu połączenia jest w stanie oczekiwania w kolejce połączeń przychodzących. <xref:System.Net.Sockets.Socket.EndAccept%2A> Metoda akceptuje połączenia przychodzące i zwraca nowy <xref:System.Net.Sockets.Socket> który może służyć do wysyłania i odbierania danych z hosta zdalnego.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.Sockets.Socket.BeginAccept%2A> do tworzenia i połączenia gniazda i zaakceptować początkowej 10 bajtów danych. Wywołuje delegata wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndAccept%2A> do zakończenia żądania asynchronicznego. Liczba bajtów wysłanych i dane są zwracane w `buffer` i `bytesTransferred` parametry tej metody i są wyświetlane w konsoli.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows NT jest wymagany dla tej metody.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest pusty.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie została utworzona przez wywołanie do <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> wcześniej wywołano metodę.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>Zakończenie żądania oczekujące połączenia asynchronicznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A> blokowanie metody, która kończy żądanie połączenia asynchronicznego hosta zdalnego jest uruchomiona w <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginConnect%2A>, należy utworzyć metody wywołania zwrotnego, który implementuje <xref:System.AsyncCallback> delegowanie. Ta metoda wywołania zwrotnego wykonuje w oddzielnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginConnect%2A> zwraca. Metoda wywołania zwrotnego musi obsługiwać <xref:System.IAsyncResult> zwrócony przez <xref:System.Net.Sockets.Socket.BeginConnect%2A> metody jako parametr.  
  
 W ramach metody wywołania zwrotnego należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody <xref:System.IAsyncResult> parametr, aby uzyskać <xref:System.Net.Sockets.Socket> , na którym odbywa się próba nawiązania połączenia. Po uzyskaniu <xref:System.Net.Sockets.Socket>, można wywołać <xref:System.Net.Sockets.Socket.EndConnect%2A> metody do pomyślnego ukończenia próba nawiązania połączenia.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu kończy się próba połączenia asynchronicznego. Pełny przykład przedstawiający asynchroniczną komunikację z gniazda, zobacz [przykłady kodu gniazda](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie został zwrócony przez wywołanie do <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> wcześniej została wywołana dla połączenia asynchronicznego.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Obiekt zawierający informacje o stanie i danych zdefiniowanych przez użytkownika dla tej operacji asynchronicznej.</param>
        <summary>Zakończenie żądania oczekujące asynchronicznego odłączania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> wykonuje wywołanie <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>. <xref:System.Net.Sockets.Socket.EndDisconnect%2A> Blokuje metody do momentu ukończenia Rozłącz. Aby uzyskać informacje o operacji asynchronicznych zobacz temat Omówienie programowania asynchronicznego w bibliotece MSDN.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy gniazda dla komunikacji asynchronicznej i wysyła określone dane z hostem zdalnym. Po wysłaniu danych <xref:System.Net.Sockets.Socket.Shutdown%2A> jest wywoływana w celu zatrzymania wysyłania i odbierania działania. Następnie <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> jest wywoływana, aby rozpocząć żądanie rozłączenia. Wywołuje delegata wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndDisconnect%2A> do zakończenia żądania asynchronicznego. Po zakończeniu wykonywania żądania <xref:System.Net.Sockets.Socket.Connected%2A> właściwości jest poddawany kwerendzie, aby sprawdzić, czy gniazda jest odłączony.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">System operacyjny jest system Windows 2000 lub starszym, a ta metoda wymaga systemu Windows XP.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie został zwrócony przez wywołanie do <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> wcześniej została wywołana dla połączenia asynchronicznego.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.Net.WebException">Upłynął limit czasu żądania rozłączenia.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kończy się oczekujące odczyt asynchroniczny.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>Kończy się oczekujące odczyt asynchroniczny.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> Ukończeniu metody asynchronicznej operacji odczytu w <xref:System.Net.Sockets.Socket.BeginReceive%2A> metody.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginReceive%2A>, należy utworzyć metody wywołania zwrotnego, który implementuje <xref:System.AsyncCallback> delegowanie. Ta metoda wywołania zwrotnego wykonuje w oddzielnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginReceive%2A> zwraca. Metoda wywołania zwrotnego musi obsługiwać <xref:System.IAsyncResult> zwrócony przez <xref:System.Net.Sockets.Socket.BeginReceive%2A> metody jako parametr.  
  
 W obrębie metody wywołania zwrotnego należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody <xref:System.IAsyncResult> można uzyskać stanu obiekt przekazany do <xref:System.Net.Sockets.Socket.BeginReceive%2A> metody. Wyodrębnij odbieranie <xref:System.Net.Sockets.Socket> z tego stanu obiektu. Po uzyskaniu <xref:System.Net.Sockets.Socket>, można wywołać <xref:System.Net.Sockets.Socket.EndReceive%2A> metodę, aby pomyślnie wykonać operacji odczytu i zwraca liczbę bajtów do odczytu.  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> Metody zablokuje dopóki dane są dostępne. Jeśli używasz protokołu bez połączenia, <xref:System.Net.Sockets.Socket.EndReceive%2A> odczyta pierwszy dostępny w buforze przychodzącego sieci datagram umieszczonych w kolejce. Jeśli używasz protokołu nawiązaniem połączenia, <xref:System.Net.Sockets.Socket.EndReceive%2A> metoda odczytuje jak najwięcej danych, ponieważ są dostępne do liczby bajtów określonych w `size` parametr <xref:System.Net.Sockets.Socket.BeginReceive%2A> metody. Jeśli host zdalny wyłączony <xref:System.Net.Sockets.Socket> połączenia z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano — metoda i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.EndReceive%2A> metoda zostanie natychmiast wykonać i zwraca zero bajtów.  
  
 Aby uzyskać odebranych danych, należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody <xref:System.IAsyncResult>i Wyodrębnij buforu zawarte w powstałym obiekcie stanu.  
  
 Aby anulować oczekujące <xref:System.Net.Sockets.Socket.BeginReceive%2A>, wywołaj <xref:System.Net.Sockets.Socket.Close%2A> metody.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Wszystkie operacje We/Wy inicjowane przez danego wątku jest anulowany, gdy który wątku wyjścia. Istnieje oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek kończy się przed zakończeniem operacji.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu kończy oczekujące odczyt asynchroniczny. Pełny przykład przedstawiający asynchroniczną komunikację z gniazda, zobacz [przykłady kodu gniazda](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie został zwrócony przez wywołanie do <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> wcześniej została wywołana dla odczyt asynchroniczny.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Która przechowuje informacje o stanie i danych zdefiniowanych przez użytkownika dla tej operacji asynchronicznej.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> obiekt zawierający błąd gniazda.</param>
        <summary>Kończy się oczekujące odczyt asynchroniczny.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> Ukończeniu metody asynchronicznej operacji odczytu w <xref:System.Net.Sockets.Socket.BeginReceive%2A> metody.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginReceive%2A>, należy utworzyć metody wywołania zwrotnego, który implementuje <xref:System.AsyncCallback> delegowanie. Ta metoda wywołania zwrotnego wykonuje w oddzielnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginReceive%2A> zwraca. Metoda wywołania zwrotnego musi obsługiwać <xref:System.IAsyncResult> zwrócony przez <xref:System.Net.Sockets.Socket.BeginReceive%2A> metody jako parametr.  
  
 W obrębie metody wywołania zwrotnego należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody <xref:System.IAsyncResult> można uzyskać stanu obiekt przekazany do <xref:System.Net.Sockets.Socket.BeginReceive%2A> metody. Wyodrębnij odbieranie <xref:System.Net.Sockets.Socket> z tego stanu obiektu. Po uzyskaniu <xref:System.Net.Sockets.Socket>, można wywołać <xref:System.Net.Sockets.Socket.EndReceive%2A> metodę, aby pomyślnie wykonać operacji odczytu i zwraca liczbę bajtów do odczytu.  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> Metody zablokuje dopóki dane są dostępne. Jeśli używasz protokołu bez połączenia, <xref:System.Net.Sockets.Socket.EndReceive%2A> odczyta pierwszy dostępny w buforze przychodzącego sieci datagram umieszczonych w kolejce. Jeśli używasz protokołu nawiązaniem połączenia, <xref:System.Net.Sockets.Socket.EndReceive%2A> metoda odczytuje jak najwięcej danych, ponieważ są dostępne do liczby bajtów określonych w `size` parametr <xref:System.Net.Sockets.Socket.BeginReceive%2A> metody. Jeśli host zdalny wyłączony <xref:System.Net.Sockets.Socket> połączenia z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano — metoda i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.EndReceive%2A> metoda zostanie natychmiast wykonać i zwraca zero bajtów.  
  
 Aby uzyskać odebranych danych, należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody <xref:System.IAsyncResult>i Wyodrębnij buforu zawarte w powstałym obiekcie stanu.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Wszystkie operacje We/Wy inicjowane przez danego wątku jest anulowany, gdy który wątku wyjścia. Istnieje oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek kończy się przed zakończeniem operacji.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie został zwrócony przez wywołanie do <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> wcześniej została wywołana dla odczyt asynchroniczny.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="end_point" Type="System.Net.EndPoint&amp;" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <param name="endPoint">To be added.</param>
        <param name="end_point">To be added.</param>
        <summary>Kończy się oczekujące asynchroniczny odczyt z określonego punktu końcowego.</summary>
        <returns>W przypadku powodzenia liczba bajtów odebranych. W przypadku niepowodzenia zwraca wartość 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Ukończeniu metody asynchronicznej operacji odczytu w <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, należy utworzyć metody wywołania zwrotnego, który implementuje <xref:System.AsyncCallback> delegowanie. Ta metoda wywołania zwrotnego wykonuje w oddzielnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> zwraca. Metoda wywołania zwrotnego musi obsługiwać <xref:System.IAsyncResult> zwrócony przez <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody jako parametr.  
  
 W obrębie metody wywołania zwrotnego należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody <xref:System.IAsyncResult> można uzyskać stanu obiekt przekazany do <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody. Wyodrębnij odbieranie <xref:System.Net.Sockets.Socket> z tego stanu obiektu. Po uzyskaniu <xref:System.Net.Sockets.Socket>, można wywołać <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> metodę, aby pomyślnie wykonać operacji odczytu i zwraca liczbę bajtów do odczytu.  
  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Metody zablokuje dopóki dane są dostępne. Jeśli używasz protokołu bez połączenia, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> odczyta pierwszy dostępny w buforze przychodzącego sieci datagram umieszczonych w kolejce. Jeśli używasz protokołu nawiązaniem połączenia, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> metoda odczytuje jak najwięcej danych, ponieważ są dostępne do liczby bajtów określonych w `size` parametr <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metody. Jeśli host zdalny wyłączony <xref:System.Net.Sockets.Socket> połączenia z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano — metoda i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> metoda zostanie natychmiast wykonać i zwraca zero bajtów. Aby uzyskać odebranych danych, należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody <xref:System.IAsyncResult> obiektu, a następnie Wyodrębnij buforu zawarte w powstałym obiekcie stanu. Aby zidentyfikować hosta źródłowego, Wyodrębnij <xref:System.Net.EndPoint> i rzutować obiekt <xref:System.Net.IPEndPoint>. Użyj <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> metodę, aby uzyskać adres IP i <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> sposób uzyskać numer portu.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu kończy się oczekujące asynchroniczny odczyt z konkretną <xref:System.Net.EndPoint>.  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie został zwrócony przez wywołanie do <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> wcześniej została wywołana dla odczyt asynchroniczny.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Która przechowuje informacje o stanie i danych zdefiniowanych przez użytkownika dla tej operacji asynchronicznej.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości odebrany pakiet.</param>
        <param name="endPoint">Źródło <see cref="T:System.Net.EndPoint" />.</param>
        <param name="ipPacketInformation">
          <see cref="T:System.Net.IPAddress" /> i interfejsu Odebrano pakiet.</param>
        <summary>Kończy się oczekujące asynchroniczny odczyt z określonego punktu końcowego. Ta metoda również wskazuje więcej informacji na temat pakietów niż <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</summary>
        <returns>W przypadku powodzenia liczba bajtów odebranych. W przypadku niepowodzenia zwraca wartość 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli działanie nie zostało ukończone, ta metoda blokuje, dopóki nie robi.  
  
 Aby wykonać tę operację synchronicznie, użyj <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metody.  
  
 Sprawdź `ipPacketInformation` Jeśli musisz wiedzieć, czy datagram został wysłany przy użyciu emisji pojedynczej, adres multiemisji lub emisji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" /> - lub - <paramref name="endPoint" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie został zwrócony przez wywołanie do <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> wcześniej została wywołana dla odczyt asynchroniczny.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kończy się oczekujące asynchronicznego wysyłania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>Kończy się oczekujące asynchronicznego wysyłania.</summary>
        <returns>Jeśli się powodzeniem, liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />; w przeciwnym razie nieprawidłową <see cref="T:System.Net.Sockets.Socket" /> błędu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> wykonuje operację asynchronicznego wysyłania w <xref:System.Net.Sockets.Socket.BeginSend%2A>.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSend%2A>, należy utworzyć metody wywołania zwrotnego, który implementuje <xref:System.AsyncCallback> delegowanie. Ta metoda wywołania zwrotnego wykonuje w oddzielnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginSend%2A> zwraca. Metoda wywołania zwrotnego musi obsługiwać <xref:System.IAsyncResult> zwrócony przez <xref:System.Net.Sockets.Socket.BeginSend%2A> metody jako parametr.  
  
 W ramach metody wywołania zwrotnego należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody <xref:System.IAsyncResult> parametr, aby uzyskać wysyłanie <xref:System.Net.Sockets.Socket>. Po uzyskaniu <xref:System.Net.Sockets.Socket>, można wywołać <xref:System.Net.Sockets.Socket.EndSend%2A> metodę pomyślnie ukończyć operacji wysyłania i zwraca liczbę bajtów wysłanych.  
  
 Jeśli używasz protokołu bez połączenia, <xref:System.Net.Sockets.Socket.EndSend%2A> zablokuje momentu wysłania datagram. Jeśli używasz protokołu nawiązaniem połączenia, <xref:System.Net.Sockets.Socket.EndSend%2A> zablokuje dopóki niektóre buforu została wysłana. Jeśli wartość zwrotu z <xref:System.Net.Sockets.Socket.EndSend%2A> wskazuje, że bufor nie jest całkowicie wysyłane, wywołaj <xref:System.Net.Sockets.Socket.BeginSend%2A> metody ponownie, modyfikując buforu do przechowywania danych niewysłanych.  
  
 Nie ma żadnej gwarancji, który danych wysyłanych będzie widoczny w sieci, natychmiast. Aby zwiększyć wydajność sieci, źródłowy system może być opóźniona transmisji, dopóki nie są zbierane znaczną ilość danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.BeginSend%2A> metody oznacza, że źródłowy system miał miejsca w buforze wysyłania danych w sieci.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Wszystkie operacje We/Wy inicjowane przez danego wątku jest anulowany, gdy który wątku wyjścia. Istnieje oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek kończy się przed zakończeniem operacji.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że danych zostało pomyślnie dostarczone. Jeśli nie ma przestrzeni buforu w systemie transportu do przechowywania danych, które mają być przekazywane, wysyłania zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu kończy oczekujące asynchronicznego wysyłania.  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie został zwrócony przez wywołanie do <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> wcześniej została wywołana dla asynchronicznego wysyłania.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Która przechowuje informacje o stanie dla tej operacji asynchronicznej.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> obiekt zawierający błąd gniazda.</param>
        <summary>Kończy się oczekujące asynchronicznego wysyłania.</summary>
        <returns>Jeśli się powodzeniem, liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />; w przeciwnym razie nieprawidłową <see cref="T:System.Net.Sockets.Socket" /> błędu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> wykonuje operację asynchronicznego wysyłania w <xref:System.Net.Sockets.Socket.BeginSend%2A>.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSend%2A>, należy utworzyć metody wywołania zwrotnego, który implementuje <xref:System.AsyncCallback> delegowanie. Ta metoda wywołania zwrotnego wykonuje w oddzielnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginSend%2A> zwraca. Metoda wywołania zwrotnego musi obsługiwać <xref:System.IAsyncResult> zwrócony przez <xref:System.Net.Sockets.Socket.BeginSend%2A> metody jako parametr.  
  
 W ramach metody wywołania zwrotnego należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody <xref:System.IAsyncResult> parametr, aby uzyskać wysyłanie <xref:System.Net.Sockets.Socket>. Po uzyskaniu <xref:System.Net.Sockets.Socket>, można wywołać <xref:System.Net.Sockets.Socket.EndSend%2A> metodę pomyślnie ukończyć operacji wysyłania i zwraca liczbę bajtów wysłanych.  
  
 Jeśli używasz protokołu bez połączenia, <xref:System.Net.Sockets.Socket.EndSend%2A> zablokuje momentu wysłania datagram. Jeśli używasz protokołu nawiązaniem połączenia, <xref:System.Net.Sockets.Socket.EndSend%2A> zablokuje dopóki niektóre buforu została wysłana. Jeśli wartość zwrotu z <xref:System.Net.Sockets.Socket.EndSend%2A> wskazuje, że bufor nie jest całkowicie wysyłane, wywołaj <xref:System.Net.Sockets.Socket.BeginSend%2A> metody ponownie, modyfikując buforu do przechowywania danych niewysłanych.  
  
 Nie ma żadnej gwarancji, który danych wysyłanych będzie widoczny w sieci, natychmiast. Aby zwiększyć wydajność sieci, źródłowy system może być opóźniona transmisji, dopóki nie są zbierane znaczną ilość danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.BeginSend%2A> metody oznacza, że źródłowy system miał miejsca w buforze wysyłania danych w sieci.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Wszystkie operacje We/Wy inicjowane przez danego wątku jest anulowany, gdy który wątku wyjścia. Istnieje oczekująca operacja asynchroniczna może zakończyć się niepowodzeniem, jeśli wątek kończy się przed zakończeniem operacji.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że danych zostało pomyślnie dostarczone. Jeśli nie ma przestrzeni buforu w systemie transportu do przechowywania danych, które mają być przekazywane, wysyłania zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie został zwrócony przez wywołanie do <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> wcześniej została wywołana dla asynchronicznego wysyłania.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Obiekt zawierający informacje o stanie dla tej operacji asynchronicznej.</param>
        <summary>Kończy się oczekujące asynchronicznego wysyłania pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A> wykonuje operację asynchronicznego wysyłania w <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, należy utworzyć metody wywołania zwrotnego, który implementuje <xref:System.AsyncCallback> delegowanie. Ta metoda wywołania zwrotnego wykonuje w oddzielnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginSendFile%2A> zwraca. Metoda wywołania zwrotnego musi obsługiwać <xref:System.IAsyncResult> obiektu zwróconego przez <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metody jako parametr.  
  
 W ramach metody wywołania zwrotnego należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody <xref:System.IAsyncResult> parametr, aby uzyskać wysyłanie <xref:System.Net.Sockets.Socket>. Po uzyskaniu <xref:System.Net.Sockets.Socket>, można wywołać <xref:System.Net.Sockets.Socket.EndSendFile%2A> metody do pomyślnego ukończenia operacji wysyłania.  
  
 Jeśli używasz protokołu bez połączenia, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blokuje momentu wysłania datagram. Jeśli używasz protokołu nawiązaniem połączenia, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blokuje momentu wysłania całego pliku. Nie ma żadnej gwarancji, który danych wysyłanych będzie widoczny w sieci, natychmiast. Aby zwiększyć wydajność sieci, źródłowy system może być opóźniona transmisji, dopóki nie są zbierane znaczną ilość danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metody oznacza, że źródłowy system miał miejsca w buforze wysyłania danych w sieci.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy i połączenie gniazda dla komunikacji asynchronicznej i rozpoczyna wysyłanie pliku "text.txt" asynchronicznie do hosta zdalnego. Wywołuje delegata wywołania zwrotnego <xref:System.Net.Sockets.Socket.EndSendFile%2A> aby zakończyć przekazywanie.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows NT jest wymagany dla tej metody.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest pusty.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie został zwrócony przez wywołanie do <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> wcześniej została wywołana dla asynchroniczną <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>Kończy się oczekujące asynchronicznego wysyłania do określonej lokalizacji.</summary>
        <returns>Jeśli powiodło się, liczba bajtów wysłanych; w przeciwnym razie nieprawidłową <see cref="T:System.Net.Sockets.Socket" /> błędu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A> wykonuje operację asynchronicznego wysyłania w <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.  
  
 Przed wywołaniem <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, należy utworzyć metody wywołania zwrotnego, który implementuje <xref:System.AsyncCallback> delegowanie. Ta metoda wywołania zwrotnego wykonuje w oddzielnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.Socket.BeginReceive%2A> zwraca. Metoda wywołania zwrotnego musi obsługiwać <xref:System.IAsyncResult> zwrócony przez <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metody jako parametr.  
  
 W ramach metody wywołania zwrotnego należy wywołać <xref:System.IAsyncResult.AsyncState%2A> metody <xref:System.IAsyncResult> parametr, aby uzyskać wysyłanie <xref:System.Net.Sockets.Socket>. Po uzyskaniu <xref:System.Net.Sockets.Socket>, można wywołać <xref:System.Net.Sockets.Socket.EndSendTo%2A> metodę pomyślnie ukończyć operacji wysyłania i zwraca liczbę bajtów wysłanych.  
  
 Jeśli używasz protokołu bez połączenia, <xref:System.Net.Sockets.Socket.EndSendTo%2A> zablokuje momentu wysłania datagram. Jeśli używasz protokołu nawiązaniem połączenia, <xref:System.Net.Sockets.Socket.EndSendTo%2A> zablokuje dopóki wysłaniem żądanej liczby bajtów. Nie ma żadnej gwarancji, który danych wysyłanych będzie widoczny w sieci, natychmiast. Aby zwiększyć wydajność sieci, źródłowy system może być opóźniona transmisji, dopóki nie są zbierane znaczną ilość danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metody oznacza, że źródłowy system miał miejsca w buforze wysyłania danych w sieci.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu kończy asynchronicznego wysyłania do określonej lokalizacji.  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie został zwrócony przez wywołanie do <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> wcześniej została wywołana dla asynchronicznego wysyłania.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określająca, czy <see cref="T:System.Net.Sockets.Socket" /> umożliwia tylko jeden proces powiązać z portem.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.Socket" /> umożliwia tylko jednego gniazda do powiązania do określonego portu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" /> dla systemu Windows Server 2003 i Windows XP z dodatkiem Service Pack 2 i <see langword="false" /> dla wszystkich innych wersji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> jest `false`, można użyć wielu sockets <xref:System.Net.Sockets.Socket.Bind%2A> metody do powiązania do określonego portu; jednak tylko jeden z gniazdami mogą wykonywać operacje na ruch sieciowy wysyłane do portu. Jeśli więcej niż jedno gniazdo próbuje użyć <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> metody powiązać z określonego portu, a następnie jedną z bardziej określony adres IP będzie obsługiwać ruch sieciowy, wysyłane do tego portu.  
  
 Jeśli <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> jest `true`, pierwsze użycie elementu <xref:System.Net.Sockets.Socket.Bind%2A> powiedzie się próba powiązania do określonego portu, niezależnie od adresu Internet Protocol (IP), metoda; wszystkie kolejne korzysta z <xref:System.Net.Sockets.Socket.Bind%2A> sposób powiązania tego portu będą zakończyć się niepowodzeniem, dopóki nie zostanie zniszczony oryginalnego gniazda powiązania.  
  
 Ta właściwość musi być ustawiona przed <xref:System.Net.Sockets.Socket.Bind%2A> jest wywołana; w przeciwnym <xref:System.InvalidOperationException> zostanie wygenerowany.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> została wywołana dla tego <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.Net.Sockets.Socket" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> Klasy wywołania finalizator <xref:System.Net.Sockets.Socket.Close%2A> metody, aby zamknąć <xref:System.Net.Sockets.Socket> i zwolnić zasoby skojarzone z <xref:System.Net.Sockets.Socket>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość <see cref="T:System.Net.Sockets.Socket" /> opcji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Jeden z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</param>
        <param name="optionName">Jeden z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</param>
        <summary>Zwraca wartość określonej <see cref="T:System.Net.Sockets.Socket" /> opcji reprezentowany przez obiekt.</summary>
        <returns>Obiekt, który reprezentuje wartość opcji. Gdy <paramref name="optionName" /> ustawiono parametr <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> wartość zwracana jest wystąpieniem <see cref="T:System.Net.Sockets.LingerOption" /> klasy. Gdy <paramref name="optionName" /> ustawiono <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> lub <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, wartość zwracana jest wystąpieniem <see cref="T:System.Net.Sockets.MulticastOption" /> klasy. Gdy <paramref name="optionName" /> wszelkie inne wartości, jest zwracana wartość jest liczbą całkowitą.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> opcje określają zachowanie bieżącego <xref:System.Net.Sockets.Socket>. Użyj tego przeciążenia, aby uzyskać <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, i <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> opcje. Aby uzyskać <xref:System.Net.Sockets.SocketOptionName.Linger> , należy użyć <xref:System.Net.Sockets.Socket> dla `optionLevel` parametru. Aby uzyskać <xref:System.Net.Sockets.SocketOptionName.AddMembership> i <xref:System.Net.Sockets.SocketOptionName.DropMembership>, użyj <xref:System.Net.Sockets.SocketOptionLevel.IP>. Jeśli chcesz ustawić wartości opcji wymienionych powyżej, użyj <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metody.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy kod pobiera przykład <xref:System.Net.Sockets.LingerOption> i <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu wartości i wyświetla je w konsoli.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.  - lub - <paramref name="optionName" /> została ustawiona na wartość nieobsługiwana <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Jeden z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</param>
        <param name="optionName">Jeden z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</param>
        <param name="optionValue">Tablica typu <see cref="T:System.Byte" /> do odbierania ustawienia opcji.</param>
        <summary>Zwraca określony <see cref="T:System.Net.Sockets.Socket" /> opcji ustawienie reprezentowane jako tablicę bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> opcje określają zachowanie bieżącego <xref:System.Net.Sockets.Socket>. Po pomyślnym ukończeniu tej metody tablicy określona przez `optionValue` parametru zawiera wartość z określonym <xref:System.Net.Sockets.Socket> opcji.  
  
 Gdy długość `optionValue` tablica jest mniejszy niż liczba bajtów wymaganą do przechowywania wartości określonego <xref:System.Net.Sockets.Socket> opcji <xref:System.Net.Sockets.Socket.GetSocketOption%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu. Użyj tego przeciążenia dla dowolnego gniazd, które są reprezentowane przez wartościami logicznymi lub liczb całkowitych.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy kod pobiera przykład <xref:System.Net.Sockets.LingerOption> i <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu wartości i wyświetla je w konsoli.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.  \- lub - aplikacji w programie .NET Compact Framework ilość miejsca w buforze domyślne systemu Windows CE 32768 bajtów. Można zmienić na miejsca w buforze gniazda przez wywołanie metody <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Jeden z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</param>
        <param name="optionName">Jeden z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</param>
        <param name="optionLength">Długość, w bajtach, oczekiwano zwracanej wartości.</param>
        <summary>Zwraca wartość określonego <see cref="T:System.Net.Sockets.Socket" /> opcji w tablicy.</summary>
        <returns>Tablica typu <see cref="T:System.Byte" /> zawierający wartość opcji gniazda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `optionLength` Parametr ustawia maksymalny rozmiar tablicy bajtów zwrócona. Jeśli wartość opcji wymaga mniej bajtów, tablica będzie zawierać tylko liczby bajtów. Jeśli wartość opcji wymaga więcej bajtów <xref:System.Net.Sockets.Socket.GetSocketOption%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Użyj tego przeciążenia dla dowolnego gniazd, które są reprezentowane przez wartościami logicznymi lub liczb całkowitych.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy kod pobiera przykład <xref:System.Net.Sockets.LingerOption> i <xref:System.Net.Sockets.Socket.Send%2A> limitu czasu wartości i wyświetla je w konsoli.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.  \- lub - aplikacji w programie .NET Compact Framework ilość miejsca w buforze domyślne systemu Windows CE 32768 bajtów. Można zmienić na miejsca w buforze gniazda przez wywołanie metody <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dojście systemu operacyjnego dla <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>
          <see cref="T:System.IntPtr" /> Reprezentujący dojście systemu operacyjnego dla <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia niskiego poziomu tryby działania <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">
          <see cref="T:System.Int32" /> Wartość, która określa kod sterujący operacji do wykonania.</param>
        <param name="optionInValue">A <see cref="T:System.Byte" /> tablica zawierająca danych wejściowych wymaganych przez operację.</param>
        <param name="optionOutValue">A <see cref="T:System.Byte" /> tablica zawierająca danych wyjściowych zwrócony przez operację.</param>
        <summary>Ustawia niskiego poziomu tryby działania <see cref="T:System.Net.Sockets.Socket" /> przy użyciu kodów liczbowe formantu.</summary>
        <returns>Liczba bajtów w <paramref name="optionOutValue" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.IOControl%2A> Metoda zapewnia niskiego poziomu dostępu do systemu operacyjnego <xref:System.Net.Sockets.Socket> bieżące wystąpienie klasy podstawowej <xref:System.Net.Sockets.Socket> klasy. Aby uzyskać więcej informacji zobacz dokumentację Operacja WSAIoctl w bibliotece MSDN.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu porównuje wyniki FIONREAD i dostępnych właściwości.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Próbowano zmienić tryb blokowania bez użycia <see cref="P:System.Net.Sockets.Socket.Blocking" /> właściwości.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący na stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do wykonywania kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">A <see cref="T:System.Net.Sockets.IOControlCode" /> wartość, która określa kod sterujący operacji do wykonania.</param>
        <param name="optionInValue">Tablica typu <see cref="T:System.Byte" /> zawierający danych wejściowych wymaganych przez operację.</param>
        <param name="optionOutValue">Tablica typu <see cref="T:System.Byte" /> zawierający danych wyjściowych zwrócony przez operację.</param>
        <summary>Ustawia niskiego poziomu tryby działania <see cref="T:System.Net.Sockets.Socket" /> przy użyciu <see cref="T:System.Net.Sockets.IOControlCode" /> wyliczeniu, aby określić kody kontrolki.</summary>
        <returns>Liczba bajtów w <paramref name="optionOutValue" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zapewnia niskiego poziomu dostępu do systemu operacyjnego <xref:System.Net.Sockets.Socket> bieżące wystąpienie klasy podstawowej <xref:System.Net.Sockets.Socket> klasy. Aby uzyskać więcej informacji zobacz dokumentację Operacja WSAIoctl w bibliotece MSDN.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu porównuje wyniki wywołania <xref:System.Net.Sockets.Socket.IOControl%2A> z <xref:System.Net.Sockets.IOControlCode.DataToRead> i <xref:System.Net.Sockets.Socket.Available%2A> właściwości.  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Próbowano zmienić tryb blokowania bez użycia <see cref="P:System.Net.Sockets.Socket.Blocking" /> właściwości.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do wykonywania kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Net.Sockets.Socket" /> jest powiązany z określonego portu lokalnego.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.Socket" /> jest powiązana z portu lokalnego; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gniazda jest uznawany za powiązany z portu lokalnego, jeśli jest on powiązany jawnie przez wywołanie metody <xref:System.Net.Sockets.Socket.Bind%2A> metody, lub niejawnie związane wywołania składników, takich jak <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, lub <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, używających tymczasowych portów lokalnych (wolne portu większa niż 1024, wybrana przez system operacyjny.) Serwery używają <xref:System.Net.Sockets.Socket.Bind%2A> metodę, aby powiązać dobrze znanego portu, dzięki czemu klienci mogą łączyć się z nimi.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.Socket.IsBound%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą czy <see cref="T:System.Net.Sockets.Socket" /> zostanie opóźnione zamknięcia gniazda próba wysłania wszystkie oczekujące dane.</summary>
        <value>A <see cref="T:System.Net.Sockets.LingerOption" /> , który określa sposób linger podczas zamykania gniazda.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LingerState%2A> Właściwości zmienia sposób <xref:System.Net.Sockets.Socket.Close%2A> zachowuje metody. Tej właściwości, gdy zestaw modyfikuje warunków, w których można zresetować połączenia Winsock. Resetuje połączenie można nadal występują w oparciu o zachowanie protokołu IP.  
  
 Ta właściwość określa czas, który nawiązaniem połączenia połączenie pozostanie otwarte po wywołaniu <xref:System.Net.Sockets.Socket.Close%2A> kiedy dane pozostają na wysłanie.  
  
 Po wywołaniu metody w celu wysyłania danych do elementu równorzędnego tych danych jest umieszczona w buforze wychodzących sieci. Ta właściwość może służyć do zapewnienia, że te dane są wysyłane do hosta zdalnego przed <xref:System.Net.Sockets.TcpClient.Close%2A> metody porzuca połączenie.  
  
 Aby włączyć pokutujące, Utwórz <xref:System.Net.Sockets.LingerOption> wystąpienie zawierającego odpowiednie wartości, a następnie ustaw <xref:System.Net.Sockets.Socket.LingerState%2A> właściwości do tego wystąpienia.  
  
 W poniższej tabeli opisano zachowanie <xref:System.Net.Sockets.Socket.Close%2A> metodę możliwe wartości <xref:System.Net.Sockets.LingerOption.Enabled%2A> właściwości i <xref:System.Net.Sockets.LingerOption.LingerTime%2A> właściwości przechowywanych w <xref:System.Net.Sockets.Socket.LingerState%2A> właściwości.  
  
|LingerState.Enabled|LingerState.LingerTime|Zachowanie|  
|-------------------------|----------------------------|--------------|  
|`false` (wyłączone), wartość domyślna|Nie ma zastosowania, limit czasu (domyślnie).|Próbuje wysłać oczekujących danych do momentu wygaśnięcia domyślny limit czasu protokołu IP.|  
|`true` (włączone)|Niezerowe limitu czasu|Próbuje wysłać oczekujących danych dopiero po przekroczeniu określonego limitu czasu i jeśli próba nie powiedzie się, następnie Winsock resetuje połączenie.|  
|`true` (włączone)|Zero przekroczenie limitu czasu.|Odrzuca wszystkie oczekujące danych. Dla nawiązaniem połączenia gniazda (na przykład TCP) Winsock resetuje połączenie.|  
  
 Stos IP oblicza domyślny okres limitu czasu protokołu IP do użycia na podstawie czasu obiegu połączenia. W większości przypadków limit czasu obliczane przez stos jest większe niż określone przez aplikację. Jest to domyślne zachowanie dla gniazda podczas <xref:System.Net.Sockets.Socket.LingerState%2A> nie ustawiono właściwości.  
  
 Gdy <xref:System.Net.Sockets.LingerOption.LingerTime%2A> właściwości przechowywanych w <xref:System.Net.Sockets.Socket.LingerState%2A> właściwość ma wartość większą niż domyślny limit czasu protokołu IP, nadal zastosuje i przesłonić domyślny limit czasu protokołu IP.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.Socket.LingerState%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">Maksymalna długość kolejki oczekujących połączeń.</param>
        <summary>Miejsca <see cref="T:System.Net.Sockets.Socket" /> w stanie nasłuchiwania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A> powoduje, że nawiązaniem połączenia <xref:System.Net.Sockets.Socket> do nasłuchiwania przychodzących próby nawiązania połączenia. `backlog` Parametr określa liczbę połączeń przychodzących, które można umieścić w kolejce do przyjęcia. Aby określić maksymalną liczbę połączeń, można określić, pobrać <xref:System.Net.Sockets.SocketOptionName.MaxConnections> wartość. <xref:System.Net.Sockets.Socket.Listen%2A> nie są blokowane.  
  
 Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu. Użyj <xref:System.Net.Sockets.Socket.Accept%2A> lub <xref:System.Net.Sockets.Socket.BeginAccept%2A> do akceptowania połączeń z kolejki.  
  
> [!NOTE]
>  Należy wywołać <xref:System.Net.Sockets.Socket.Bind%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.Listen%2A>, lub <xref:System.Net.Sockets.Socket.Listen%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Parametr zaległości jest ograniczony do różnych wartości w zależności od systemu operacyjnego. Można określić wyższej wartości, ale zaległości będą ograniczone na podstawie systemu operacyjnego.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.Sockets.Socket> do nasłuchiwania przychodzących połączeń.  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lokalny punkt końcowy.</summary>
        <value>
          <see cref="T:System.Net.EndPoint" /> Który <see cref="T:System.Net.Sockets.Socket" /> używa do komunikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Pobiera właściwość <xref:System.Net.EndPoint> zawiera lokalne IP adres i numer portu do którego Twojej <xref:System.Net.Sockets.Socket> jest powiązany. Należy to rzutować <xref:System.Net.EndPoint> do <xref:System.Net.IPEndPoint> przed pobraniem żadnych informacji. Następnie można wywołać <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> metoda pobierania lokalnego <xref:System.Net.IPAddress>i <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> metoda pobierania numerem portu lokalnego.  
  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Właściwość jest zwykle ustawiana po wprowadzeniu wywołanie <xref:System.Net.Sockets.Socket.Bind%2A> metody. Jeśli zezwolisz na system można przypisać z gniazda lokalny adres IP i numer portu <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwość zostanie ustawiona po wykonaniu pierwszej operacji We/Wy. Protokoły oparte na połączeniu pierwszej operacji We/Wy będzie wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metody. Przesyłanie protokołów pierwszej operacji We/Wy może być dowolny wysyłania lub odbieranie połączeń.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i wyświetla lokalnych i zdalnych punktów końcowych.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy wychodzących pakietów multiemisji są dostarczane do aplikację wysyłającą.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.Socket" /> odbiera wychodzących pakietów multiemisji; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multiemisja to metoda skalowalne wiele do wielu komunikacji w Internecie. Proces subskrybuje adresu multiemisji; następnie wszystkie pakiety wysyłane przez proces subskrybowanego są odbierane przez każdy inny proces subskrybuje adres multiemisji.  
  
 Ustawienie tej właściwości na gnieździe Transmission Control Protocol (TCP) nie odniesie żadnego skutku.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określająca, czy strumień <see cref="T:System.Net.Sockets.Socket" /> używa algorytmu Nagle'a.</summary>
        <value>
          <see langword="false" /> Jeśli <see cref="T:System.Net.Sockets.Socket" /> używa algorytmu Nagle'a; w przeciwnym razie <see langword="true" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algorytm Nagle'a zaprojektowano w celu zmniejszenie ruchu w sieci, powodując gniazda buforować małe pakiety, a następnie połączyć i wysyłać je w jednym pakiecie w pewnych okolicznościach. Pakiet TCP składa się z 40 bajtów nagłówka plus wysyłanych danych. Gdy małe pakiety danych są wysyłane w przypadku protokołu TCP, obciążenie wynikające z nagłówka TCP może stać się znaczną część ruchu sieciowego. W sieciach obciążonego przeciążenia wynikające z tej czynności może spowodować utraty datagramów i liczba retransmisji, a także czas propagacji nadmiernego spowodowane przeciążenia. Algorytm Nagle'a uniemożliwia wysłanie nowej segmentswhen TCP nowe dane wychodzące dociera od użytkownika, jeśli wszystkie dane previouslytransmitted na połączenie pozostaje niepotwierdzonych.  
  
 Większość aplikacji sieciowych powinien używać algorytmu Nagle'a.  
  
 Ustawienie tej właściwości na gnieździe protokołu UDP (User Datagram) nie odniesie żadnego skutku.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.Socket.NoDelay%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy system operacyjny i karty sieciowe obsługują Internet Protocol w wersji 4 (IPv4).</summary>
        <value>
          <see langword="true" /> Jeśli system operacyjny i karty sieciowe obsługują protokół IPv4; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 System operacyjny może obsługiwać protokoły IPv4 i IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy system operacyjny i karty sieciowe obsługują Internet Protocol w wersji 6 (IPv6).</summary>
        <value>
          <see langword="true" /> Jeśli system operacyjny i karty sieciowe obsługują protokół IPv6; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 System operacyjny może obsługiwać protokoły IPv4 i IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" />
      </Parameters>
      <Docs>
        <param name="microSeconds">Czas oczekiwania na odpowiedź w mikrosekundach.</param>
        <param name="mode">Jeden z <see cref="T:System.Net.Sockets.SelectMode" /> wartości.</param>
        <summary>Określa stan <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Stan <see cref="T:System.Net.Sockets.Socket" /> na podstawie wartości tryb sondowania przekazano <paramref name="mode" /> parametru.  
  
 <bpt id="p1">&lt;list type="table"&gt;</bpt><bpt id="p2">&lt;listheader&gt;</bpt><bpt id="p3">&lt;term&gt;</bpt> Mode  <ept id="p3">&lt;/term&gt;</ept><bpt id="p4">&lt;description&gt;</bpt> Return Value  <ept id="p4">&lt;/description&gt;</ept><ept id="p2">&lt;/listheader&gt;</ept><bpt id="p5">&lt;item&gt;</bpt><bpt id="p6">&lt;term&gt;</bpt><ph id="ph1">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectRead" /&gt;</ph><ept id="p6">&lt;/term&gt;</ept><bpt id="p7">&lt;description&gt;</bpt><ph id="ph2">&lt;see langword="true" /&gt;</ph> if <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> has been called and a connection is pending;  -or-  <ph id="ph4">&lt;see langword="true" /&gt;</ph> if data is available for reading;  -or-  <ph id="ph5">&lt;see langword="true" /&gt;</ph> if the connection has been closed, reset, or terminated;  otherwise, returns <ph id="ph6">&lt;see langword="false" /&gt;</ph>.  <ept id="p7">&lt;/description&gt;</ept><ept id="p5">&lt;/item&gt;</ept><bpt id="p8">&lt;item&gt;</bpt><bpt id="p9">&lt;term&gt;</bpt><ph id="ph7">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /&gt;</ph><ept id="p9">&lt;/term&gt;</ept><bpt id="p10">&lt;description&gt;</bpt><ph id="ph8">&lt;see langword="true" /&gt;</ph>, if processing a <ph id="ph9">&lt;see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /&gt;</ph>, and the connection has succeeded;  -or-  <ph id="ph10">&lt;see langword="true" /&gt;</ph> if data can be sent;  otherwise, returns <ph id="ph11">&lt;see langword="false" /&gt;</ph>.  <ept id="p10">&lt;/description&gt;</ept><ept id="p8">&lt;/item&gt;</ept><bpt id="p11">&lt;item&gt;</bpt><bpt id="p12">&lt;term&gt;</bpt><ph id="ph12">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectError" /&gt;</ph><ept id="p12">&lt;/term&gt;</ept><bpt id="p13">&lt;description&gt;</bpt><ph id="ph13">&lt;see langword="true" /&gt;</ph> if processing a <ph id="ph14">&lt;see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /&gt;</ph> that does not block, and the connection has failed;  -or-  <ph id="ph15">&lt;see langword="true" /&gt;</ph> if <ph id="ph16">&lt;see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /&gt;</ph> is not set and out-of-band data is available;  otherwise, returns <ph id="ph17">&lt;see langword="false" /&gt;</ph>.  <ept id="p13">&lt;/description&gt;</ept><ept id="p11">&lt;/item&gt;</ept><ept id="p1">&lt;/list&gt;</ept></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Poll%2A> Metoda będzie sprawdzać stan <xref:System.Net.Sockets.Socket>. Określ <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> dla `selectMode` parametr, aby ustalić, czy <xref:System.Net.Sockets.Socket> jest możliwy do odczytu. Określ <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> można określić, czy <xref:System.Net.Sockets.Socket> jest zapisywalna. Użyj <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> wykryć warunek błędu. <xref:System.Net.Sockets.Socket.Poll%2A> blokuje wykonywanie do momentu w określonym okresie, mierzony w `microseconds`, upływa. Ustaw `microSeconds` parametru do ujemnej liczby całkowitej, jeśli chcesz nieograniczony czas oczekiwania na odpowiedź. Jeśli chcesz sprawdzić stan wiele gniazd, może być wolą używać <xref:System.Net.Sockets.Socket.Select%2A> metody.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ta metoda nie może wykryć niektóre rodzaje problemów z połączeniem, takie jak kabel sieciowy przerwany, lub host zdalny został zamknięty ungracefully. Należy próba wysłania lub odebrania danych, aby wykryć tego rodzaju błędów.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy gniazda, nawiązuje połączenie z serwerem i używa <xref:System.Net.Sockets.Socket.Poll%2A> sprawdzać stan gniazda.  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="mode" /> Parametru nie jest jednym z <see cref="T:System.Net.Sockets.SelectMode" /> wartości.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ protokołu <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Jeden z <see cref="T:System.Net.Sockets.ProtocolType" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ProtocolType%2A> Właściwości jest ustawiana podczas <xref:System.Net.Sockets.Socket> jest tworzony i określa protokół używany przez to <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, i <xref:System.Net.Sockets.ProtocolType> do konsoli.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odbiera dane z powiązanej <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizację przechowywania dla odebranych danych.</param>
        <summary>Odbiera dane z powiązanej <see cref="T:System.Net.Sockets.Socket" /> do buforu odbierania.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczytuje dane w parametrze buforu i zwraca liczbę bajtów odczytanych pomyślnie. Możesz wywołać <xref:System.Net.Sockets.Socket.Receive%2A> z zarówno połączeń i bez połączenia gniazda.  
  
 To przeciążenie tylko wymaga podania bufor odbioru. Wartość domyślna to 0, domyślne ustawienia rozmiaru do długości buforu parametru przesunięcia buforu i <xref:System.Net.Sockets.SocketFlags> wartością domyślną będzie <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Jeśli używasz protokołu zorientowaną na połączenie, musi albo wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> ustanowić połączenie zdalnego hosta lub <xref:System.Net.Sockets.Socket.Accept%2A> akceptować połączenia przychodzące przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Metody odczyta tylko dane przychodzący z hostem zdalnym w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli używany jest protokół bez połączenia, można również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Umożliwia odbieranie danych otrzymywanych z dowolnym hostem.  
  
 Jeśli dane są niedostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> metody zablokuje dopóki dane są dostępne, chyba że ustawiono wartość limitu czasu przy użyciu <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Receive%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. Jeśli jesteś w trybie bez blokowania, a dane są niedostępne w w buforze stosu protokołu <xref:System.Net.Sockets.Socket.Receive%2A> metody zostanie natychmiast wykonać i zgłosić <xref:System.Net.Sockets.SocketException>. Można użyć <xref:System.Net.Sockets.Socket.Available%2A> właściwości w celu określenia, czy dane są dostępne do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.  
  
 Jeśli korzystasz z nawiązaniem połączenia <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> metoda odczytuje jak najwięcej danych, ponieważ jest dostępna, zgodnie z rozmiarem buforu. Jeśli host zdalny wyłączony <xref:System.Net.Sockets.Socket> połączenia z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano — metoda i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.Receive%2A> metoda zostanie natychmiast wykonać i zwraca zero bajtów.  
  
 Jeśli używasz przesyłanie <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> odczyta pierwszy datagram umieszczonych w kolejce z adresu docelowego określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metody. Jeśli pojawi się datagram jest większy niż rozmiar `buffer` parametru `buffer` wypełnia z pierwszej części komunikatu nadmiarowe dane zostaną utracone i <xref:System.Net.Sockets.SocketException> jest generowany.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu odbiera dane w połączonych <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący na stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z siecią. Wyliczenie skojarzone: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">Lista <see cref="T:System.ArraySegment`1" />s typu <see cref="T:System.Byte" /> zawierający odebranych danych.</param>
        <summary>Odbiera dane z powiązanej <see cref="T:System.Net.Sockets.Socket" /> do listy buforów odbioru.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje dane w parametrze buforów i zwraca liczbę bajtów odczytanych pomyślnie. Możesz wywołać zarówno połączeń i bez połączenia gniazda.  
  
 To przeciążenie wymaga podania jeden lub więcej buforów odbioru.  
  
 Jeśli używasz protokołu zorientowaną na połączenie, musi albo wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> ustanowić połączenie zdalnego hosta lub <xref:System.Net.Sockets.Socket.Accept%2A> akceptować połączenia przychodzące przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Metody odczyta tylko dane przychodzący z hosta zdalnego połączenia w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli używany jest protokół bez połączenia, można również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Umożliwia odbieranie danych otrzymywanych z dowolnym hostem.  
  
 Jeśli dane są niedostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> metody zablokuje dopóki dane są dostępne, chyba że ustawiono wartość limitu czasu przy użyciu <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Receive%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. Jeśli jesteś w trybie bez blokowania, a dane są niedostępne w w buforze stosu protokołu <xref:System.Net.Sockets.Socket.Receive%2A> metody zostanie natychmiast wykonać i zgłosić <xref:System.Net.Sockets.SocketException>. Można użyć <xref:System.Net.Sockets.Socket.Available%2A> właściwości w celu określenia, czy dane są dostępne do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.  
  
 Jeśli korzystasz z nawiązaniem połączenia <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> metoda odczytuje jak najwięcej danych, ponieważ jest dostępna, zgodnie z rozmiarem buforu. Jeśli host zdalny wyłączony <xref:System.Net.Sockets.Socket> połączenia z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano — metoda i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.Receive%2A> metoda zostanie natychmiast wykonać i zwraca zero bajtów.  
  
 Jeśli używasz przesyłanie <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> odczyta pierwszy datagram umieszczonych w kolejce z adresu docelowego określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metody. Jeśli pojawi się datagram jest większy niż rozmiar `buffers` parametru `buffers` wypełnia z pierwszej części komunikatu nadmiarowe dane zostaną utracone i <xref:System.Net.Sockets.SocketException> jest generowany.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
 **Uwaga** ten element członkowski danych wyjściowych informacji o śledzeniu, po włączeniu śledzenie sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizację przechowywania dla odebranych danych.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <summary>Odbiera dane z powiązanej <see cref="T:System.Net.Sockets.Socket" /> do buforu odbioru, przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczytuje dane w parametrze buforu i zwraca liczbę bajtów odczytanych pomyślnie. Możesz wywołać <xref:System.Net.Sockets.Socket.Receive%2A> z zarówno połączeń i bez połączenia gniazda.  
  
 To przeciążenie tylko wymaga podania buforów odbioru i niezbędnych <xref:System.Net.Sockets.SocketFlags>. Suma przesunięcia buforu wartość domyślna to 0, a rozmiar domyślna długość parametru bajtów.  
  
 Jeśli używasz protokołu zorientowaną na połączenie, musi albo wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> ustanowić połączenie zdalnego hosta lub <xref:System.Net.Sockets.Socket.Accept%2A> akceptować połączenia przychodzące przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Metody odczyta tylko dane przychodzący z hostem zdalnym w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli używany jest protokół bez połączenia, można również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Umożliwia odbieranie danych otrzymywanych z dowolnym hostem.  
  
 Jeśli dane są niedostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> metody zablokuje dopóki dane są dostępne. Jeśli jesteś w trybie bez blokowania, a dane są niedostępne w buforze stosu protokołu <xref:System.Net.Sockets.Socket.Receive%2A> metody zostanie natychmiast wykonać i zgłosić <xref:System.Net.Sockets.SocketException>. Można użyć <xref:System.Net.Sockets.Socket.Available%2A> właściwości w celu określenia, czy dane są dostępne do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie z operacji odbierania.  
  
 Jeśli korzystasz z nawiązaniem połączenia <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> metoda odczytuje jak najwięcej danych, ponieważ jest dostępna, zgodnie z rozmiarem buforu. Jeśli host zdalny wyłączony <xref:System.Net.Sockets.Socket> połączenia z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano — metoda i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.Receive%2A> metoda zostanie natychmiast wykonać i zwraca zero bajtów.  
  
 Jeśli używasz przesyłanie <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> odczyta pierwszy datagram umieszczonych w kolejce z adresu docelowego określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metody. Jeśli pojawi się datagram jest większy niż rozmiar `buffer` parametru `buffer` wypełnia z pierwszej części komunikatu nadmiarowe dane zostaną utracone i <xref:System.Net.Sockets.SocketException> jest generowany.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu określa buforu danych i <xref:System.Net.Sockets.SocketFlags> przy odbieraniu danych na połączonych <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący na stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z siecią. Wyliczenie skojarzone: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">Lista <see cref="T:System.ArraySegment`1" />s typu <see cref="T:System.Byte" /> zawierający odebranych danych.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <summary>Odbiera dane z powiązanej <see cref="T:System.Net.Sockets.Socket" /> do listy buforów odbioru, przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje dane do `buffers` parametrów i zwraca liczbę bajtów odczytanych pomyślnie. Możesz wywołać zarówno połączeń i bez połączenia gniazda.  
  
 To przeciążenie wymaga podania jeden lub więcej buforów odbioru. <xref:System.Net.Sockets.SocketFlags> Wartością domyślną będzie <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Jeśli używasz protokołu zorientowaną na połączenie, musi albo wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> ustanowić połączenie zdalnego hosta lub <xref:System.Net.Sockets.Socket.Accept%2A> akceptować połączenia przychodzące przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Metody odczyta tylko dane przychodzący z hosta zdalnego połączenia w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli używany jest protokół bez połączenia, można również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Umożliwia odbieranie danych otrzymywanych z dowolnym hostem.  
  
 Jeśli dane są niedostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> metody zablokuje dopóki dane są dostępne, chyba że ustawiono wartość limitu czasu przy użyciu <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Receive%2A> wywołać zgłasza <xref:System.Net.Sockets.SocketException>. Jeśli jesteś w trybie bez blokowania, a dane są niedostępne w w buforze stosu protokołu <xref:System.Net.Sockets.Socket.Receive%2A> metody zostanie natychmiast wykonać i zgłosić <xref:System.Net.Sockets.SocketException>. Można użyć <xref:System.Net.Sockets.Socket.Available%2A> właściwości w celu określenia, czy dane są dostępne do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.  
  
 Jeśli korzystasz z nawiązaniem połączenia <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> metoda odczytuje jak najwięcej danych, ponieważ jest dostępna, zgodnie z rozmiarem buforu. Jeśli host zdalny wyłączony <xref:System.Net.Sockets.Socket> połączenia z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano — metoda i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.Receive%2A> metoda zostanie natychmiast wykonać i zwraca zero bajtów.  
  
 Jeśli używasz przesyłanie <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> odczyta pierwszy datagram umieszczonych w kolejce z adresu docelowego określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metody. Jeśli pojawi się datagram jest większy niż rozmiar `buffers` parametru `buffers` wypełnia z pierwszej części komunikatu nadmiarowe dane zostaną utracone i <xref:System.Net.Sockets.SocketException> jest generowany.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób odbierania danych na połączonych <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> jest <see langword="null" />.  - lub - <paramref name="buffers" />. Liczba jest równa zero.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z siecią. Wyliczenie skojarzone: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizację przechowywania dla odebranych danych.</param>
        <param name="size">Liczba bajtów do odbierania.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <summary>Odbiera określoną liczbę bajtów danych z powiązanych z <see cref="T:System.Net.Sockets.Socket" /> do buforu odbioru, przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczytuje dane do `buffer` parametrów i zwraca liczbę bajtów odczytanych pomyślnie. Możesz wywołać <xref:System.Net.Sockets.Socket.Receive%2A> z zarówno połączeń i bez połączenia gniazda.  
  
 To przeciążenie tylko wymaga podania bufor odbioru, liczba bajtów, które chcesz otrzymywać i niezbędnych <xref:System.Net.Sockets.SocketFlags>.  
  
 Jeśli używasz protokołu zorientowaną na połączenie, musi albo wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> ustanowić połączenie zdalnego hosta lub <xref:System.Net.Sockets.Socket.Accept%2A> akceptować połączenia przychodzące przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Metody odczyta tylko dane przychodzący z hostem zdalnym w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli używany jest protokół bez połączenia, można również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Umożliwia odbieranie danych otrzymywanych z dowolnym hostem.  
  
 Jeśli dane są niedostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> metody zablokuje dopóki dane są dostępne, chyba że ustawiono wartość limitu czasu przy użyciu <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Receive%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. Jeśli jesteś w trybie bez blokowania, a dane są niedostępne w w buforze stosu protokołu <xref:System.Net.Sockets.Socket.Receive%2A> metody zostanie natychmiast wykonać i zgłosić <xref:System.Net.Sockets.SocketException>. Można użyć <xref:System.Net.Sockets.Socket.Available%2A> właściwości w celu określenia, czy dane są dostępne do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie z operacji odbierania.  
  
 Jeśli korzystasz z nawiązaniem połączenia <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> metoda odczytuje jak najwięcej danych, ponieważ są dostępne do liczby bajtów określona przez `size` parametru. Jeśli host zdalny wyłączony <xref:System.Net.Sockets.Socket> połączenia z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano — metoda i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.Receive%2A> metoda zostanie natychmiast wykonać i zwraca zero bajtów.  
  
 Jeśli używasz przesyłanie <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> odczyta pierwszy datagram umieszczonych w kolejce z adresu docelowego określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metody. Jeśli pojawi się datagram jest większy niż rozmiar `buffer` parametru `buffer` wypełnia z pierwszej części komunikatu nadmiarowe dane zostaną utracone i <xref:System.Net.Sockets.SocketException> jest generowany.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Znaleziono do danych otrzymuje następujące `buffer`i określa <xref:System.Net.Sockets.SocketFlags.None> dla <xref:System.Net.Sockets.SocketFlags>.  
  
 [!code-cpp[Socket_Send_Recieve#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Recieve#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#4)]
 [!code-vb[Socket_Send_Recieve#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> przekracza rozmiar <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący na stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z siecią. Wyliczenie skojarzone: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">Lista <see cref="T:System.ArraySegment`1" />s typu <see cref="T:System.Byte" /> zawierający odebranych danych.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> obiekt zawierający błąd gniazda.</param>
        <summary>Odbiera dane z powiązanej <see cref="T:System.Net.Sockets.Socket" /> do listy buforów odbioru, przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje dane do `buffers` parametrów i zwraca liczbę bajtów odczytanych pomyślnie. Możesz wywołać zarówno połączeń i bez połączenia gniazda.  
  
 To przeciążenie wymaga podania jeden lub więcej buforów odbioru. <xref:System.Net.Sockets.SocketFlags> Wartością domyślną będzie <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Jeśli używasz protokołu zorientowaną na połączenie, musi albo wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> ustanowić połączenie zdalnego hosta lub <xref:System.Net.Sockets.Socket.Accept%2A> akceptować połączenia przychodzące przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Metody odczyta tylko dane przychodzący z hosta zdalnego połączenia w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli używany jest protokół bez połączenia, można również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Umożliwia odbieranie danych otrzymywanych z dowolnym hostem.  
  
 Jeśli dane są niedostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> metody zablokuje dopóki dane są dostępne, chyba że ustawiono wartość limitu czasu przy użyciu <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Receive%2A> wywołać zgłasza <xref:System.Net.Sockets.SocketException>. Jeśli jesteś w trybie bez blokowania, a dane są niedostępne w w buforze stosu protokołu <xref:System.Net.Sockets.Socket.Receive%2A> metody zostanie natychmiast wykonać i zgłosić <xref:System.Net.Sockets.SocketException>. Można użyć <xref:System.Net.Sockets.Socket.Available%2A> właściwości w celu określenia, czy dane są dostępne do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.  
  
 Jeśli korzystasz z nawiązaniem połączenia <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> metoda odczytuje jak najwięcej danych, ponieważ jest dostępna, zgodnie z rozmiarem buforu. Jeśli host zdalny wyłączony <xref:System.Net.Sockets.Socket> połączenia z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano — metoda i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.Receive%2A> metoda zostanie natychmiast wykonać i zwraca zero bajtów.  
  
 Jeśli używasz przesyłanie <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> odczyta pierwszy datagram umieszczonych w kolejce z adresu docelowego określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metody. Jeśli pojawi się datagram jest większy niż rozmiar `buffers` parametru `buffers` wypełnia z pierwszej części komunikatu nadmiarowe dane zostaną utracone i <xref:System.Net.Sockets.SocketException> jest generowany.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> jest <see langword="null" />.  - lub - <paramref name="buffers" />. Liczba jest równa zero.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z siecią. Wyliczenie skojarzone: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizację przechowywania dla odebranych danych.</param>
        <param name="offset">Lokalizacja w <c>buforu</c> do przechowywania odebranych danych.</param>
        <param name="size">Liczba bajtów do odbierania.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <summary>Odbiera określoną liczbę bajtów z powiązanej <see cref="T:System.Net.Sockets.Socket" /> do określonej pozycji przesunięcia buforu odbioru, przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczytuje dane w parametrze buforu i zwraca liczbę bajtów odczytanych pomyślnie. Możesz wywołać <xref:System.Net.Sockets.Socket.Receive%2A> z zarówno połączeń i bez połączenia gniazda.  
  
 Jeśli używasz protokołu zorientowaną na połączenie, musi albo wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> ustanowić połączenie zdalnego hosta lub <xref:System.Net.Sockets.Socket.Accept%2A> akceptować połączenia przychodzące przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Metody odczyta tylko dane przychodzący z hostem zdalnym w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli używany jest protokół bez połączenia, można również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Umożliwia odbieranie danych otrzymywanych z dowolnym hostem.  
  
 Jeśli dane są niedostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> metody zablokuje dopóki dane są dostępne, chyba że ustawiono wartość limitu czasu przy użyciu <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Receive%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. Jeśli jesteś w trybie bez blokowania, a dane są niedostępne w w buforze stosu protokołu <xref:System.Net.Sockets.Socket.Receive%2A> metody zostanie natychmiast wykonać i zgłosić <xref:System.Net.Sockets.SocketException>. Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej. Można użyć <xref:System.Net.Sockets.Socket.Available%2A> właściwości w celu określenia, czy dane są dostępne do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.  
  
 Jeśli korzystasz z nawiązaniem połączenia <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> metoda odczytuje jak najwięcej danych, ponieważ są dostępne do liczby bajtów określonej przez parametr rozmiaru. Jeśli host zdalny wyłączony <xref:System.Net.Sockets.Socket> połączenia z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano — metoda i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.Receive%2A> metoda zostanie natychmiast wykonać i zwraca zero bajtów.  
  
 Jeśli używasz przesyłanie <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> odczyta pierwszy datagram umieszczonych w kolejce z adresu docelowego określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metody. Jeśli pojawi się datagram jest większy niż rozmiar `buffer` parametru `buffer` wypełnia z pierwszej części komunikatu nadmiarowe dane zostaną utracone i <xref:System.Net.Sockets.SocketException> jest generowany.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu określa buforu danych, przesunięcie, rozmiar i flagę gniazda przed rozpoczęciem odbierania danych na połączonych <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  - lub - <paramref name="offset" /> jest większa niż długość <paramref name="buffer" />.  - lub - <paramref name="size" /> jest mniejszy niż 0.  - lub - <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> nie jest prawidłową kombinację wartości.  - lub - <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> właściwość nie została ustawiona.  - lub - wystąpi błąd systemu operacyjnego podczas uzyskiwania dostępu do <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący na stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z siecią. Wyliczenie skojarzone: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizację przechowywania dla odebranych danych.</param>
        <param name="offset">Pozycja w <c>buforu</c> parametr do zapisania odebranych danych.</param>
        <param name="size">Liczba bajtów do odbierania.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> obiekt zawierający błąd gniazda.</param>
        <summary>Odbiera dane z powiązanej <see cref="T:System.Net.Sockets.Socket" /> do buforu odbioru, przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> Metoda odczytuje dane w parametrze buforu i zwraca liczbę bajtów odczytanych pomyślnie. Możesz wywołać <xref:System.Net.Sockets.Socket.Receive%2A> z zarówno połączeń i bez połączenia gniazda.  
  
 Jeśli używasz protokołu zorientowaną na połączenie, musi albo wywołanie <xref:System.Net.Sockets.Socket.Connect%2A> ustanowić połączenie zdalnego hosta lub <xref:System.Net.Sockets.Socket.Accept%2A> akceptować połączenia przychodzące przed wywołaniem <xref:System.Net.Sockets.Socket.Receive%2A>. <xref:System.Net.Sockets.Socket.Receive%2A> Metody odczyta tylko dane przychodzący z hostem zdalnym w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli używany jest protokół bez połączenia, można również użyć <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Umożliwia odbieranie danych otrzymywanych z dowolnym hostem.  
  
 Jeśli dane są niedostępne do odczytu, <xref:System.Net.Sockets.Socket.Receive%2A> metody zablokuje dopóki dane są dostępne, chyba że ustawiono wartość limitu czasu przy użyciu <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Receive%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. Jeśli jesteś w trybie bez blokowania, a dane są niedostępne w w buforze stosu protokołu <xref:System.Net.Sockets.Socket.Receive%2A> metody zostanie natychmiast wykonać i zgłosić <xref:System.Net.Sockets.SocketException>. Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej. Można użyć <xref:System.Net.Sockets.Socket.Available%2A> właściwości w celu określenia, czy dane są dostępne do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.  
  
 Jeśli korzystasz z nawiązaniem połączenia <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> metoda odczytuje jak najwięcej danych, ponieważ są dostępne do liczby bajtów określonej przez parametr rozmiaru. Jeśli host zdalny wyłączony <xref:System.Net.Sockets.Socket> połączenia z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano — metoda i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.Receive%2A> metoda zostanie natychmiast wykonać i zwraca zero bajtów.  
  
 Jeśli używasz przesyłanie <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> odczyta pierwszy datagram umieszczonych w kolejce z adresu docelowego określonego w <xref:System.Net.Sockets.Socket.Connect%2A> metody. Jeśli pojawi się datagram jest większy niż rozmiar `buffer` parametru `buffer` wypełnia z pierwszej części komunikatu nadmiarowe dane zostaną utracone i <xref:System.Net.Sockets.SocketException> jest generowany.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  - lub - <paramref name="offset" /> jest większa niż długość <paramref name="buffer" />.  - lub - <paramref name="size" /> jest mniejszy niż 0.  - lub - <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> nie jest prawidłową kombinację wartości.  - lub - <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> nie ustawiono właściwości.  - lub - wystąpi błąd systemu operacyjnego podczas uzyskiwania dostępu do <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący na stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z siecią. Wyliczenie skojarzone: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Obiekt ma być używany dla tej operacji asynchronicznej gniazda.</param>
        <summary>Rozpoczyna się żądania asynchronicznego na odbieranie danych z połączonych <see cref="T:System.Net.Sockets.Socket" /> obiektu.</summary>
        <returns>Zwraca <see langword="true" /> przypadku oczekujących operacji We/Wy. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenia w <paramref name="e" /> parametr zostanie wygenerowany, po zakończeniu operacji.  Zwraca <see langword="false" /> Jeśli synchronicznie wykonać operacji We/Wy. W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenia w <paramref name="e" /> parametr nie zostanie wygenerowany i <paramref name="e" /> przekazano obiekt jako parametr może być zbadana natychmiast po wywołaniu metody zwraca można pobrać wyniku operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> Używana jest metoda połączenia gniazda lub powiązane bez połączenia gniazda i jest używany do odczytu danych przychodzących. Adres lokalnego gniazda musi być znane.  
  
 Dla powiązania bez połączenia gniazda ta funkcja ogranicza adresów, które mają być akceptowane odebranej wiadomości. Funkcja zwraca tylko komunikaty z adresu zdalnego określono w połączeniu. Komunikaty z innych adresów dyskretnie zostaną odrzucone.  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> Właściwość `e` parametru zapewnia dostawcę usługi Windows Sockets dodatkowe informacje o żądanie odczytu. Aby uzyskać więcej informacji na temat używania tego parametru, zobacz <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.  
  
 Poniższe właściwości i zdarzeń w <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiektu są wymagane do pomyślnego wywołania tej metody:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> lub <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Jeśli <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> ustawiono  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Jeśli <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> ustawiono  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwości do każdego obiektu stanu użytkownika potrzebne przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> metodę, tak, aby informacje pobieranie metody wywołania zwrotnego. Jeśli wywołanie zwrotne wymaga informacji więcej niż jeden obiekt, aby pomieścić inne wymagane informacje o stanie jako elementy członkowskie można tworzyć małych klasy.  
  
 Dla gniazda stylu strumień bajtów przychodzących danych jest umieszczane w buforze bufor jest wypełniony, połączenie jest zamknięte lub wyczerpaniem wewnętrznie buforowane dane.  
  
 Dla gniazda do przesyłania wiadomości, wiadomości przychodzącej jest umieszczona w buforze do całkowitego rozmiaru buforu skojarzone z `e` parametru. Jeśli komunikat jest większy niż rozmiar buforu, bufor jest wypełniony pierwszej części wiadomości.  
  
 Dla połączeń sockets <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> — metoda może oznaczać łagodne przerwanie obwodu wirtualnego w jeden z dwóch sposobów zależne czy gniazda jest strumień bajtów lub zorientowany na wiadomości. Strumienie bajtów zero bajtów przeczytany wskazuje zamknięcia bezpieczne i nie więcej bajtów kiedykolwiek zostaną odczytane. Dla gniazda przesyłania wiadomości, gdzie wiadomość zero bajtów często jest dozwolony, <xref:System.Net.Sockets.SocketException> z <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> zestaw macierzysty kod błędu Winsock WSAEDISCON (10101) służy do wskazywania operację prawidłowego zamknięcia. W każdym przypadku <xref:System.Net.Sockets.SocketException> z <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> ustawioną natywnego WSAECONNRESET Winsock (10054). kod błędu wskazuje przerywające Zamknij.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Argument był nieprawidłowy. <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> Lub <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> właściwości <paramref name="e" /> parametru musi odwoływać się buforów prawidłowe. Jedna z tych właściwości może być zestaw, ale nie oba jednocześnie.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja gniazda zostało już w toku, używając <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiektu określonego w <paramref name="e" /> parametru.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP lub nowszy jest wymagany dla tej metody.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą rozmiar buforu odbioru z <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>
          <see cref="T:System.Int32" /> Zawierający rozmiar w bajtach buforu odbioru. Wartość domyślna to 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Większy rozmiar buforu potencjalnie zmniejsza liczbę potwierdzeń pusty (TCP pakiety z fragmentów danych), ale może również opóźnienie rozpoznawania trudności połączenia. Rozważ zwiększenie rozmiaru buforu transferowania dużych plików, czy używasz wysokiej przepustowości, duże opóźnienie połączenia (np. dostawcę satelity połączenia szerokopasmowego użytkownika.)  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona dla operacji ustawienia jest mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odbiera datagram i przechowuje źródłowego punktu końcowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizację przechowywania dla odebranych danych.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />, Przekazywane przez odwołanie, który reprezentuje serwer zdalny.</param>
        <summary>Odbiera datagram w buforze danych i zapisuje punktu końcowego.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda odczytuje dane do `buffer` parametru zwraca liczbę bajtów odczytanych pomyślnie i przechwytywanie hosta zdalnego punktu końcowego, z którego wysłano danych. Ta metoda jest przydatna, jeśli chcesz otrzymywać przesyłanie datagramy Nieznany host lub na wielu hostach.  
  
 To przeciążenie musisz tylko podać receive `buffer`i <xref:System.Net.EndPoint> reprezentujący hosta zdalnego. Suma przesunięcia buforu wartość domyślna to 0. Rozmiar jest równa długości `buffer` parametru i `socketFlags` wartością domyślną będzie <xref:System.Net.Sockets.SocketFlags.None>.  
  
> [!NOTE]
>  Przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, należy jawnie powiązać <xref:System.Net.Sockets.Socket> do lokalnego punktu końcowego za pomocą <xref:System.Net.Sockets.Socket.Bind%2A> metody. Jeśli nie, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Przy użyciu protokołów przesyłanie <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> odczyta pierwszy datagram umieszczonych w kolejce odebrane w buforze sieci lokalnej. Jeśli pojawi się datagram jest większy niż rozmiar `buffer`, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody spowoduje wypełnienie `buffer` z tyle komunikatu, ponieważ jest to możliwe, a throw <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu zawodnych nadmiarowe dane zostaną utracone. Jeśli używasz protokołu niezawodnych, nadmiarowe dane będą przechowywane przez dostawcę usług i mogą być pobierane przez wywołanie metody <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody z dostatecznie dużego buforu.  
  
 Jeśli dane są niedostępne do odczytu, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody zablokuje dopóki dane są dostępne. Jeśli jesteś w trybie bez blokowania, a dane są niedostępne w w buforze stosu protokołu <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody zostanie natychmiast wykonać i zgłosić <xref:System.Net.Sockets.SocketException>. Można użyć <xref:System.Net.Sockets.Socket.Available%2A> właściwości w celu określenia, czy dane są dostępne do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.  
  
 Mimo że <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> jest przeznaczony dla protokołów bez połączenia, można użyć również protokół nawiązaniem połączenia. Jeśli wybierzesz to zrobić, albo nawiązania połączenia zdalnego hosta przez wywołanie metody <xref:System.Net.Sockets.Socket.Connect%2A> metody lub Zaakceptuj przychodzące zdalnego hosta połączenia przez wywołanie metody <xref:System.Net.Sockets.Socket.Accept%2A> — metoda. Jeśli nie ustanowić lub zaakceptować połączenie przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody, otrzymasz <xref:System.Net.Sockets.SocketException>. Możesz także udostępnić domyślnego hosta zdalnego bez połączenia protokołu przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. W tych przypadkach <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> zignoruje metody `remoteEP` parametru i odbierać dane z połączonych lub domyślnego hosta zdalnego.  
  
 Z nawiązaniem połączenia gniazda <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> odczyta jak najwięcej danych, ponieważ są dostępne do rozmiaru `buffer`. Jeśli host zdalny wyłączony <xref:System.Net.Sockets.Socket> połączenia z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano — metoda i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metoda zostanie natychmiast wykonać i zwraca zero bajtów.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> z <xref:System.Net.EndPoint> używane w <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> musi być zgodna <xref:System.Net.Sockets.AddressFamily> z <xref:System.Net.EndPoint> używane w <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu odbiera wymiany datagramów z hosta zdalnego.  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.  - lub - <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący na stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z siecią. Wyliczenie skojarzone: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizację przechowywania dla odebranych danych.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />, Przekazywane przez odwołanie, który reprezentuje serwer zdalny.</param>
        <summary>Odbiera datagram do bufora danych przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />i przechowuje punktu końcowego.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda odczytuje dane do `buffer` parametru zwraca liczbę bajtów odczytanych pomyślnie i przechwytywanie hosta zdalnego punktu końcowego, z którego wysłano danych. Ta metoda jest przydatna, jeśli chcesz otrzymywać przesyłanie datagramy Nieznany host lub na wielu hostach.  
  
 To przeciążenie tylko wymaga podania bufor odbioru, niezbędne <xref:System.Net.Sockets.SocketFlags>i <xref:System.Net.EndPoint> reprezentujący hosta zdalnego. Przesunięcia wartość domyślna to 0 oraz wartości domyślnych rozmiaru do długości buforu parametru.  
  
> [!NOTE]
>  Przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, należy jawnie powiązać <xref:System.Net.Sockets.Socket> do lokalnego punktu końcowego za pomocą <xref:System.Net.Sockets.Socket.Bind%2A> metody. Jeśli nie, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Przy użyciu protokołów przesyłanie <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> odczyta pierwszy datagram umieszczonych w kolejce odebrane w buforze sieci lokalnej. Jeśli pojawi się datagram jest większy niż rozmiar `buffer`, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody spowoduje wypełnienie `buffer` z tyle komunikatu, ponieważ jest to możliwe, a throw <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu zawodnych nadmiarowe dane zostaną utracone. Jeśli używasz protokołu niezawodnych, nadmiarowe dane będą przechowywane przez dostawcę usług i mogą być pobierane przez wywołanie metody <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody z dostatecznie dużego buforu.  
  
 Jeśli dane są niedostępne do odczytu, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody zablokuje dopóki dane są dostępne. Jeśli jesteś w trybie bez blokowania, a dane są niedostępne w w buforze stosu protokołu <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody zostanie natychmiast wykonać i zgłosić <xref:System.Net.Sockets.SocketException>. Można użyć <xref:System.Net.Sockets.Socket.Available%2A> właściwości w celu określenia, czy dane są dostępne do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.  
  
 Mimo że <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> jest przeznaczony dla protokołów bez połączenia, można użyć również protokół nawiązaniem połączenia. Jeśli wybierzesz to zrobić, albo nawiązania połączenia zdalnego hosta przez wywołanie metody <xref:System.Net.Sockets.Socket.Connect%2A> metody lub Zaakceptuj przychodzące zdalnego hosta połączenia przez wywołanie metody <xref:System.Net.Sockets.Socket.Accept%2A> — metoda. Jeśli nie ustanowić lub zaakceptować połączenie przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody, otrzymasz <xref:System.Net.Sockets.SocketException>. Możesz także udostępnić domyślnego hosta zdalnego bez połączenia protokołu przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. W tych przypadkach <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> zignoruje metody `remoteEP` parametru i odbierać dane z połączonych lub domyślnego hosta zdalnego.  
  
 Z nawiązaniem połączenia gniazda <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> odczyta jak najwięcej danych, ponieważ są dostępne do rozmiaru `buffer`. Jeśli host zdalny wyłączony <xref:System.Net.Sockets.Socket> połączenia z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano — metoda i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metoda zostanie natychmiast wykonać i zwraca zero bajtów.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> z <xref:System.Net.EndPoint> używane w <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> musi być zgodna <xref:System.Net.Sockets.AddressFamily> z <xref:System.Net.EndPoint> używane w <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu odbiera wymiany datagramów z hosta zdalnego. <xref:System.Net.Sockets.SocketFlags> są przekazywane do <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody.  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.  - lub - <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący na stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z siecią. Wyliczenie skojarzone: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizację przechowywania dla odebranych danych.</param>
        <param name="size">Liczba bajtów do odbierania.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />, Przekazywane przez odwołanie, który reprezentuje serwer zdalny.</param>
        <summary>Odbiera określoną liczbę bajtów w buforze danych, korzystając z określonego <see cref="T:System.Net.Sockets.SocketFlags" />i przechowuje punktu końcowego.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda odczytuje dane do `buffer` parametru zwraca liczbę bajtów odczytanych pomyślnie i przechwytywanie hosta zdalnego punktu końcowego, z którego wysłano danych. Ta metoda jest przydatna, jeśli chcesz otrzymywać przesyłanie datagramy Nieznany host lub na wielu hostach.  
  
 To przeciążenie tylko wymaga podania bufor odbioru, liczba bajtów, które chcesz otrzymywać niezbędne <xref:System.Net.Sockets.SocketFlags>i <xref:System.Net.EndPoint> reprezentujący hosta zdalnego. Suma przesunięcia buforu wartość domyślna to 0.  
  
 Przy użyciu protokołów przesyłanie <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> odczyta pierwszy datagram umieszczonych w kolejce odebrane w buforze sieci lokalnej. Jeśli pojawi się datagram jest większy niż rozmiar `buffer`, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody spowoduje wypełnienie `buffer` z tyle komunikatu, ponieważ jest to możliwe, a throw <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu zawodnych nadmiarowe dane zostaną utracone. Jeśli używasz protokołu niezawodnych, nadmiarowe dane będą przechowywane przez dostawcę usług i mogą być pobierane przez wywołanie metody <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody z dostatecznie dużego buforu.  
  
 Jeśli dane są niedostępne do odczytu, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody zablokuje dopóki dane są dostępne. Jeśli jesteś w trybie bez blokowania, a dane są niedostępne w w buforze stosu protokołu <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody zostanie natychmiast wykonać i zgłosić <xref:System.Net.Sockets.SocketException>. Można użyć <xref:System.Net.Sockets.Socket.Available%2A> właściwości w celu określenia, czy dane są dostępne do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.  
  
 Mimo że <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> jest przeznaczony dla protokołów bez połączenia, można użyć również protokół nawiązaniem połączenia. Jeśli wybierzesz to zrobić, albo nawiązania połączenia zdalnego hosta przez wywołanie metody <xref:System.Net.Sockets.Socket.Connect%2A> metody lub Zaakceptuj przychodzące zdalnego hosta połączenia przez wywołanie metody <xref:System.Net.Sockets.Socket.Accept%2A> — metoda. Jeśli nie ustanowić lub zaakceptować połączenie przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody, otrzymasz <xref:System.Net.Sockets.SocketException>. Możesz także udostępnić domyślnego hosta zdalnego bez połączenia protokołu przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. W tych przypadkach <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> zignoruje metody `remoteEP` parametru i odbierać dane z połączonych lub domyślnego hosta zdalnego.  
  
 Z nawiązaniem połączenia gniazda <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> odczyta jak najwięcej danych, ponieważ są dostępne do liczby bajtów określona przez `size` parametru. Jeśli host zdalny wyłączony <xref:System.Net.Sockets.Socket> połączenia z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano — metoda i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metoda zostanie natychmiast wykonać i zwraca zero bajtów.  
  
> [!NOTE]
>  Przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, należy jawnie powiązać <xref:System.Net.Sockets.Socket> do lokalnego punktu końcowego za pomocą <xref:System.Net.Sockets.Socket.Bind%2A> metody. Jeśli nie, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> z <xref:System.Net.EndPoint> używane w <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> musi być zgodna <xref:System.Net.Sockets.AddressFamily> z <xref:System.Net.EndPoint> używane w <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu odbiera wymiany datagramów z hosta zdalnego. Rozmiar buforu i <xref:System.Net.Sockets.SocketFlags> są przekazywane do <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody.  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.  - lub - <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> jest mniejsza niż 0.  - lub - <paramref name="size" /> jest większa niż długość <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> nie jest prawidłową kombinację wartości.  - lub - <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> właściwość nie została ustawiona.  - lub - wystąpi błąd systemu operacyjnego podczas uzyskiwania dostępu do <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący na stosie wywołań nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z siecią. Wyliczenie skojarzone: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizację przechowywania dla odebranych danych.</param>
        <param name="offset">Pozycja w <c>buforu</c> parametr do zapisania odebranych danych.</param>
        <param name="size">Liczba bajtów do odbierania.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />, Przekazywane przez odwołanie, który reprezentuje serwer zdalny.</param>
        <summary>Odbiera określoną liczbę bajtów danych do określonej lokalizacji buforu danych przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />i przechowuje punktu końcowego.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Metoda odczytuje dane do `buffer` parametru zwraca liczbę bajtów odczytanych pomyślnie i przechwytywanie hosta zdalnego punktu końcowego, z którego wysłano danych. Ta metoda jest przydatna, jeśli chcesz otrzymywać przesyłanie datagramy Nieznany host lub na wielu hostach.  
  
 Przy użyciu protokołów przesyłanie <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> odczyta pierwszy datagram umieszczonych w kolejce odebrane w buforze sieci lokalnej. Jeśli pojawi się datagram jest większy niż rozmiar `buffer`, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody spowoduje wypełnienie `buffer` z tyle komunikatu, ponieważ jest to możliwe, a throw <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu zawodnych nadmiarowe dane zostaną utracone. Jeśli używasz protokołu niezawodnych, nadmiarowe dane będą przechowywane przez dostawcę usług i mogą być pobierane przez wywołanie metody <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody z dostatecznie dużego buforu.  
  
 Jeśli dane są niedostępne do odczytu, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody zablokuje dopóki dane są dostępne. Jeśli jesteś w trybie bez blokowania, a dane są niedostępne w w buforze stosu protokołu <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody zostanie natychmiast wykonać i zgłosić <xref:System.Net.Sockets.SocketException>. Można użyć <xref:System.Net.Sockets.Socket.Available%2A> właściwości w celu określenia, czy dane są dostępne do odczytu. Gdy <xref:System.Net.Sockets.Socket.Available%2A> jest różna od zera, spróbuj ponownie wykonać operację odbierania.  
  
 Mimo że <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> jest przeznaczony dla protokołów bez połączenia, można użyć również protokół nawiązaniem połączenia. Jeśli wybierzesz to zrobić, albo nawiązania połączenia zdalnego hosta przez wywołanie metody <xref:System.Net.Sockets.Socket.Connect%2A> metody lub Zaakceptuj przychodzące zdalnego hosta połączenia przez wywołanie metody <xref:System.Net.Sockets.Socket.Accept%2A> — metoda. Jeśli nie ustanowić lub zaakceptować połączenie przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody, otrzymasz <xref:System.Net.Sockets.SocketException>. Możesz także udostępnić domyślnego hosta zdalnego bez połączenia protokołu przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody. W tych przypadkach <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> zignoruje metody `remoteEP` parametru i odbierać dane z połączonych lub domyślnego hosta zdalnego.  
  
 Z nawiązaniem połączenia gniazda <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> odczyta jak najwięcej danych, ponieważ są dostępne do ilości bajtów określona przez `size` parametru. Jeśli host zdalny wyłączony <xref:System.Net.Sockets.Socket> połączenia z <xref:System.Net.Sockets.Socket.Shutdown%2A> Odebrano — metoda i wszystkie dostępne dane <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metoda zostanie natychmiast wykonać i zwraca zero bajtów.  
  
> [!NOTE]
>  Przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, należy jawnie powiązać <xref:System.Net.Sockets.Socket> do lokalnego punktu końcowego za pomocą <xref:System.Net.Sockets.Socket.Bind%2A> metody. Jeśli nie, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> z <xref:System.Net.EndPoint> używane w <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> musi być zgodna <xref:System.Net.Sockets.AddressFamily> z <xref:System.Net.EndPoint> używane w <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu odbiera wymiany datagramów z hosta zdalnego. Przesunięcie, rozmiar buforu i <xref:System.Net.Sockets.SocketFlags> są przekazywane do <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metody.  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.  - lub - <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  - lub - <paramref name="offset" /> jest większa niż długość <paramref name="buffer" />.  - lub - <paramref name="size" /> jest mniejszy niż 0.  - lub - <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość parametru przesunięcia.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> nie jest prawidłową kombinację wartości.  - lub - <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> właściwość nie została ustawiona.  - lub - wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z siecią. Wyliczenie skojarzone: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Obiekt ma być używany dla tej operacji asynchronicznej gniazda.</param>
        <summary>Zaczyna asynchronicznie odbieranie danych z określonego urządzenia sieciowego.</summary>
        <returns>Zwraca <see langword="true" /> przypadku oczekujących operacji We/Wy. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenia w <paramref name="e" /> parametr zostanie wygenerowany, po zakończeniu operacji.  Zwraca <see langword="false" /> Jeśli synchronicznie wykonać operacji We/Wy. W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenia w <paramref name="e" /> parametr nie zostanie wygenerowany i <paramref name="e" /> przekazano obiekt jako parametr może być zbadana natychmiast po wywołaniu metody zwraca można pobrać wyniku operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> Metoda jest używana głównie w celu odbierania danych na bez połączenia gniazda. Adres lokalnego gniazda musi być znane.  
  
 Obiekt wywołujący musi ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> właściwości <xref:System.Net.IPEndPoint> zdalnego hosta, z którego ma zostać odebrane dane.  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> Właściwość `e` parametru zapewnia dostawcę usługi Windows Sockets dodatkowe informacje o żądanie odczytu. Aby uzyskać więcej informacji na temat używania tego parametru, zobacz <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.  
  
 Poniższe właściwości i zdarzeń w <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiektu są wymagane do pomyślnego wywołania tej metody:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwości do każdego obiektu stanu użytkownika potrzebne przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> metodę, tak, aby informacje pobieranie metody wywołania zwrotnego. Jeśli wywołanie zwrotne wymaga informacji więcej niż jeden obiekt, aby pomieścić inne wymagane informacje o stanie jako elementy członkowskie można tworzyć małych klasy.  
  
 Gniazda do przesyłania wiadomości wiadomości przychodzącej jest umieścić w buforze maksymalnie całkowity rozmiar buforu. <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> i <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> właściwości określają, gdzie w buforze dane są umieszczane w i ilości danych.  
  
 Dla gniazda stylu strumień bajtów przychodzących danych jest umieszczane w buforze bufor jest wypełniony, połączenie jest zamknięte lub wyczerpaniem wewnętrznie buforowane dane. <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> i <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> właściwości określają, gdzie w buforze dane są umieszczane w i ilości danych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> Nie może mieć wartości null.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja gniazda zostało już w toku, używając <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiektu określonego w <paramref name="e" /> parametru.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP lub nowszy jest wymagany dla tej metody.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> oznacza to lokalizację przechowywania dla odebranych danych.</param>
        <param name="offset">Pozycja w <c>buforu</c> parametr do zapisania odebranych danych.</param>
        <param name="size">Liczba bajtów do odbierania.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />, Przekazywane przez odwołanie, który reprezentuje serwer zdalny.</param>
        <param name="ipPacketInformation">
          <see cref="T:System.Net.Sockets.IPPacketInformation" /> Zawierający informacje dotyczące adresu i interfejsu.</param>
        <summary>Odbiera określoną liczbę bajtów danych do określonej lokalizacji buforu danych przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />i przechowuje informacje dotyczące punktu końcowego i pakietów.</summary>
        <returns>Liczba odebranych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Metoda odczytuje dane do `buffer` parametru zwraca liczbę bajtów odczytanych pomyślnie i przechwytywanie hosta zdalnego punktu końcowego, z którego dane zostały wysłane, a także informacje o odebrany pakiet.  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Metoda jest używana głównie w celu odbierać dane wiadomości na bez połączenia gniazda. Adres lokalnego gniazda musi być znane. Tej metody można używać tylko datagram i gniazd. Gniazda musi zostać zainicjowany z typem gniazda ustawioną <xref:System.Net.Sockets.SocketType.Dgram> lub <xref:System.Net.Sockets.SocketType.Raw> przed wywołaniem tej metody. Można to zrobić po gniazda jest tworzony przy użyciu <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 Dla gniazda do przesyłania wiadomości, wiadomości przychodzącej jest umieszczany w `buffer` parametru do całkowity rozmiar określony w `size` parametru. `offset` Parametr określa, gdzie w `buffer` dane są umieszczane w. Rzeczywista ilość danych umieszczane `buffer` jest zwracany przez <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metody.  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Metoda automatycznie ustawia metodę <xref:System.Net.Sockets.SocketOptionName.PacketInformation> gniazda możliwość `true` po raz pierwszy jest wywoływana dla danego <xref:System.Net.Sockets.Socket>. Jednak zwracana <xref:System.Net.Sockets.IPPacketInformation> obiektu tylko będzie obowiązywał dla pakietów, które został odebrany w komputerze lokalnym po została ustawiona opcja gniazda. Jeśli gniazda jest wysyłany pakietów między, gdy jest on powiązany z lokalnego punktu końcowego (jawnie przez <xref:System.Net.Sockets.Socket.Bind%2A> metody lub niejawnie za pomocą jednej z <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, lub <xref:System.Net.Sockets.Socket.SendToAsync%2A> metody) i jego pierwsze wywołanie w celu <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> wywołuje metodę, aby <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metoda zwróci nieprawidłowy <xref:System.Net.Sockets.IPPacketInformation> obiektów dla tych pakietów.  
  
 Aby upewnić się, że wszystkie <xref:System.Net.Sockets.IPPacketInformation> obiekty są prawidłowe, należy ustawić aplikacji <xref:System.Net.Sockets.SocketOptionName.PacketInformation> gniazda opcję, aby `true` przed jest powiązany z lokalnego punktu końcowego za pomocą <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> — metoda.  
  
 Aplikację można sprawdzić `ipPacketInformation` parametru, jeśli musi wiedzieć, czy datagram został wysłany przy użyciu emisji pojedynczej, adres multiemisji lub emisji.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> z <xref:System.Net.EndPoint> używane w <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> musi być zgodna <xref:System.Net.Sockets.AddressFamily> z <xref:System.Net.EndPoint> używane w <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.  \- lub - <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  - lub - <paramref name="offset" /> jest większa niż długość <paramref name="buffer" />.  - lub - <paramref name="size" /> jest mniejszy niż 0.  - lub - <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość parametru przesunięcia.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> nie jest prawidłową kombinację wartości.  - lub - <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> właściwość nie została ustawiona.  - lub - .NET Framework jest uruchomiona na AMD 64-bitowy procesor.  - lub - wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">System operacyjny jest system Windows 2000 lub starszym, a ta metoda wymaga systemu Windows XP.</exception>
        <permission cref="T:System.Net.SocketPermission">do akceptowania połączeń z siecią. Wyliczenie skojarzone: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Obiekt ma być używany dla tej operacji asynchronicznej gniazda.</param>
        <summary>Rozpoczyna asynchronicznie otrzymywać określoną liczbę bajtów danych do określonej lokalizacji w buforze danych przy użyciu określonego <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />i przechowuje informacje dotyczące punktu końcowego i pakietów.</summary>
        <returns>Zwraca <see langword="true" /> przypadku oczekujących operacji We/Wy. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenia w <paramref name="e" /> parametr zostanie wygenerowany, po zakończeniu operacji.  Zwraca <see langword="false" /> Jeśli synchronicznie wykonać operacji We/Wy. W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenia w <paramref name="e" /> parametr nie zostanie wygenerowany i <paramref name="e" /> przekazano obiekt jako parametr może być zbadana natychmiast po wywołaniu metody zwraca można pobrać wyniku operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> Metoda jest używana głównie w celu odbierać dane wiadomości na bez połączenia gniazda. Adres lokalnego gniazda musi być znane. Tej metody można używać tylko datagram i gniazd. Gniazda musi zostać zainicjowany z typem gniazda ustawioną <xref:System.Net.Sockets.SocketType.Dgram> lub <xref:System.Net.Sockets.SocketType.Raw> przed wywołaniem tej metody. Można to zrobić po gniazda jest tworzony przy użyciu <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 Obiekt wywołujący musi ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> właściwości <xref:System.Net.IPEndPoint> zdalnego hosta, z którego ma zostać odebrane dane.  
  
 Poniższe właściwości i zdarzeń w <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiektu są wymagane do pomyślnego wywołania tej metody:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwości do każdego obiektu stanu użytkownika potrzebne przed wywołaniem <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> metodę, tak, aby informacje pobieranie metody wywołania zwrotnego. Jeśli wywołanie zwrotne wymaga informacji więcej niż jeden obiekt, aby pomieścić inne wymagane informacje o stanie jako elementy członkowskie można tworzyć małych klasy.  
  
 Gniazda do przesyłania wiadomości wiadomości przychodzącej jest umieścić w buforze maksymalnie całkowity rozmiar buforu. <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> i <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> właściwości określają, gdzie w buforze dane są umieszczane w i ilości danych.  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> Metoda automatycznie ustawia <xref:System.Net.Sockets.SocketOptionName.PacketInformation> gniazda możliwość `true` po raz pierwszy jest wywoływana dla danego <xref:System.Net.Sockets.Socket>. Jednak <xref:System.Net.Sockets.IPPacketInformation> obiektu tylko będzie obowiązywał dla pakietów, które został odebrany w komputerze lokalnym po została ustawiona opcja gniazda. Jeśli gniazda jest wysyłany pakietów między, gdy gniazda jest powiązana z lokalnego punktu końcowego (jawnie przez <xref:System.Net.Sockets.Socket.Bind%2A> metody lub niejawnie za pomocą jednej z <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, lub <xref:System.Net.Sockets.Socket.SendToAsync%2A> metody) i w pierwszym wywołaniu <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>wywołań metody <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> metody spowoduje nieprawidłowe <xref:System.Net.Sockets.IPPacketInformation> obiektów dla tych pakietów.  
  
 Aby upewnić się, że wszystkie <xref:System.Net.Sockets.IPPacketInformation> obiekty są prawidłowe, należy ustawić aplikacji <xref:System.Net.Sockets.SocketOptionName.PacketInformation> gniazda opcję, aby`true` przed jest powiązany z lokalnego punktu końcowego za pomocą <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> — metoda.  
  
 Aplikację można sprawdzić powstałe w ten sposób <xref:System.Net.Sockets.IPPacketInformation> obiekty, jeśli musi wiedzieć, czy datagram został wysłany przy użyciu emisji pojedynczej, adres multiemisji lub emisji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> Nie może mieć wartości null.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP lub nowszy jest wymagany dla tej metody.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, która określa czas, po którym synchronicznego <see cref="Overload:System.Net.Sockets.Socket.Receive" /> wywołanie zostanie limit czasu.</summary>
        <value>Wartość limitu czasu w milisekundach. Wartość domyślna to 0, co wskazuje nieskończony limit czasu. Określanie -1 wskazuje także nieskończonego limitu czasu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta opcja ma zastosowanie do synchroniczne <xref:System.Net.Sockets.Socket.Receive%2A> tylko wywołania. Po przekroczeniu limitu czasu <xref:System.Net.Sockets.Socket.Receive%2A> metoda zgłosi <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona dla operacji ustawienia jest mniejsza niż -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zdalny punkt końcowy.</summary>
        <value>
          <see cref="T:System.Net.EndPoint" /> z którym <see cref="T:System.Net.Sockets.Socket" /> komunikuje się.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz protokołu nawiązaniem połączenia, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> pobiera właściwość <xref:System.Net.EndPoint> zawierający zdalny adres IP i port numer do którego <xref:System.Net.Sockets.Socket> jest połączony. Jeśli używasz protokołu bez połączenia, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> zawiera domyślne zdalny adres IP i port numer, z którym <xref:System.Net.Sockets.Socket> będą komunikować się. Należy to rzutować <xref:System.Net.EndPoint> do <xref:System.Net.IPEndPoint> przed pobraniem żadnych informacji. Następnie można wywołać <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> metoda pobierania zdalnego <xref:System.Net.IPAddress>i <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> metoda pobierania numer portu zdalnego.  
  
 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> Jest ustawiany po wywołaniu albo <xref:System.Net.Sockets.Socket.Accept%2A> lub <xref:System.Net.Sockets.Socket.Connect%2A>. Jeśli spróbujesz wcześniej, dostęp do tej właściwości <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i wyświetla lokalnych i zdalnych punktów końcowych.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" />
        <Parameter Name="checkError" Type="System.Collections.IList" />
        <Parameter Name="microSeconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="checkRead">
          <see cref="T:System.Collections.IList" /> z <see cref="T:System.Net.Sockets.Socket" /> wystąpień, aby wyszukać czytelności.</param>
        <param name="checkWrite">
          <see cref="T:System.Collections.IList" /> z <see cref="T:System.Net.Sockets.Socket" /> wystąpień, aby wyszukać writability.</param>
        <param name="checkError">
          <see cref="T:System.Collections.IList" /> z <see cref="T:System.Net.Sockets.Socket" /> wystąpień, aby sprawdzić błędy.</param>
        <param name="microSeconds">Wartość limitu czasu w mikrosekundach. Wartość-1 wskazuje nieskończonego limitu czasu.</param>
        <summary>Określa stan co najmniej jednego gniazda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A> jest statyczną metodę, która określa stan co najmniej jednego <xref:System.Net.Sockets.Socket> wystąpień. Należy zaznaczyć co najmniej jednego gniazda do <xref:System.Collections.IList> przed użyciem <xref:System.Net.Sockets.Socket.Select%2A> metody. Wyszukaj czytelności przez wywołanie metody <xref:System.Net.Sockets.Socket.Select%2A> z <xref:System.Collections.IList> jako `checkRead` parametru. Aby sprawdzić writability Twojego gniazd, należy użyć `checkWrite` parametru. Wykrywanie błędów, użyj `checkError`. Po wywołaniu <xref:System.Net.Sockets.Socket.Select%2A>, <xref:System.Collections.IList> wypełnione tylko gniazd, które spełniają warunki.  
  
 Jeśli jesteś w stanie nasłuchiwania czytelność oznacza, że wywołanie <xref:System.Net.Sockets.Socket.Accept%2A> powiedzie się bez blokowania. Zaakceptował połączenia czytelność oznacza, że dane są dostępne do odczytu. W takich przypadkach odbierać wszystkie operacje będą się pomyślnie bez blokowania. Czytelność można również określić, czy zdalny <xref:System.Net.Sockets.Socket> została zamknięta połączenie; w takim przypadku wywołania <xref:System.Net.Sockets.Socket.Receive%2A> zwróci natychmiast z zero bajtów zwrócona.  
  
 <xref:System.Net.Sockets.Socket.Select%2A> Po co najmniej jeden z gniazda zainteresowania (sockets w `checkRead`, `checkWrite`, i `checkError` wymieniono) spełnia określone kryteria lub `microSeconds` parametr został przekroczony, jeżeli zostanie osiągnięty jako pierwszy. Ustawienie `microSeconds` -1 określa nieskończony limit czasu.  
  
 Jeśli wprowadzisz nieblokujących wywołanie <xref:System.Net.Sockets.Socket.Connect%2A>, writability oznacza, że nawiązano połączenie pomyślnie. Jeśli masz już połączenie nawiązane, writability oznacza, że wysłanie wszystkie operacje powiedzie się bez blokowania.  
  
 Jeśli wprowadzono nieblokujące wywołania <xref:System.Net.Sockets.Socket.Connect%2A>, `checkerror` parametr identyfikuje gniazd, które nie łączyły pomyślnie.  
  
> [!NOTE]
>  Użyj <xref:System.Net.Sockets.Socket.Poll%2A> metodę, jeśli chcesz określić stan pojedynczy <xref:System.Net.Sockets.Socket>.  
  
> [!NOTE]
>  Ta metoda nie może wykryć niektóre rodzaje problemów z połączeniem, takie jak kabel sieciowy przerwany, lub host zdalny został zamknięty ungracefully. Należy próba wysłania lub odebrania danych, aby wykryć tego rodzaju błędów.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.Sockets.Socket.Select%2A> można określić, które nasłuchiwania sockets żądanie połączenia.  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="checkRead" /> Parametr jest <see langword="null" /> lub jest pusty.  - i - <paramref name="checkWrite" /> parametr jest <see langword="null" /> lub jest pusty - i - <paramref name="checkError" /> parametr jest <see langword="null" /> lub jest pusty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wysyła dane do połączonych <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <summary>Wysyła dane do połączonych <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> synchronicznie wysyła dane do hosta zdalnego określono w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metodę i zwraca liczbę bajtów pomyślnie wysłane. <xref:System.Net.Sockets.Socket.Send%2A> może służyć do zarówno połączeń i bez połączenia.  
  
 To przeciążenie wymaga buforu, który zawiera dane, które chcesz wysyłać. <xref:System.Net.Sockets.SocketFlags> Domyślne wartości na 0, wartość domyślna to 0, a liczba bajtów do wysłania domyślne do rozmiaru buforu przesunięcie buforu.  
  
 Jeśli używasz protokołu bez połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu nawiązaniem połączenia, należy używać <xref:System.Net.Sockets.Socket.Connect%2A> w celu nawiązania połączenia zdalnego hosta lub użyj <xref:System.Net.Sockets.Socket.Accept%2A> akceptować połączenia przychodzące.  
  
 Jeśli korzystasz z protokołu przesyłanie i plan do wysyłania danych do wielu różnych hostach, należy użyć <xref:System.Net.Sockets.Socket.SendTo%2A> metody. Jeśli nie używasz <xref:System.Net.Sockets.Socket.SendTo%2A> metody należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed każdym wywołaniu <xref:System.Net.Sockets.Socket.Send%2A>. Można użyć <xref:System.Net.Sockets.Socket.SendTo%2A> nawet po ustaleniu domyślna zdalnego hosta z <xref:System.Net.Sockets.Socket.Connect%2A>. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> przez inne wywołanie <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Jeśli używasz protokołu nawiązaniem połączenia, <xref:System.Net.Sockets.Socket.Send%2A> zablokuje dopóki wszystkie bajtów w buforze są wysyłane, jeśli nie ustawiono limit czasu za pomocą <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Send%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. W trybie nieblokujących <xref:System.Net.Sockets.Socket.Send%2A> może zakończyć się pomyślnie nawet wtedy, gdy wysyła on mniejszy niż liczba bajtów w buforze. Jest odpowiedzialny za aplikacji, aby śledzić liczbę bajtów wysłanych i spróbuj ponownie wykonać operację, dopóki aplikacja wysyła bajtów w buforze. Ponadto nie ma żadnej gwarancji, który danych wysyłanych będzie widoczny w sieci, natychmiast. Aby zwiększyć wydajność sieci, źródłowy system może być opóźniona transmisji, dopóki nie są zbierane znaczną ilość danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że źródłowy system miał miejsca w buforze wysyłania danych w sieci.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że danych zostało pomyślnie dostarczone. Jeśli nie ma przestrzeni buforu w systemie transportu do przechowywania danych, które mają być przekazywane, wysyłania zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wysyłanie danych na połączonych <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">Lista <see cref="T:System.ArraySegment`1" />s typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <summary>Wysyła zbiór buforów na liście do połączonych <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> może służyć do zarówno połączeń i bez połączenia.  
  
 To przeciążenie wymaga co najmniej jeden buforu, który zawiera dane, które chcesz wysyłać.  
  
 Jeśli używasz protokołu bez połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu nawiązaniem połączenia, należy używać <xref:System.Net.Sockets.Socket.Connect%2A> w celu nawiązania połączenia zdalnego hosta lub użyj <xref:System.Net.Sockets.Socket.Accept%2A> akceptować połączenia przychodzące.  
  
 Jeśli korzystasz z protokołu przesyłanie i plan do wysyłania danych do wielu różnych hostach, należy użyć <xref:System.Net.Sockets.Socket.SendTo%2A> metody. Jeśli nie używasz <xref:System.Net.Sockets.Socket.SendTo%2A> metody należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed każdym wywołaniu <xref:System.Net.Sockets.Socket.Send%2A>. Można użyć <xref:System.Net.Sockets.Socket.SendTo%2A> nawet po ustaleniu domyślna zdalnego hosta z <xref:System.Net.Sockets.Socket.Connect%2A>. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> przez inne wywołanie <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Jeśli używasz protokołu nawiązaniem połączenia, <xref:System.Net.Sockets.Socket.Send%2A> zablokuje dopóki wszystkie bajtów w buforze są wysyłane, jeśli nie ustawiono limit czasu za pomocą <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Send%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. W trybie nieblokujących <xref:System.Net.Sockets.Socket.Send%2A> może zakończyć się pomyślnie nawet wtedy, gdy wysyła on mniejszy niż liczba bajtów w buforze. Jest odpowiedzialny za aplikacji, aby śledzić liczbę bajtów wysłanych i spróbuj ponownie wykonać operację, dopóki aplikacja wysyła bajtów w buforze. Ponadto nie ma żadnej gwarancji, który danych wysyłanych będzie widoczny w sieci, natychmiast. Aby zwiększyć wydajność sieci, źródłowy system może być opóźniona transmisji, dopóki nie są zbierane znaczną ilość danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że źródłowy system miał miejsca w buforze wysyłania danych w sieci.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że danych zostało pomyślnie dostarczone. Jeśli nie ma przestrzeni buforu w systemie transportu do przechowywania danych, które mają być przekazywane, wysyłania zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> jest pusty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Zobacz uwagi poniżej.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <summary>Wysyła dane do połączonych <see cref="T:System.Net.Sockets.Socket" /> przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> synchronicznie wysyła dane do zdalnego hosta w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metodę i zwraca liczbę bajtów pomyślnie wysłane. <xref:System.Net.Sockets.Socket.Send%2A> Metody można użyć protokołów zarówno połączeń i bez połączenia.  
  
 To przeciążenie wymaga buforu, który zawiera dane, których chcesz wysyłać i bitowe połączenie <xref:System.Net.Sockets.SocketFlags>. Wartość domyślna to 0, a liczba bajtów do wysłania domyślne do rozmiaru buforu przesunięcia buforu. Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketflags` wartości parametru, dane są wysyłane, nie zostaną przesłane.  
  
 Jeśli używasz protokołu bez połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu nawiązaniem połączenia, należy używać <xref:System.Net.Sockets.Socket.Connect%2A> w celu nawiązania połączenia zdalnego hosta lub użyj <xref:System.Net.Sockets.Socket.Accept%2A> akceptować połączenia przychodzące.  
  
 Jeśli korzystasz z protokołu przesyłanie i plan do wysyłania danych do wielu różnych hostach, należy użyć <xref:System.Net.Sockets.Socket.SendTo%2A> metody. Jeśli nie używasz <xref:System.Net.Sockets.Socket.SendTo%2A> metody należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> metody przed każdym wywołaniu <xref:System.Net.Sockets.Socket.Send%2A>. Można użyć <xref:System.Net.Sockets.Socket.SendTo%2A> nawet po ustaleniu domyślna zdalnego hosta z <xref:System.Net.Sockets.Socket.Connect%2A>. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> przez inne wywołanie <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Jeśli używasz protokołu nawiązaniem połączenia, <xref:System.Net.Sockets.Socket.Send%2A> zablokuje dopóki wszystkie bajtów w buforze są wysyłane, jeśli nie ustawiono limit czasu za pomocą <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Send%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. W trybie nieblokujących <xref:System.Net.Sockets.Socket.Send%2A> może zakończyć się pomyślnie nawet wtedy, gdy wysyła on mniejszy niż liczba bajtów w buforze. Jest odpowiedzialny za aplikacji, aby śledzić liczbę bajtów wysłanych i spróbuj ponownie wykonać operację, dopóki aplikacja wysyła żądanej liczby bajtów. Ponadto nie ma żadnej gwarancji, który danych wysyłanych będzie widoczny w sieci, natychmiast. Aby zwiększyć wydajność sieci, źródłowy system może być opóźniona transmisji, dopóki nie są zbierane znaczną ilość danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że źródłowy system miał miejsca w buforze wysyłania danych w sieci.  
  
> [!NOTE]
>  Należy się upewnić, że rozmiar buforu przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie zostaną wysłane i <xref:System.Net.Sockets.Socket.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że danych zostało pomyślnie dostarczone. Jeśli nie ma przestrzeni buforu w systemie transportu do przechowywania danych, które mają być przekazywane, wysyłania zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wysyłanie danych na połączonych <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">Lista <see cref="T:System.ArraySegment`1" />s typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <summary>Wysyła zbiór buforów na liście do połączonych <see cref="T:System.Net.Sockets.Socket" />, przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie wymaga co najmniej jeden buforu, który zawiera dane, które chcesz wysyłać. <xref:System.Net.Sockets.SocketFlags> Wartość wartość domyślna to 0. Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketFlags` parametru, dane są wysyłane, nie zostaną przesłane.  
  
 Jeśli używasz protokołu bez połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu nawiązaniem połączenia, należy używać <xref:System.Net.Sockets.Socket.Connect%2A> w celu nawiązania połączenia zdalnego hosta lub użyj <xref:System.Net.Sockets.Socket.Accept%2A> akceptować połączenia przychodzące.  
  
 Jeśli korzystasz z protokołu przesyłanie i plan do wysyłania danych do wielu różnych hostach, należy użyć <xref:System.Net.Sockets.Socket.SendTo%2A> metody. Jeśli nie używasz <xref:System.Net.Sockets.Socket.SendTo%2A> metody należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed każdym wywołaniu <xref:System.Net.Sockets.Socket.Send%2A>. Można użyć <xref:System.Net.Sockets.Socket.SendTo%2A> nawet po ustaleniu domyślna zdalnego hosta z <xref:System.Net.Sockets.Socket.Connect%2A>. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> przez inne wywołanie <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Jeśli używasz protokołu nawiązaniem połączenia, <xref:System.Net.Sockets.Socket.Send%2A> zablokuje dopóki wszystkie bajtów w buforze są wysyłane, jeśli nie ustawiono limit czasu za pomocą <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Send%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. W trybie bez blokowania <xref:System.Net.Sockets.Socket.Send%2A> może zakończyć się pomyślnie nawet wtedy, gdy wysyła on mniejszy niż liczba bajtów w buforze. Jest odpowiedzialny za aplikacji, aby śledzić liczbę bajtów wysłanych i spróbuj ponownie wykonać operację, dopóki aplikacja wysyła bajtów w buforze. Ponadto nie ma żadnej gwarancji, który danych wysyłanych będzie widoczny w sieci, natychmiast. Aby zwiększyć wydajność sieci, źródłowy system może być opóźniona transmisji, dopóki nie są zbierane znaczną ilość danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że źródłowy system miał miejsca w buforze wysyłania danych w sieci.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że danych zostało pomyślnie dostarczone. Jeśli nie ma przestrzeni buforu w systemie transportu do przechowywania danych, które mają być przekazywane, wysyłania zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> jest pusty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="size">Liczba bajtów do wysłania.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <summary>Wysyła określoną liczbę bajtów danych do połączonych <see cref="T:System.Net.Sockets.Socket" />, przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> synchronicznie wysyła dane do zdalnego hosta w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metodę i zwraca liczbę bajtów pomyślnie wysłane. <xref:System.Net.Sockets.Socket.Send%2A> może służyć do zarówno połączeń i bez połączenia.  
  
 To przeciążenie wymaga buforu, który zawiera dane, których chcesz wysyłać, liczba bajtów, które chcesz wysyłać i bitowe połączenie dowolnego <xref:System.Net.Sockets.SocketFlags>. Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketflags` parametru, dane są wysyłane, nie zostaną przesłane.  
  
 Jeśli używasz protokołu bez połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu nawiązaniem połączenia, należy używać <xref:System.Net.Sockets.Socket.Connect%2A> w celu nawiązania połączenia zdalnego hosta lub użyj <xref:System.Net.Sockets.Socket.Accept%2A> akceptować połączenia przychodzące.  
  
 Jeśli korzystasz z protokołu przesyłanie i plan do wysyłania danych do wielu różnych hostach, należy użyć <xref:System.Net.Sockets.Socket.SendTo%2A> metody. Jeśli nie używasz <xref:System.Net.Sockets.Socket.SendTo%2A> metody należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> metody przed każdym wywołaniu <xref:System.Net.Sockets.Socket.Send%2A> metody. Można użyć <xref:System.Net.Sockets.Socket.SendTo%2A> nawet po ustaleniu domyślna zdalnego hosta z <xref:System.Net.Sockets.Socket.Connect%2A>. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> przez inne wywołanie <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Za pomocą połączeń protokołu <xref:System.Net.Sockets.Socket.Send%2A> zablokuje dopóki wysłaniem żądanej liczby bajtów, chyba że ustawiono limit czasu za pomocą <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Send%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. W trybie nieblokujących <xref:System.Net.Sockets.Socket.Send%2A> może zakończyć się pomyślnie nawet wtedy, gdy wysyła on mniejszy niż liczba bajtów w przypadku żądania. Jest odpowiedzialny za aplikacji, aby śledzić liczbę bajtów wysłanych i spróbuj ponownie wykonać operację, dopóki aplikacja wysyła żądanej liczby bajtów. Ponadto nie ma żadnej gwarancji, który danych wysyłanych będzie widoczny w sieci, natychmiast. Aby zwiększyć wydajność sieci, źródłowy system może być opóźniona transmisji, dopóki nie są zbierane znaczną ilość danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że źródłowy system miał miejsca w buforze wysyłania danych w sieci.  
  
> [!NOTE]
>  Należy się upewnić, że rozmiar przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie zostaną wysłane i <xref:System.Net.Sockets.Socket.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że danych zostało pomyślnie dostarczone. Jeśli nie ma przestrzeni buforu w systemie transportu do przechowywania danych, które mają być przekazywane, wysyłania zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła dane w buforze i określa <xref:System.Net.Sockets.SocketFlags.None> dla <xref:System.Net.Sockets.SocketFlags>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> jest mniejsza niż 0 lub większa niż rozmiar buforu.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> nie jest prawidłową kombinację wartości.  - lub - wystąpi błąd systemu operacyjnego podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">Lista <see cref="T:System.ArraySegment`1" />s typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> obiekt zawierający błąd gniazda.</param>
        <summary>Wysyła zbiór buforów na liście do połączonych <see cref="T:System.Net.Sockets.Socket" />, przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie wymaga co najmniej jeden buforu, który zawiera dane, które chcesz wysyłać. <xref:System.Net.Sockets.SocketFlags> Wartość wartość domyślna to 0. Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketFlags` parametru, dane są wysyłane, nie zostaną przesłane.  
  
 Jeśli używasz protokołu bez połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu nawiązaniem połączenia, należy używać <xref:System.Net.Sockets.Socket.Connect%2A> w celu nawiązania połączenia zdalnego hosta lub użyj <xref:System.Net.Sockets.Socket.Accept%2A> akceptować połączenia przychodzące.  
  
 Jeśli korzystasz z protokołu przesyłanie i plan do wysyłania danych do wielu różnych hostach, należy użyć <xref:System.Net.Sockets.Socket.SendTo%2A> metody. Jeśli nie używasz <xref:System.Net.Sockets.Socket.SendTo%2A> metody należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed każdym wywołaniu <xref:System.Net.Sockets.Socket.Send%2A>. Można użyć <xref:System.Net.Sockets.Socket.SendTo%2A> nawet po ustaleniu domyślna zdalnego hosta z <xref:System.Net.Sockets.Socket.Connect%2A>. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> przez inne wywołanie <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Jeśli używasz protokołu nawiązaniem połączenia, <xref:System.Net.Sockets.Socket.Send%2A> zablokuje dopóki wszystkie bajtów w buforze są wysyłane, jeśli nie ustawiono limit czasu za pomocą <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Send%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. W trybie bez blokowania <xref:System.Net.Sockets.Socket.Send%2A> może zakończyć się pomyślnie nawet wtedy, gdy wysyła on mniejszy niż liczba bajtów w buforze. Jest odpowiedzialny za aplikacji, aby śledzić liczbę bajtów wysłanych i spróbuj ponownie wykonać operację, dopóki aplikacja wysyła bajtów w buforze. Ponadto nie ma żadnej gwarancji, który danych wysyłanych będzie widoczny w sieci, natychmiast. Aby zwiększyć wydajność sieci, źródłowy system może być opóźniona transmisji, dopóki nie są zbierane znaczną ilość danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że źródłowy system miał miejsca w buforze wysyłania danych w sieci.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że danych zostało pomyślnie dostarczone. Jeśli nie ma przestrzeni buforu w systemie transportu do przechowywania danych, które mają być przekazywane, wysyłania zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> jest pusty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="offset">Pozycja w buforze danych, w którym należy rozpocząć wysyłanie danych.</param>
        <param name="size">Liczba bajtów do wysłania.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <summary>Wysyła określoną liczbę bajtów danych do połączonych <see cref="T:System.Net.Sockets.Socket" />, zaczynając od określonego przesunięcia i przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> synchronicznie wysyła dane do hosta zdalnego określono w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metodę i zwraca liczbę bajtów pomyślnie wysłane. <xref:System.Net.Sockets.Socket.Send%2A> może służyć do zarówno połączeń i bez połączenia.  
  
 W tej przeciążenia, jeśli określono <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketflags` parametru, dane są wysyłane, nie zostaną przesłane.  
  
 Jeśli używasz protokołu bez połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu nawiązaniem połączenia, należy używać <xref:System.Net.Sockets.Socket.Connect%2A> w celu nawiązania połączenia zdalnego hosta lub użyj <xref:System.Net.Sockets.Socket.Accept%2A> akceptować połączenia przychodzące.  
  
 Jeśli korzystasz z protokołu przesyłanie i plan do wysyłania danych do wielu różnych hostach, należy użyć <xref:System.Net.Sockets.Socket.SendTo%2A>. Jeśli nie używasz <xref:System.Net.Sockets.Socket.SendTo%2A>, należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed każdym wywołaniu <xref:System.Net.Sockets.Socket.Send%2A>. Można użyć <xref:System.Net.Sockets.Socket.SendTo%2A> nawet po ustaleniu domyślna zdalnego hosta z <xref:System.Net.Sockets.Socket.Connect%2A>. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> przez inne wywołanie <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Również należy się upewnić, że rozmiar przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie zostaną wysłane i <xref:System.Net.Sockets.Socket.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Jeśli używasz protokołu nawiązaniem połączenia, <xref:System.Net.Sockets.Socket.Send%2A> zablokuje dopóki wysłaniem żądanej liczby bajtów, chyba że ustawiono limit czasu za pomocą <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Send%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. W trybie nieblokujących <xref:System.Net.Sockets.Socket.Send%2A> może zakończyć się pomyślnie nawet wtedy, gdy wysyła on mniejszy niż liczba bajtów w przypadku żądania. Jest odpowiedzialny za aplikacji, aby śledzić liczbę bajtów wysłanych i spróbuj ponownie wykonać operację, dopóki aplikacja wysyła żądanej liczby bajtów. Ponadto nie ma żadnej gwarancji, który danych wysyłanych będzie widoczny w sieci, natychmiast. Aby zwiększyć wydajność sieci, źródłowy system może być opóźniona transmisji, dopóki nie są zbierane znaczną ilość danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że źródłowy system miał miejsca w buforze wysyłania danych w sieci.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że danych zostało pomyślnie dostarczone. Jeśli nie ma przestrzeni buforu w systemie transportu do przechowywania danych, które mają być przekazywane, wysyłania zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu określa przesunięcie buforu danych, o rozmiarze i <xref:System.Net.Sockets.SocketFlags> do wysyłania danych do połączonych <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  - lub - <paramref name="offset" /> jest większa niż długość <paramref name="buffer" />.  - lub - <paramref name="size" /> jest mniejszy niż 0.  - lub - <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> nie jest prawidłową kombinację wartości.  - lub - wystąpi błąd systemu operacyjnego podczas uzyskiwania dostępu do <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="offset">Pozycja w buforze danych, w którym należy rozpocząć wysyłanie danych.</param>
        <param name="size">Liczba bajtów do wysłania.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> obiekt zawierający błąd gniazda.</param>
        <summary>Wysyła określoną liczbę bajtów danych do połączonych <see cref="T:System.Net.Sockets.Socket" />, zaczynając od określonego przesunięcia i przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" /></summary>
        <returns>Liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> synchronicznie wysyła dane do hosta zdalnego określono w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metodę i zwraca liczbę bajtów pomyślnie wysłane. <xref:System.Net.Sockets.Socket.Send%2A> może służyć do zarówno połączeń i bez połączenia.  
  
 W tej przeciążenia, jeśli określono <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketflags` parametru, dane są wysyłane, nie zostaną przesłane.  
  
 Jeśli używasz protokołu bez połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody lub <xref:System.Net.Sockets.Socket.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu nawiązaniem połączenia, należy używać <xref:System.Net.Sockets.Socket.Connect%2A> w celu nawiązania połączenia zdalnego hosta lub użyj <xref:System.Net.Sockets.Socket.Accept%2A> akceptować połączenia przychodzące.  
  
 Jeśli korzystasz z protokołu przesyłanie i plan do wysyłania danych do wielu różnych hostach, należy użyć <xref:System.Net.Sockets.Socket.SendTo%2A>. Jeśli nie używasz <xref:System.Net.Sockets.Socket.SendTo%2A>, należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed każdym wywołaniu <xref:System.Net.Sockets.Socket.Send%2A>. Można użyć <xref:System.Net.Sockets.Socket.SendTo%2A> nawet po ustaleniu domyślna zdalnego hosta z <xref:System.Net.Sockets.Socket.Connect%2A>. Możesz również zmienić domyślnego hosta zdalnego przed wywołaniem <xref:System.Net.Sockets.Socket.Send%2A> przez inne wywołanie <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Również należy się upewnić, że rozmiar przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie zostaną wysłane i <xref:System.Net.Sockets.Socket.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Jeśli używasz protokołu nawiązaniem połączenia, <xref:System.Net.Sockets.Socket.Send%2A> zablokuje dopóki wysłaniem żądanej liczby bajtów, chyba że ustawiono limit czasu za pomocą <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Jeśli wartość limitu czasu został przekroczony, <xref:System.Net.Sockets.Socket.Send%2A> zgłosi wywołania <xref:System.Net.Sockets.SocketException>. W trybie nieblokujących <xref:System.Net.Sockets.Socket.Send%2A> może zakończyć się pomyślnie nawet wtedy, gdy wysyła on mniejszy niż liczba bajtów w przypadku żądania. Jest odpowiedzialny za aplikacji, aby śledzić liczbę bajtów wysłanych i spróbuj ponownie wykonać operację, dopóki aplikacja wysyła żądanej liczby bajtów. Ponadto nie ma żadnej gwarancji, który danych wysyłanych będzie widoczny w sieci, natychmiast. Aby zwiększyć wydajność sieci, źródłowy system może być opóźniona transmisji, dopóki nie są zbierane znaczną ilość danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.Send%2A> metody oznacza, że źródłowy system miał miejsca w buforze wysyłania danych w sieci.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Pomyślne zakończenie wysyłania nie wskazuje, że danych zostało pomyślnie dostarczone. Jeśli nie ma przestrzeni buforu w systemie transportu do przechowywania danych, które mają być przekazywane, wysyłania zablokuje, chyba że gniazda został umieszczony w trybie nieblokujących.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu określa przesunięcie buforu danych, o rozmiarze i <xref:System.Net.Sockets.SocketFlags> do wysyłania danych do połączonych <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  - lub - <paramref name="offset" /> jest większa niż długość <paramref name="buffer" />.  - lub - <paramref name="size" /> jest mniejszy niż 0.  - lub - <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> nie jest prawidłową kombinację wartości.  - lub - wystąpi błąd systemu operacyjnego podczas uzyskiwania dostępu do <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Obiekt ma być używany dla tej operacji asynchronicznej gniazda.</param>
        <summary>Wysyła dane asynchronicznie do połączonych <see cref="T:System.Net.Sockets.Socket" /> obiektu.</summary>
        <returns>Zwraca <see langword="true" /> przypadku oczekujących operacji We/Wy. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenia w <paramref name="e" /> parametr zostanie wygenerowany, po zakończeniu operacji.  Zwraca <see langword="false" /> Jeśli synchronicznie wykonać operacji We/Wy. W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenia w <paramref name="e" /> parametr nie zostanie wygenerowany i <paramref name="e" /> przekazano obiekt jako parametr może być zbadana natychmiast po wywołaniu metody zwraca można pobrać wyniku operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendAsync%2A> Metoda służy do zapisywania danych wychodzących z jednego lub więcej buforów nawiązaniem połączenia gniazda. Tej metody można również, jednak na przesyłanie gniazd, które określono hosta zdalnego operacji połączenia.  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A> Metody rozpoczyna się operacja asynchronicznego wysyłania do zdalnego hosta w <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metody.  
  
 Poniższe właściwości i zdarzeń w <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiektu są wymagane do pomyślnego wywołania tej metody:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> lub <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Jeśli <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> ustawiono  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Jeśli <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> ustawiono  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwości do każdego obiektu stanu użytkownika potrzebne przed wywołaniem <xref:System.Net.Sockets.Socket.SendAsync%2A> metodę, tak, aby informacje pobieranie metody wywołania zwrotnego. Jeśli wywołanie zwrotne wymaga informacji więcej niż jeden obiekt, aby pomieścić inne wymagane informacje o stanie jako elementy członkowskie można tworzyć małych klasy.  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A> Metoda zgłosi wyjątek, jeśli najpierw nie zostanie wywołana <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.  
  
 Wywoływanie <xref:System.Net.Sockets.Socket.SendAsync%2A> metody daje możliwość wysyłania danych w ramach oddzielnego wykonanie wątku.  
  
 Gniazda do przesyłania wiadomości nie przekraczają maksymalny rozmiar wiadomości podstawowego dostawcy usług Windows sockets. Jeśli dane są zbyt długie, aby automatycznie przechodzą przez dostawcę usługi podstawowej, żadne dane nie są przesyłane i <xref:System.Net.Sockets.Socket.SendAsync%2A> metoda zgłasza <xref:System.Net.Sockets.SocketException> z <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> ustawioną natywny kod błędu Winsock WSAEMSGSIZE (10040).  
  
 Należy pamiętać, że pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendAsync%2A> — metoda nie wskazuje, że dane zostało pomyślnie dostarczone.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> Lub <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> właściwości <paramref name="e" /> parametru musi odwoływać się buforów prawidłowe. Jedna z tych właściwości może być zestaw, ale nie oba jednocześnie.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja gniazda zostało już w toku, używając <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiektu określonego w <paramref name="e" /> parametru.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP lub nowszy jest wymagany dla tej metody.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <see cref="T:System.Net.Sockets.Socket" /> Nie jest jeszcze podłączona lub nie uzyskano za pośrednictwem <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />, lub <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />, metody.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą rozmiar buforu wysyłania z <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>
          <see cref="T:System.Int32" /> Zawierający rozmiar w bajtach buforu wysyłania. Wartość domyślna to 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Większy rozmiar buforu może opóźnić rozpoznawania trudności połączenia. Rozważ zwiększenie rozmiaru buforu transferowania dużych plików, czy używasz wysokiej przepustowości, duże opóźnienie połączenia (np. dostawcę satelity połączenia szerokopasmowego użytkownika.)  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.Socket.SendBufferSize%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona dla operacji ustawienia jest mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wysyła pliku i opcjonalnymi danymi synchronicznie do połączonych <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">A <see cref="T:System.String" /> zawiera ścieżkę i nazwę pliku do wysłania. Ten parametr może być <see langword="null" />.</param>
        <summary>Wysyła pliku <paramref name="fileName" /> do połączonych <see cref="T:System.Net.Sockets.Socket" /> obiekt z <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> przekazuje flagę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie wysyła plik `fileName` do połączenia gniazda. `flags` Jest domyślnie <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0) i `preBuffer` i `postBuffer` domyślne parametry `null`. Jeśli `fileName` jest w katalogu lokalnego może zostać zidentyfikowane na nazwę pliku; w przeciwnym razie należy określić pełną ścieżkę i nazwę pliku. Symbole wieloznaczne ("... \\\myfile.txt ") i nazwy udziału UNC ("\\\\\\katalogu \shared\\\myfile.txt ") są obsługiwane. Jeśli plik nie zostanie znaleziony, wyjątek <xref:System.IO.FileNotFoundException> jest generowany.  
  
 Ta metoda używa `TransmitFile` funkcja znaleziono w interfejsie API Windows Sockets 2. Aby uzyskać więcej informacji na temat `TransmitFile` funkcji i jej flag, można znaleźć w dokumentacji systemu Windows Sockets w bibliotece MSDN.  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> synchronicznie wysyła plik do hosta zdalnego określono w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metody. <xref:System.Net.Sockets.Socket.SendFile%2A> może służyć dla obu tych połączeń i protokoły bez połączenia.  
  
 Jeśli używasz protokołu bez połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody, w przeciwnym razie <xref:System.Net.Sockets.Socket.SendFile%2A> zgłasza <xref:System.Net.Sockets.SocketException> wyjątku. Jeśli używasz protokołu nawiązaniem połączenia, należy używać <xref:System.Net.Sockets.Socket.Connect%2A> do nawiązywania połączenia zdalnego hosta lub użyj <xref:System.Net.Sockets.Socket.Accept%2A> akceptować połączenia przychodzące.  
  
 Jeśli używasz protokołu nawiązaniem połączenia, <xref:System.Net.Sockets.Socket.SendFile%2A> blokuje momentu wysłania pliku. W trybie nieblokujących <xref:System.Net.Sockets.Socket.SendFile%2A> może zakończyć się powodzeniem przed cały plik został wysłany. Nie ma żadnej gwarancji, który danych wysyłanych będzie widoczny w sieci, natychmiast. Aby zwiększyć wydajność sieci, źródłowy system może być opóźniona transmisji, dopóki nie są zbierane znaczną ilość danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendFile%2A> metody oznacza, że źródłowy system miał miejsca w buforze wysyłania danych w sieci.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy i nawiązuje połączenie gniazda, a następnie wysyła plik do hosta zdalnego. Plik "test.txt" znajduje się w katalogu głównym komputera lokalnego.  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Gniazda nie jest połączony z hostem zdalnym.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt nie jest w trybie blokowania i nie może zaakceptować tego wywołania synchronicznego.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik <paramref name="fileName" /> nie został znaleziony.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
      </Parameters>
      <Docs>
        <param name="fileName">A <see cref="T:System.String" /> zawiera ścieżkę i nazwę pliku do wysłania. Ten parametr może być <see langword="null" />.</param>
        <param name="preBuffer">A <see cref="T:System.Byte" /> tablicy, która zawiera dane mają być wysyłane przed wysłaniem pliku. Ten parametr może być <see langword="null" />.</param>
        <param name="postBuffer">A <see cref="T:System.Byte" /> tablicy, która zawiera dane mają być wysyłane po wysłaniu pliku. Ten parametr może być <see langword="null" />.</param>
        <param name="flags">Co najmniej jeden z <see cref="T:System.Net.Sockets.TransmitFileOptions" /> wartości.</param>
        <summary>Wysyła pliku <paramref name="fileName" /> i buforów danych do połączonych <see cref="T:System.Net.Sockets.Socket" /> przy użyciu określonego <see cref="T:System.Net.Sockets.TransmitFileOptions" /> wartość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie wymaga nazwy pliku, który chcesz wysłać i bitowe połączenie <xref:System.Net.Sockets.TransmitFileOptions> wartości. `preBuffer` Parametr zawiera wszystkie dane poprzedzającą pliku. `postBuffer` zawiera dane, które chcesz wykonać pliku. Jeśli `fileName` jest w bieżący katalog roboczy, może zostać zidentyfikowane na nazwę pliku; w przeciwnym razie należy określić pełną ścieżkę i nazwę pliku. Symbole wieloznaczne ("... \\\myfile.txt ") i nazwy udziału UNC ("\\\\\\katalogu \shared\\\myfile.txt ") są obsługiwane.  
  
 `flags` Parametru zapewnia dostawcę usługi Windows Sockets o dodatkowe informacje dotyczące transferu plików. Aby uzyskać więcej informacji na temat używania tego parametru, zobacz <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Ta metoda używa `TransmitFile` funkcja znaleziono w interfejsie API Windows Sockets 2. Aby uzyskać więcej informacji na temat `TransmitFile` funkcji i jej flag, można znaleźć w dokumentacji systemu Windows Sockets w bibliotece MSDN.  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> synchronicznie wysyła plik do hosta zdalnego określono w <xref:System.Net.Sockets.Socket.Connect%2A> lub <xref:System.Net.Sockets.Socket.Accept%2A> metody. <xref:System.Net.Sockets.Socket.SendFile%2A> może służyć dla obu tych połączeń i protokoły bez połączenia.  
  
 Jeśli używasz protokołu bez połączenia należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> przed wywołaniem tej metody; w przeciwnym razie <xref:System.Net.Sockets.Socket.SendFile%2A> zgłasza <xref:System.Net.Sockets.SocketException>. Jeśli używasz protokołu nawiązaniem połączenia, należy używać <xref:System.Net.Sockets.Socket.Connect%2A> w celu nawiązania połączenia zdalnego hosta lub użyj <xref:System.Net.Sockets.Socket.Accept%2A> akceptować połączenia przychodzące.  
  
 Jeśli używasz protokołu nawiązaniem połączenia, <xref:System.Net.Sockets.Socket.SendFile%2A> blokuje momentu wysłania całego pliku. W trybie nieblokujących <xref:System.Net.Sockets.Socket.SendFile%2A> może zakończyć się powodzeniem przed cały plik został wysłany. Nie ma żadnej gwarancji, który danych wysyłanych będzie widoczny w sieci, natychmiast. Aby zwiększyć wydajność sieci, źródłowy system może być opóźniona transmisji, dopóki nie są zbierane znaczną ilość danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendFile%2A> metody oznacza, że źródłowy system miał miejsca w buforze wysyłania danych w sieci.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy i łączy gniazda. Plik "test.txt" znajduje się w katalogu głównym komputera lokalnego. W tym przykładzie mamy utworzyć prebuffer i postbuffer danych i wysyłać je do zdalnego hosta z pliku. Wartość domyślna <xref:System.Net.Sockets.TransmitFileOptions> są używane.  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">System operacyjny nie jest systemu Windows NT lub nowszego.  \- lub - gniazda nie jest połączony z hostem zdalnym.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt nie jest w trybie blokowania i nie może zaakceptować tego wywołania synchronicznego.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik <paramref name="fileName" /> nie został znaleziony.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Obiekt ma być używany dla tej operacji asynchronicznej gniazda.</param>
        <summary>Wysyła kolekcji plików lub w pamięci buforów danych asynchronicznie do połączonych <see cref="T:System.Net.Sockets.Socket" /> obiektu.</summary>
        <returns>Zwraca <see langword="true" /> przypadku oczekujących operacji We/Wy. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenia w <paramref name="e" /> parametr zostanie wygenerowany, po zakończeniu operacji.  Zwraca <see langword="false" /> Jeśli synchronicznie wykonać operacji We/Wy. W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenia w <paramref name="e" /> parametr nie zostanie wygenerowany i <paramref name="e" /> przekazano obiekt jako parametr może być zbadana natychmiast po wywołaniu metody zwraca można pobrać wyniku operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Metoda jest używana do wysyłania buforów danych kolekcji plików lub w pamięci z hostem zdalnym. <xref:System.Net.Sockets.Socket> Już musi być podłączony do hosta zdalnego.  
  
 Jeśli <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> odwołuje się do pliku w katalogu roboczym, może zostać zidentyfikowane na nazwę pliku; w przeciwnym razie należy określić pełną ścieżkę i nazwę pliku. Są obsługiwane symbole wieloznaczne i nazwy udziału UNC. Jeśli plik nie zostanie znaleziony, <xref:System.IO.FileNotFoundException> jest generowany.  
  
 Ma być powiadamiany o zakończeniu, należy utworzyć metody wywołania zwrotnego, który implementuje EventHandler\<obiektu SocketAsyncEventArgs > delegować i Dołącz do wywołania zwrotnego <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> zdarzeń.  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> Właściwość `e` parametru zapewnia dostawcę usługi Windows Sockets o dodatkowe informacje dotyczące transferu plików. Aby uzyskać więcej informacji na temat używania tego parametru, zobacz <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Poniższe właściwości i zdarzeń w <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiektu są wymagane do pomyślnego wywołania tej metody:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwości do każdego obiektu stanu użytkownika potrzebne przed wywołaniem <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> metodę, tak, aby informacje pobieranie metody wywołania zwrotnego. Jeśli wywołanie zwrotne wymaga informacji więcej niż jeden obiekt, aby pomieścić inne wymagane informacje o stanie jako elementy członkowskie można tworzyć małych klasy.  
  
 Ta metoda korzysta z funkcji TransmitPackets znaleziono w interfejsie API Windows Sockets 2. Aby uzyskać więcej informacji o funkcji TransmitPackets i flag zobacz dokumentację systemu Windows Sockets w bibliotece MSDN.  
  
 Mimo że przeznaczonych dla połączeń protokołów <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> metody działa także dla protokołów bez połączenia, pod warunkiem, że pierwsze wywołanie <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodę ustanawiania domyślnego hosta zdalnego. Przy użyciu protokołów przesyłanie również należy się upewnić, że rozmiar pliku przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie są wysyłane i <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> zgłasza <xref:System.Net.Sockets.SocketException> wyjątku.  
  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Metody jest zoptymalizowany wybranego systemu operacyjnego, na którym jest używany. We wszystkich wersjach systemu Windows server <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> metody jest zoptymalizowany pod kątem wysokiej wydajności.  
  
 W wersjach klienckich systemu Windows <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> metody jest zoptymalizowany pod kątem minimalnej pamięci i użycia zasobów.  
  
 Użycie <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> oflagowane w <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> właściwość `e` parametru zapewnia wydajność znaczących korzyści. Jeśli inicjowanie wątku <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> wywołania metody jest używany w obliczeniach duże, jest to możliwe, chociaż jest to mało prawdopodobne, że APCs może uniemożliwić uruchomienie. Należy pamiętać, że występuje różnica między APCs jądra i trybu użytkownika. Uruchom APCs jądra, gdy wątek jest w stanie oczekiwania. Uruchamianie APCs trybu użytkownika, gdy wątek jest w stanie oczekiwania dla  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony w <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> nie znaleziono właściwości.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja gniazda zostało już w toku, używając <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiektu określonego w <paramref name="e" /> parametru.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP lub nowszy jest wymagany dla tej metody. Ten wyjątek ma miejsce, gdy <see cref="T:System.Net.Sockets.Socket" /> nie jest połączony z hostem zdalnym.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Przesyłanie <see cref="T:System.Net.Sockets.Socket" /> jest używana i plik wysyłany przekracza maksymalny rozmiar pakietu źródłowego transportu.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, która określa czas, po którym synchronicznego <see cref="Overload:System.Net.Sockets.Socket.Send" /> wywołanie zostanie limit czasu.</summary>
        <value>Wartość limitu czasu w milisekundach. Jeśli zostanie ustawiona właściwość z wartością z zakresu od 1 do 499, wartość zostanie zmieniony na 500. Wartość domyślna to 0, co wskazuje nieskończony limit czasu. Określanie -1 wskazuje także nieskończonego limitu czasu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta opcja ma zastosowanie do synchroniczne <xref:System.Net.Sockets.Socket.Send%2A> tylko wywołania. Po przekroczeniu limitu czasu <xref:System.Net.Sockets.Socket.Send%2A> metoda zgłosi <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.Socket.SendTimeout%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona dla operacji ustawienia jest mniejsza niż -1.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wysyła dane do określonego punktu końcowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> Reprezentujący miejsca docelowego dla danych.</param>
        <summary>Wysyła dane do określonego punktu końcowego.</summary>
        <returns>Liczba wysłanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W tym przeciążenia przesunięcia wartość domyślna to 0, liczba bajtów do wysłania domyślne do rozmiaru buforu `buffer` parametru i <xref:System.Net.Sockets.SocketFlags> wartość wartość domyślna to 0.  
  
 Jeśli używasz protokołu bez połączenia, nie należy ustanowić domyślnego hosta zdalnego z <xref:System.Net.Sockets.Socket.Connect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>. Należy to zrobić, jeśli zamierzasz wywołać <xref:System.Net.Sockets.Socket.Send%2A> metody. Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.Connect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` parametru spowoduje zastąpienie hosta zdalnego określoną wartość domyślną, dla którego tylko operacji wysyłania. Ponadto nie należy wywołać <xref:System.Net.Sockets.Socket.Bind%2A> metody, ponieważ źródłowy dostawca usługi przypisze najbardziej odpowiedni adres i port numer sieci lokalnej. Jeśli trzeba będzie zidentyfikować przypisaną sieci lokalnej adres i numer portu, możesz użyć <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwości po <xref:System.Net.Sockets.Socket.SendTo%2A> pomyślnym zakończeniu metody.  
  
 Mimo że przeznaczonych dla protokołów przesyłanie <xref:System.Net.Sockets.Socket.SendTo%2A> współdziała również z nawiązaniem połączenia protokołów. Jeśli używasz protokołu łączeniem nawiązania połączenia zdalnego hosta przez wywołanie metody <xref:System.Net.Sockets.Socket.Connect%2A> — metoda lub zaakceptuj przychodzących połączeń żądania przy użyciu <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli nie ustanowić lub zaakceptować połączenie hosta zdalnego <xref:System.Net.Sockets.Socket.SendTo%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Możesz także udostępnić domyślnego hosta zdalnego bez połączenia protokołu przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A> metody. W tych przypadkach <xref:System.Net.Sockets.Socket.SendTo%2A> zignoruje `remoteEP` parametr i tylko wysyłać dane do połączonych lub domyślnego hosta zdalnego.  
  
 Blokowanie sockets zablokuje dopóki nie są wysyłane do wszystkich bajtów w buforze. Ponieważ nieblokujących <xref:System.Net.Sockets.Socket> zakończeniu natychmiast go może nie wysyłać wszystkich bajtów `buffer`. Odpowiedzialność aplikacji, aby śledzić liczbę bajtów wysłanych i spróbuj ponownie wykonać operację, dopóki aplikacja wysyła wszystkie bajty `buffer`. Ponadto nie ma żadnej gwarancji, który danych wysyłanych będzie widoczny w sieci, natychmiast. Aby zwiększyć wydajność sieci, źródłowy system może być opóźniona transmisji, dopóki nie są zbierane znaczną ilość danych wychodzących. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendTo%2A> metody oznacza, że źródłowy system miał miejsca w buforze wysyłania danych w sieci.  
  
 Jeśli używasz protokołu bez połączenia w trybie blokowania <xref:System.Net.Sockets.Socket.SendTo%2A> zablokuje momentu wysłania datagram. Jeśli chcesz wysyłać dane do adresu emisji, należy najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> — metoda i gniazda zestaw opcji w celu <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Również należy się upewnić, że liczba bajtów wysłanych nie przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie zostaną wysłane i <xref:System.Net.Sockets.Socket.SendTo%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła wymiany datagramów na określony host zdalny.  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.  - lub - <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> Reprezentujący lokalizację docelową dla danych.</param>
        <summary>Wysyła dane do określonego punktu końcowego przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba wysłanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W tym przeciążenia przesunięcia wartość domyślna to 0, a liczba bajtów do wysłania domyślne do rozmiaru buforu `buffer`. Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketflags` parametru, dane są wysyłane, nie zostaną przesłane.  
  
 Jeśli używasz protokołu bez połączenia, nie należy ustanowić domyślnego hosta zdalnego z <xref:System.Net.Sockets.Socket.Connect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>. Należy to zrobić, jeśli zamierzasz wywołać <xref:System.Net.Sockets.Socket.Send%2A> metody. Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.Connect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` parametru spowoduje zastąpienie hosta zdalnego określoną wartość domyślną, dla którego tylko operacji wysyłania. Ponadto nie należy wywołać <xref:System.Net.Sockets.Socket.Bind%2A> metody, ponieważ źródłowy dostawca usługi przypisze najbardziej odpowiedni adres i port numer sieci lokalnej. Jeśli trzeba będzie zidentyfikować przypisaną sieci lokalnej adres i numer portu, możesz użyć <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwości po <xref:System.Net.Sockets.Socket.SendTo%2A> pomyślnym zakończeniu metody.  
  
 Mimo że przeznaczonych dla protokołów przesyłanie <xref:System.Net.Sockets.Socket.SendTo%2A> współdziała również z nawiązaniem połączenia protokołów. Jeśli używasz protokołu łączeniem nawiązania połączenia zdalnego hosta przez wywołanie metody <xref:System.Net.Sockets.Socket.Connect%2A> — metoda lub zaakceptuj przychodzących połączeń żądania przy użyciu <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli nie ustanowić lub zaakceptować połączenie hosta zdalnego <xref:System.Net.Sockets.Socket.SendTo%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Możesz także udostępnić domyślnego hosta zdalnego bez połączenia protokołu przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A> metody. W tych przypadkach <xref:System.Net.Sockets.Socket.SendTo%2A> zignoruje `remoteEP` parametr i tylko wysyłać dane do połączonych lub domyślnego hosta zdalnego.  
  
 Blokowanie sockets zablokuje do żądanego wszystkich bajtów `buffer` są wysyłane. Ponieważ nieblokujących <xref:System.Net.Sockets.Socket> zakończeniu natychmiast go może nie wysyłać wszystkich bajtów `buffer`. Odpowiedzialność aplikacji, aby śledzić liczbę bajtów wysłanych i spróbuj ponownie wykonać operację, dopóki aplikacja wysyła wszystkie bajty `buffer`. Ponadto nie ma żadnej gwarancji, który danych wysyłanych będzie widoczny w sieci, natychmiast. Aby zwiększyć wydajność sieci, źródłowy system może być opóźniona transmisji, dopóki znaczną ilość wyjściowego przerywaj dane są zbierane. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendTo%2A> metody oznacza, że źródłowy system miał miejsca w buforze wysyłania danych w sieci.  
  
 Jeśli używasz protokołu bez połączenia w trybie blokowania <xref:System.Net.Sockets.Socket.SendTo%2A> zablokuje momentu wysłania datagram. Jeśli chcesz wysyłać dane do adresu emisji, należy najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> — metoda i gniazda zestaw opcji w celu <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Również należy się upewnić, że liczba bajtów wysłanych nie przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie zostaną wysłane i <xref:System.Net.Sockets.Socket.SendTo%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła wymiany datagramów na określony host zdalny. <xref:System.Net.Sockets.SocketFlags> są przekazywane do <xref:System.Net.Sockets.Socket.SendTo%2A> metody.  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.  - lub - <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="size">Liczba bajtów do wysłania.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> Reprezentujący lokalizację docelową dla danych.</param>
        <summary>Wysyła określoną liczbę bajtów danych do określonego punktu końcowego przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba wysłanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W tym przeciążenia buforu przesunięcia wartość domyślna to 0. Jeśli określisz <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketflags` parametru, dane są wysyłane, nie zostaną przesłane.  
  
 Jeśli używasz protokołu bez połączenia, nie należy ustanowić domyślnego hosta zdalnego z <xref:System.Net.Sockets.Socket.Connect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>. Należy to zrobić, jeśli zamierzasz wywołać <xref:System.Net.Sockets.Socket.Send%2A> metody. Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.Connect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` parametru spowoduje zastąpienie hosta zdalnego określoną wartość domyślną, dla którego tylko operacji wysyłania. Ponadto nie należy wywołać <xref:System.Net.Sockets.Socket.Bind%2A> metody, ponieważ źródłowy dostawca usługi przypisze najbardziej odpowiedni adres i port numer sieci lokalnej. Jeśli trzeba będzie zidentyfikować przypisaną sieci lokalnej adres i numer portu, możesz użyć <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwości po <xref:System.Net.Sockets.Socket.SendTo%2A> pomyślnym zakończeniu metody.  
  
 Mimo że przeznaczonych dla protokołów przesyłanie <xref:System.Net.Sockets.Socket.SendTo%2A> współdziała również z nawiązaniem połączenia protokołów. Jeśli używasz protokołu łączeniem nawiązania połączenia zdalnego hosta przez wywołanie metody <xref:System.Net.Sockets.Socket.Connect%2A> — metoda lub zaakceptuj przychodzących połączeń żądania przy użyciu <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli nie ustanowić lub zaakceptować połączenie hosta zdalnego <xref:System.Net.Sockets.Socket.SendTo%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Możesz także udostępnić domyślnego hosta zdalnego bez połączenia protokołu przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A> metody. W tych przypadkach <xref:System.Net.Sockets.Socket.SendTo%2A> zignoruje `remoteEP` parametr i tylko wysyłać dane do połączonych lub domyślnego hosta zdalnego.  
  
 Blokowanie sockets zablokuje dopóki wysłaniem żądanej liczby bajtów. Ponieważ nieblokujących <xref:System.Net.Sockets.Socket> zakończeniu natychmiast go może nie wysyłać wszystkich bajtów w ramach jednej operacji. Jest odpowiedzialny za aplikacji, aby śledzić liczbę bajtów wysłanych i spróbuj ponownie wykonać operację, dopóki aplikacja wysyła żądanej liczby bajtów. Ponadto nie ma żadnej gwarancji, który danych wysyłanych będzie widoczny w sieci, natychmiast. Aby zwiększyć wydajność sieci, źródłowy system może być opóźniona transmisji, dopóki znaczną ilość wyjściowego przerywaj dane są zbierane. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendTo%2A> metody oznacza, że źródłowy system miał miejsca w buforze wysyłania danych w sieci.  
  
 Jeśli używasz protokołu bez połączenia w trybie blokowania <xref:System.Net.Sockets.Socket.SendTo%2A> zablokuje momentu wysłania datagram. Jeśli chcesz wysyłać dane do adresu emisji, należy najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> — metoda i gniazda zestaw opcji w celu <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Również należy się upewnić, że liczba bajtów wysłanych nie przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie zostaną wysłane i <xref:System.Net.Sockets.Socket.SendTo%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła wymiany datagramów na określony host zdalny. Rozmiar i <xref:System.Net.Sockets.SocketFlags> są przekazywane do <xref:System.Net.Sockets.Socket.SendTo%2A> metody.  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.  - lub - <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Określony <paramref name="size" /> przekracza rozmiar <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica typu <see cref="T:System.Byte" /> zawierający dane do wysłania.</param>
        <param name="offset">Pozycja w buforze danych, w którym należy rozpocząć wysyłanie danych.</param>
        <param name="size">Liczba bajtów do wysłania.</param>
        <param name="socketFlags">Bitowe połączenie <see cref="T:System.Net.Sockets.SocketFlags" /> wartości.</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> Reprezentujący lokalizację docelową dla danych.</param>
        <summary>Wysyła określoną liczbę bajtów danych do określonego punktu końcowego, zaczynając od określonej lokalizacji w buforze, a przy użyciu określonego <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Liczba wysłanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W tej przeciążenia, jeśli określono <xref:System.Net.Sockets.SocketFlags.DontRoute> Flaga jako `socketflags` parametru, dane są wysyłane, nie zostaną przesłane.  
  
 Jeśli używasz protokołu bez połączenia, nie należy ustanowić domyślnego hosta zdalnego z <xref:System.Net.Sockets.Socket.Connect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>. Należy to zrobić, jeśli zamierzasz wywołać <xref:System.Net.Sockets.Socket.Send%2A> metody. Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.Connect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` parametru spowoduje zastąpienie hosta zdalnego określoną wartość domyślną, dla którego tylko operacji wysyłania. Ponadto nie należy wywołać <xref:System.Net.Sockets.Socket.Bind%2A> metody, ponieważ źródłowy dostawca usługi przypisze najbardziej odpowiedni adres i port numer sieci lokalnej. Jeśli trzeba będzie zidentyfikować przypisaną sieci lokalnej adres i numer portu, możesz użyć <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwości po <xref:System.Net.Sockets.Socket.SendTo%2A> pomyślnym zakończeniu metody.  
  
 Mimo że przeznaczonych dla protokołów przesyłanie <xref:System.Net.Sockets.Socket.SendTo%2A> współdziała również z nawiązaniem połączenia protokołów. Jeśli używasz protokołu łączeniem nawiązania połączenia zdalnego hosta przez wywołanie metody <xref:System.Net.Sockets.Socket.Connect%2A> — metoda lub zaakceptuj przychodzących połączeń żądania przy użyciu <xref:System.Net.Sockets.Socket.Accept%2A> metody. Jeśli nie ustanowić lub zaakceptować połączenie hosta zdalnego <xref:System.Net.Sockets.Socket.SendTo%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Możesz także udostępnić domyślnego hosta zdalnego bez połączenia protokołu przed wywołaniem <xref:System.Net.Sockets.Socket.SendTo%2A> metody. W tych przypadkach <xref:System.Net.Sockets.Socket.SendTo%2A> zignoruje `remoteEP` parametr i tylko wysyłać dane do połączonych lub domyślnego hosta zdalnego.  
  
 Blokowanie sockets zablokuje dopóki wysłaniem żądanej liczby bajtów. Ponieważ nieblokujące <xref:System.Net.Sockets.Socket> zakończeniu natychmiast go może nie wysyłać wszystkich bajtów w ramach jednej operacji. Jest odpowiedzialny za Twoje aplikacje do śledzenia liczba bajtów wysłanych i spróbuj ponownie wykonać operację, dopóki aplikacja wysyła żądanej liczby bajtów. Ponadto nie ma żadnej gwarancji, który danych wysyłanych będzie widoczny w sieci, natychmiast. Aby zwiększyć wydajność sieci, źródłowy system może być opóźniona transmisji, dopóki znaczną ilość wyjściowego przerywaj dane są zbierane. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendTo%2A> metody oznacza, że źródłowy system miał miejsca w buforze wysyłania danych w sieci.  
  
 Jeśli używasz protokołu bez połączenia w trybie blokowania <xref:System.Net.Sockets.Socket.SendTo%2A> zablokuje momentu wysłania datagram. Jeśli chcesz wysyłać dane do adresu emisji, należy najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> — metoda i gniazda zestaw opcji w celu <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Również należy się upewnić, że rozmiar przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie zostaną wysłane i <xref:System.Net.Sockets.Socket.SendTo%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła wymiany datagramów na określony host zdalny. Przesunięcie, rozmiar, a <xref:System.Net.Sockets.SocketFlags> są przekazywane do <xref:System.Net.Sockets.Socket.SendTo%2A> metody.  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.  - lub - <paramref name="remoteEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż 0.  - lub - <paramref name="offset" /> jest większa niż długość <paramref name="buffer" />.  - lub - <paramref name="size" /> jest mniejszy niż 0.  - lub - <paramref name="size" /> jest większa niż długość <paramref name="buffer" /> minus wartość <paramref name="offset" /> parametru.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> nie jest prawidłową kombinację wartości.  - lub - wystąpi błąd systemu operacyjnego podczas uzyskiwania dostępu do <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący na stosie wywołań nie ma wymaganych uprawnień.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Obiekt ma być używany dla tej operacji asynchronicznej gniazda.</param>
        <summary>Wysyła dane asynchronicznie do określonego hosta zdalnego.</summary>
        <returns>Zwraca <see langword="true" /> przypadku oczekujących operacji We/Wy. <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Zdarzenia w <paramref name="e" /> parametr zostanie wygenerowany, po zakończeniu operacji.  Zwraca <see langword="false" /> Jeśli synchronicznie wykonać operacji We/Wy. W takim przypadku <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> zdarzenia w <paramref name="e" /> parametr nie zostanie wygenerowany i <paramref name="e" /> przekazano obiekt jako parametr może być zbadana natychmiast po wywołaniu metody zwraca można pobrać wyniku operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendToAsync%2A> Metody rozpoczyna się operacja asynchronicznego wysyłania do hosta zdalnego określono w <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> właściwość `e` parametru. Wywoływanie <xref:System.Net.Sockets.Socket.SendToAsync%2A> metody daje możliwość wysyłania danych w ramach oddzielnego wykonanie wątku. Mimo że ta metoda jest przeznaczona dla protokołów przesyłanie <xref:System.Net.Sockets.Socket.SendToAsync%2A> współpracuje z protokołami przesyłanie i nawiązaniem połączenia.  
  
 Ma być powiadamiany o zakończeniu, należy utworzyć metody wywołania zwrotnego, który implementuje EventHandler\<obiektu SocketAsyncEventArgs > delegować i Dołącz do wywołania zwrotnego <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> zdarzeń.  
  
 Poniższe właściwości i zdarzeń w <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> obiektu są wymagane do pomyślnego wywołania tej metody:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Obiekt wywołujący może ustawić <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> właściwości do każdego obiektu stanu użytkownika potrzebne przed wywołaniem <xref:System.Net.Sockets.Socket.SendToAsync%2A> metodę, tak, aby informacje pobieranie metody wywołania zwrotnego. Jeśli wywołanie zwrotne wymaga informacji więcej niż jeden obiekt, aby pomieścić inne wymagane informacje o stanie jako elementy członkowskie można tworzyć małych klasy.  
  
 Jeśli korzystasz z nawiązaniem połączenia protokołu, należy najpierw wywołać <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metody. W przeciwnym razie <xref:System.Net.Sockets.Socket.SendToAsync%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Korzystając z nawiązaniem połączenia protokołu, <xref:System.Net.Sockets.Socket.SendToAsync%2A> zignoruje metody <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> właściwości i wysyłania danych do <xref:System.Net.EndPoint?displayProperty=nameWithType> określonych w <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A> , lub <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metody.  
  
 Jeśli używasz protokołu bez połączenia, nie należy ustanowić domyślnego hosta zdalnego z <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.SendToAsync%2A>. Należy to zrobić, jeśli zamierzasz wywołać <xref:System.Net.Sockets.Socket.BeginSend%2A> lub <xref:System.Net.Sockets.Socket.SendAsync%2A> metody. Jeśli zostanie wywołana <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, lub <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metoda przed wywołaniem <xref:System.Net.Sockets.Socket.SendToAsync%2A>, <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> właściwość spowoduje zastąpienie hosta zdalnego określoną wartość domyślną, dla którego tylko operacji wysyłania. Ponadto nie należy wywołać <xref:System.Net.Sockets.Socket.Bind%2A> metody. W takim przypadku podstawowego dostawcy usług przypisze najbardziej odpowiednia sieci lokalnej IP adres i numer portu. Numer portu równą zero, należy użyć, jeśli do wyboru portu wolne podstawowego dostawcy usług. Jeśli trzeba będzie zidentyfikować numer adres i port IP przypisanej sieci lokalnej, możesz użyć <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> właściwości po <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> zdarzenie jest sygnalizowane i skojarzone obiekty delegowane są nazywane.  
  
 Jeśli chcesz wysyłać dane do adresu emisji, należy najpierw wywołać <xref:System.Net.Sockets.Socket.SetSocketOption%2A> — metoda i gniazda zestaw opcji dla <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> na wartość true. Również należy się upewnić, że rozmiar buforu przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług. Jeśli tak, datagram nie zostaną wysłane i <xref:System.Net.Sockets.Socket.SendToAsync%2A> zgłosi <xref:System.Net.Sockets.SocketException>.  
  
 Jeśli określono flagę DontRoute <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> właściwości, dane są wysyłane, nie zostaną przesłane.  
  
 Dla gniazda do przesyłania wiadomości należy uważać aby nie przekracza maksymalny rozmiar wiadomości podstawowej transportu. Jeśli rozmiar buforu przekracza maksymalny rozmiar pakietu podstawowego dostawcy usług, datagram nie są wysyłane i <xref:System.Net.Sockets.Socket.SendToAsync%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Pomyślne zakończenie <xref:System.Net.Sockets.Socket.SendToAsync%2A> — metoda nie wskazuje, że dane zostało pomyślnie dostarczone.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> Nie może mieć wartości null.</exception>
        <exception cref="T:System.InvalidOperationException">Operacja gniazda zostało już w toku, używając <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> obiektu określonego w <paramref name="e" /> parametru.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP lub nowszy jest wymagany dla tej metody.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Protokół określony jest zorientowany na połączenie, ale <see cref="T:System.Net.Sockets.Socket" /> nie jest jeszcze podłączony.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" />
      </Parameters>
      <Docs>
        <param name="level">Poziom ochrony IP można ustawić dla tego gniazda.</param>
        <summary>Ustaw poziom ochrony IP dla gniazda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> Metoda umożliwia ograniczenie gniazda do nasłuchiwania określonego zakresu, takie jak adresy o tej samej link lokalnego lub lokacji lokalnej prefiks IPv6 lub adres IP. Ta opcja gniazda umożliwia aplikacjom ograniczają dostęp do gniazda IPv6 lub adres IP. Takie ograniczenia Włącz aplikacji uruchomionej w prywatnej sieci LAN po prostu i niezawodnie zabezpieczyć się przed atakami zewnętrznych. Ta opcja gniazda można również usunąć ograniczenia dostępu, jeśli `level` ustawiono parametr <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>. Ta opcja gniazda rozszerzenie czy zawęża zakres nasłuchiwania gniazda, włączanie nieograniczony dostęp z publicznych i prywatnych użytkowników, gdy jest to konieczne, lub ograniczać dostęp tylko do tej samej lokacji, zgodnie z wymaganiami.  
  
 Ta opcja gniazda został zdefiniowany poziomów ochrony, określona w <xref:System.Net.Sockets.IPProtectionLevel> wyliczenia.  
  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> Metoda służy do włączania lub wyłączania przechodzenie adresów sieciowych (NAT) dla <xref:System.Net.Sockets.Socket> wystąpienia. Przechodzenie translatora adresów Sieciowych mogą być dostarczane za pomocą protokołu Teredo, 6to4 lub tunelu protokołu ISATAP.  
  
 Gdy `level` ustawiono parametr <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, lub <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, jawnie wyłącza przechodzenia translatora adresów Sieciowych dla <xref:System.Net.Sockets.Socket> wystąpienia.  
  
 Gdy `level` ustawiono parametr <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, może to umożliwić Przechodzenie translatora adresów Sieciowych dla <xref:System.Net.Sockets.Socket> w zależności od reguły zapory w miejscu, w systemie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="level" /> Parametr nie może być <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />. Poziom ochrony IP nie można ustawić nieokreślony.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Net.Sockets.AddressFamily" /> Gniazda musi być równa albo <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zestawy <see cref="T:System.Net.Sockets.Socket" /> opcji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Jeden z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</param>
        <param name="optionName">Jeden z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</param>
        <param name="optionValue">Wartość opcji reprezentowane jako <see cref="T:System.Boolean" />.</param>
        <summary>Ustawia określony <see cref="T:System.Net.Sockets.Socket" /> opcji do określonego <see cref="T:System.Boolean" /> wartość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> opcje określają zachowanie bieżącego <xref:System.Net.Sockets.Socket>. Ustaw `optionValue` do `true` Aby włączyć opcję, lub do `false` wyłączyć opcję.  
  
 <xref:System.Net.Sockets.Socket> opcje są pogrupowane według poziomu obsługi protokołu.  
  
 Poniżej wymieniono różne <xref:System.Net.Sockets.Socket> opcje, które można ustawić za pomocą tego przeciążenia. Te opcje są pogrupowane według odpowiednie <xref:System.Net.Sockets.SocketOptionLevel> wartość. Jeśli planujesz dowolną z tych opcji, należy użyć odpowiedniej <xref:System.Net.Sockets.SocketOptionLevel> wartość `optionLevel` parametru. Należy określić opcję, aby ustawić w `optionName` parametru. Jeśli chcesz uzyskać bieżącą wartość opcji na liście, użyj <xref:System.Net.Sockets.Socket.GetSocketOption%2A> metody.  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 Aby uzyskać więcej informacji na temat tych opcji, zapoznaj się <xref:System.Net.Sockets.SocketOptionName> wyliczenia.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException> wyjątek, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera gniazda i umożliwia `DontLinger` i `OutOfBandInline` gniazda opcje.  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Obiekt został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Jeden z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</param>
        <param name="optionName">Jeden z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</param>
        <param name="optionValue">Tablica typu <see cref="T:System.Byte" /> reprezentujący wartość opcji.</param>
        <summary>Ustawia określony <see cref="T:System.Net.Sockets.Socket" /> opcji z podaną wartością reprezentowane jako tablicę bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> opcje określają zachowanie bieżącego <xref:System.Net.Sockets.Socket>. Użyj tego przeciążenia, aby ustawić te <xref:System.Net.Sockets.Socket> opcje, które wymagają tablicę bajtów jako wartość opcji.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy kod przykładzie <xref:System.Net.Sockets.LingerOption> i <xref:System.Net.Sockets.Socket.Send%2A> wartości limitu czasu.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Jeden z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</param>
        <param name="optionName">Jeden z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</param>
        <param name="optionValue">Wartość opcji.</param>
        <summary>Ustawia określony <see cref="T:System.Net.Sockets.Socket" /> opcji do określonej liczby całkowitej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> opcje określają zachowanie bieżącego <xref:System.Net.Sockets.Socket>. Dla opcji z <xref:System.Boolean> typ danych, określ wartość różną od zera, aby włączyć opcję, a wartość zerową wyłączyć opcję. Dla opcji typu Liczba całkowita określ odpowiednią wartość. <xref:System.Net.Sockets.Socket> opcje są pogrupowane według poziomu obsługi protokołu.  
  
 Poniżej wymieniono różne <xref:System.Net.Sockets.Socket> opcje, które można ustawić za pomocą tego przeciążenia. Te opcje są pogrupowane według odpowiednie <xref:System.Net.Sockets.SocketOptionLevel>. Jeśli planujesz dowolną z tych opcji, należy użyć odpowiedniej <xref:System.Net.Sockets.SocketOptionLevel> dla `optionLevel` parametru. Należy określić opcję, aby ustawić w `optionName` parametru. Jeśli chcesz uzyskać bieżącą wartość opcji na liście, użyj <xref:System.Net.Sockets.Socket.GetSocketOption%2A> metody.  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> Opcje, które można ustawić za pomocą tego przeciążenia.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 Aby uzyskać więcej informacji na temat tych opcji, zapoznaj się <xref:System.Net.Sockets.SocketOptionName> wyliczenia.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy kod przykładzie <xref:System.Net.Sockets.LingerOption> i <xref:System.Net.Sockets.Socket.Send%2A> wartości limitu czasu.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Jeden z <see cref="T:System.Net.Sockets.SocketOptionLevel" /> wartości.</param>
        <param name="optionName">Jeden z <see cref="T:System.Net.Sockets.SocketOptionName" /> wartości.</param>
        <param name="optionValue">A <see cref="T:System.Net.Sockets.LingerOption" /> lub <see cref="T:System.Net.Sockets.MulticastOption" /> zawierający wartość opcji.</param>
        <summary>Ustawia określony <see cref="T:System.Net.Sockets.Socket" /> opcji z podaną wartością reprezentowany przez obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> opcje określają zachowanie bieżącego <xref:System.Net.Sockets.Socket>. To przeciążenie umożliwia ustawienie <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, i <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> opcje. Aby uzyskać <xref:System.Net.Sockets.SocketOptionName.Linger> , należy użyć <xref:System.Net.Sockets.Socket> dla `optionLevel` parametru. Aby uzyskać <xref:System.Net.Sockets.SocketOptionName.AddMembership> i <xref:System.Net.Sockets.SocketOptionName.DropMembership>, użyj <xref:System.Net.Sockets.SocketOptionLevel.IP>. Jeśli chcesz uzyskać bieżącą wartość opcji wymienionych powyżej, użyj <xref:System.Net.Sockets.Socket.GetSocketOption%2A> metody.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
   
  
## Examples  
 Poniższy kod przykładzie <xref:System.Net.Sockets.LingerOption> i <xref:System.Net.Sockets.Socket.Send%2A> wartości limitu czasu.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="optionValue" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">Jeden z <see cref="T:System.Net.Sockets.SocketShutdown" /> wartości, które określa operację, których nie będzie możliwe.</param>
        <summary>Wyłącza wysyła i odbiera na <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystając z nawiązaniem połączenia <xref:System.Net.Sockets.Socket>, zawsze wywołać <xref:System.Net.Sockets.Socket.Shutdown%2A> metoda przed zamknięciem <xref:System.Net.Sockets.Socket>. Dzięki temu, że wszystkie dane są wysyłane i odbierane na połączone gniazdo, przed jego zamknięciem.  
  
 Wywołanie <xref:System.Net.Sockets.Socket.Close%2A> metody, aby zwolnić wszystkie zarządzane i niezarządzane zasoby skojarzone z <xref:System.Net.Sockets.Socket>. Nie należy próbować użyć ponownie <xref:System.Net.Sockets.Socket> po zamknięciu.  
  
 W poniższej tabeli przedstawiono <xref:System.Net.Sockets.SocketShutdown> wartości wyliczenia, które są prawidłowe dla `how` parametru.  
  
|Wartość|Opis|  
|-----------|-----------------|  
|Wyślij|Wyłącz wysyłanie na tym <xref:System.Net.Sockets.Socket>.|  
|Odbieranie|Wyłączyć odbieranie na tym <xref:System.Net.Sockets.Socket>.|  
|Zarówno|Wyłącz zarówno wysyłanie i odbieranie w to <xref:System.Net.Sockets.Socket>.|  
  
 Ustawienie `how` do <xref:System.Net.Sockets.SocketShutdown.Send> Określa, że kolejnych wywołań <xref:System.Net.Sockets.Socket.Send%2A> są niedozwolone. Jeśli używasz przesyłanie <xref:System.Net.Sockets.Socket>, określania <xref:System.Net.Sockets.SocketShutdown.Send> nie odniesie żadnego skutku.  
  
 Ustawienie `how` do <xref:System.Net.Sockets.SocketShutdown.Receive> Określa, że kolejnych wywołań <xref:System.Net.Sockets.Socket.Receive%2A> są niedozwolone. To nie ma wpływu na niższych warstwach protokołu. Jeśli używasz protokołu nawiązaniem połączenia, połączenie jest przerywane, jeśli istnieje jeden z następujących warunków po wywołaniu <xref:System.Net.Sockets.Socket.Shutdown%2A> :  
  
-   Dane są w buforze przychodzącego sieci oczekiwania do odebrania.  
  
-   Odebrano więcej danych.  
  
 Jeśli używasz protokołu przesyłanie datagramy są akceptowane i umieszczonych w kolejce. Jednak jeśli brak miejsca w buforze jest dostępna w dodatkowych datagramy przychodzące, zostaną one odrzucone i błąd nie zostanie zwrócony do nadawcy. Przy użyciu <xref:System.Net.Sockets.Socket.Shutdown%2A> na przesyłanie <xref:System.Net.Sockets.Socket> nie jest zalecane.  
  
 Ustawienie `how` do <xref:System.Net.Sockets.SocketShutdown.Both> wyłącza zarówno wysyła i odbiera zgodnie z powyższym opisem.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException> podczas wywoływania metody <xref:System.Net.Sockets.Socket.Shutdown%2A> metody, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.Sockets.Socket.Shutdown%2A> wyłączyć <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Jeden z <see cref="T:System.Net.Sockets.SocketType" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SocketType%2A> jest tylko do odczytu i jest ustawiana w przypadku <xref:System.Net.Sockets.Socket> jest tworzony.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, i <xref:System.Net.Sockets.ProtocolType> do konsoli.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy obsługa protokołu IPv4 jest dostępna i włączona na bieżącym hoście.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący host obsługuje protokół IPv4; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 System operacyjny może obsługiwać protokoły IPv4 i IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy platforma obsługuje protokół IPv6 dla niektórych przestarzałych <see cref="T:System.Net.Dns" /> elementów członkowskich.</summary>
        <value>
          <see langword="true" /> Jeśli w ramach obsługuje protokół IPv6 dla niektórych przestarzałe <see cref="T:System.Net.Dns" /> metod; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 System operacyjny może obsługiwać protokoły IPv4 i IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą wartość czasu wygaśnięcia (TTL) protokołu internetowego (IP) pakietów wysłanych przez <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Wartość TTL.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość TTL wskazuje maksymalną liczbę routery pakietu można przechodzić między nimi przed routera odrzuca pakiet i kontroli protokołu ICMP (Internet Message) "Przekroczono TTL" nadawcy jest zwracany komunikat o błędzie.  
  
 Wartość TTL może mieć ustawioną wartość z zakresu od 0 do 255. Gdy ta właściwość nie jest ustawiona, domyślna wartość TTL gniazda wynosi 32.  
  
 Ustawienie tej właściwości na gnieździe Transmission Control Protocol (TCP) jest ignorowana przez stos TCP/IP, jeśli udane połączenie zostało nawiązane przy użyciu gniazda.  
  
 Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod odwołuje się do wersji Windows Sockets 2 dokumentacji kodów błędów interfejsu API w bibliotece MSDN szczegółowy opis błędu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.Socket.Ttl%2A> właściwości.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Nie można ustawić wartości TTL liczbą ujemną.</exception>
        <exception cref="T:System.NotSupportedException">Tej właściwości można ustawić tylko dla gniazda w <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> rodziny.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda. Ten błąd jest także zwracany, gdy nastąpiła próba ustawioną na wartość większą niż 255 TTL.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy gniazda należy używać tylko tryb pokrywający się we/wy.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.Socket" /> używa tylko pokrywający się we/wy; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest ustawiana `true` dla <xref:System.Net.Sockets.Socket> zamierzasz wywołać <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>. W przeciwnym razie platformę może przypisać portu zakończenia do gniazda, które mogłyby uniemożliwić korzystanie z <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Gniazda został powiązany z portem ukończenia.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
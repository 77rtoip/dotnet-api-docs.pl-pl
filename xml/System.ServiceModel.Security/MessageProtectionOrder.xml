<Type Name="MessageProtectionOrder" FullName="System.ServiceModel.Security.MessageProtectionOrder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="47b28b0fb20f3ab058671799bffbb846577fd307" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36612795" />
  </Metadata>
  <TypeSignature Language="C#" Value="public enum MessageProtectionOrder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed MessageProtectionOrder extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Security.MessageProtectionOrder" />
  <TypeSignature Language="VB.NET" Value="Public Enum MessageProtectionOrder" />
  <TypeSignature Language="C++ CLI" Value="public enum class MessageProtectionOrder" />
  <TypeSignature Language="F#" Value="type MessageProtectionOrder = " />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Docs>
    <summary>Określa kolejność operacji, które chronić wiadomości.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To wyliczenie jest używany z <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement.MessageProtectionOrder%2A?displayProperty=nameWithType> właściwość <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement> i <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.MessageProtectionOrder%2A?displayProperty=nameWithType> właściwość <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement> klasy.  
  
 Jeśli komunikat jest narażony na atak szyfrowanego (na przykład, jeśli komunikat jest krótka lub brakuje entropii), należy użyć opcji SignBeforeEncryptAndEncryptSignature lub EncryptBeforeSign. (*Entropii* jest losowe dane dostarczone przez serwer i klienta i jest używany do tworzenia klucza wspólnego szyfrowania i odszyfrowywania danych.)  
  
## <a name="what-is-ordered"></a>Co to jest uporządkowana?  
 Usługi WCF oferuje trzy różnych poziomów ochrony określające, jak komunikaty są chronione przy użyciu zabezpieczeń wiadomości protokołu SOAP. Wartość domyślna to SignBeforeEncryptAndEncryptSignature. To ustawienie najpierw podpisuje komunikat, szyfruje treść komunikatu i następnie szyfruje podpis XML. Zmniejsza to prawdopodobieństwo kryptograficznych guessing ataku podpisu.  
  
 Jednak przy użyciu domyślnego ma wpływ na wydajność. W efekcie jest wadą wydajności, aby zwiększyć bezpieczeństwo. Szyfrowanie podpis może obniżyć wydajność od 40 procent 10. Jeśli zawartość danych komunikatu jest o niskiej wartości, i zwiększa się przepływności wydajności, użyj SignBeforeEncrypt. To ustawienie, skrót sygnatura są wysyłane w postaci zwykłego tekstu, a w związku z tym komunikacie jest bardziej narażony na wynik i sprawdź ataków na niski entropii.  
  
## <a name="custom-bindings-only"></a>Tylko powiązania niestandardowe  
 Aby zmienić `MessageProtectionOrder` właściwości wymaga utworzenia powiązania niestandardowego zabezpieczeń. Aby uzyskać więcej informacji o tworzeniu niestandardowych powiązań, zobacz [powiązania Creating User-Defined](~/docs/framework/wcf/extending/creating-user-defined-bindings.md). Aby uzyskać więcej informacji na temat tworzenia niestandardowego powiązania dla trybu uwierzytelniania określonych zobacz [porady: Tworzenie elementu SecurityBindingElement dla trybu uwierzytelniania określone](~/docs/framework/wcf/feature-details/how-to-create-a-securitybindingelement-for-a-specified-authentication-mode.md).  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement> elementu i ustawia jej <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.MessageProtectionOrder%2A> SignBeforeEncrypt dla właściwości.  
  
 [!code-csharp[c_CustomBinding#3](~/samples/snippets/csharp/VS_Snippets_CFX/c_custombinding/cs/c_custombinding.cs#3)]
 [!code-vb[c_CustomBinding#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/c_custombinding/vb/source.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceModel.Security.MessageProtectionOrder" />
    <altmember cref="T:System.ServiceModel.Channels.AsymmetricSecurityBindingElement" />
    <altmember cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" />
  </Docs>
  <Members>
    <Member MemberName="EncryptBeforeSign">
      <MemberSignature Language="C#" Value="EncryptBeforeSign" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.ServiceModel.Security.MessageProtectionOrder EncryptBeforeSign = int32(2)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceModel.Security.MessageProtectionOrder.EncryptBeforeSign" />
      <MemberSignature Language="VB.NET" Value="EncryptBeforeSign" />
      <MemberSignature Language="C++ CLI" Value="EncryptBeforeSign" />
      <MemberSignature Language="F#" Value="EncryptBeforeSign = 2" Usage="System.ServiceModel.Security.MessageProtectionOrder.EncryptBeforeSign" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Security.MessageProtectionOrder</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Określa, że komunikatu protokołu SOAP są szyfrowane przed wygenerowaniem podpisu cyfrowego dla komunikatu SOAP.</summary>
      </Docs>
    </Member>
    <Member MemberName="SignBeforeEncrypt">
      <MemberSignature Language="C#" Value="SignBeforeEncrypt" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.ServiceModel.Security.MessageProtectionOrder SignBeforeEncrypt = int32(0)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceModel.Security.MessageProtectionOrder.SignBeforeEncrypt" />
      <MemberSignature Language="VB.NET" Value="SignBeforeEncrypt" />
      <MemberSignature Language="C++ CLI" Value="SignBeforeEncrypt" />
      <MemberSignature Language="F#" Value="SignBeforeEncrypt = 0" Usage="System.ServiceModel.Security.MessageProtectionOrder.SignBeforeEncrypt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Security.MessageProtectionOrder</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>Określa, że podpis cyfrowy jest generowany dla komunikatu protokołu SOAP, zanim jakiejkolwiek jego części komunikatu protokołu SOAP jest zaszyfrowany, ale nie jest zaszyfrowany podpisu cyfrowego.</summary>
      </Docs>
    </Member>
    <Member MemberName="SignBeforeEncryptAndEncryptSignature">
      <MemberSignature Language="C#" Value="SignBeforeEncryptAndEncryptSignature" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.ServiceModel.Security.MessageProtectionOrder SignBeforeEncryptAndEncryptSignature = int32(1)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceModel.Security.MessageProtectionOrder.SignBeforeEncryptAndEncryptSignature" />
      <MemberSignature Language="VB.NET" Value="SignBeforeEncryptAndEncryptSignature" />
      <MemberSignature Language="C++ CLI" Value="SignBeforeEncryptAndEncryptSignature" />
      <MemberSignature Language="F#" Value="SignBeforeEncryptAndEncryptSignature = 1" Usage="System.ServiceModel.Security.MessageProtectionOrder.SignBeforeEncryptAndEncryptSignature" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Security.MessageProtectionOrder</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary>Określa, że podpis cyfrowy jest generowany dla komunikatu protokołu SOAP, zanim jakiejkolwiek jego części komunikatu protokołu SOAP są szyfrowane i podpis cyfrowy jest zaszyfrowany.</summary>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="HttpDigestClientCredential" FullName="System.ServiceModel.Security.HttpDigestClientCredential">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8740955d333e0ef62ee82598954a9f26acbeb560" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36613208" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpDigestClientCredential" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpDigestClientCredential extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Security.HttpDigestClientCredential" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpDigestClientCredential" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpDigestClientCredential sealed" />
  <TypeSignature Language="F#" Value="type HttpDigestClientCredential = class" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Używany do uwierzytelniania szyfrowanego klientów HTTP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uwierzytelnianie szyfrowane sprawdza, czy obu stron do komunikacji znać wspólny klucz tajny (hasło). Uwierzytelnianie jest wykonywane bez wysyłania hasła niezabezpieczona. Uwierzytelnianie szyfrowane jest oparta na modelu odpowiedź na żądanie. Wyzwania schemat szyfrowane przy użyciu nonce ("numer używany po") wartość. Odpowiedź musi zawierać nazwę użytkownika, hasło nonce wartość, metoda HTTP i żądanego identyfikatora URI sumy kontrolnej.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AllowedImpersonationLevel">
      <MemberSignature Language="C#" Value="public System.Security.Principal.TokenImpersonationLevel AllowedImpersonationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Principal.TokenImpersonationLevel AllowedImpersonationLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Security.HttpDigestClientCredential.AllowedImpersonationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowedImpersonationLevel As TokenImpersonationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::TokenImpersonationLevel AllowedImpersonationLevel { System::Security::Principal::TokenImpersonationLevel get(); void set(System::Security::Principal::TokenImpersonationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.AllowedImpersonationLevel : System.Security.Principal.TokenImpersonationLevel with get, set" Usage="System.ServiceModel.Security.HttpDigestClientCredential.AllowedImpersonationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.TokenImpersonationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia poziom personifikacji klienta umożliwia z podanych poświadczeń klienta.</summary>
        <value>
          <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> Czy klient przyznaje serwera w ramach uwierzytelniania HTTP digest.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dozwolone wartości:  
  
 <xref:System.Security.Principal.TokenImpersonationLevel.Delegation>,  
  
 <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, a  
  
 <xref:System.Security.Principal.TokenImpersonationLevel.Impersonation>.  
  
 Z powodu ograniczeń uwierzytelniania szyfrowanego, gdy klient korzysta z poświadczeń innych niż domyślne, tylko `Impersonation` i `Delegation` dozwolona liczba poziomów to.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób ustawić tę właściwość.  
  
 [!code-csharp[S_UE_HttpDigestClientCredential#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_httpdigestclientcredential/cs/source.cs#1)]
 [!code-vb[S_UE_HttpDigestClientCredential#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_httpdigestclientcredential/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientCredential">
      <MemberSignature Language="C#" Value="public System.Net.NetworkCredential ClientCredential { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.NetworkCredential ClientCredential" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Security.HttpDigestClientCredential.ClientCredential" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCredential As NetworkCredential" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::NetworkCredential ^ ClientCredential { System::Net::NetworkCredential ^ get(); void set(System::Net::NetworkCredential ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCredential : System.Net.NetworkCredential with get, set" Usage="System.ServiceModel.Security.HttpDigestClientCredential.ClientCredential" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.NetworkCredential</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia poświadczenia sieciowe służący do uwierzytelniania szyfrowanego.</summary>
        <value>
          <see cref="T:System.Net.NetworkCredential" /> Służący do uwierzytelniania szyfrowanego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie zostanie określony, będzie można użyć domyślnych poświadczeń wątku.  
  
   
  
## Examples  
 W poniższych przykładach kodu przedstawiają sposób uwierzytelniania klienta jako inny podmiot zabezpieczeń.  
  
 Jak zmienić właściwości wystąpienia jest <xref:System.Net.NetworkCredential> klasy, która jest zwracana przez tę właściwość.  
  
 [!code-csharp[S_UE_HttpDigestClientCredential#2](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_httpdigestclientcredential/cs/source.cs#2)]  
  
 A Oto jak utworzyć nowe wystąpienie klasy <xref:System.Net.NetworkCredential> klasy i przypisz je do tej właściwości.  
  
 [!code-csharp[S_UE_HttpDigestClientCredential#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_httpdigestclientcredential/cs/source.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="HttpDigestClientCredential" FullName="System.ServiceModel.Security.HttpDigestClientCredential">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6523b6b95dfab46c208ff494d08b86b2deba2198" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39865819" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpDigestClientCredential" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpDigestClientCredential extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Security.HttpDigestClientCredential" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpDigestClientCredential" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpDigestClientCredential sealed" />
  <TypeSignature Language="F#" Value="type HttpDigestClientCredential = class" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Używany do uwierzytelniania szyfrowanego klientów HTTP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uwierzytelnianie szyfrowane weryfikuje, że obie strony do komunikacji wiedzą, Wspólny klucz tajny (hasło). Uwierzytelnianie jest wykonywane bez wysyłania hasła niezaszyfrowane. Uwierzytelnianie szyfrowane jest oparty na modelu odpowiedź na żądanie. Wyzwania schemat szyfrowane przy użyciu nonce ("Liczba użyć raz") wartość. Odpowiedzi muszą zawierać sumy kontrolnej nazwę użytkownika, hasło, wartość jednorazowy, metodę HTTP i żądanego identyfikatora URI.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AllowedImpersonationLevel">
      <MemberSignature Language="C#" Value="public System.Security.Principal.TokenImpersonationLevel AllowedImpersonationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Principal.TokenImpersonationLevel AllowedImpersonationLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Security.HttpDigestClientCredential.AllowedImpersonationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowedImpersonationLevel As TokenImpersonationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::TokenImpersonationLevel AllowedImpersonationLevel { System::Security::Principal::TokenImpersonationLevel get(); void set(System::Security::Principal::TokenImpersonationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.AllowedImpersonationLevel : System.Security.Principal.TokenImpersonationLevel with get, set" Usage="System.ServiceModel.Security.HttpDigestClientCredential.AllowedImpersonationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.TokenImpersonationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia poziom personifikacji, umożliwiająca klienta przy użyciu podanych poświadczeń klienta.</summary>
        <value>
          <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> Czy klienta daje serwer jako część uwierzytelniania szyfrowanego protokołu HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopuszczalne wartości obejmują:  
  
 <xref:System.Security.Principal.TokenImpersonationLevel.Delegation>,  
  
 <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, a  
  
 <xref:System.Security.Principal.TokenImpersonationLevel.Impersonation>.  
  
 Ze względu na ograniczenia uwierzytelniania szyfrowanego, gdy klient korzysta z poświadczeń innych niż domyślne, tylko `Impersonation` i `Delegation` poziomy są dozwolone.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak ustawić tę właściwość.  
  
 [!code-csharp[S_UE_HttpDigestClientCredential#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_httpdigestclientcredential/cs/source.cs#1)]
 [!code-vb[S_UE_HttpDigestClientCredential#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_httpdigestclientcredential/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientCredential">
      <MemberSignature Language="C#" Value="public System.Net.NetworkCredential ClientCredential { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.NetworkCredential ClientCredential" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Security.HttpDigestClientCredential.ClientCredential" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCredential As NetworkCredential" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::NetworkCredential ^ ClientCredential { System::Net::NetworkCredential ^ get(); void set(System::Net::NetworkCredential ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCredential : System.Net.NetworkCredential with get, set" Usage="System.ServiceModel.Security.HttpDigestClientCredential.ClientCredential" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.NetworkCredential</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia poświadczenia sieciowe, które ma być używany do uwierzytelniania na podstawie skrótu.</summary>
        <value>
          <see cref="T:System.Net.NetworkCredential" /> Ma być używany do uwierzytelniania na podstawie skrótu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie zostanie określony, będą używane domyślne poświadczenia wątku.  
  
   
  
## Examples  
 W poniższych przykładach kodu pokazano, jak można uwierzytelnić klienta jako inny podmiot zabezpieczeń.  
  
 Jest to jak zmienić właściwości wystąpienia <xref:System.Net.NetworkCredential> klasę, która jest zwracana przez tę właściwość.  
  
 [!code-csharp[S_UE_HttpDigestClientCredential#2](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_httpdigestclientcredential/cs/source.cs#2)]  
  
 A Oto jak utworzyć nowe wystąpienie klasy <xref:System.Net.NetworkCredential> klasy i przypisz je do tej właściwości.  
  
 [!code-csharp[S_UE_HttpDigestClientCredential#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_httpdigestclientcredential/cs/source.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
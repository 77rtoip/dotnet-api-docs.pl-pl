<Type Name="RenderOptions" FullName="System.Windows.Media.RenderOptions">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fdae54d801d670554b170fd61494c34840db62a2" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69446463" /></Metadata><TypeSignature Language="C#" Value="public static class RenderOptions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit RenderOptions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.RenderOptions" />
  <TypeSignature Language="VB.NET" Value="Public Class RenderOptions" />
  <TypeSignature Language="C++ CLI" Value="public ref class RenderOptions abstract sealed" />
  <TypeSignature Language="F#" Value="type RenderOptions = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Oferuje opcje kontrolowania zachowania renderowania obiektów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć właściwości dołączonych klasy, <xref:System.Windows.Media.RenderOptions> aby określić opcje renderowania tekstu i elementów wizualnych w aplikacji WPF. Te opcje umożliwiają optymalizację renderowania dla szybkości lub jakości.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Media.RenderCapability" />
    <related type="Article" href="https://msdn.microsoft.com/library/67cafaad-57ad-4ecb-9c08-57fac144393e">narzędzia profilowania wydajności dla WPF</related>
  </Docs>
  <Members>
    <Member MemberName="BitmapScalingMode">
      <MemberSignature Language="C#" Value="see GetBitmapScalingMode, and SetBitmapScalingMode" />
      <MemberSignature Language="ILAsm" Value="see GetBitmapScalingMode, and SetBitmapScalingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.BitmapScalingMode" />
      <MemberSignature Language="VB.NET" Value="see GetBitmapScalingMode, and SetBitmapScalingMode" />
      <MemberSignature Language="F#" Value="see GetBitmapScalingMode, and SetBitmapScalingMode" Usage="see GetBitmapScalingMode, and SetBitmapScalingMode" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see cref="T:System.Windows.Media.BitmapScalingMode" /> dla danego <see cref="T:System.Windows.DependencyObject" />elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.RenderOptions.BitmapScalingMode%2A> Użyj właściwości<xref:System.Windows.UIElement> obiektu lub<xref:System.Windows.Media.DrawingGroup> elementu podrzędnego, który animować mapę bitową.  
  
 W przypadku animowania skali dowolnej mapy bitowej domyślny algorytm próbkowania obrazu o wysokiej jakości może czasami zużywać wystarczające zasoby systemowe, aby spowodować spadek liczby klatek, co skutecznie powoduje, że animacje Stutter. Ustawiając <xref:System.Windows.Media.RenderOptions.BitmapScalingMode%2A> właściwość na <xref:System.Windows.Media.BitmapScalingMode.LowQuality?displayProperty=nameWithType>, można utworzyć gładszą animację podczas skalowania mapy bitowej.  
  
 Aby uzyskać dostęp do tej właściwości w kodzie, <xref:System.Windows.Media.RenderOptions.GetBitmapScalingMode%2A> Użyj <xref:System.Windows.Media.RenderOptions.SetBitmapScalingMode%2A> metod i.  
  
<a name="dependencyPropertyInfo_BitmapScalingMode"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Media.RenderOptions.BitmapScalingModeProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetBitmapScalingMode(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetBitmapScalingMode(System.Windows.DependencyObject,System.Windows.Media.BitmapScalingMode)" />
      </Docs>
    </Member>
    <Member MemberName="BitmapScalingModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BitmapScalingModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BitmapScalingModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.RenderOptions.BitmapScalingModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BitmapScalingModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BitmapScalingModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BitmapScalingModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.RenderOptions.BitmapScalingModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Media.RenderOptions.BitmapScalingMode" /> Identyfikuje załączoną właściwość.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheInvalidationThresholdMaximum">
      <MemberSignature Language="C#" Value="see GetCacheInvalidationThresholdMaximum, and SetCacheInvalidationThresholdMaximum" />
      <MemberSignature Language="ILAsm" Value="see GetCacheInvalidationThresholdMaximum, and SetCacheInvalidationThresholdMaximum" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" />
      <MemberSignature Language="VB.NET" Value="see GetCacheInvalidationThresholdMaximum, and SetCacheInvalidationThresholdMaximum" />
      <MemberSignature Language="F#" Value="see GetCacheInvalidationThresholdMaximum, and SetCacheInvalidationThresholdMaximum" Usage="see GetCacheInvalidationThresholdMaximum, and SetCacheInvalidationThresholdMaximum" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną wartość progową unieważnienia pamięci podręcznej dla <see cref="T:System.Windows.DependencyObject" />danego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta dołączona właściwość jest obsługiwana <xref:System.Windows.Media.TileBrush> przez i jej typy pochodne. Jest przeznaczony do użycia z pędzlami, które mają pośrednie powierzchnie, <xref:System.Windows.Media.DrawingBrush> takie <xref:System.Windows.Media.VisualBrush>jak i. Działa tylko wtedy, <xref:System.Windows.Media.RenderOptions.CachingHint%2A> gdy właściwość jest ustawiona na. <xref:System.Windows.Media.CachingHint.Cache>  
  
 Domyślnie program [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] nie przechowuje w pamięci podręcznej renderowanej <xref:System.Windows.Media.VisualBrush> <xref:System.Windows.Media.DrawingBrush> zawartości obiektów i. W scenariuszach statycznych, w których ani zawartość, ani użycie pędzla w scenie nie zmienia się, buforowanie zawartości nie zapewnia korzyści, ponieważ chroni pamięć wideo. Gdy pędzel z zawartością statyczną jest używany w sposób niestatyczny, domyślnym zachowaniem [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] jest ponowne renderowanie całej zawartości pędzla w każdej klatce, nawet gdy zawartość ulega zmianie. Na przykład dzieje się tak, gdy statyczny <xref:System.Windows.Media.DrawingBrush> lub <xref:System.Windows.Media.VisualBrush> jest mapowany na powierzchnię obracającego się obiektu 3W. Ponowne renderowanie zawartości statycznej może mieć negatywny wpływ na wydajność.  
  
 Ustawiając <xref:System.Windows.Media.RenderOptions.CachingHint%2A> przyłączoną Właściwość pędzla do <xref:System.Windows.Media.CachingHint.Cache>, można zwiększyć wydajność przy użyciu zbuforowanych wersji obiektów pędzla z rozdziałami.  
  
 Wartości właściwości <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> isą<xref:System.Windows.Media.TileBrush> wartościami względnymi rozmiaru, które określają, kiedy należy ponownie wygenerować obiekt ze względu na zmiany w skali. <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum%2A> Na przykład gdy <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> właściwość jest ustawiona na 2,0, pamięć podręczna <xref:System.Windows.Media.TileBrush> dla wymaga ponownego wygenerowania, tylko wtedy, gdy rozmiar bieżącej pamięci podręcznej przekroczy dwa razy.  
  
 Aby uzyskać dostęp do tej właściwości w kodzie, <xref:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMaximum%2A> Użyj <xref:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMaximum%2A> metod i.  
  
<a name="dependencyPropertyInfo_CacheInvalidationThresholdMaximum"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximumProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać opcji wskazówki buforowania dla <xref:System.Windows.Media.DrawingBrush>.  
  
 [!code-xml[RenderOptions#CachingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml#cachingxaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject,System.Double)" />
        <altmember cref="P:System.Windows.Media.RenderOptions.CachingHint" />
      </Docs>
    </Member>
    <Member MemberName="CacheInvalidationThresholdMaximumProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CacheInvalidationThresholdMaximumProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CacheInvalidationThresholdMaximumProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximumProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CacheInvalidationThresholdMaximumProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CacheInvalidationThresholdMaximumProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CacheInvalidationThresholdMaximumProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximumProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" /> Identyfikuje załączoną właściwość.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheInvalidationThresholdMinimum">
      <MemberSignature Language="C#" Value="see GetCacheInvalidationThresholdMinimum, and SetCacheInvalidationThresholdMinimum" />
      <MemberSignature Language="ILAsm" Value="see GetCacheInvalidationThresholdMinimum, and SetCacheInvalidationThresholdMinimum" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" />
      <MemberSignature Language="VB.NET" Value="see GetCacheInvalidationThresholdMinimum, and SetCacheInvalidationThresholdMinimum" />
      <MemberSignature Language="F#" Value="see GetCacheInvalidationThresholdMinimum, and SetCacheInvalidationThresholdMinimum" Usage="see GetCacheInvalidationThresholdMinimum, and SetCacheInvalidationThresholdMinimum" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera lub ustawia minimalną wartość progową unieważnienia pamięci podręcznej <see cref="T:System.Windows.DependencyObject" />dla danego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta dołączona właściwość jest obsługiwana <xref:System.Windows.Media.TileBrush> przez i jej typy pochodne. Jest przeznaczony do użycia z pędzlami, które mają pośrednie powierzchnie, <xref:System.Windows.Media.DrawingBrush> takie <xref:System.Windows.Media.VisualBrush>jak i. Działa tylko wtedy, <xref:System.Windows.Media.RenderOptions.CachingHint%2A> gdy właściwość jest ustawiona na. <xref:System.Windows.Media.CachingHint.Cache>  
  
 Domyślnie program [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] nie przechowuje w pamięci podręcznej renderowanej <xref:System.Windows.Media.VisualBrush> <xref:System.Windows.Media.DrawingBrush> zawartości obiektów i. W scenariuszach statycznych, w których ani zawartość, ani użycie pędzla w scenie nie zmienia się, buforowanie zawartości nie zapewnia korzyści, ponieważ chroni pamięć wideo. Gdy pędzel z zawartością statyczną jest używany w sposób niestatyczny, domyślnym zachowaniem [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] jest ponowne renderowanie całej zawartości pędzla w każdej klatce, nawet gdy zawartość ulega zmianie. Na przykład dzieje się tak, gdy statyczny <xref:System.Windows.Media.DrawingBrush> lub <xref:System.Windows.Media.VisualBrush> jest mapowany na powierzchnię obracającego się obiektu 3W. Ponowne renderowanie zawartości statycznej może mieć negatywny wpływ na wydajność.  
  
 Ustawiając <xref:System.Windows.Media.RenderOptions.CachingHint%2A> przyłączoną Właściwość pędzla do <xref:System.Windows.Media.CachingHint.Cache>, można zwiększyć wydajność przy użyciu zbuforowanych wersji obiektów pędzla z rozdziałami.  
  
 Wartości właściwości <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> isą<xref:System.Windows.Media.TileBrush> wartościami względnymi rozmiaru, które określają, kiedy należy ponownie wygenerować obiekt ze względu na zmiany w skali. <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum%2A> Na przykład gdy <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum%2A> właściwość jest ustawiona na 0,5, pamięć podręczna <xref:System.Windows.Media.TileBrush> dla wymaga ponownego wygenerowania, tylko wtedy, gdy jej rozmiar jest mniejszy niż rozmiar połowy bieżącej pamięci podręcznej.  
  
 Aby uzyskać dostęp do tej właściwości w kodzie, <xref:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMinimum%2A> Użyj <xref:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMinimum%2A> metod i.  
  
<a name="dependencyPropertyInfo_CacheInvalidationThresholdMinimum"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimumProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać opcji wskazówki buforowania dla <xref:System.Windows.Media.DrawingBrush>.  
  
 [!code-xml[RenderOptions#CachingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml#cachingxaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject,System.Double)" />
        <altmember cref="P:System.Windows.Media.RenderOptions.CachingHint" />
      </Docs>
    </Member>
    <Member MemberName="CacheInvalidationThresholdMinimumProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CacheInvalidationThresholdMinimumProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CacheInvalidationThresholdMinimumProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimumProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CacheInvalidationThresholdMinimumProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CacheInvalidationThresholdMinimumProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CacheInvalidationThresholdMinimumProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimumProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" /> Identyfikuje załączoną właściwość.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CachingHint">
      <MemberSignature Language="C#" Value="see GetCachingHint, and SetCachingHint" />
      <MemberSignature Language="ILAsm" Value="see GetCachingHint, and SetCachingHint" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.CachingHint" />
      <MemberSignature Language="VB.NET" Value="see GetCachingHint, and SetCachingHint" />
      <MemberSignature Language="F#" Value="see GetCachingHint, and SetCachingHint" Usage="see GetCachingHint, and SetCachingHint" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, że renderowana zawartość powinna być buforowana, gdy jest to możliwe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta dołączona właściwość jest obsługiwana <xref:System.Windows.Media.TileBrush> przez i jej typy pochodne. Jest przeznaczony do użycia z pędzlami, które mają pośrednie powierzchnie, <xref:System.Windows.Media.DrawingBrush> takie <xref:System.Windows.Media.VisualBrush>jak i.  
  
 Domyślnie program [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] nie przechowuje w pamięci podręcznej renderowanej <xref:System.Windows.Media.VisualBrush> <xref:System.Windows.Media.DrawingBrush> zawartości obiektów i. W scenariuszach statycznych, w których ani zawartość, ani użycie pędzla w scenie nie zmienia się, buforowanie nie zapewnia korzyści, ponieważ zachowuje pamięć wideo. Gdy pędzel z zawartością statyczną jest używany w sposób niestatyczny, domyślnym zachowaniem [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] jest ponowne renderowanie całej zawartości pędzla w każdej klatce, nawet gdy zawartość ulega zmianie. Na przykład dzieje się tak, gdy statyczny <xref:System.Windows.Media.DrawingBrush> lub <xref:System.Windows.Media.VisualBrush> jest mapowany na powierzchnię obracającego się obiektu 3W. Ponowne renderowanie zawartości statycznej może mieć negatywny wpływ na wydajność.  
  
 Ustawiając <xref:System.Windows.Media.RenderOptions.CachingHint%2A> dołączoną Właściwość pędzla do <xref:System.Windows.Media.CachingHint.Cache>, można zwiększyć wydajność przy użyciu zbuforowanych wersji obiektów pędzla z rozdziałami.  
  
 Wartości właściwości <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> isą<xref:System.Windows.Media.TileBrush> wartościami względnymi rozmiaru, które określają, kiedy należy ponownie wygenerować obiekt ze względu na zmiany w skali. <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum%2A> Na przykład gdy <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> właściwość jest ustawiona na 2,0, pamięć podręczna <xref:System.Windows.Media.TileBrush> dla wymaga ponownego wygenerowania, tylko wtedy, gdy rozmiar bieżącej pamięci podręcznej przekroczy dwa razy.  
  
 Aby uzyskać dostęp do tej właściwości w kodzie, <xref:System.Windows.Media.RenderOptions.GetCachingHint%2A> Użyj <xref:System.Windows.Media.RenderOptions.SetCachingHint%2A> metod i.  
  
<a name="dependencyPropertyInfo_CachingHint"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Media.RenderOptions.CachingHintProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać opcji wskazówki buforowania dla <xref:System.Windows.Media.DrawingBrush>.  
  
 [!code-xml[RenderOptions#CachingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml#cachingxaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCachingHint(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCachingHint(System.Windows.DependencyObject,System.Windows.Media.CachingHint)" />
        <altmember cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" />
        <altmember cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" />
      </Docs>
    </Member>
    <Member MemberName="CachingHintProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CachingHintProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CachingHintProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.RenderOptions.CachingHintProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CachingHintProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CachingHintProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CachingHintProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.RenderOptions.CachingHintProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Media.RenderOptions.CachingHint" /> Identyfikuje załączoną właściwość.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearTypeHint">
      <MemberSignature Language="C#" Value="see GetClearTypeHint, and SetClearTypeHint" />
      <MemberSignature Language="ILAsm" Value="see GetClearTypeHint, and SetClearTypeHint" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.ClearTypeHint" />
      <MemberSignature Language="VB.NET" Value="see GetClearTypeHint, and SetClearTypeHint" />
      <MemberSignature Language="F#" Value="see GetClearTypeHint, and SetClearTypeHint" Usage="see GetClearTypeHint, and SetClearTypeHint" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą aparatowi renderowania, czy tekst może być renderowany przy użyciu technologii ClearType.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> Użyj dołączonej właściwości, aby wskazać, że tekst może być renderowany przy użyciu technologii ClearType w określonej części drzewa wizualnego.  
  
 Tekst ClearType nie jest wyświetlany prawidłowo w tle, który nie jest w pełni nieprzezroczysty. Pośrednie elementy docelowe renderowania, takie <xref:System.Windows.UIElement.Effect%2A>jak <xref:System.Windows.UIElement.OpacityMask%2A> <xref:System.Windows.Media.VisualBrush>, <xref:System.Windows.Media.DrawingBrush> <xref:System.Windows.UIElement.Clip%2A>,,, i <xref:System.Windows.UIElement.Opacity%2A>, mogą wprowadzać tła, które nie są w pełni nieprzezroczyste. WPF wyłącza technologię ClearType, gdy wykryje, że bufor, w którym jest rysowany tekst, może mieć przezroczyste tło.  
  
 Ustaw właściwość na <xref:System.Windows.Media.ClearTypeHint.Enabled> , aby wskazać, że poddrzewo jest bezpieczne dla renderowania tekstu ClearType. <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> Zrób to tylko wtedy, gdy można upewnić się, że tekst jest renderowany w pełni nieprzezroczyste tło. Gdy element w poddrzewie przedstawia przezroczystość, można włączyć technologię ClearType; mogą jednak wystąpić problemy z renderowaniem. Jeśli część poddrzewa zawiera więcej elementów docelowych renderowania pośredniego, należy ustawić <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> ją ponownie dla elementów podrzędnych tego poddrzewa.  
  
 Na poniższej liście pokazano, jak upewnić się, że tekst, który ma być renderowany przy użyciu technologii ClearType, pojawia się poprawnie.  
  
-   Nie wprowadzaj pośrednich elementów <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> docelowych renderowania między i tekstu, który ma być renderowany przy użyciu technologii ClearType.  
  
-   Przypisz tło nieprzezroczyste, tak jak to możliwe, w drzewie wizualnym do tekstu.  
  
-   Należy pamiętać, <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> że ponowne włączenie technologii ClearType dla poddrzewa, ale nie wymusza renderowania technologii ClearType.  
  
-   Należy pamiętać, <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> że nie przesłania ustawień systemu ani <xref:System.Windows.Media.TextOptions.TextRenderingMode%2A> ustawień.  
  
> [!NOTE]
>  Dołączona właściwość nie <xref:System.Windows.Controls.TextBox> wpływa na kontrolkę, jednak działa z <xref:System.Windows.Controls.TextBlock> kontrolką. <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A>  
  
> [!NOTE]
>  W przypadku wielu formantów <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> dołączona właściwość nie działa, chyba że ustawisz tło nieprzezroczyste za tekstem.  
  
 Aby uzyskać dostęp do tej właściwości w kodzie, <xref:System.Windows.Media.RenderOptions.GetClearTypeHint%2A> Użyj <xref:System.Windows.Media.RenderOptions.SetClearTypeHint%2A> metod i.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> jak właściwość ma wpływ na różne gałęzie drzewa wizualnego. W pierwszej kontrolce bloku tekstu tekst jest renderowany przy użyciu technologii ClearType, ponieważ blok tekstu dziedziczy ustawienie z okna głównego. W drugim bloku tekstu technologia ClearType nie jest używana, ponieważ <xref:System.Windows.UIElement.OpacityMask%2A> właściwość elementu nadrzędnego jest ustawiona. W trzecim bloku <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> tekstu jest używany, ale mogą wystąpić problemy z renderowaniem.  
  
```xaml
<Window x:Class="ClearTypeHintDemo.Window1"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Window1" Height="300" Width="300"
        AllowsTransparency="True" 
        WindowStyle="None" 
        RenderOptions.ClearTypeHint="Enabled" 
        Background="White">
    <Window.Resources>
        <LinearGradientBrush x:Key="opacityBrush" >
            <GradientStop Color="#FF000000" Offset="0.0" />
            <GradientStop Color="#00000000" Offset="1.0" />
        </LinearGradientBrush>
    </Window.Resources>

    <StackPanel>
        <TextBlock Text="This text is rendered with ClearType." />
        <StackPanel OpacityMask="{StaticResource opacityBrush}" >
            <TextBlock Text="This text is not rendered with ClearType." />
            <TextBlock RenderOptions.ClearTypeHint="Enabled" 
                       Text="This text is rendered with ClearType but may alpha-blend incorrectly." />
        </StackPanel>
    </StackPanel>
</Window>  
```

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearTypeHintProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ClearTypeHintProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ClearTypeHintProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.RenderOptions.ClearTypeHintProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClearTypeHintProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ClearTypeHintProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClearTypeHintProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.RenderOptions.ClearTypeHintProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" /> Identyfikuje załączoną właściwość.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EdgeMode">
      <MemberSignature Language="C#" Value="see GetEdgeMode, and SetEdgeMode" />
      <MemberSignature Language="ILAsm" Value="see GetEdgeMode, and SetEdgeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.EdgeMode" />
      <MemberSignature Language="VB.NET" Value="see GetEdgeMode, and SetEdgeMode" />
      <MemberSignature Language="F#" Value="see GetEdgeMode, and SetEdgeMode" Usage="see GetEdgeMode, and SetEdgeMode" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Media.EdgeMode" /> wartość wyliczenia dla elementu podstawowego niebędącego tekstem, który określa sposób renderowania jego krawędzi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.RenderOptions.EdgeMode%2A> Użyj dołączonej właściwości, aby zwiększyć wydajność renderowania przez określenie, że obiekt wizualizacji ma być renderowany przy użyciu krawędzi z aliasami. Obiekty tekstowe są zawsze wyświetlane z wygładzaniem i nie mają wpływ na ustawienie wartości tryb krawędzi. Po ustawieniu wartości tryb krawędzi obiektu wizualnego wszystkie elementy podstawowe rysowania obiektu wizualizacji są ustawione na tę samą wartość trybu krawędzi.  
  
 Aby uzyskać dostęp do tej właściwości w kodzie, <xref:System.Windows.Media.RenderOptions.GetEdgeMode%2A> Użyj <xref:System.Windows.Media.RenderOptions.SetEdgeMode%2A> metod i.  
  
<a name="dependencyPropertyInfo_EdgeMode"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Media.RenderOptions.EdgeModeProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetEdgeMode(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetEdgeMode(System.Windows.DependencyObject,System.Windows.Media.EdgeMode)" />
      </Docs>
    </Member>
    <Member MemberName="EdgeModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty EdgeModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty EdgeModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.RenderOptions.EdgeModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EdgeModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ EdgeModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable EdgeModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.RenderOptions.EdgeModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Media.RenderOptions.EdgeMode" /> Identyfikuje załączoną właściwość.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBitmapScalingMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.BitmapScalingMode GetBitmapScalingMode (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Media.BitmapScalingMode GetBitmapScalingMode(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.GetBitmapScalingMode(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBitmapScalingMode (target As DependencyObject) As BitmapScalingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::BitmapScalingMode GetBitmapScalingMode(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetBitmapScalingMode : System.Windows.DependencyObject -&gt; System.Windows.Media.BitmapScalingMode" Usage="System.Windows.Media.RenderOptions.GetBitmapScalingMode target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForType(typeof(System.Windows.DependencyObject))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.BitmapScalingMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt zależności, z którego ma zostać pobrana wartość <see cref="P:System.Windows.Media.RenderOptions.BitmapScalingMode" /> dołączonej właściwości.</param>
        <summary>Zwraca wartość <see cref="P:System.Windows.Media.RenderOptions.BitmapScalingMode" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <returns>Bieżąca wartość <see cref="P:System.Windows.Media.RenderOptions.BitmapScalingMode" /> dołączonej właściwości w określonym obiekcie Dependency.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Media.BitmapScalingMode> jak uzyskać dla obiektu obrazu.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet1](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet1)]
 [!code-vb[RenderOptions#RenderOptionsSnippet1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Określona <paramref name="target" /> wartość to <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.SetBitmapScalingMode(System.Windows.DependencyObject,System.Windows.Media.BitmapScalingMode)" />
      </Docs>
    </Member>
    <Member MemberName="GetCacheInvalidationThresholdMaximum">
      <MemberSignature Language="C#" Value="public static double GetCacheInvalidationThresholdMaximum (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetCacheInvalidationThresholdMaximum(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCacheInvalidationThresholdMaximum (target As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetCacheInvalidationThresholdMaximum(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetCacheInvalidationThresholdMaximum : System.Windows.DependencyObject -&gt; double" Usage="System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMaximum target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForType(typeof(System.Windows.Media.TileBrush))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt zależności, z którego ma zostać pobrana wartość <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" /> dołączonej właściwości.</param>
        <summary>Zwraca wartość <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <returns>Bieżąca wartość <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" /> dołączonej właściwości w określonym obiekcie Dependency.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać wartości z wskazówki dotyczące buforowania dla <xref:System.Windows.Media.DrawingBrush>.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet4)]
 [!code-vb[RenderOptions#RenderOptionsSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Określona <paramref name="target" /> wartość to <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCachingHint(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="GetCacheInvalidationThresholdMinimum">
      <MemberSignature Language="C#" Value="public static double GetCacheInvalidationThresholdMinimum (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetCacheInvalidationThresholdMinimum(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCacheInvalidationThresholdMinimum (target As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetCacheInvalidationThresholdMinimum(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetCacheInvalidationThresholdMinimum : System.Windows.DependencyObject -&gt; double" Usage="System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMinimum target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForType(typeof(System.Windows.Media.TileBrush))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt zależności, z którego ma zostać pobrana wartość <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" /> dołączonej właściwości.</param>
        <summary>Zwraca wartość <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <returns>Bieżąca wartość <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" /> dołączonej właściwości w określonym obiekcie Dependency.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać wartości z wskazówki dotyczące buforowania dla <xref:System.Windows.Media.DrawingBrush>.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet4)]
 [!code-vb[RenderOptions#RenderOptionsSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Określona <paramref name="target" /> wartość to <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCachingHint(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="GetCachingHint">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.CachingHint GetCachingHint (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Media.CachingHint GetCachingHint(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.GetCachingHint(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCachingHint (target As DependencyObject) As CachingHint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::CachingHint GetCachingHint(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetCachingHint : System.Windows.DependencyObject -&gt; System.Windows.Media.CachingHint" Usage="System.Windows.Media.RenderOptions.GetCachingHint target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForType(typeof(System.Windows.Media.TileBrush))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CachingHint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt zależności, z którego ma zostać pobrana wartość <see cref="P:System.Windows.Media.RenderOptions.CachingHint" /> dołączonej właściwości.</param>
        <summary>Zwraca wartość <see cref="P:System.Windows.Media.RenderOptions.CachingHint" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <returns>Bieżąca wartość <see cref="P:System.Windows.Media.RenderOptions.CachingHint" /> dołączonej właściwości w określonym obiekcie Dependency.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać wartości z wskazówki dotyczące buforowania dla <xref:System.Windows.Media.DrawingBrush>.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet4)]
 [!code-vb[RenderOptions#RenderOptionsSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Określona <paramref name="target" /> wartość to <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="GetClearTypeHint">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.ClearTypeHint GetClearTypeHint (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Media.ClearTypeHint GetClearTypeHint(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.GetClearTypeHint(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClearTypeHint (target As DependencyObject) As ClearTypeHint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::ClearTypeHint GetClearTypeHint(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetClearTypeHint : System.Windows.DependencyObject -&gt; System.Windows.Media.ClearTypeHint" Usage="System.Windows.Media.RenderOptions.GetClearTypeHint target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Windows.AttachedPropertyBrowsableForType(typeof(System.Windows.DependencyObject))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ClearTypeHint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Windows.DependencyObject" /> Do<see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" /> pobrania dołączonej właściwości dla.</param>
        <summary>Pobiera wartość <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" /> dołączonej właściwości określonego elementu.</summary>
        <returns>Wartość <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" /> dołączonej właściwości dla <paramref name="target" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEdgeMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.EdgeMode GetEdgeMode (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Media.EdgeMode GetEdgeMode(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.GetEdgeMode(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEdgeMode (target As DependencyObject) As EdgeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::EdgeMode GetEdgeMode(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetEdgeMode : System.Windows.DependencyObject -&gt; System.Windows.Media.EdgeMode" Usage="System.Windows.Media.RenderOptions.GetEdgeMode target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForType(typeof(System.Windows.DependencyObject))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.EdgeMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt zależności, z którego ma zostać pobrana wartość <see cref="P:System.Windows.Media.RenderOptions.EdgeMode" /> dołączonej właściwości.</param>
        <summary>Zwraca wartość <see cref="P:System.Windows.Media.RenderOptions.EdgeMode" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <returns>Bieżąca wartość <see cref="P:System.Windows.Media.RenderOptions.EdgeMode" /> dołączonej właściwości w określonym obiekcie Dependency.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość domyślna dla elementów pierwotnych rysowania nietekstowych, takich jak <xref:System.Windows.Shapes.Ellipse> i <xref:System.Windows.Shapes.Polygon>, jest <xref:System.Windows.Media.EdgeMode.Unspecified>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Określona <paramref name="target" /> wartość to <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessRenderMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Interop.RenderMode ProcessRenderMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Interop.RenderMode ProcessRenderMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.ProcessRenderMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ProcessRenderMode As RenderMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Interop::RenderMode ProcessRenderMode { System::Windows::Interop::RenderMode get(); void set(System::Windows::Interop::RenderMode value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessRenderMode : System.Windows.Interop.RenderMode with get, set" Usage="System.Windows.Media.RenderOptions.ProcessRenderMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.RenderMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa preferencję trybu renderowania dla bieżącego procesu.</summary>
        <value><see cref="T:System.Windows.Interop.RenderMode" /> Preferencja dla bieżącego procesu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj właściwości <xref:System.Windows.Media.RenderOptions.ProcessRenderMode%2A> , aby wymusić renderowanie oprogramowania dla bieżącego procesu. Można uniknąć wielu problemów z renderowaniem występujących w aplikacjach WPF i spowodowanych problemami zewnętrznymi, jeśli zmienisz preferencję na renderowanie oprogramowania.  
  
 W trakcie uruchamiania aplikacji, jeśli aplikacja wykryje problemy z renderowaniem, np. szybkości wolnej ramki, można ustawić tryb renderowania wyłącznie na oprogramowanie. Ponadto można włączyć ustawienie użytkownika, gdy aplikacja jest uruchomiona.  
  
 Preferencja<xref:System.Windows.Interop.HwndTarget.RenderMode%2A>zastępujeustawienie. <xref:System.Windows.Interop.RenderMode.SoftwareOnly> Kolejność pierwszeństwa renderowania oprogramowania to:  
  
1.  Klucz rejestru DisableHWAcceleration  
  
2.  <xref:System.Windows.Media.RenderOptions.ProcessRenderMode%2A>  
  
3.  <xref:System.Windows.Interop.HwndTarget.RenderMode%2A>(na cel)  
  
 **Uwaga** <xref:System.Windows.Media.RenderOptions.ProcessRenderMode%2A> Określa preferencję i nie musi zmieniać rzeczywistego trybu renderowania. Inne części systemu mogą zastąpić to preferencje i wymusić renderowanie systemu w systemie.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby ustawić tę właściwość. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Interop.RenderMode" />
      </Docs>
    </Member>
    <Member MemberName="SetBitmapScalingMode">
      <MemberSignature Language="C#" Value="public static void SetBitmapScalingMode (System.Windows.DependencyObject target, System.Windows.Media.BitmapScalingMode bitmapScalingMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetBitmapScalingMode(class System.Windows.DependencyObject target, valuetype System.Windows.Media.BitmapScalingMode bitmapScalingMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.SetBitmapScalingMode(System.Windows.DependencyObject,System.Windows.Media.BitmapScalingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetBitmapScalingMode(System::Windows::DependencyObject ^ target, System::Windows::Media::BitmapScalingMode bitmapScalingMode);" />
      <MemberSignature Language="F#" Value="static member SetBitmapScalingMode : System.Windows.DependencyObject * System.Windows.Media.BitmapScalingMode -&gt; unit" Usage="System.Windows.Media.RenderOptions.SetBitmapScalingMode (target, bitmapScalingMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="bitmapScalingMode" Type="System.Windows.Media.BitmapScalingMode" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt <see cref="T:System.Windows.UIElement" /> podrzędny <see cref="T:System.Windows.Media.DrawingGroup" /> lub, na którym ma zostać <see cref="P:System.Windows.Media.RenderOptions.BitmapScalingMode" /> ustawiona wartość właściwości.</param>
        <param name="bitmapScalingMode">Nowa wartość, dla której ma zostać ustawiona właściwość.</param>
        <summary>Ustawia wartość <see cref="P:System.Windows.Media.RenderOptions.BitmapScalingMode" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.RenderOptions.SetBitmapScalingMode%2A> Użyj metody<xref:System.Windows.UIElement> z lub<xref:System.Windows.Media.DrawingGroup> elementu podrzędnego, który animować mapę bitową.  
  
 W przypadku animowania skali dowolnej mapy bitowej domyślny algorytm próbkowania obrazu o wysokiej jakości może czasami zużywać wystarczające zasoby systemowe, aby spowodować spadek liczby klatek, co skutecznie powoduje, że animacje Stutter. Ustawiając <xref:System.Windows.Media.RenderOptions.BitmapScalingMode%2A> Właściwość <xref:System.Windows.Media.RenderOptions> obiektu na<xref:System.Windows.Media.BitmapScalingMode.LowQuality>, można utworzyć płynną animację podczas skalowania mapy bitowej.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Media.BitmapScalingMode> jak ustawić <xref:System.Windows.Controls.Image> dla obiektu obiekt.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet2](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet2)]
 [!code-vb[RenderOptions#RenderOptionsSnippet2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Określona <paramref name="target" /> wartość to <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetBitmapScalingMode(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetCacheInvalidationThresholdMaximum">
      <MemberSignature Language="C#" Value="public static void SetCacheInvalidationThresholdMaximum (System.Windows.DependencyObject target, double cacheInvalidationThresholdMaximum);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCacheInvalidationThresholdMaximum(class System.Windows.DependencyObject target, float64 cacheInvalidationThresholdMaximum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCacheInvalidationThresholdMaximum (target As DependencyObject, cacheInvalidationThresholdMaximum As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCacheInvalidationThresholdMaximum(System::Windows::DependencyObject ^ target, double cacheInvalidationThresholdMaximum);" />
      <MemberSignature Language="F#" Value="static member SetCacheInvalidationThresholdMaximum : System.Windows.DependencyObject * double -&gt; unit" Usage="System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMaximum (target, cacheInvalidationThresholdMaximum)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="cacheInvalidationThresholdMaximum" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt zależności, na którym ma zostać ustawiona wartość <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" /> właściwości.</param>
        <param name="cacheInvalidationThresholdMaximum">Nowa wartość, dla której ma zostać ustawiona właściwość.</param>
        <summary>Ustawia wartość <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby ustawić <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> przyłączoną właściwość w kodzie.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać opcji wskazówki buforowania dla <xref:System.Windows.Media.DrawingBrush>.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet3](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet3)]
 [!code-vb[RenderOptions#RenderOptionsSnippet3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Określona <paramref name="target" /> wartość to <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCachingHint(System.Windows.DependencyObject,System.Windows.Media.CachingHint)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="SetCacheInvalidationThresholdMinimum">
      <MemberSignature Language="C#" Value="public static void SetCacheInvalidationThresholdMinimum (System.Windows.DependencyObject target, double cacheInvalidationThresholdMinimum);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCacheInvalidationThresholdMinimum(class System.Windows.DependencyObject target, float64 cacheInvalidationThresholdMinimum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCacheInvalidationThresholdMinimum (target As DependencyObject, cacheInvalidationThresholdMinimum As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCacheInvalidationThresholdMinimum(System::Windows::DependencyObject ^ target, double cacheInvalidationThresholdMinimum);" />
      <MemberSignature Language="F#" Value="static member SetCacheInvalidationThresholdMinimum : System.Windows.DependencyObject * double -&gt; unit" Usage="System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMinimum (target, cacheInvalidationThresholdMinimum)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="cacheInvalidationThresholdMinimum" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt zależności, na którym ma zostać ustawiona wartość <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" /> właściwości.</param>
        <param name="cacheInvalidationThresholdMinimum">Nowa wartość, dla której ma zostać ustawiona właściwość.</param>
        <summary>Ustawia wartość <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby ustawić <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum%2A> przyłączoną właściwość w kodzie.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać opcji wskazówki buforowania dla <xref:System.Windows.Media.DrawingBrush>.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet3](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet3)]
 [!code-vb[RenderOptions#RenderOptionsSnippet3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Określona <paramref name="target" /> wartość to <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCachingHint(System.Windows.DependencyObject,System.Windows.Media.CachingHint)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="SetCachingHint">
      <MemberSignature Language="C#" Value="public static void SetCachingHint (System.Windows.DependencyObject target, System.Windows.Media.CachingHint cachingHint);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCachingHint(class System.Windows.DependencyObject target, valuetype System.Windows.Media.CachingHint cachingHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.SetCachingHint(System.Windows.DependencyObject,System.Windows.Media.CachingHint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCachingHint(System::Windows::DependencyObject ^ target, System::Windows::Media::CachingHint cachingHint);" />
      <MemberSignature Language="F#" Value="static member SetCachingHint : System.Windows.DependencyObject * System.Windows.Media.CachingHint -&gt; unit" Usage="System.Windows.Media.RenderOptions.SetCachingHint (target, cachingHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="cachingHint" Type="System.Windows.Media.CachingHint" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt zależności, na którym ma zostać ustawiona wartość <see cref="P:System.Windows.Media.RenderOptions.CachingHint" /> właściwości.</param>
        <param name="cachingHint">Nowa wartość, dla której ma zostać ustawiona właściwość.</param>
        <summary>Ustawia wartość <see cref="P:System.Windows.Media.RenderOptions.CachingHint" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie program [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] nie przechowuje w pamięci podręcznej renderowanej <xref:System.Windows.Media.VisualBrush> <xref:System.Windows.Media.DrawingBrush> zawartości obiektów i. W scenariuszach statycznych, w których ani zawartość, ani użycie pędzla w scenie nie zmienia się, buforowanie nie zapewnia korzyści, ponieważ zachowuje pamięć wideo. Gdy pędzel z zawartością statyczną jest używany w sposób niestatyczny, domyślnym zachowaniem [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] jest ponowne renderowanie całej zawartości pędzla w każdej klatce, nawet gdy zawartość ulega zmianie. Na przykład dzieje się tak, gdy statyczny <xref:System.Windows.Media.DrawingBrush> lub <xref:System.Windows.Media.VisualBrush> jest mapowany na powierzchnię obracającego się obiektu 3W. Ponowne renderowanie zawartości statycznej może mieć negatywny wpływ na wydajność.  
  
 Ustawiając <xref:System.Windows.Media.RenderOptions.CachingHint%2A> dołączoną Właściwość pędzla do <xref:System.Windows.Media.CachingHint.Cache>, można zwiększyć wydajność przy użyciu zbuforowanych wersji obiektów pędzla z rozdziałami.  
  
 Wartości właściwości <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> isą<xref:System.Windows.Media.TileBrush> wartościami względnymi rozmiaru, które określają, kiedy należy ponownie wygenerować obiekt ze względu na zmiany w skali. <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum%2A> Na przykład gdy <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> właściwość jest ustawiona na 2,0, pamięć podręczna <xref:System.Windows.Media.TileBrush> dla wymaga ponownego wygenerowania, tylko wtedy, gdy rozmiar bieżącej pamięci podręcznej przekroczy dwa razy.  
  
 Użyj tej metody, aby ustawić <xref:System.Windows.Media.RenderOptions.CachingHint%2A> przyłączoną właściwość w kodzie.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać opcji wskazówki buforowania dla <xref:System.Windows.Media.DrawingBrush>.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet3](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet3)]
 [!code-vb[RenderOptions#RenderOptionsSnippet3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Określona <paramref name="target" /> wartość to <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject,System.Double)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="SetClearTypeHint">
      <MemberSignature Language="C#" Value="public static void SetClearTypeHint (System.Windows.DependencyObject target, System.Windows.Media.ClearTypeHint clearTypeHint);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetClearTypeHint(class System.Windows.DependencyObject target, valuetype System.Windows.Media.ClearTypeHint clearTypeHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.SetClearTypeHint(System.Windows.DependencyObject,System.Windows.Media.ClearTypeHint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetClearTypeHint(System::Windows::DependencyObject ^ target, System::Windows::Media::ClearTypeHint clearTypeHint);" />
      <MemberSignature Language="F#" Value="static member SetClearTypeHint : System.Windows.DependencyObject * System.Windows.Media.ClearTypeHint -&gt; unit" Usage="System.Windows.Media.RenderOptions.SetClearTypeHint (target, clearTypeHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="clearTypeHint" Type="System.Windows.Media.ClearTypeHint" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="target">, <see cref="T:System.Windows.DependencyObject" /> Aby<see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" /> ustawić przyłączoną właściwość w.</param>
        <param name="clearTypeHint">Nowa <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" /> wartość.</param>
        <summary>Ustawia wartość <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" /> dołączonej właściwości określonego elementu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Określona <paramref name="target" /> wartość to <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetEdgeMode">
      <MemberSignature Language="C#" Value="public static void SetEdgeMode (System.Windows.DependencyObject target, System.Windows.Media.EdgeMode edgeMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEdgeMode(class System.Windows.DependencyObject target, valuetype System.Windows.Media.EdgeMode edgeMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.SetEdgeMode(System.Windows.DependencyObject,System.Windows.Media.EdgeMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEdgeMode(System::Windows::DependencyObject ^ target, System::Windows::Media::EdgeMode edgeMode);" />
      <MemberSignature Language="F#" Value="static member SetEdgeMode : System.Windows.DependencyObject * System.Windows.Media.EdgeMode -&gt; unit" Usage="System.Windows.Media.RenderOptions.SetEdgeMode (target, edgeMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="edgeMode" Type="System.Windows.Media.EdgeMode" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt zależności, na którym ma zostać ustawiona wartość <see cref="P:System.Windows.Media.RenderOptions.EdgeMode" /> właściwości.</param>
        <param name="edgeMode">Nowa wartość, dla której ma zostać ustawiona właściwość.</param>
        <summary>Ustawia wartość <see cref="P:System.Windows.Media.RenderOptions.EdgeMode" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekty tekstowe są zawsze wyświetlane z wygładzaniem i nie mają wpływ na ustawienie wartości tryb krawędzi. Po ustawieniu wartości tryb krawędzi obiektu wizualnego wszystkie elementy podstawowe rysowania obiektu wizualizacji są ustawione na tę samą wartość trybu krawędzi.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Media.RenderOptions.SetEdgeMode%2A> jak używać metody do ustawiania trybu krawędzi dla <xref:System.Windows.Media.EdgeMode.Aliased>obiektu wizualizacji.  
  
 [!code-csharp[VisualSnippets#SetEdgeMode](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Snippets.cs#setedgemode)]
 [!code-vb[VisualSnippets#SetEdgeMode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/snippets.vb#setedgemode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Określona <paramref name="target" /> wartość to <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

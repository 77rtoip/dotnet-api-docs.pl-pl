<Type Name="Visual" FullName="System.Windows.Media.Visual">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5b527b32ee76f33673588093569045920a744596" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69446280" /></Metadata><TypeSignature Language="C#" Value="public abstract class Visual : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Visual extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Visual" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Visual&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Visual abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Visual = class&#xA;    inherit DependencyObject&#xA;    interface DUCE.IResource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zapewnia obsługę renderowania w programie WPF, która obejmuje testowanie trafień, transformację współrzędnej i obliczenia pól ograniczenia.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa stanowi podstawowe streszczenie, z którego pochodzi każdy <xref:System.Windows.FrameworkElement> obiekt. <xref:System.Windows.Media.Visual> Służy również jako punkt wejścia do pisania nowych kontrolek w programie [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], a na wiele sposobów można traktować jako odpowiednik okna uchwytu (HWND) [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] w modelu aplikacji.  
  
 Obiekt jest obiektem podstawowym [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] , którego podstawową rolą jest zapewnienie obsługi renderowania. <xref:System.Windows.Media.Visual> Kontrolki interfejsu użytkownika, takie <xref:System.Windows.Controls.Button> jak <xref:System.Windows.Controls.TextBox>i, pochodne od <xref:System.Windows.Media.Visual> klasy i używają <xref:System.Windows.Media.Visual> zdefiniowanych właściwości do utrwalania danych renderowania. <xref:System.Windows.Media.Visual> Obiekt zapewnia obsługę następujących funkcji:  
  
-   Wyświetlanie danych wyjściowych: Renderowanie utrwalonej i serializowanej zawartości rysunku wizualizacji.  
  
-   Przekształcenia Wykonywanie transformacji na wizualizacji.  
  
-   Wycinka Zapewnianie obsługi regionu przycinania dla wizualizacji.  
  
-   Testowanie trafień: Określanie, czy określona Współrzędna (punkt) lub geometria jest zawarta w granicach wizualizacji.  
  
-   Obliczenia pola ograniczenia: Określanie prostokąta ograniczenia wizualizacji.  
  
 W sposób [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] architektoniczny obiektnieobejmujeobsługiinnychwymagańifunkcjizwiązanychztworzeniemaplikacji,któreniesąbezpośredniopowiązanezrenderowaniem,<xref:System.Windows.Media.Visual> takich jak następujące:  
  
-   Obsługa zdarzeń  
  
-   Układ  
  
-   Style  
  
-   Powiązanie danych  
  
-   Globalizacja  
  
 <xref:System.Windows.Media.Visual>jest dostarczany jako publiczna klasa abstrakcyjna, z której mogą być wyprowadzane dalsze klasy. Na poniższej ilustracji przedstawiono hierarchię istniejących obiektów wizualizacji, które są zdefiniowane w [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] architekturze.  
  
 ![Diagram klas pochodnych dla obiektu wizualnego] (~/add/media/visualclass01.png "Diagram klas pochodnych dla obiektu wizualnego")  
Hierarchia klas wizualnych  
  
 W niektórych przypadkach elementy członkowskie, które są zdefiniowane jako chronione <xref:System.Windows.Media.Visual> w programie, są ujawniane jako bardziej łatwo dostępne elementy członkowskie o <xref:System.Windows.UIElement> podobnych nazwach w klasie pochodnej.  
  
 Aby uzyskać więcej informacji, zobacz [Omówienie renderowania grafiki WPF](~/docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
 <xref:System.Windows.Media.Visual> Ma ograniczoną liczbę poziomów. W poprzednich wersjach .NET Framework ta Maksymalna głębokość była 255. Ten limit jest nieodpowiedni dla niektórych układów, które mają wiele poziomów w drzewie wizualnym.  
  
 W [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]programie Maksymalna głębokość <xref:System.Windows.Media.Visual> to 2047, która umożliwia znacznie bardziej dokładniejsze drzewa wizualne. W większości aplikacji jest za mało miejsca na stosie, aby przetworzyć wiele poziomów, a wynik jest <xref:System.StackOverflowException> w trakcie układu. W przypadku domyślnego rozmiaru stosu ten wyjątek jest zwykle generowany, gdy Głębokość drzewa wynosi około 800, co odnosi się do około 190 obiektów <xref:System.Windows.Controls.TreeViewItem> zagnieżdżonych.  
  
 Jeśli ten wyjątek jest zgłaszany przez aplikację i trzeba mieć dokładniejsze drzewo wizualne, można zwiększyć rozmiar stosu aplikacji. Rozmiar stosu można zwiększyć przy użyciu opcji/STACK w czasie kompilacji lub przy użyciu narzędzia polecenia EDITBIN. Zwiększenie rozmiaru stosu może wpłynąć na wydajność aplikacji. Aby uzyskać więcej informacji, zobacz temat [Alokacje stosu](https://go.microsoft.com/fwlink/?LinkId=165510) i [Opcje polecenia EDITBIN](https://go.microsoft.com/fwlink/?LinkId=165511).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Media.VisualCollection" />
    <altmember cref="T:System.Windows.Media.VisualTreeHelper" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Visual ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Visual();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Zapewnia podstawowe inicjowanie obiektów pochodzących od <see cref="T:System.Windows.Media.Visual" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddVisualChild">
      <MemberSignature Language="C#" Value="protected void AddVisualChild (System.Windows.Media.Visual child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AddVisualChild(class System.Windows.Media.Visual child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.AddVisualChild(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AddVisualChild (child As Visual)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AddVisualChild(System::Windows::Media::Visual ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddVisualChild : System.Windows.Media.Visual -&gt; unit" Usage="visual.AddVisualChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="child">Podrzędny obiekt wizualny, który ma zostać dodany do wizualizacji nadrzędnej.</param>
        <summary>Definiuje relację nadrzędny-podrzędny między dwiema wizualizacjami.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Visual.AddVisualChild%2A> Metoda konfiguruje relację nadrzędny-podrzędny między dwoma obiektami wizualnymi. Ta metoda musi być używana, gdy potrzebna jest większa kontrola nad podstawową implementacją obiektów podrzędnych Visual. <xref:System.Windows.Media.VisualCollection>może służyć jako domyślna implementacja do przechowywania obiektów podrzędnych.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak zdefiniować niestandardowe wymagania dotyczące magazynu dla wizualnego elementu podrzędnego. W przykładzie zastosowano <xref:System.Windows.Media.Visual.AddVisualChild%2A> metody <xref:System.Windows.Media.Visual.RemoveVisualChild%2A> i, aby skonfigurować relację nadrzędny-podrzędny między wizualizacją nadrzędną `child`a. Aby drzewo wizualne zostało prawidłowo wyliczone, w przykładzie przedstawiono przesłonięte implementacje <xref:System.Windows.Media.Visual.GetVisualChild%2A> metody i <xref:System.Windows.Media.Visual.VisualChildrenCount%2A> właściwości.  
  
> [!NOTE]
>  Chociaż można używać <xref:System.Windows.Media.VisualCollection> do tworzenia relacji nadrzędny-podrzędny między obiektami wizualnymi, bardziej wydajne jest zapewnienie własnej niestandardowej implementacji magazynu, gdy tylko jeden element podrzędny jest połączony z elementem nadrzędnym.  
  
 [!code-csharp[AddVisualChild#AddVisualChild01](~/samples/snippets/csharp/VS_Snippets_Wpf/AddVisualChild/CSharp/Window1.xaml.cs#addvisualchild01)]
 [!code-vb[AddVisualChild#AddVisualChild01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/AddVisualChild/visualbasic/window1.xaml.vb#addvisualchild01)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.VisualCollection" />
      </Docs>
    </Member>
    <Member MemberName="FindCommonVisualAncestor">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject FindCommonVisualAncestor (System.Windows.DependencyObject otherVisual);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject FindCommonVisualAncestor(class System.Windows.DependencyObject otherVisual) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.FindCommonVisualAncestor(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindCommonVisualAncestor (otherVisual As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ FindCommonVisualAncestor(System::Windows::DependencyObject ^ otherVisual);" />
      <MemberSignature Language="F#" Value="member this.FindCommonVisualAncestor : System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="visual.FindCommonVisualAncestor otherVisual" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherVisual" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="otherVisual">Obiekt wizualizacji typu <see cref="T:System.Windows.DependencyObject" />.</param>
        <summary>Zwraca wspólny element nadrzędny dwóch obiektów wizualnych.</summary>
        <returns>Wspólny element nadrzędny obiektu wizualizacji i <paramref name="otherVisual" /> jeśli taki istnieje; <see langword="null" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 obiekty 2D i 3D mogą mieć typowe elementy nadrzędne wizualne, więc można przekazać <xref:System.Windows.Media.Media3D.Visual3D> `otherVisual`do.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetVisualChild : int -&gt; System.Windows.Media.Visual&#xA;override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="visual.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks obiektu wizualizacji w <see cref="T:System.Windows.Media.VisualCollection" />.</param>
        <summary>Zwraca określony <see cref="T:System.Windows.Media.Visual" /> element w obiekcie nadrzędnym <see cref="T:System.Windows.Media.VisualCollection" />.</summary>
        <returns>Element podrzędny w <see cref="T:System.Windows.Media.VisualCollection" /> podanej <paramref name="index" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Windows.Media.Visual> nie ma żadnych elementów podrzędnych. W związku z tym Domyślna implementacja zawsze zgłasza <xref:System.ArgumentOutOfRangeException>.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano przesłoniętą <xref:System.Windows.Media.Visual.GetVisualChild%2A>implementację programu.  
  
 [!code-csharp[DrawingVisualSample#102b](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingVisualSample/CSharp/Window1.xaml.cs#102b)]
 [!code-vb[DrawingVisualSample#102b](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingVisualSample/visualbasic/window1.xaml.vb#102b)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Klasa, która pochodzi od <see cref="T:System.Windows.Media.Visual" /> , musi zastąpić tę metodę, a <see cref="P:System.Windows.Media.Visual.VisualChildrenCount" /> także właściwość dla drzewa wizualnego, która ma zostać prawidłowo wyliczona.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="HitTestCore">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy wartość punktu lub geometrii znajduje się w granicach obiektu wizualizacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Media.GeometryHitTestResult HitTestCore (System.Windows.Media.GeometryHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.GeometryHitTestResult HitTestCore(class System.Windows.Media.GeometryHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.GeometryHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function HitTestCore (hitTestParameters As GeometryHitTestParameters) As GeometryHitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Media::GeometryHitTestResult ^ HitTestCore(System::Windows::Media::GeometryHitTestParameters ^ hitTestParameters);" />
      <MemberSignature Language="F#" Value="abstract member HitTestCore : System.Windows.Media.GeometryHitTestParameters -&gt; System.Windows.Media.GeometryHitTestResult&#xA;override this.HitTestCore : System.Windows.Media.GeometryHitTestParameters -&gt; System.Windows.Media.GeometryHitTestResult" Usage="visual.HitTestCore hitTestParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeometryHitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.GeometryHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">Obiekt, który <see cref="T:System.Windows.Media.Geometry" /> określa test trafień. <see cref="T:System.Windows.Media.GeometryHitTestParameters" /></param>
        <summary>Określa, czy wartość geometrii znajduje się w granicach obiektu wizualizacji.</summary>
        <returns><see cref="T:System.Windows.Media.GeometryHitTestResult" /> Reprezentuje wynik testu trafień.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można przesłonić domyślne wsparcie testowania trafień dla obiektu wizualizacji, <xref:System.Windows.Media.Visual.HitTestCore%2A> zastępując metodę. Oznacza to, że po wywołaniu <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> metody, zastąpiona <xref:System.Windows.Media.Visual.HitTestCore%2A> implementacja jest wywoływana. Zastąpiona metoda jest wywoływana, gdy test trafień znajduje się w granicach obiektu wizualizacji, nawet jeśli Współrzędna znajduje się poza geometrią obiektu wizualnego.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Media.Visual.HitTestCore%28System.Windows.Media.GeometryHitTestParameters%29> jak zastąpić metodę. Jednym z powodów, dla których warto zastąpić tę metodę, jest zapewnienie dodatkowych funkcji podczas procesu testowania trafień.  
  
 [!code-csharp[HitTestingOverview#HitTestingOverviewSnippet13](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestingOverview/CSharp/GeometryHitTest.cs#hittestingoverviewsnippet13)]
 [!code-vb[HitTestingOverview#HitTestingOverviewSnippet13](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestingOverview/visualbasic/geometryhittest.vb#hittestingoverviewsnippet13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Media.HitTestResult HitTestCore (System.Windows.Media.PointHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.HitTestResult HitTestCore(class System.Windows.Media.PointHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.PointHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function HitTestCore (hitTestParameters As PointHitTestParameters) As HitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Media::HitTestResult ^ HitTestCore(System::Windows::Media::PointHitTestParameters ^ hitTestParameters);" />
      <MemberSignature Language="F#" Value="abstract member HitTestCore : System.Windows.Media.PointHitTestParameters -&gt; System.Windows.Media.HitTestResult&#xA;override this.HitTestCore : System.Windows.Media.PointHitTestParameters -&gt; System.Windows.Media.HitTestResult" Usage="visual.HitTestCore hitTestParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.PointHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">Obiekt, który <see cref="T:System.Windows.Point" /> określa test trafień. <see cref="T:System.Windows.Media.PointHitTestParameters" /></param>
        <summary>Określa, czy wartość współrzędnej punktu znajduje się w granicach obiektu wizualizacji.</summary>
        <returns><see cref="T:System.Windows.Media.HitTestResult" /> Reprezentujący,któryjestzwracany<see cref="T:System.Windows.Media.Visual" /> z testu trafień.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można zastąpić domyślną obsługę testowania trafień w obiektach wizualnych, zastępując <xref:System.Windows.Media.Visual.HitTestCore%2A> metodę. Oznacza to, że po wywołaniu <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> metody, zastąpiona <xref:System.Windows.Media.Visual.HitTestCore%2A> implementacja jest wywoływana. Zastąpiona metoda jest wywoływana, gdy test trafień znajduje się w granicach obiektu wizualizacji, nawet jeśli Współrzędna znajduje się poza geometrią obiektu wizualnego.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Media.Visual.HitTestCore%28System.Windows.Media.PointHitTestParameters%29> jak zastąpić metodę. Jednym z powodów, dla których warto zastąpić tę metodę, jest zapewnienie dodatkowych funkcji podczas procesu testowania trafień.  
  
 [!code-csharp[HitTestingOverview#107](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestingOverview/CSharp/Window1.xaml.cs#107)]
 [!code-vb[HitTestingOverview#107](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestingOverview/visualbasic/window1.xaml.vb#107)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAncestorOf">
      <MemberSignature Language="C#" Value="public bool IsAncestorOf (System.Windows.DependencyObject descendant);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAncestorOf(class System.Windows.DependencyObject descendant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.IsAncestorOf(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAncestorOf (descendant As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAncestorOf(System::Windows::DependencyObject ^ descendant);" />
      <MemberSignature Language="F#" Value="member this.IsAncestorOf : System.Windows.DependencyObject -&gt; bool" Usage="visual.IsAncestorOf descendant" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descendant" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="descendant">Wartość typu <see cref="T:System.Windows.DependencyObject" />.</param>
        <summary>Określa, czy obiekt wizualny jest elementem nadrzędnym obiektu wizualizacji podrzędnej.</summary>
        <returns><see langword="true" />Jeśli obiekt wizualny jest elementem nadrzędnym <paramref name="descendant" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDescendantOf">
      <MemberSignature Language="C#" Value="public bool IsDescendantOf (System.Windows.DependencyObject ancestor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDescendantOf(class System.Windows.DependencyObject ancestor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.IsDescendantOf(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDescendantOf (ancestor As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDescendantOf(System::Windows::DependencyObject ^ ancestor);" />
      <MemberSignature Language="F#" Value="member this.IsDescendantOf : System.Windows.DependencyObject -&gt; bool" Usage="visual.IsDescendantOf ancestor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ancestor" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="ancestor">Wartość typu <see cref="T:System.Windows.DependencyObject" />.</param>
        <summary>Określa, czy obiekt wizualny jest elementem potomnym obiektu wizualizacji nadrzędnej.</summary>
        <returns><see langword="true" />Jeśli obiektem wizualnym jest element podrzędny <paramref name="ancestor" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChanged (oldDpi As DpiScale, newDpi As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChanged(System::Windows::DpiScale oldDpi, System::Windows::DpiScale newDpi);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit&#xA;override this.OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit" Usage="visual.OnDpiChanged (oldDpi, newDpi)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="oldDpi">Poprzednie ustawienie skalowania DPI.</param>
        <param name="newDpi">Nowe ustawienie skalowania DPI.</param>
        <summary>Wywołuje się, gdy zmienia się wartość DPI, w której jest renderowany ten widok.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualChildrenChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnVisualChildrenChanged (System.Windows.DependencyObject visualAdded, System.Windows.DependencyObject visualRemoved);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnVisualChildrenChanged(class System.Windows.DependencyObject visualAdded, class System.Windows.DependencyObject visualRemoved) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.OnVisualChildrenChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnVisualChildrenChanged (visualAdded As DependencyObject, visualRemoved As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnVisualChildrenChanged(System::Windows::DependencyObject ^ visualAdded, System::Windows::DependencyObject ^ visualRemoved);" />
      <MemberSignature Language="F#" Value="abstract member OnVisualChildrenChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit&#xA;override this.OnVisualChildrenChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="visual.OnVisualChildrenChanged (visualAdded, visualRemoved)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visualAdded" Type="System.Windows.DependencyObject" />
        <Parameter Name="visualRemoved" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="visualAdded"><see cref="T:System.Windows.Media.Visual" /> , Który został dodany do kolekcji</param>
        <param name="visualRemoved">, <see cref="T:System.Windows.Media.Visual" /> Który został usunięty z kolekcji</param>
        <summary>Wywołuje się, <see cref="T:System.Windows.Media.VisualCollection" /> gdy obiekt wizualny jest modyfikowany.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="abstract member OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit&#xA;override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="visual.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Wartość typu <see cref="T:System.Windows.DependencyObject" /> , która reprezentuje poprzedni element nadrzędny <see cref="T:System.Windows.Media.Visual" /> obiektu. Jeśli obiekt nie miał powyższego elementu nadrzędnego, wartość parametru to <see langword="null" />. <see cref="T:System.Windows.Media.Visual" /></param>
        <summary>Wywołuje się, gdy obiekt nadrzędny obiektu wizualnego zostanie zmieniony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa, która dziedziczy z <xref:System.Windows.Media.Visual> , może przesłonić tę metodę.  
  
 Nie ma podanego zdarzenia "VisualParentChanged", które zgłasza tę zmianę do wystąpień. W związku z tym należy zastąpić tę metodę, aby obsługiwać scenariusze powiadomień i udostępnić wersję wystąpienia powiadomienia, jeśli jest to część Twojego scenariusza.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano przesłoniętą <xref:System.Windows.Media.Visual.OnVisualParentChanged%2A>implementację programu.  
  
 [!code-csharp[VisualSnippets#VisualSnippet10](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet10)]
 [!code-vb[VisualSnippets#VisualSnippet10](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Visual.VisualParent" />
      </Docs>
    </Member>
    <Member MemberName="PointFromScreen">
      <MemberSignature Language="C#" Value="public System.Windows.Point PointFromScreen (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Point PointFromScreen(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.PointFromScreen(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Point PointFromScreen(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="member this.PointFromScreen : System.Windows.Point -&gt; System.Windows.Point" Usage="visual.PointFromScreen point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point"><see cref="T:System.Windows.Point" /> Wartość we współrzędnych ekranu.</param>
        <summary>Konwertuje Współrzędne ekranu <see cref="T:System.Windows.Point" /> do obiektu, który reprezentuje <see cref="T:System.Windows.Media.Visual" />bieżący system współrzędnych. <see cref="T:System.Windows.Point" /></summary>
        <returns>Przekonwertowana <see cref="T:System.Windows.Point" /> wartość, która reprezentuje bieżący system <see cref="T:System.Windows.Media.Visual" />współrzędnych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj metody, aby skonwertować obiekt <xref:System.Windows.Point> , który reprezentuje <xref:System.Windows.Media.Visual> bieżący <xref:System.Windows.Point> układ współrzędnych do współrzędnych na ekranie. <xref:System.Windows.Media.Visual.PointToScreen%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PointToScreen">
      <MemberSignature Language="C#" Value="public System.Windows.Point PointToScreen (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Point PointToScreen(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.PointToScreen(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Point PointToScreen(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="member this.PointToScreen : System.Windows.Point -&gt; System.Windows.Point" Usage="visual.PointToScreen point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Wartość, która reprezentuje bieżący system <see cref="T:System.Windows.Media.Visual" />współrzędnych. <see cref="T:System.Windows.Point" /></param>
        <summary>Konwertuje element <see cref="T:System.Windows.Point" /> reprezentujący bieżący układ <see cref="T:System.Windows.Media.Visual" /> współrzędnych do <see cref="T:System.Windows.Point" /> współrzędnych ekranu.</summary>
        <returns>Przekonwertowana <see cref="T:System.Windows.Point" /> wartość we współrzędnych ekranu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj metody, aby <xref:System.Windows.Point> skonwertować Współrzędne ekranu do <xref:System.Windows.Point> obiektu <xref:System.Windows.Media.Visual>, który reprezentuje bieżący system współrzędnych. <xref:System.Windows.Media.Visual.PointFromScreen%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveVisualChild">
      <MemberSignature Language="C#" Value="protected void RemoveVisualChild (System.Windows.Media.Visual child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RemoveVisualChild(class System.Windows.Media.Visual child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.RemoveVisualChild(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RemoveVisualChild (child As Visual)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RemoveVisualChild(System::Windows::Media::Visual ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveVisualChild : System.Windows.Media.Visual -&gt; unit" Usage="visual.RemoveVisualChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="child">Obiekt podrzędny elementu wizualnego do usunięcia z wizualizacji nadrzędnej.</param>
        <summary>Usuwa relację nadrzędny-podrzędny między dwiema wizualizacjami.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Visual.RemoveVisualChild%2A> Metoda usuwa relację nadrzędny-podrzędny między dwiema wizualizacjami. Ta metoda, wraz z <xref:System.Windows.Media.Visual.AddVisualChild%2A> metodą, musi być używana, gdy potrzebna jest większa kontrola niskiego poziomu względem podstawowej implementacji magazynu obiektów podrzędnych Visual. <xref:System.Windows.Media.VisualCollection>może służyć jako domyślna implementacja do przechowywania obiektów podrzędnych.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak zdefiniować niestandardowe wymagania dotyczące magazynu dla wizualnego elementu podrzędnego. W przykładzie zastosowano <xref:System.Windows.Media.Visual.AddVisualChild%2A> metody <xref:System.Windows.Media.Visual.RemoveVisualChild%2A> i, aby skonfigurować relację nadrzędny-podrzędny między wizualizacją nadrzędną `child`a. Aby drzewo wizualne zostało prawidłowo wyliczone, w przykładzie przedstawiono przesłonięte implementacje <xref:System.Windows.Media.Visual.GetVisualChild%2A> metody i <xref:System.Windows.Media.Visual.VisualChildrenCount%2A> właściwości.  
  
> [!NOTE]
>  Chociaż można używać <xref:System.Windows.Media.VisualCollection> do tworzenia relacji nadrzędny-podrzędny między obiektami wizualnymi, bardziej wydajne jest zapewnienie własnej niestandardowej implementacji magazynu, gdy tylko jeden element podrzędny jest połączony z elementem nadrzędnym.  
  
 [!code-csharp[AddVisualChild#AddVisualChild01](~/samples/snippets/csharp/VS_Snippets_Wpf/AddVisualChild/CSharp/Window1.xaml.cs#addvisualchild01)]
 [!code-vb[AddVisualChild#AddVisualChild01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/AddVisualChild/visualbasic/window1.xaml.vb#addvisualchild01)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.VisualCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TransformToAncestor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca transformację, która może być użyta do przekształcenia współrzędnych z <see cref="T:System.Windows.Media.Visual" /> do określonego elementu nadrzędnego obiektu wizualizacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransformToAncestor">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Media3D.GeneralTransform2DTo3D TransformToAncestor (System.Windows.Media.Media3D.Visual3D ancestor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Media3D.GeneralTransform2DTo3D TransformToAncestor(class System.Windows.Media.Media3D.Visual3D ancestor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Media3D.Visual3D)" />
      <MemberSignature Language="VB.NET" Value="Public Function TransformToAncestor (ancestor As Visual3D) As GeneralTransform2DTo3D" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Media3D::GeneralTransform2DTo3D ^ TransformToAncestor(System::Windows::Media::Media3D::Visual3D ^ ancestor);" />
      <MemberSignature Language="F#" Value="member this.TransformToAncestor : System.Windows.Media.Media3D.Visual3D -&gt; System.Windows.Media.Media3D.GeneralTransform2DTo3D" Usage="visual.TransformToAncestor ancestor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Media3D.GeneralTransform2DTo3D</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ancestor" Type="System.Windows.Media.Media3D.Visual3D" />
      </Parameters>
      <Docs>
        <param name="ancestor">, <see cref="T:System.Windows.Media.Media3D.Visual3D" /> Do którego współrzędne są przekształcane.</param>
        <summary>Zwraca transformację, która może być użyta do przekształcenia współrzędnych <see cref="T:System.Windows.Media.Visual" /> z <see cref="T:System.Windows.Media.Media3D.Visual3D" /> do określonego elementu nadrzędnego obiektu wizualizacji.</summary>
        <returns>Transformacja, która może służyć do przekształcenia współrzędnych z <see cref="T:System.Windows.Media.Visual" /> do określonego <see cref="T:System.Windows.Media.Media3D.Visual3D" /> elementu nadrzędnego obiektu wizualizacji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransformToAncestor">
      <MemberSignature Language="C#" Value="public System.Windows.Media.GeneralTransform TransformToAncestor (System.Windows.Media.Visual ancestor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.GeneralTransform TransformToAncestor(class System.Windows.Media.Visual ancestor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Public Function TransformToAncestor (ancestor As Visual) As GeneralTransform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::GeneralTransform ^ TransformToAncestor(System::Windows::Media::Visual ^ ancestor);" />
      <MemberSignature Language="F#" Value="member this.TransformToAncestor : System.Windows.Media.Visual -&gt; System.Windows.Media.GeneralTransform" Usage="visual.TransformToAncestor ancestor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeneralTransform</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ancestor" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="ancestor">, <see cref="T:System.Windows.Media.Visual" /> Do którego współrzędne są przekształcane.</param>
        <summary>Zwraca transformację, która może być użyta do przekształcenia współrzędnych <see cref="T:System.Windows.Media.Visual" /> z <see cref="T:System.Windows.Media.Visual" /> do określonego elementu nadrzędnego obiektu wizualizacji.</summary>
        <returns>Wartość typu <see cref="T:System.Windows.Media.GeneralTransform" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alternatywnie możesz użyć <xref:System.Windows.Media.VisualTreeHelper.GetOffset%2A?displayProperty=nameWithType> metody, aby pobrać przesunięcie obiektu wizualizacji względem jego elementu nadrzędnego. Wartości przesunięcia są zawarte w zwracanej <xref:System.Windows.Vector> wartości.  
  
 [!code-csharp[VisualSnippets#VisualSnippet2](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet2)]
 [!code-vb[VisualSnippets#VisualSnippet2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet2)]  
  
   
  
## Examples  
 Poniższy przykład znacznika pokazuje <xref:System.Windows.Controls.TextBlock> , że jest zagnieżdżony w obrębie dwóch <xref:System.Windows.Controls.StackPanel> obiektów.  
  
 [!code-xaml[VisualSnippets#VisualSnippet7](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window2.xaml#visualsnippet7)]  
  
 Poniższy przykład kodu pokazuje, <xref:System.Windows.Media.Visual.TransformToAncestor%2A> jak za pomocą metody pobrać przesunięcie <xref:System.Windows.Controls.TextBlock> względem elementu zawierającego <xref:System.Windows.Window>. Wartości przesunięcia są zawarte w zwracanym <xref:System.Windows.Media.GeneralTransform>elemencie.  
  
 [!code-csharp[VisualSnippets#VisualSnippet5](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet5)]
 [!code-vb[VisualSnippets#VisualSnippet5](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet5)]  
  
 Przesunięcie uwzględnia <xref:System.Windows.FrameworkElement.Margin%2A> wartości dla wszystkich obiektów w obszarze zawierającym <xref:System.Windows.Window>. W tym przypadku <xref:System.Windows.Vector.X%2A> ma 28 i <xref:System.Windows.Vector.Y%2A> wynosi 28.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="ancestor" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="ancestor" />nie jest elementem nadrzędnym wizualizacji.</exception>
        <exception cref="T:System.InvalidOperationException">Obiekty wizualne nie są powiązane.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransformToDescendant">
      <MemberSignature Language="C#" Value="public System.Windows.Media.GeneralTransform TransformToDescendant (System.Windows.Media.Visual descendant);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.GeneralTransform TransformToDescendant(class System.Windows.Media.Visual descendant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.TransformToDescendant(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Public Function TransformToDescendant (descendant As Visual) As GeneralTransform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::GeneralTransform ^ TransformToDescendant(System::Windows::Media::Visual ^ descendant);" />
      <MemberSignature Language="F#" Value="member this.TransformToDescendant : System.Windows.Media.Visual -&gt; System.Windows.Media.GeneralTransform" Usage="visual.TransformToDescendant descendant" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeneralTransform</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descendant" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="descendant">, <see cref="T:System.Windows.Media.Visual" /> Do którego współrzędne są przekształcane.</param>
        <summary>Zwraca transformację, która może być użyta do przekształcenia współrzędnych z <see cref="T:System.Windows.Media.Visual" /> do określonego elementu podrzędnego obiektu wizualnego.</summary>
        <returns>Wartość typu <see cref="T:System.Windows.Media.GeneralTransform" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład znaczników pokazuje <xref:System.Windows.Controls.TextBlock> , który jest zawarty <xref:System.Windows.Controls.StackPanel> w obiekcie.  
  
 [!code-xaml[VisualSnippets#VisualSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml#visualsnippet4)]  
  
 Poniższy przykład kodu pokazuje, <xref:System.Windows.Media.Visual.TransformToDescendant%2A> jak używać metody do pobierania przesunięcia <xref:System.Windows.Controls.StackPanel> względem jego elementu podrzędnego <xref:System.Windows.Controls.TextBlock>. Wartości przesunięcia są zawarte w zwracanej <xref:System.Windows.Media.GeneralTransform> wartości.  
  
 [!code-csharp[VisualSnippets#VisualSnippet9](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet9)]
 [!code-vb[VisualSnippets#VisualSnippet9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet9)]  
  
 Przesunięcie uwzględnia <xref:System.Windows.FrameworkElement.Margin%2A> wartości dla wszystkich obiektów. W tym przypadku <xref:System.Windows.Vector.X%2A> jest-4, a <xref:System.Windows.Vector.Y%2A> to-4. Wartości przesunięcia są wartościami ujemnymi, ponieważ obiekt nadrzędny ma ujemne przesunięcie względem jego obiektu podrzędnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="descendant" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wizualizacja nie jest elementem nadrzędnym <paramref name="descendant" /> wizualizacji.</exception>
        <exception cref="T:System.InvalidOperationException">Obiekty wizualne nie są powiązane.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransformToVisual">
      <MemberSignature Language="C#" Value="public System.Windows.Media.GeneralTransform TransformToVisual (System.Windows.Media.Visual visual);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.GeneralTransform TransformToVisual(class System.Windows.Media.Visual visual) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.TransformToVisual(System.Windows.Media.Visual)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::GeneralTransform ^ TransformToVisual(System::Windows::Media::Visual ^ visual);" />
      <MemberSignature Language="F#" Value="member this.TransformToVisual : System.Windows.Media.Visual -&gt; System.Windows.Media.GeneralTransform" Usage="visual.TransformToVisual visual" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeneralTransform</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visual" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="visual">, <see cref="T:System.Windows.Media.Visual" /> Do którego współrzędne są przekształcane.</param>
        <summary>Zwraca transformację, która może być użyta do przekształcenia współrzędnych z <see cref="T:System.Windows.Media.Visual" /> do określonego obiektu wizualnego.</summary>
        <returns>Wartość typu <see cref="T:System.Windows.Media.GeneralTransform" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody <xref:System.Windows.Media.Visual.TransformToAncestor%2A> i<xref:System.Windows.Media.Visual.TransformToDescendant%2A> można również użyć do zwrócenia przekształcenia dla obiektu wizualnego.  
  
   
  
## Examples  
 Poniższy przykład znaczników pokazuje <xref:System.Windows.Controls.TextBlock> , który jest zawarty <xref:System.Windows.Controls.StackPanel> w obiekcie.  
  
 [!code-xaml[VisualSnippets#VisualSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml#visualsnippet4)]  
  
 Poniższy przykład kodu pokazuje, <xref:System.Windows.Media.Visual.TransformToVisual%2A> jak używać metody do pobierania przesunięcia <xref:System.Windows.Controls.StackPanel> względem jego elementu podrzędnego <xref:System.Windows.Controls.TextBlock>. Wartości przesunięcia są zawarte w zwracanej <xref:System.Windows.Media.GeneralTransform> wartości.  
  
 [!code-csharp[VisualSnippets#VisualSnippet8](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet8)]
 [!code-vb[VisualSnippets#VisualSnippet8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet8)]  
  
 Przesunięcie uwzględnia <xref:System.Windows.FrameworkElement.Margin%2A> wartości dla wszystkich obiektów. W tym przypadku <xref:System.Windows.Vector.X%2A> jest-4, a <xref:System.Windows.Vector.Y%2A> to-4. Wartości przesunięcia są wartościami ujemnymi, ponieważ obiekt nadrzędny ma ujemne przesunięcie względem jego obiektu podrzędnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="visual" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Obiekty wizualne nie są powiązane.</exception>
      </Docs>
    </Member>
    <Member MemberName="VisualBitmapEffect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffect VisualBitmapEffect { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffect VisualBitmapEffect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualBitmapEffect" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualBitmapEffect As BitmapEffect" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Effects::BitmapEffect ^ VisualBitmapEffect {  protected public:&#xA;System::Windows::Media::Effects::BitmapEffect ^ get(); protected:&#xA; void set(System::Windows::Media::Effects::BitmapEffect ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualBitmapEffect : System.Windows.Media.Effects.BitmapEffect with get, set" Usage="System.Windows.Media.Visual.VisualBitmapEffect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Obsolete("Avoid using BitmapEffects as they have very poor performance characteristics.  They will be deprecated in a future version.  Consider using the UIElement.Effect property and ShaderEffects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Media.Effects.BitmapEffect" /> wartość <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Efekt mapy bitowej dla tego obiektu wizualnego.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.UIElement.BitmapEffect" />
      </Docs>
    </Member>
    <Member MemberName="VisualBitmapEffectInput">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffectInput VisualBitmapEffectInput { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffectInput VisualBitmapEffectInput" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualBitmapEffectInput" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualBitmapEffectInput As BitmapEffectInput" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Effects::BitmapEffectInput ^ VisualBitmapEffectInput {  protected public:&#xA;System::Windows::Media::Effects::BitmapEffectInput ^ get(); protected:&#xA; void set(System::Windows::Media::Effects::BitmapEffectInput ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualBitmapEffectInput : System.Windows.Media.Effects.BitmapEffectInput with get, set" Usage="System.Windows.Media.Visual.VisualBitmapEffectInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Obsolete("Avoid using BitmapEffects as they have very poor performance characteristics.  They will be deprecated in a future version.  Consider using the UIElement.Effect property and ShaderEffects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffectInput</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Media.Effects.BitmapEffectInput" /> wartość <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Wartość wejściowa efektu mapy bitowej dla tego obiektu wizualnego.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.UIElement.BitmapEffectInput" />
      </Docs>
    </Member>
    <Member MemberName="VisualBitmapScalingMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.BitmapScalingMode VisualBitmapScalingMode { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.BitmapScalingMode VisualBitmapScalingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualBitmapScalingMode" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualBitmapScalingMode As BitmapScalingMode" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::BitmapScalingMode VisualBitmapScalingMode {  protected public:&#xA;System::Windows::Media::BitmapScalingMode get(); protected:&#xA; void set(System::Windows::Media::BitmapScalingMode value); };" />
      <MemberSignature Language="F#" Value="member this.VisualBitmapScalingMode : System.Windows.Media.BitmapScalingMode with get, set" Usage="System.Windows.Media.Visual.VisualBitmapScalingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.BitmapScalingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Media.BitmapScalingMode" /> <see cref="T:System.Windows.Media.Visual" />dla elementu.</summary>
        <value><see cref="T:System.Windows.Media.BitmapScalingMode" /> Wartość .<see cref="T:System.Windows.Media.Visual" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualCacheMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.CacheMode VisualCacheMode { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.CacheMode VisualCacheMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualCacheMode" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualCacheMode As CacheMode" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::CacheMode ^ VisualCacheMode {  protected public:&#xA;System::Windows::Media::CacheMode ^ get(); protected:&#xA; void set(System::Windows::Media::CacheMode ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualCacheMode : System.Windows.Media.CacheMode with get, set" Usage="System.Windows.Media.Visual.VisualCacheMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CacheMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia buforowaną reprezentację <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>A <see cref="T:System.Windows.Media.CacheMode" /> który przechowuje w pamięci podręcznej <see cref="T:System.Windows.Media.Visual" />reprezentację.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Visual.VisualCacheMode%2A> Ustaw właściwość, gdy chcesz zwiększyć wydajność dla zawartości, która jest czasochłonna do renderowania. Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Media.BitmapCache>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.CacheMode" />
        <altmember cref="P:System.Windows.Media.ContainerVisual.CacheMode" />
        <altmember cref="T:System.Windows.Media.BitmapCache" />
        <altmember cref="T:System.Windows.Media.BitmapCacheBrush" />
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected virtual int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.Media.Visual.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów podrzędnych dla <see cref="T:System.Windows.Media.Visual" />elementu.</summary>
        <value>Liczba elementów podrzędnych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Windows.Media.Visual> nie ma żadnych elementów podrzędnych. W związku z tym Domyślna implementacja zawsze zwraca wartość 0.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano przesłoniętą <xref:System.Windows.Media.Visual.VisualChildrenCount%2A>implementację programu.  
  
 [!code-csharp[DrawingVisualSample#102a](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingVisualSample/CSharp/Window1.xaml.cs#102a)]
 [!code-vb[DrawingVisualSample#102a](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingVisualSample/visualbasic/window1.xaml.vb#102a)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Klasa, która pochodzi od <see cref="T:System.Windows.Media.Visual" /> , musi zastąpić tę właściwość, a <see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" /> także metodę, aby można było poprawnie wyliczyć drzewo wizualne.</para></block>
      </Docs>
    </Member>
    <Member MemberName="VisualClearTypeHint">
      <MemberSignature Language="C#" Value="protected internal System.Windows.Media.ClearTypeHint VisualClearTypeHint { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.ClearTypeHint VisualClearTypeHint" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualClearTypeHint" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property VisualClearTypeHint As ClearTypeHint" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::Media::ClearTypeHint VisualClearTypeHint { System::Windows::Media::ClearTypeHint get(); void set(System::Windows::Media::ClearTypeHint value); };" />
      <MemberSignature Language="F#" Value="member this.VisualClearTypeHint : System.Windows.Media.ClearTypeHint with get, set" Usage="System.Windows.Media.Visual.VisualClearTypeHint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ClearTypeHint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see cref="T:System.Windows.Media.ClearTypeHint" /> określającą sposób renderowania technologii ClearType <see cref="T:System.Windows.Media.Visual" />w.</summary>
        <value>A <see cref="T:System.Windows.Media.ClearTypeHint" /> .<see cref="T:System.Windows.Media.Visual" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualClip">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Geometry VisualClip { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Geometry VisualClip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualClip" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualClip As Geometry" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Geometry ^ VisualClip {  protected public:&#xA;System::Windows::Media::Geometry ^ get(); protected:&#xA; void set(System::Windows::Media::Geometry ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualClip : System.Windows.Media.Geometry with get, set" Usage="System.Windows.Media.Visual.VisualClip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia region <see cref="T:System.Windows.Media.Visual" /> przycinania <see cref="T:System.Windows.Media.Geometry" /> jako wartość.</summary>
        <value>Wartość regionu Clip wizualizacji jako <see cref="T:System.Windows.Media.Geometry" /> typ.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms746710(v=vs.90)">Instrukcje: Tworzenie regionu klipu</related>
      </Docs>
    </Member>
    <Member MemberName="VisualEdgeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.EdgeMode VisualEdgeMode { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.EdgeMode VisualEdgeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualEdgeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualEdgeMode As EdgeMode" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::EdgeMode VisualEdgeMode {  protected public:&#xA;System::Windows::Media::EdgeMode get(); protected:&#xA; void set(System::Windows::Media::EdgeMode value); };" />
      <MemberSignature Language="F#" Value="member this.VisualEdgeMode : System.Windows.Media.EdgeMode with get, set" Usage="System.Windows.Media.Visual.VisualEdgeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.EdgeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tryb <see cref="T:System.Windows.Media.Visual" /> krawędzi <see cref="T:System.Windows.Media.EdgeMode" /> jako wartość.</summary>
        <value><see cref="T:System.Windows.Media.EdgeMode" /> Wartość wizualizacji.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualEffect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.Effect VisualEffect { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.Effect VisualEffect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualEffect" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualEffect As Effect" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Effects::Effect ^ VisualEffect {  protected public:&#xA;System::Windows::Media::Effects::Effect ^ get(); protected:&#xA; void set(System::Windows::Media::Effects::Effect ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualEffect : System.Windows.Media.Effects.Effect with get, set" Usage="System.Windows.Media.Visual.VisualEffect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.Effect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia efekt mapy bitowej, <see cref="T:System.Windows.Media.Visual" />który ma zostać zastosowany do.</summary>
        <value><see cref="T:System.Windows.Media.Effects.Effect" /> Reprezentuje efekt mapy bitowej.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Media.Effects.Effect" />
        <altmember cref="T:System.Windows.Media.Effects.ShaderEffect" />
      </Docs>
    </Member>
    <Member MemberName="VisualOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Vector VisualOffset { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Vector VisualOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualOffset As Vector" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Vector VisualOffset {  protected public:&#xA;System::Windows::Vector get(); protected:&#xA; void set(System::Windows::Vector value); };" />
      <MemberSignature Language="F#" Value="member this.VisualOffset : System.Windows.Vector with get, set" Usage="System.Windows.Media.Visual.VisualOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Vector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość przesunięcia obiektu wizualnego.</summary>
        <value>A <see cref="T:System.Windows.Vector" /> , która określa wartość przesunięcia.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualOpacity">
      <MemberSignature Language="C#" Value="public double VisualOpacity { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 VisualOpacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualOpacity" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualOpacity As Double" />
      <MemberSignature Language="C++ CLI" Value="public:  property double VisualOpacity {  protected public:&#xA;double get(); protected:&#xA; void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.VisualOpacity : double with get, set" Usage="System.Windows.Media.Visual.VisualOpacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nieprzezroczystość <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Wartość nieprzezroczystości wizualizacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość nieprzezroczystości <xref:System.Windows.Media.Visual> jest wyrażona w postaci wartości z przedziału od 0 do 1. Wartość 0 oznacza, że element jest całkowicie przezroczysty, a wartość 1 oznacza, że element jest całkowicie nieprzezroczysty. Wartość 0,5 wskazuje, że element jest 50 procent nieprzezroczysty. Wartości mniejsze od 0 są traktowane jako 0; wartości, które są większe niż 1 są traktowane jako 1.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualOpacityMask">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush VisualOpacityMask { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush VisualOpacityMask" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualOpacityMask" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualOpacityMask As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Brush ^ VisualOpacityMask {  protected public:&#xA;System::Windows::Media::Brush ^ get(); protected:&#xA; void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualOpacityMask : System.Windows.Media.Brush with get, set" Usage="System.Windows.Media.Visual.VisualOpacityMask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Media.Brush" /> wartość reprezentującą maskę <see cref="T:System.Windows.Media.Visual" />nieprzezroczystości.</summary>
        <value><see cref="T:System.Windows.Media.Brush" /> Reprezentujący wartość maski nieprzezroczystości wizualizacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Maska nieprzezroczystości jest <xref:System.Windows.Media.Brush> stosowana do wszystkich masek kanału alfa dla renderowanej zawartości tej wizualizacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualParent">
      <MemberSignature Language="C#" Value="protected System.Windows.DependencyObject VisualParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject VisualParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualParent" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property VisualParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Windows::DependencyObject ^ VisualParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualParent : System.Windows.DependencyObject" Usage="System.Windows.Media.Visual.VisualParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element nadrzędny drzewa wizualnego obiektu wizualnego.</summary>
        <value><see cref="T:System.Windows.Media.Visual" /> Element nadrzędny.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Parent" />
        <altmember cref="T:System.Windows.Media.VisualTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="VisualScrollableAreaClip">
      <MemberSignature Language="C#" Value="public Nullable&lt;System.Windows.Rect&gt; VisualScrollableAreaClip { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;valuetype System.Windows.Rect&gt; VisualScrollableAreaClip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualScrollableAreaClip" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualScrollableAreaClip As Nullable(Of Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:  property Nullable&lt;System::Windows::Rect&gt; VisualScrollableAreaClip {  protected public:&#xA;Nullable&lt;System::Windows::Rect&gt; get(); protected:&#xA; void set(Nullable&lt;System::Windows::Rect&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.VisualScrollableAreaClip : Nullable&lt;System.Windows.Rect&gt; with get, set" Usage="System.Windows.Media.Visual.VisualScrollableAreaClip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Windows.Rect&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia przycięty obszar przewijalny dla <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>, Który reprezentuje przewijany obszar przycinania lub <see langword="null" /> Jeśli nie przypisano obszaru przycinania. <see cref="T:System.Windows.Rect" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> Ustaw właściwość, aby włączyć przyspieszanie przewijania podczas renderowania w oprogramowaniu. Jest to przydatne w scenariuszach renderowania zdalnego, takich jak uruchamianie przez Pulpit zdalny lub uruchamianie na maszynie wirtualnej. Ustaw tę właściwość dla elementu nadrzędnego, którego elementy podrzędne zostaną przeprzewijane. <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> Ustawienie właściwości nie ma wpływu, gdy renderowanie jest przyspieszone.  
  
 <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> Właściwość włącza określone, zaawansowane scenariusze. Poniższa lista zawiera zastrzeżenia, które są stosowane podczas korzystania z <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> właściwości.  
  
-   Tło przewijanego obszaru musi być nieprzezroczyste lub następuje przewinięcie artefaktów.  
  
-   Właściwość <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> przyspiesza przewijanie tylko wtedy, gdy WPF jest renderowana w oprogramowaniu. Na przykład taka sytuacja występuje, gdy aplikacja działa przez Pulpit zdalny lub działa lokalnie na maszynie wirtualnej.  
  
-   Zachowanie przewijania jest niezmienione podczas renderowania sprzętowego. Aby zapobiec różnicom w zachowaniu przewijania, należy zachować <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> Właściwość włączoną dla sprzętu i oprogramowania.  
  
-   Przekształcenia Obróć i pochyl powodują wyłączenie przyspieszania przewijania. Przekształceń skalowania i w poziomie lub w pionie powyżej przewinięcie regionu działają prawidłowo i nie należy wyłączać przyspieszenia przewijania.  
  
-   Zmiana poddrzewa lub wyzwolenie części obszaru przewijanego do ponownego rysowania przy użyciu animacji zachowuje się zgodnie z oczekiwaniami, ale utracisz korzyść przyspieszenia przewijania dla ponownie narysowanego obszaru. Każda animacja, która unieważnia przewijany obszar w tej samej klatce, w której występuje przewijanie eliminuje korzyść tej optymalizacji.  
  
-   <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> Prostokąt przyciąga do wewnątrz do pikseli. W związku z tym rozmiar przypiętego prostokąta przewijania jest zawsze mniejszy lub równy rozmiarowi ustawionemu przez użytkownika.  
  
-   Przesunięcia w dół. Oznacza to, że różnica poprzedniego przyciągania i bieżącego przyciągania jest zawsze liczbą całkowitą pikseli.  
  
-   Testy trafień można wyłączyć nawet o jeden piksel.  
  
-   Zaokrąglanie układu powinno być włączone, ponieważ zapewnia, że krawędzie obszarów przewijanych i obszaru klienta okna granicy są przyciągane do krawędzi pikseli, co skutkuje prawidłowym wyrównaniem.  
  
-   Przyspieszenie przewijania nie działa w przypadku okien z warstwami. Oznacza to, że system Windows, w którym AllowTransparency = = true, Window. WindowName = = None i tak dalej.  
  
-   Przyspieszenie przewijania nie występuje podczas renderowania pełnego okna.  
  
-   Przyspieszenie przewijania nie działa, gdy okno zawiera dwa monitory.  
  
-   Przyspieszenie przewijania nie działa w obecności pośrednich obiektów docelowych renderowania w łańcuchu nadrzędnym przewijanego elementu. Poniższa lista zawiera niektóre z tych pośrednich elementów docelowych renderowania.  
  
    -   Film  
  
    -   Efekty  
  
    -   DrawingBrushes  
  
    -   VisualBrushes  
  
    -   OpacityMasks  
  
    -   Nieprzezroczystość  
  
-   Tylko jedno przyspieszone przewijanie może wystąpić na klatkę. Może istnieć wiele szybszych obszarów przewijania, ale tylko jedna z nich może wykonywać przyspieszenie przewijania w ramce. Obszar, który jest przewijany jest nieokreślony.  
  
-   Przyspieszenie przewijania obsługuje zawartość powyżej regionu przewijania (w kolejności z), która nie jest przewijana wraz z resztą zawartości. System oblicza wszystkie niepotrzebne regiony zanieczyszczone i wykonuje przyspieszone przewijanie, ale wysyła kilka dodatkowych map bitowych za pośrednictwem sieci, aby przenieść przypadkowo przewinięcie części do odpowiedniej pozycji na ekranie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualTextHintingMode">
      <MemberSignature Language="C#" Value="protected internal System.Windows.Media.TextHintingMode VisualTextHintingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.TextHintingMode VisualTextHintingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualTextHintingMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property VisualTextHintingMode As TextHintingMode" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::Media::TextHintingMode VisualTextHintingMode { System::Windows::Media::TextHintingMode get(); void set(System::Windows::Media::TextHintingMode value); };" />
      <MemberSignature Language="F#" Value="member this.VisualTextHintingMode : System.Windows.Media.TextHintingMode with get, set" Usage="System.Windows.Media.Visual.VisualTextHintingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.TextHintingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see cref="T:System.Windows.Media.TextHintingMode" />. <see cref="T:System.Windows.Media.Visual" /></summary>
        <value>Zastosowano<see cref="T:System.Windows.Media.Visual" />do. <see cref="T:System.Windows.Media.TextHintingMode" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualTextRenderingMode">
      <MemberSignature Language="C#" Value="protected internal System.Windows.Media.TextRenderingMode VisualTextRenderingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.TextRenderingMode VisualTextRenderingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualTextRenderingMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property VisualTextRenderingMode As TextRenderingMode" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::Media::TextRenderingMode VisualTextRenderingMode { System::Windows::Media::TextRenderingMode get(); void set(System::Windows::Media::TextRenderingMode value); };" />
      <MemberSignature Language="F#" Value="member this.VisualTextRenderingMode : System.Windows.Media.TextRenderingMode with get, set" Usage="System.Windows.Media.Visual.VisualTextRenderingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.TextRenderingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see cref="T:System.Windows.Media.TextRenderingMode" />. <see cref="T:System.Windows.Media.Visual" /></summary>
        <value>Zastosowano<see cref="T:System.Windows.Media.Visual" />do. <see cref="T:System.Windows.Media.TextRenderingMode" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform VisualTransform { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform VisualTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualTransform" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualTransform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Transform ^ VisualTransform {  protected public:&#xA;System::Windows::Media::Transform ^ get(); protected:&#xA; void set(System::Windows::Media::Transform ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualTransform : System.Windows.Media.Transform with get, set" Usage="System.Windows.Media.Visual.VisualTransform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Media.Transform" /> wartość <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Wartość przekształcenia wizualizacji.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualXSnappingGuidelines">
      <MemberSignature Language="C#" Value="public System.Windows.Media.DoubleCollection VisualXSnappingGuidelines { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.DoubleCollection VisualXSnappingGuidelines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualXSnappingGuidelines" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualXSnappingGuidelines As DoubleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::DoubleCollection ^ VisualXSnappingGuidelines {  protected public:&#xA;System::Windows::Media::DoubleCollection ^ get(); protected:&#xA; void set(System::Windows::Media::DoubleCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualXSnappingGuidelines : System.Windows.Media.DoubleCollection with get, set" Usage="System.Windows.Media.Visual.VisualXSnappingGuidelines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.DoubleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolekcję wytycznych x-współrzędnej (pionowej).</summary>
        <value>Podstawowa kolekcja wizualizacji x.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przyciąganie do pikseli to proces, w którym ustalany jest układ zawartości, aby krawędzie obiektów były renderowane w pikselach specyficznych dla urządzenia. System [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] grafiki używa jednostek niezależnych od urządzenia, aby umożliwić Rozwiązywanie problemów i niezależność urządzeń. Każdy niezależny piksel urządzenia automatycznie skaluje się [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] przy użyciu ustawienia systemu. Dzięki [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] temu aplikacje są odpowiednie do skalowania dla różnych [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] ustawień i umożliwiają [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)]automatyczne rozpoznawanie aplikacji.  
  
 [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] Niezależność może jednak spowodować nieregularne renderowanie krawędzi z powodu wygładzania. Te artefakty, często postrzegane jako rozmyte lub "miękkie", mogą wystąpić, gdy lokalizacja krawędzi znajduje się w środku piksela urządzenia, a nie między pikselami urządzeń. Aby rozwiązać ten problem, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] program umożliwia stosowanie krawędzi obiektów w drzewie wizualnym do "przyciągania" do pikseli urządzenia, eliminując niewygładzone krawędzie powstające przez wygładzanie.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.VisualTreeHelper.GetXSnappingGuidelines(System.Windows.Media.Visual)" />
      </Docs>
    </Member>
    <Member MemberName="VisualYSnappingGuidelines">
      <MemberSignature Language="C#" Value="public System.Windows.Media.DoubleCollection VisualYSnappingGuidelines { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.DoubleCollection VisualYSnappingGuidelines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualYSnappingGuidelines" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualYSnappingGuidelines As DoubleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::DoubleCollection ^ VisualYSnappingGuidelines {  protected public:&#xA;System::Windows::Media::DoubleCollection ^ get(); protected:&#xA; void set(System::Windows::Media::DoubleCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualYSnappingGuidelines : System.Windows.Media.DoubleCollection with get, set" Usage="System.Windows.Media.Visual.VisualYSnappingGuidelines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.DoubleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolekcję wskazówek dotyczących osi y (w poziomie).</summary>
        <value>Podstawowa kolekcja współrzędnej y wizualizacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przyciąganie do pikseli to proces, w którym ustalany jest układ zawartości, aby krawędzie obiektów były renderowane w pikselach specyficznych dla urządzenia. System [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] grafiki używa jednostek niezależnych od urządzenia, aby umożliwić Rozwiązywanie problemów i niezależność urządzeń. Każdy niezależny piksel urządzenia automatycznie skaluje się [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] przy użyciu ustawienia systemu. Dzięki [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] temu aplikacje są odpowiednie do skalowania dla różnych [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] ustawień i umożliwiają [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)]automatyczne rozpoznawanie aplikacji.  
  
 [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] Niezależność może jednak spowodować nieregularne renderowanie krawędzi z powodu wygładzania. Te artefakty, często postrzegane jako rozmyte lub "miękkie", mogą wystąpić, gdy lokalizacja krawędzi znajduje się w środku piksela urządzenia, a nie między pikselami urządzeń. Aby rozwiązać ten problem, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] program umożliwia stosowanie krawędzi obiektów w drzewie wizualnym do "przyciągania" do pikseli urządzenia, eliminując niewygładzone krawędzie powstające przez wygładzanie.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.VisualTreeHelper.GetYSnappingGuidelines(System.Windows.Media.Visual)" />
      </Docs>
    </Member>
  </Members>
</Type>

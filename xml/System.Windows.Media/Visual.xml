<Type Name="Visual" FullName="System.Windows.Media.Visual">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3e9ff5e020c2a0b40cc9f1a9cf79c83b9cddf495" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30712571" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Visual : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Visual extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Visual" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Visual&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Visual abstract : System::Windows::DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zapewnia obsługę renderowania na platformie WPF, w tym trafień testowania i przekształcenia współrzędnych i ograniczenia pole obliczeń.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Visual> Podstawowe abstrakcji, z którego jest klasa co <xref:System.Windows.FrameworkElement> pochodzi z obiektu. Służy również jako punkt wejścia dla zapisywania nowych formantów [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]i na wiele sposobów można traktować jako równoważne uchwyt okna (HWND) w [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] modelu aplikacji.  
  
 <xref:System.Windows.Media.Visual> Obiekt jest podstawowa [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] obiektu, którego podstawową rolą jest zapewnia obsługę renderowania. Formanty interfejsu użytkownika, takich jak <xref:System.Windows.Controls.Button> i <xref:System.Windows.Controls.TextBox>, pochodzi z <xref:System.Windows.Media.Visual> klasy, a następnie użyć <xref:System.Windows.Media.Visual> właściwości zdefiniowane dla przechowywanie ich renderowania danych. <xref:System.Windows.Media.Visual> Obiektu zapewnia obsługę następujących czynności:  
  
-   Dane wyjściowe wyświetlania: renderowanie utrwalonego, serializacji rysowania zawartości obiektu visual.  
  
-   Przekształcenia: Przekształcenia element wizualny.  
  
-   Wycinka: Zapewnianie wycinka region obsługi dla obiektu visual.  
  
-   Testowanie trafień: Określanie, czy określony współrzędnych (punkt) lub geometrii znajduje się w granicach obiektu visual.  
  
-   Ograniczenia pole obliczenia: Określanie prostokąt ograniczający element wizualny.  
  
 Pod względem architektury <xref:System.Windows.Media.Visual> obiekt nie ma obsługi innych wymagań rozwoju aplikacji / [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] funkcje, które nie są bezpośrednio związane z jego renderowania, takie jak następujące:  
  
-   Obsługa zdarzeń  
  
-   Układ  
  
-   Style  
  
-   Powiązanie danych  
  
-   Globalizacja  
  
 <xref:System.Windows.Media.Visual> jest dostępna w publicznej klasy abstrakcyjnej, z którego dalsze klasy mogą pochodzić. Na poniższej ilustracji przedstawiono hierarchii istniejących obiektów visual, które są zdefiniowane w [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] architektury.  
  
 ![Diagram klas pochodnych obiekt wizualny](~/add/media/visualclass01.png "Diagram klas pochodnych obiekt wizualny")  
Hierarchia klas Visual  
  
 W niektórych przypadkach chronione elementy członkowskie, które są zdefiniowane jako <xref:System.Windows.Media.Visual> są widoczne jako bardziej łatwo dostępne elementy członkowskie o podobnej nazwie w pochodnej <xref:System.Windows.UIElement> klasy.  
  
 Aby uzyskać więcej informacji, zobacz [Przegląd renderowania grafiki WPF](~/docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
 A <xref:System.Windows.Media.Visual> ma ograniczoną liczbę poziomów. W poprzednich wersjach programu .NET Framework to maksymalna głębokość został 255. Ten limit jest nieodpowiedni dla układy, które mają wiele poziomów w drzewie wizualnym.  
  
 W [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], maksymalna głębokość <xref:System.Windows.Media.Visual> jest 2047, dzięki czemu znacznie lepszą drzewa wizualnego. W większości aplikacji nie istnieje wystarczająca ilość miejsca na stosie przejść przez wiele poziomów, a w rezultacie <xref:System.StackOverflowException> podczas układu. Domyślny rozmiar stosu, zgłoszenia tego wyjątku zwykle gdy głębokość drzewa wynosi około 800, co odpowiada około 190 zagnieżdżone <xref:System.Windows.Controls.TreeViewItem> obiektów.  
  
 Jeśli wyjątek przez aplikację, musisz mieć bardziej drzewa wizualnego może zwiększyć rozmiar stosu aplikacji. Przy użyciu opcji /STACK w czasie kompilacji lub za pomocą narzędzia polecenia EDITBIN można zwiększyć rozmiar stosu. Zwiększanie rozmiaru stosu mogą wpływać na wydajność aplikacji. Aby uzyskać więcej informacji, zobacz [alokacji stosu](http://go.microsoft.com/fwlink/?LinkId=165510) i [opcje polecenia EDITBIN](http://go.microsoft.com/fwlink/?LinkId=165511).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Media.VisualCollection" />
    <altmember cref="T:System.Windows.Media.VisualTreeHelper" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Visual ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Visual();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Zapewnia podstawowe Inicjowanie obiektów pochodzących z <see cref="T:System.Windows.Media.Visual" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddVisualChild">
      <MemberSignature Language="C#" Value="protected void AddVisualChild (System.Windows.Media.Visual child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AddVisualChild(class System.Windows.Media.Visual child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.AddVisualChild(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AddVisualChild (child As Visual)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AddVisualChild(System::Windows::Media::Visual ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="child">Podrzędny obiekt visual do dodania do elementu nadrzędnego visual.</param>
        <summary>Definiuje relacji nadrzędny podrzędny między dwoma elementami Visual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Visual.AddVisualChild%2A> Metody konfiguruje relacji nadrzędny podrzędny między dwoma obiektami visual. Tej metody należy użyć, gdy będziesz potrzebować większą kontrolę niskiego poziomu nad ta implementacja magazynu obiektów podrzędnych visual. <xref:System.Windows.Media.VisualCollection> może służyć jako domyślną implementację do przechowywania obiektów podrzędnych.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób definiowania wymagania dotyczące magazynu niestandardowego dla elementu podrzędnego visual. W przykładzie użyto <xref:System.Windows.Media.Visual.AddVisualChild%2A> i <xref:System.Windows.Media.Visual.RemoveVisualChild%2A> metody konfiguruje relacji nadrzędny podrzędny między elementem nadrzędnym visual i `child`. Aby drzewa wizualnego, które mają zostać wyliczone poprawnie, w przykładzie przedstawiono implementacji przesłoniętych <xref:System.Windows.Media.Visual.GetVisualChild%2A> — metoda i <xref:System.Windows.Media.Visual.VisualChildrenCount%2A> właściwości.  
  
> [!NOTE]
>  Chociaż można używać <xref:System.Windows.Media.VisualCollection> można utworzyć relacji między obiektami visual nadrzędny podrzędny, jest bardziej wydajne zapewnienie implementacji niestandardowych magazynu powiązane tylko jeden element podrzędny elementu nadrzędnego.  
  
 [!code-csharp[AddVisualChild#AddVisualChild01](~/samples/snippets/csharp/VS_Snippets_Wpf/AddVisualChild/CSharp/Window1.xaml.cs#addvisualchild01)]
 [!code-vb[AddVisualChild#AddVisualChild01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/AddVisualChild/visualbasic/window1.xaml.vb#addvisualchild01)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.VisualCollection" />
      </Docs>
    </Member>
    <Member MemberName="FindCommonVisualAncestor">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject FindCommonVisualAncestor (System.Windows.DependencyObject otherVisual);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject FindCommonVisualAncestor(class System.Windows.DependencyObject otherVisual) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.FindCommonVisualAncestor(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindCommonVisualAncestor (otherVisual As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ FindCommonVisualAncestor(System::Windows::DependencyObject ^ otherVisual);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherVisual" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="otherVisual">Obiekt wizualny typu <see cref="T:System.Windows.DependencyObject" />.</param>
        <summary>Zwraca element nadrzędny wspólnej dwóch obiektów visual.</summary>
        <returns>Wspólnego elementu nadrzędnego obiektu visual i <paramref name="otherVisual" /> jeśli taki istnieje; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekty 2W i 3W mogą mieć wspólne visual obiektów nadrzędnych, dlatego można przekazać <xref:System.Windows.Media.Media3D.Visual3D> dla `otherVisual`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks obiektu visual w <see cref="T:System.Windows.Media.VisualCollection" />.</param>
        <summary>Zwraca określony <see cref="T:System.Windows.Media.Visual" /> w obiekcie nadrzędnym <see cref="T:System.Windows.Media.VisualCollection" />.</summary>
        <returns>Obiekt podrzędny w <see cref="T:System.Windows.Media.VisualCollection" /> pod określonym <paramref name="index" /> wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Windows.Media.Visual> nie ma elementów podrzędnych. W związku z tym zwraca zawsze wartość domyślną implementację <xref:System.ArgumentOutOfRangeException>.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano implementacji przesłoniętych <xref:System.Windows.Media.Visual.GetVisualChild%2A>.  
  
 [!code-csharp[DrawingVisualSample#102b](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingVisualSample/CSharp/Window1.xaml.cs#102b)]
 [!code-vb[DrawingVisualSample#102b](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingVisualSample/visualbasic/window1.xaml.vb#102b)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Klasa, która pochodzi z <see cref="T:System.Windows.Media.Visual" /> muszą przesłaniać tę metodę, a także <see cref="P:System.Windows.Media.Visual.VisualChildrenCount" /> właściwości do drzewa wizualnego, które mają zostać wyliczone poprawnie.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="HitTestCore">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy wartości punktów lub geometrii znajduje się w granicach obiektu visual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Media.GeometryHitTestResult HitTestCore (System.Windows.Media.GeometryHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.GeometryHitTestResult HitTestCore(class System.Windows.Media.GeometryHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.GeometryHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function HitTestCore (hitTestParameters As GeometryHitTestParameters) As GeometryHitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Media::GeometryHitTestResult ^ HitTestCore(System::Windows::Media::GeometryHitTestParameters ^ hitTestParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeometryHitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.GeometryHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">A <see cref="T:System.Windows.Media.GeometryHitTestParameters" /> obiekt, który określa <see cref="T:System.Windows.Media.Geometry" /> trafienie badanie.</param>
        <summary>Określa, czy wartości geometrycznej znajduje się w granicach obiektu visual.</summary>
        <returns>A <see cref="T:System.Windows.Media.GeometryHitTestResult" /> reprezentujący wynik testu trafienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można zastąpić domyślne trafień testowania pomocy technicznej dla obiekt wizualny przez zastąpienie <xref:System.Windows.Media.Visual.HitTestCore%2A> metody. Oznacza to, że po wywołaniu <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> metoda, implementacji przesłoniętych <xref:System.Windows.Media.Visual.HitTestCore%2A> jest wywoływana. Przesłoniętą metodę wywoływaną, gdy testu trafienia mieści się w prostokątem obiektu visual nawet jeśli Współrzędna wypada poza geometrii obiektu visual.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób przesłonięcia <xref:System.Windows.Media.Visual.HitTestCore%28System.Windows.Media.GeometryHitTestParameters%29> metody. Jedną z przyczyn się, że należy przesłonić tę metodę ma na celu dostarczenie dodatkowych funkcji podczas testowania trafień.  
  
 [!code-csharp[HitTestingOverview#HitTestingOverviewSnippet13](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestingOverview/CSharp/GeometryHitTest.cs#hittestingoverviewsnippet13)]
 [!code-vb[HitTestingOverview#HitTestingOverviewSnippet13](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestingOverview/visualbasic/geometryhittest.vb#hittestingoverviewsnippet13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Media.HitTestResult HitTestCore (System.Windows.Media.PointHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.HitTestResult HitTestCore(class System.Windows.Media.PointHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.PointHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function HitTestCore (hitTestParameters As PointHitTestParameters) As HitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Media::HitTestResult ^ HitTestCore(System::Windows::Media::PointHitTestParameters ^ hitTestParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.PointHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">A <see cref="T:System.Windows.Media.PointHitTestParameters" /> obiekt, który określa <see cref="T:System.Windows.Point" /> trafienie badanie.</param>
        <summary>Określa, czy wartość współrzędnych punktu znajduje się w granicach obiektu visual.</summary>
        <returns>A <see cref="T:System.Windows.Media.HitTestResult" /> reprezentujący <see cref="T:System.Windows.Media.Visual" /> która jest zwracana z testu trafienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można zastąpić trafień domyślnego badania obsługi obiektów visual przez zastąpienie <xref:System.Windows.Media.Visual.HitTestCore%2A> metody. Oznacza to, że po wywołaniu <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> metoda, implementacji przesłoniętych <xref:System.Windows.Media.Visual.HitTestCore%2A> jest wywoływana. Przesłoniętą metodę wywoływaną, gdy testu trafienia mieści się w prostokątem obiektu visual nawet jeśli Współrzędna wypada poza geometrii obiektu visual.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób przesłonięcia <xref:System.Windows.Media.Visual.HitTestCore%28System.Windows.Media.PointHitTestParameters%29> metody. Jedną z przyczyn się, że należy przesłonić tę metodę ma na celu dostarczenie dodatkowych funkcji podczas testowania trafień.  
  
 [!code-csharp[HitTestingOverview#107](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestingOverview/CSharp/Window1.xaml.cs#107)]
 [!code-vb[HitTestingOverview#107](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestingOverview/visualbasic/window1.xaml.vb#107)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAncestorOf">
      <MemberSignature Language="C#" Value="public bool IsAncestorOf (System.Windows.DependencyObject descendant);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAncestorOf(class System.Windows.DependencyObject descendant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.IsAncestorOf(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAncestorOf (descendant As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAncestorOf(System::Windows::DependencyObject ^ descendant);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descendant" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="descendant">Wartości typu <see cref="T:System.Windows.DependencyObject" />.</param>
        <summary>Określa, czy obiekt visual jest elementem nadrzędnym elementów podrzędnych obiektu visual.</summary>
        <returns>
          <see langword="true" /> Jeśli obiekt visual jest elementem nadrzędnym <paramref name="descendant" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDescendantOf">
      <MemberSignature Language="C#" Value="public bool IsDescendantOf (System.Windows.DependencyObject ancestor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDescendantOf(class System.Windows.DependencyObject ancestor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.IsDescendantOf(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDescendantOf (ancestor As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDescendantOf(System::Windows::DependencyObject ^ ancestor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ancestor" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="ancestor">Wartości typu <see cref="T:System.Windows.DependencyObject" />.</param>
        <summary>Określa, czy obiekt visual jest podrzędny elementu nadrzędnego obiektu visual.</summary>
        <returns>
          <see langword="true" /> Jeśli obiekt visual jest elementem potomnym <paramref name="ancestor" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChanged (oldDpi As DpiScale, newDpi As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChanged(System::Windows::DpiScale oldDpi, System::Windows::DpiScale newDpi);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" />
      </Parameters>
      <Docs>
        <param name="oldDpi">Skali DPI poprzedniego ustawienia.</param>
        <param name="newDpi">Skala DPI nowe ustawienie.</param>
        <summary>Wywoływane, gdy wartość DPI, w którym ten widok jest renderowany zmiany.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualChildrenChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnVisualChildrenChanged (System.Windows.DependencyObject visualAdded, System.Windows.DependencyObject visualRemoved);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnVisualChildrenChanged(class System.Windows.DependencyObject visualAdded, class System.Windows.DependencyObject visualRemoved) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.OnVisualChildrenChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnVisualChildrenChanged (visualAdded As DependencyObject, visualRemoved As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnVisualChildrenChanged(System::Windows::DependencyObject ^ visualAdded, System::Windows::DependencyObject ^ visualRemoved);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visualAdded" Type="System.Windows.DependencyObject" />
        <Parameter Name="visualRemoved" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="visualAdded">
          <see cref="T:System.Windows.Media.Visual" /> Który został dodany do kolekcji</param>
        <param name="visualRemoved">
          <see cref="T:System.Windows.Media.Visual" /> Który został usunięty z kolekcji</param>
        <summary>Wywoływane, gdy <see cref="T:System.Windows.Media.VisualCollection" /> obiektu visual jest modyfikowany.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Wartości typu <see cref="T:System.Windows.DependencyObject" /> reprezentujący poprzedniego elementu nadrzędnego <see cref="T:System.Windows.Media.Visual" /> obiektu. Jeśli <see cref="T:System.Windows.Media.Visual" /> obiekt nie ma nadrzędnego poprzedniej, wartość parametru jest <see langword="null" />.</param>
        <summary>Wywoływane, gdy zostanie zmieniona visual obiekt nadrzędny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa, która pochodzi z <xref:System.Windows.Media.Visual> można przesłonić tę metodę.  
  
 Brak żadne zdarzenie "VisualParentChanged", pod warunkiem, aby raporty do wystąpień tej zmiany. W związku z tym muszą przesłaniać tę metodę, aby obsługiwać scenariusze powiadomień i podaj wersją wystąpienia powiadomienia, jeśli jest częścią Twojego scenariusza.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano implementacji przesłoniętych <xref:System.Windows.Media.Visual.OnVisualParentChanged%2A>.  
  
 [!code-csharp[VisualSnippets#VisualSnippet10](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet10)]
 [!code-vb[VisualSnippets#VisualSnippet10](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Visual.VisualParent" />
      </Docs>
    </Member>
    <Member MemberName="PointFromScreen">
      <MemberSignature Language="C#" Value="public System.Windows.Point PointFromScreen (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Point PointFromScreen(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.PointFromScreen(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Point PointFromScreen(System::Windows::Point point);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">
          <see cref="T:System.Windows.Point" /> Wartość we współrzędnych ekranu.</param>
        <summary>Konwertuje <see cref="T:System.Windows.Point" /> we współrzędnych ekranu do <see cref="T:System.Windows.Point" /> reprezentujący bieżący współrzędnych <see cref="T:System.Windows.Media.Visual" />.</summary>
        <returns>Skonwertowany <see cref="T:System.Windows.Point" /> wartość, która reprezentuje bieżący współrzędnych <see cref="T:System.Windows.Media.Visual" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Media.Visual.PointToScreen%2A> metodę, aby przekonwertować <xref:System.Windows.Point> reprezentujący bieżący współrzędnych <xref:System.Windows.Media.Visual> do <xref:System.Windows.Point> we współrzędnych ekranu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PointToScreen">
      <MemberSignature Language="C#" Value="public System.Windows.Point PointToScreen (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Point PointToScreen(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.PointToScreen(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Point PointToScreen(System::Windows::Point point);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">
          <see cref="T:System.Windows.Point" /> Wartość, która reprezentuje bieżący współrzędnych <see cref="T:System.Windows.Media.Visual" />.</param>
        <summary>Konwertuje <see cref="T:System.Windows.Point" /> reprezentujący bieżący współrzędnych <see cref="T:System.Windows.Media.Visual" /> do <see cref="T:System.Windows.Point" /> we współrzędnych ekranu.</summary>
        <returns>Skonwertowany <see cref="T:System.Windows.Point" /> wartość we współrzędnych ekranu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Media.Visual.PointFromScreen%2A> metodę, aby przekonwertować <xref:System.Windows.Point> we współrzędnych ekranu do <xref:System.Windows.Point> reprezentujący bieżący współrzędnych <xref:System.Windows.Media.Visual>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveVisualChild">
      <MemberSignature Language="C#" Value="protected void RemoveVisualChild (System.Windows.Media.Visual child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RemoveVisualChild(class System.Windows.Media.Visual child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.RemoveVisualChild(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RemoveVisualChild (child As Visual)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RemoveVisualChild(System::Windows::Media::Visual ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="child">Podrzędny obiekt visual do usunięcia z elementu nadrzędnego visual.</param>
        <summary>Usuwa relacji nadrzędny podrzędny między dwoma elementami Visual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Visual.RemoveVisualChild%2A> Metoda usuwa relacji nadrzędny podrzędny między dwoma elementami Visual. Ta metoda wraz z programem <xref:System.Windows.Media.Visual.AddVisualChild%2A> metody, należy użyć, jeśli potrzebujesz większej kontroli niskiego poziomu nad ta implementacja magazynu obiektów podrzędnych visual. <xref:System.Windows.Media.VisualCollection> może służyć jako domyślną implementację do przechowywania obiektów podrzędnych.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób definiowania wymagania dotyczące magazynu niestandardowego dla elementu podrzędnego visual. W przykładzie użyto <xref:System.Windows.Media.Visual.AddVisualChild%2A> i <xref:System.Windows.Media.Visual.RemoveVisualChild%2A> metody konfiguruje relacji nadrzędny podrzędny między elementem nadrzędnym visual i `child`. Aby drzewa wizualnego, które mają zostać wyliczone poprawnie, w przykładzie przedstawiono implementacji przesłoniętych <xref:System.Windows.Media.Visual.GetVisualChild%2A> — metoda i <xref:System.Windows.Media.Visual.VisualChildrenCount%2A> właściwości.  
  
> [!NOTE]
>  Chociaż można używać <xref:System.Windows.Media.VisualCollection> można utworzyć relacji między obiektami visual nadrzędny podrzędny, jest bardziej wydajne zapewnienie implementacji niestandardowych magazynu powiązane tylko jeden element podrzędny elementu nadrzędnego.  
  
 [!code-csharp[AddVisualChild#AddVisualChild01](~/samples/snippets/csharp/VS_Snippets_Wpf/AddVisualChild/CSharp/Window1.xaml.cs#addvisualchild01)]
 [!code-vb[AddVisualChild#AddVisualChild01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/AddVisualChild/visualbasic/window1.xaml.vb#addvisualchild01)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.VisualCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TransformToAncestor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca przekształcania, który może służyć do przekształcenia współrzędnych z <see cref="T:System.Windows.Media.Visual" /> do określonego elementu nadrzędnego obiektu visual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransformToAncestor">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Media3D.GeneralTransform2DTo3D TransformToAncestor (System.Windows.Media.Media3D.Visual3D ancestor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Media3D.GeneralTransform2DTo3D TransformToAncestor(class System.Windows.Media.Media3D.Visual3D ancestor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Media3D.Visual3D)" />
      <MemberSignature Language="VB.NET" Value="Public Function TransformToAncestor (ancestor As Visual3D) As GeneralTransform2DTo3D" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Media3D::GeneralTransform2DTo3D ^ TransformToAncestor(System::Windows::Media::Media3D::Visual3D ^ ancestor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Media3D.GeneralTransform2DTo3D</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ancestor" Type="System.Windows.Media.Media3D.Visual3D" />
      </Parameters>
      <Docs>
        <param name="ancestor">
          <see cref="T:System.Windows.Media.Media3D.Visual3D" /> Są przekształcone współrzędne.</param>
        <summary>Zwraca przekształcania, który może służyć do przekształcenia współrzędnych z <see cref="T:System.Windows.Media.Visual" /> do określonego <see cref="T:System.Windows.Media.Media3D.Visual3D" /> elementu nadrzędnego obiektu visual.</summary>
        <returns>Przekształcanie, który może służyć do przekształcenia współrzędnych z <see cref="T:System.Windows.Media.Visual" /> do określonego <see cref="T:System.Windows.Media.Media3D.Visual3D" /> elementu nadrzędnego obiektu visual.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransformToAncestor">
      <MemberSignature Language="C#" Value="public System.Windows.Media.GeneralTransform TransformToAncestor (System.Windows.Media.Visual ancestor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.GeneralTransform TransformToAncestor(class System.Windows.Media.Visual ancestor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Public Function TransformToAncestor (ancestor As Visual) As GeneralTransform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::GeneralTransform ^ TransformToAncestor(System::Windows::Media::Visual ^ ancestor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeneralTransform</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ancestor" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="ancestor">
          <see cref="T:System.Windows.Media.Visual" /> Są przekształcone współrzędne.</param>
        <summary>Zwraca przekształcania, który może służyć do przekształcenia współrzędnych z <see cref="T:System.Windows.Media.Visual" /> do określonego <see cref="T:System.Windows.Media.Visual" /> elementu nadrzędnego obiektu visual.</summary>
        <returns>Wartości typu <see cref="T:System.Windows.Media.GeneralTransform" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alternatywnie można użyć <xref:System.Windows.Media.VisualTreeHelper.GetOffset%2A?displayProperty=nameWithType> metoda pobierania przesunięcie obiektu visual względem jego elementu nadrzędnego. Wartości przesunięcia są zawarte w zwróconym <xref:System.Windows.Vector> wartość.  
  
 [!code-csharp[VisualSnippets#VisualSnippet2](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet2)]
 [!code-vb[VisualSnippets#VisualSnippet2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet2)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano kod znaczników <xref:System.Windows.Controls.TextBlock> zagnieżdżony w dwóch <xref:System.Windows.Controls.StackPanel> obiektów.  
  
 [!code-xaml[VisualSnippets#VisualSnippet7](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window2.xaml#visualsnippet7)]  
  
 Poniższy przykładowy kod przedstawia sposób użycia <xref:System.Windows.Media.Visual.TransformToAncestor%2A> metoda pobierania przesunięcie <xref:System.Windows.Controls.TextBlock> względem zawierający <xref:System.Windows.Window>. Wartości przesunięcia są zawarte w zwróconym <xref:System.Windows.Media.GeneralTransform>.  
  
 [!code-csharp[VisualSnippets#VisualSnippet5](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet5)]
 [!code-vb[VisualSnippets#VisualSnippet5](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet5)]  
  
 Przesunięcie bierze pod uwagę <xref:System.Windows.FrameworkElement.Margin%2A> wartości dla wszystkich obiektów w ramach zawierający <xref:System.Windows.Window>. W takim przypadku <xref:System.Windows.Vector.X%2A> jest 28 i <xref:System.Windows.Vector.Y%2A> jest 28.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="ancestor" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ancestor" /> nie jest elementem nadrzędnym elementu wizualnego.</exception>
        <exception cref="T:System.InvalidOperationException">Obiekt visual nie są powiązane.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransformToDescendant">
      <MemberSignature Language="C#" Value="public System.Windows.Media.GeneralTransform TransformToDescendant (System.Windows.Media.Visual descendant);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.GeneralTransform TransformToDescendant(class System.Windows.Media.Visual descendant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.TransformToDescendant(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Public Function TransformToDescendant (descendant As Visual) As GeneralTransform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::GeneralTransform ^ TransformToDescendant(System::Windows::Media::Visual ^ descendant);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeneralTransform</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descendant" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="descendant">
          <see cref="T:System.Windows.Media.Visual" /> Są przekształcone współrzędne.</param>
        <summary>Zwraca przekształcania, który może służyć do przekształcenia współrzędnych z <see cref="T:System.Windows.Media.Visual" /> do podrzędnym określonego obiektu visual.</summary>
        <returns>Wartości typu <see cref="T:System.Windows.Media.GeneralTransform" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano kod znaczników <xref:System.Windows.Controls.TextBlock> zawarty w <xref:System.Windows.Controls.StackPanel> obiektu.  
  
 [!code-xaml[VisualSnippets#VisualSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml#visualsnippet4)]  
  
 Poniższy przykładowy kod przedstawia sposób użycia <xref:System.Windows.Media.Visual.TransformToDescendant%2A> metoda pobierania przesunięcie <xref:System.Windows.Controls.StackPanel> względem jego podrzędny <xref:System.Windows.Controls.TextBlock>. Wartości przesunięcia są zawarte w zwróconym <xref:System.Windows.Media.GeneralTransform> wartość.  
  
 [!code-csharp[VisualSnippets#VisualSnippet9](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet9)]
 [!code-vb[VisualSnippets#VisualSnippet9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet9)]  
  
 Przesunięcie bierze pod uwagę <xref:System.Windows.FrameworkElement.Margin%2A> wartości dla wszystkich obiektów. W takim przypadku <xref:System.Windows.Vector.X%2A> jest -4, i <xref:System.Windows.Vector.Y%2A> jest -4. Wartości przesunięcia są ujemne wartości, ponieważ obiekt nadrzędny negatywnie jest przesuwane względem jego obiektu podrzędnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="descendant" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Element wizualny nie jest elementem nadrzędnym <paramref name="descendant" /> visual.</exception>
        <exception cref="T:System.InvalidOperationException">Obiekt visual nie są powiązane.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransformToVisual">
      <MemberSignature Language="C#" Value="public System.Windows.Media.GeneralTransform TransformToVisual (System.Windows.Media.Visual visual);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.GeneralTransform TransformToVisual(class System.Windows.Media.Visual visual) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.TransformToVisual(System.Windows.Media.Visual)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::GeneralTransform ^ TransformToVisual(System::Windows::Media::Visual ^ visual);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeneralTransform</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visual" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="visual">
          <see cref="T:System.Windows.Media.Visual" /> Są przekształcone współrzędne.</param>
        <summary>Zwraca przekształcania, który może służyć do przekształcenia współrzędnych z <see cref="T:System.Windows.Media.Visual" /> do określonego obiektu visual.</summary>
        <returns>Wartości typu <see cref="T:System.Windows.Media.GeneralTransform" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Visual.TransformToAncestor%2A> i <xref:System.Windows.Media.Visual.TransformToDescendant%2A> metody mogą służyć do zwrócenia transformacji dla obiekt wizualny.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano kod znaczników <xref:System.Windows.Controls.TextBlock> zawarty w <xref:System.Windows.Controls.StackPanel> obiektu.  
  
 [!code-xaml[VisualSnippets#VisualSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml#visualsnippet4)]  
  
 Poniższy przykładowy kod przedstawia sposób użycia <xref:System.Windows.Media.Visual.TransformToVisual%2A> metoda pobierania przesunięcie <xref:System.Windows.Controls.StackPanel> względem jego podrzędny <xref:System.Windows.Controls.TextBlock>. Wartości przesunięcia są zawarte w zwróconym <xref:System.Windows.Media.GeneralTransform> wartość.  
  
 [!code-csharp[VisualSnippets#VisualSnippet8](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet8)]
 [!code-vb[VisualSnippets#VisualSnippet8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet8)]  
  
 Przesunięcie bierze pod uwagę <xref:System.Windows.FrameworkElement.Margin%2A> wartości dla wszystkich obiektów. W takim przypadku <xref:System.Windows.Vector.X%2A> jest -4, i <xref:System.Windows.Vector.Y%2A> jest -4. Wartości przesunięcia są ujemne wartości, ponieważ obiekt nadrzędny negatywnie jest przesuwane względem jego obiektu podrzędnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="visual" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Obiekt visual nie są powiązane.</exception>
      </Docs>
    </Member>
    <Member MemberName="VisualBitmapEffect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffect VisualBitmapEffect { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffect VisualBitmapEffect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualBitmapEffect" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualBitmapEffect As BitmapEffect" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Effects::BitmapEffect ^ VisualBitmapEffect {  protected public:&#xA;System::Windows::Media::Effects::BitmapEffect ^ get(); protected:&#xA; void set(System::Windows::Media::Effects::BitmapEffect ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Media.Effects.BitmapEffect" /> wartość <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Efekt mapy bitowej dla tego obiektu visual.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.UIElement.BitmapEffect" />
      </Docs>
    </Member>
    <Member MemberName="VisualBitmapEffectInput">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffectInput VisualBitmapEffectInput { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffectInput VisualBitmapEffectInput" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualBitmapEffectInput" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualBitmapEffectInput As BitmapEffectInput" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Effects::BitmapEffectInput ^ VisualBitmapEffectInput {  protected public:&#xA;System::Windows::Media::Effects::BitmapEffectInput ^ get(); protected:&#xA; void set(System::Windows::Media::Effects::BitmapEffectInput ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffectInput</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Media.Effects.BitmapEffectInput" /> wartość <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Wartość wejściowa efekt mapy bitowej dla tego obiektu visual.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.UIElement.BitmapEffectInput" />
      </Docs>
    </Member>
    <Member MemberName="VisualBitmapScalingMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.BitmapScalingMode VisualBitmapScalingMode { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.BitmapScalingMode VisualBitmapScalingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualBitmapScalingMode" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualBitmapScalingMode As BitmapScalingMode" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::BitmapScalingMode VisualBitmapScalingMode {  protected public:&#xA;System::Windows::Media::BitmapScalingMode get(); protected:&#xA; void set(System::Windows::Media::BitmapScalingMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.BitmapScalingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Media.BitmapScalingMode" /> dla <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>
          <see cref="T:System.Windows.Media.BitmapScalingMode" /> Wartość <see cref="T:System.Windows.Media.Visual" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualCacheMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.CacheMode VisualCacheMode { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.CacheMode VisualCacheMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualCacheMode" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualCacheMode As CacheMode" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::CacheMode ^ VisualCacheMode {  protected public:&#xA;System::Windows::Media::CacheMode ^ get(); protected:&#xA; void set(System::Windows::Media::CacheMode ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CacheMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia buforowane reprezentację <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>A <see cref="T:System.Windows.Media.CacheMode" /> przechowuje buforowane reprezentację <see cref="T:System.Windows.Media.Visual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw <xref:System.Windows.Media.Visual.VisualCacheMode%2A> właściwości, gdy potrzebne w celu zwiększenia wydajności dla zawartości, która jest czasochłonne do renderowania. Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Media.BitmapCache>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.CacheMode" />
        <altmember cref="P:System.Windows.Media.ContainerVisual.CacheMode" />
        <altmember cref="T:System.Windows.Media.BitmapCache" />
        <altmember cref="T:System.Windows.Media.BitmapCacheBrush" />
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected virtual int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów podrzędnych dla <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Liczba elementów podrzędnych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Windows.Media.Visual> nie ma elementów podrzędnych. W związku z tym Domyślna implementacja zawsze zwraca wartość 0.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano implementacji przesłoniętych <xref:System.Windows.Media.Visual.VisualChildrenCount%2A>.  
  
 [!code-csharp[DrawingVisualSample#102a](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingVisualSample/CSharp/Window1.xaml.cs#102a)]
 [!code-vb[DrawingVisualSample#102a](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingVisualSample/visualbasic/window1.xaml.vb#102a)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Klasa, która pochodzi z <see cref="T:System.Windows.Media.Visual" /> musi zastąpić tę właściwość, a także <see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" /> metody dla drzewa wizualnego, które mają zostać wyliczone poprawnie.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="VisualClearTypeHint">
      <MemberSignature Language="C#" Value="protected internal System.Windows.Media.ClearTypeHint VisualClearTypeHint { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.ClearTypeHint VisualClearTypeHint" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualClearTypeHint" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property VisualClearTypeHint As ClearTypeHint" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::Media::ClearTypeHint VisualClearTypeHint { System::Windows::Media::ClearTypeHint get(); void set(System::Windows::Media::ClearTypeHint value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ClearTypeHint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Media.ClearTypeHint" /> określający, jak ClearType jest renderowany w <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>A <see cref="T:System.Windows.Media.ClearTypeHint" /> z <see cref="T:System.Windows.Media.Visual" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualClip">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Geometry VisualClip { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Geometry VisualClip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualClip" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualClip As Geometry" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Geometry ^ VisualClip {  protected public:&#xA;System::Windows::Media::Geometry ^ get(); protected:&#xA; void set(System::Windows::Media::Geometry ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obszar przycinania z <see cref="T:System.Windows.Media.Visual" /> jako <see cref="T:System.Windows.Media.Geometry" /> wartość.</summary>
        <value>Wartości regionu klip visual jako <see cref="T:System.Windows.Media.Geometry" /> typu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualEdgeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.EdgeMode VisualEdgeMode { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.EdgeMode VisualEdgeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualEdgeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualEdgeMode As EdgeMode" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::EdgeMode VisualEdgeMode {  protected public:&#xA;System::Windows::Media::EdgeMode get(); protected:&#xA; void set(System::Windows::Media::EdgeMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.EdgeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tryb edge <see cref="T:System.Windows.Media.Visual" /> jako <see cref="T:System.Windows.Media.EdgeMode" /> wartość.</summary>
        <value>
          <see cref="T:System.Windows.Media.EdgeMode" /> Wartość elementu wizualnego.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualEffect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.Effect VisualEffect { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.Effect VisualEffect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualEffect" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualEffect As Effect" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Effects::Effect ^ VisualEffect {  protected public:&#xA;System::Windows::Media::Effects::Effect ^ get(); protected:&#xA; void set(System::Windows::Media::Effects::Effect ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.Effect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia efekt mapy bitowej do zastosowania do <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>
          <see cref="T:System.Windows.Media.Effects.Effect" /> Reprezentujący efekt mapy bitowej.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Media.Effects.Effect" />
        <altmember cref="T:System.Windows.Media.Effects.ShaderEffect" />
      </Docs>
    </Member>
    <Member MemberName="VisualOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Vector VisualOffset { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Vector VisualOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualOffset As Vector" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Vector VisualOffset {  protected public:&#xA;System::Windows::Vector get(); protected:&#xA; void set(System::Windows::Vector value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Vector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość przesunięcia obiektu visual.</summary>
        <value>A <see cref="T:System.Windows.Vector" /> , który określa wartość przesunięcia.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualOpacity">
      <MemberSignature Language="C#" Value="public double VisualOpacity { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 VisualOpacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualOpacity" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualOpacity As Double" />
      <MemberSignature Language="C++ CLI" Value="public:  property double VisualOpacity {  protected public:&#xA;double get(); protected:&#xA; void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nieprzezroczystość <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Wartość nieprzezroczystości elementu wizualnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość nieprzezroczystość <xref:System.Windows.Media.Visual> jest wyrażony jako wartość z zakresu od 0 do 1. Wartość 0 wskazuje, czy element jest całkowicie niewidoczne, natomiast wartość 1 oznacza, że element jest całkowicie nieprzezroczysta. Wartość 0,5 oznacza element 50 procent przezroczystości. Wartości, które jest mniejsza niż 0 są traktowane jako 0; wartości, które są większe niż 1 są traktowane jako 1.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualOpacityMask">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush VisualOpacityMask { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush VisualOpacityMask" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualOpacityMask" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualOpacityMask As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Brush ^ VisualOpacityMask {  protected public:&#xA;System::Windows::Media::Brush ^ get(); protected:&#xA; void set(System::Windows::Media::Brush ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Media.Brush" /> wartość, która reprezentuje maskę przezroczystości <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>A <see cref="T:System.Windows.Media.Brush" /> reprezentujący wartość maski nieprzezroczystość elementu wizualnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Maska nieprzezroczystość jest <xref:System.Windows.Media.Brush> do dowolnego maskowania kanału alfa dla renderowanej zawartości tym visual zastosowano.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualParent">
      <MemberSignature Language="C#" Value="protected System.Windows.DependencyObject VisualParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject VisualParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualParent" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property VisualParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Windows::DependencyObject ^ VisualParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element nadrzędny drzewa wizualnego obiektu visual.</summary>
        <value>
          <see cref="T:System.Windows.Media.Visual" /> Nadrzędnej.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Parent" />
        <altmember cref="T:System.Windows.Media.VisualTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="VisualScrollableAreaClip">
      <MemberSignature Language="C#" Value="public Nullable&lt;System.Windows.Rect&gt; VisualScrollableAreaClip { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;valuetype System.Windows.Rect&gt; VisualScrollableAreaClip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualScrollableAreaClip" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualScrollableAreaClip As Nullable(Of Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:  property Nullable&lt;System::Windows::Rect&gt; VisualScrollableAreaClip {  protected public:&#xA;Nullable&lt;System::Windows::Rect&gt; get(); protected:&#xA; void set(Nullable&lt;System::Windows::Rect&gt; value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Windows.Rect&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia przyciętą przewijany obszar dla <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>A <see cref="T:System.Windows.Rect" /> reprezentujący obszaru przycinania przewijanego lub <see langword="null" /> Jeśli nie przypisano żadnych obszaru przycinania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> przyspieszony właściwości, aby włączyć przewijanie podczas renderowania w oprogramowaniu. Jest to przydatne w scenariuszach renderowania zdalnego, takich jak uruchomiony za pośrednictwem pulpitu zdalnego lub działający na maszynie wirtualnej. Ustaw tę właściwość w elemencie nadrzędnym, którego elementy podrzędne będą przewijane. Ustawienie <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> właściwość nie ma wpływu podczas renderowania jest przyspieszony sprzętu.  
  
 <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> Właściwości umożliwia określone, zaawansowanych scenariuszy. Poniższa lista zawiera ostrzeżenia, które są stosowane, gdy używasz <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> właściwości.  
  
-   Tła obszaru przewijane musi być nieprzezroczyste, lub nastąpi przewijanie artefaktów.  
  
-   <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> Właściwość przyspiesza przewijanie tylko podczas renderowania WPF w oprogramowaniu. Na przykład ta sytuacja występuje, gdy aplikacja jest uruchomiona za pośrednictwem pulpitu zdalnego lub działa lokalnie na maszynie wirtualnej.  
  
-   Zachowanie przewijania niezmieniona podczas renderowania sprzętu. Aby zapobiec różnice w zachowanie przewijania, należy mieć <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> właściwość włączone dla sprzętu i oprogramowania.  
  
-   Obracanie i pochylanie transformacje wyłączyć przyspieszonego przewijania. Transformacje skali poziomej lub pionowej tłumaczeń powyżej przewijane region działa poprawnie i nie można wyłączyć przyspieszanie przewijania.  
  
-   Zmiana poddrzewo lub wyzwalania części przewijany obszar ponowne za pośrednictwem animacji działać zgodnie z oczekiwaniami, ale utracone korzyści przyspieszonego przewijania ponownie wystawionych obszaru. Wszelkie animacji, która unieważnia obszaru przewijane w tej samej ramki, w których przewijanie występuje eliminuje zaletą tego rodzaju optymalizacji.  
  
-   <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> Prostokąt czynnego przyciąganie do pikseli. W związku z tym przypięty rozmiar przewijania prostokąt jest zawsze mniejsze lub równe rozmiarowi ustawiony.  
  
-   Przesunięcia przyciąganie w dół. Oznacza to, że różnica poprzedniego przypięty przesunięcie i przesunięcie przypięty bieżącego jest zawsze liczby całkowitej określającej liczbę pikseli.  
  
-   Testy trafień mogą być wyłączone przez maksymalnie jeden piksel.  
  
-   Układ zaokrąglania powinna być włączona, ponieważ zapewnia krawędzi przewijanego obszarami i obszarem klienckim okna granic mają być przyciągane do pikseli, co powoduje wyrównanie poprawne.  
  
-   Przewijanie przyspieszenie nie działa w systemie windows warstwowego. Oznacza to windows, w których AllowTransparency == window.windowstyle ma wartość true, brak == i tak dalej.  
  
-   Przewijanie przyspieszenie nie występuje podczas renderowania pełnego okna.  
  
-   Przewijanie przyspieszenie nie działa, gdy okno pokrywającej dwóch monitorów.  
  
-   Przewijanie przyspieszenie nie działa, obecności obiektów docelowych renderowania pośrednie w łańcuchu przewijane elementu nadrzędnego. Poniższa lista przedstawia niektóre z nich pośrednich elementy docelowe renderowania.  
  
    -   Klipy  
  
    -   Efekty  
  
    -   DrawingBrushes  
  
    -   VisualBrushes  
  
    -   OpacityMasks  
  
    -   Nieprzezroczystość.  
  
-   Tylko jeden przyspieszonego przewijania może się zdarzyć na klatkę. Może istnieć wiele obszarów przyspieszonego przewijania, ale tylko jeden z nich można wykonywać przyspieszonego przewijania w ramce. Obszar jest przewijane jest nieokreślony.  
  
-   Przewijanie przyspieszenie obsługuje zawartość powyżej regionie przewijania (w kolejności), które nie jest przewijane z resztą zawartości. System oblicza wszystkie niezbędne zanieczyszczone regiony i kończy działanie z przyspieszonego przewijania, ale wysyła kilka dodatkowych bitmapy przez sieć można przenieść przypadkowo przewijane części z powrotem do odpowiedniej pozycji, na ekranie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualTextHintingMode">
      <MemberSignature Language="C#" Value="protected internal System.Windows.Media.TextHintingMode VisualTextHintingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.TextHintingMode VisualTextHintingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualTextHintingMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property VisualTextHintingMode As TextHintingMode" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::Media::TextHintingMode VisualTextHintingMode { System::Windows::Media::TextHintingMode get(); void set(System::Windows::Media::TextHintingMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.TextHintingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Media.TextHintingMode" /> z <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>
          <see cref="T:System.Windows.Media.TextHintingMode" /> Stosowane do <see cref="T:System.Windows.Media.Visual" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualTextRenderingMode">
      <MemberSignature Language="C#" Value="protected internal System.Windows.Media.TextRenderingMode VisualTextRenderingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.TextRenderingMode VisualTextRenderingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualTextRenderingMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property VisualTextRenderingMode As TextRenderingMode" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::Media::TextRenderingMode VisualTextRenderingMode { System::Windows::Media::TextRenderingMode get(); void set(System::Windows::Media::TextRenderingMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.TextRenderingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Media.TextRenderingMode" /> z <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>
          <see cref="T:System.Windows.Media.TextRenderingMode" /> Stosowane do <see cref="T:System.Windows.Media.Visual" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform VisualTransform { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform VisualTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualTransform" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualTransform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Transform ^ VisualTransform {  protected public:&#xA;System::Windows::Media::Transform ^ get(); protected:&#xA; void set(System::Windows::Media::Transform ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Media.Transform" /> wartość <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Wartość transformacji elementu wizualnego.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualXSnappingGuidelines">
      <MemberSignature Language="C#" Value="public System.Windows.Media.DoubleCollection VisualXSnappingGuidelines { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.DoubleCollection VisualXSnappingGuidelines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualXSnappingGuidelines" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualXSnappingGuidelines As DoubleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::DoubleCollection ^ VisualXSnappingGuidelines {  protected public:&#xA;System::Windows::Media::DoubleCollection ^ get(); protected:&#xA; void set(System::Windows::Media::DoubleCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.DoubleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolekcję współrzędną x wytyczne (pionową).</summary>
        <value>Kolekcja wytyczne współrzędną x elementu wizualnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przyciąganie do pikseli to proces, w którym układ zawartości jest ustalona tak, aby krawędzie obiektów mają być renderowane na następującą liczbę pikseli urządzenia. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Grafiki system używa jednostki niezależnych od urządzenia, aby umożliwić niezależność rozdzielczość i urządzenia. Każdego piksela niezależnie od urządzenia jest automatycznie skalowany w systemie [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] ustawienie. Zapewnia to [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] aplikacji odpowiednie skalowanie dla różnych [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] ustawienia i powoduje, że aplikacja automatycznie [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)]— pamiętać.  
  
 Jednak to [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] niezależność można utworzyć renderowania nieregularne krawędzi, z powodu wygładzanie. Te artefakty często postrzegane jako krawędzi rozmyte lub "słowo soft", może wystąpić, gdy lokalizację krawędzi znajduje się w środku pikseli urządzenia, a nie od pikseli urządzenia. Aby rozwiązać ten problem, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] umożliwia krawędzie obiektów w drzewie wizualnym "przyciągane" do pikseli urządzenia wyeliminowanie nietrwałego krawędzi utworzonego przez wygładzanie.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.VisualTreeHelper.GetXSnappingGuidelines(System.Windows.Media.Visual)" />
      </Docs>
    </Member>
    <Member MemberName="VisualYSnappingGuidelines">
      <MemberSignature Language="C#" Value="public System.Windows.Media.DoubleCollection VisualYSnappingGuidelines { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.DoubleCollection VisualYSnappingGuidelines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualYSnappingGuidelines" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualYSnappingGuidelines As DoubleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::DoubleCollection ^ VisualYSnappingGuidelines {  protected public:&#xA;System::Windows::Media::DoubleCollection ^ get(); protected:&#xA; void set(System::Windows::Media::DoubleCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.DoubleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia współrzędną y (poziomy) wskazówek dotyczących kolekcji.</summary>
        <value>Kolekcja wytyczne współrzędną y elementu wizualnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przyciąganie do pikseli to proces, w którym układ zawartości jest ustalona tak, aby krawędzie obiektów mają być renderowane na następującą liczbę pikseli urządzenia. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Grafiki system używa jednostki niezależnych od urządzenia, aby umożliwić niezależność rozdzielczość i urządzenia. Każdego piksela niezależnie od urządzenia jest automatycznie skalowany w systemie [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] ustawienie. Zapewnia to [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] aplikacji odpowiednie skalowanie dla różnych [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] ustawienia i powoduje, że aplikacja automatycznie [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)]— pamiętać.  
  
 Jednak to [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] niezależność można utworzyć renderowania nieregularne krawędzi, z powodu wygładzanie. Te artefakty często postrzegane jako krawędzi rozmyte lub "słowo soft", może wystąpić, gdy lokalizację krawędzi znajduje się w środku pikseli urządzenia, a nie od pikseli urządzenia. Aby rozwiązać ten problem, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] umożliwia krawędzie obiektów w drzewie wizualnym "przyciągane" do pikseli urządzenia wyeliminowanie nietrwałego krawędzi utworzonego przez wygładzanie.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.VisualTreeHelper.GetYSnappingGuidelines(System.Windows.Media.Visual)" />
      </Docs>
    </Member>
  </Members>
</Type>
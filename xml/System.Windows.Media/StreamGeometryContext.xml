<Type Name="StreamGeometryContext" FullName="System.Windows.Media.StreamGeometryContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4e6a87d9924c298998a73f24b742bed1e883596d" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39736976" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class StreamGeometryContext : System.Windows.Threading.DispatcherObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit StreamGeometryContext extends System.Windows.Threading.DispatcherObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.StreamGeometryContext" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class StreamGeometryContext&#xA;Inherits DispatcherObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class StreamGeometryContext abstract : System::Windows::Threading::DispatcherObject, IDisposable" />
  <TypeSignature Language="F#" Value="type StreamGeometryContext = class&#xA;    inherit DispatcherObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>W tym artykule opisano typy geometryczne, przy użyciu polecenia rysowania. Ta klasa jest używana z <see cref="T:System.Windows.Media.StreamGeometry" /> klasy w celu utworzenia uproszczone geometrię, która nie obsługuje wiązania danych, animacji lub modyfikacji.</summary>
    <remarks>To be added.</remarks>
    <exception cref="T:System.InvalidOperationException">Aby dodać segment bez uruchamiania rysunku, wywołując nastąpiła próba <see cref="M:System.Windows.Media.StreamGeometryContext.BeginFigure(System.Windows.Point,System.Boolean,System.Boolean)" /> metody.</exception>
    <altmember cref="T:System.Windows.Media.StreamGeometry" />
    <altmember cref="T:System.Windows.Media.PathGeometry" />
  </Docs>
  <Members>
    <Member MemberName="ArcTo">
      <MemberSignature Language="C#" Value="public abstract void ArcTo (System.Windows.Point point, System.Windows.Size size, double rotationAngle, bool isLargeArc, System.Windows.Media.SweepDirection sweepDirection, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ArcTo(valuetype System.Windows.Point point, valuetype System.Windows.Size size, float64 rotationAngle, bool isLargeArc, valuetype System.Windows.Media.SweepDirection sweepDirection, bool isStroked, bool isSmoothJoin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.StreamGeometryContext.ArcTo(System.Windows.Point,System.Windows.Size,System.Double,System.Boolean,System.Windows.Media.SweepDirection,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ArcTo(System::Windows::Point point, System::Windows::Size size, double rotationAngle, bool isLargeArc, System::Windows::Media::SweepDirection sweepDirection, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="F#" Value="abstract member ArcTo : System.Windows.Point * System.Windows.Size * double * bool * System.Windows.Media.SweepDirection * bool * bool -&gt; unit" Usage="streamGeometryContext.ArcTo (point, size, rotationAngle, isLargeArc, sweepDirection, isStroked, isSmoothJoin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="size" Type="System.Windows.Size" />
        <Parameter Name="rotationAngle" Type="System.Double" />
        <Parameter Name="isLargeArc" Type="System.Boolean" />
        <Parameter Name="sweepDirection" Type="System.Windows.Media.SweepDirection" />
        <Parameter Name="isStroked" Type="System.Boolean" />
        <Parameter Name="isSmoothJoin" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="point">Docelowy punkt końcowy łuku.</param>
        <param name="size">Promień (połowę szerokości i wysokości równej połowie wysokości) elipsy, w których obwód jest używany do rysowania kąta. Dlatego w przypadku bardzo zaokrąglony we wszystkich kierunkach oval łuk zostanie zaokrąglony, jeśli niemal płaskiej będzie łuku. Na przykład bardzo dużych szerokość i wysokość reprezentuje oval bardzo duże, który pozwoli uzyskać nieznaczną krzywiznę dla kąta.</param>
        <param name="rotationAngle">Kąt obrotu oval, który określa krzywą. Z tego parametru można obracać krzywiznę łuku.</param>
        <param name="isLargeArc">
          <see langword="true" /> Aby narysować większa niż 180 stopni; łuk w przeciwnym razie <see langword="false" />.</param>
        <param name="sweepDirection">Wartość, która wskazuje, czy łuku <see cref="F:System.Windows.Media.SweepDirection.Clockwise" /> lub <see cref="F:System.Windows.Media.SweepDirection.Counterclockwise" /> kierunku.</param>
        <param name="isStroked">
          <see langword="true" /> zapewnienie segmentu malowania, kiedy <see cref="T:System.Windows.Media.Pen" /> jest używany do renderowania segmentu; w przeciwnym razie <see langword="false" />.</param>
        <param name="isSmoothJoin">
          <see langword="true" /> traktowanie sprzężenie ten segment i poprzedniego segmentu jako rogu podczas malowania z <see cref="T:System.Windows.Media.Pen" />; w przeciwnym razie <see langword="false" />.</param>
        <summary>Rysuje łuk do określonego punktu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa punktu końcowego poprzedniego segmentu jako punktu początkowego. Jeśli jest to pierwszy segment na ilustracji, używa punktu określonego przez <xref:System.Windows.Media.StreamGeometryContext.BeginFigure%2A> metodę jako jego punkt początkowy.  
  
 A <xref:System.Windows.Media.StreamGeometry> nie może być serializowany, jeśli zawiera on <xref:System.Windows.Media.Transform> lub dowolnego innego niż malowania lub bez segmentów.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak rysowanie łuk przy użyciu <xref:System.Windows.Media.StreamGeometryContext.ArcTo%2A> metody.  
  
 [!code-csharp[GeometriesMiscSnippets_procedural_snip#StreamGeometryArcToExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/CSharp/StreamGeometryArcToExample.cs#streamgeometryarctoexamplewholepage)]
 [!code-vb[GeometriesMiscSnippets_procedural_snip#StreamGeometryArcToExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/visualbasic/streamgeometryarctoexample.vb#streamgeometryarctoexamplewholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.BezierTo(System.Windows.Point,System.Windows.Point,System.Windows.Point,System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.PolyBezierTo(System.Collections.Generic.IList{System.Windows.Point},System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.QuadraticBezierTo(System.Windows.Point,System.Windows.Point,System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.PolyQuadraticBezierTo(System.Collections.Generic.IList{System.Windows.Point},System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="BeginFigure">
      <MemberSignature Language="C#" Value="public abstract void BeginFigure (System.Windows.Point startPoint, bool isFilled, bool isClosed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginFigure(valuetype System.Windows.Point startPoint, bool isFilled, bool isClosed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.StreamGeometryContext.BeginFigure(System.Windows.Point,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub BeginFigure (startPoint As Point, isFilled As Boolean, isClosed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void BeginFigure(System::Windows::Point startPoint, bool isFilled, bool isClosed);" />
      <MemberSignature Language="F#" Value="abstract member BeginFigure : System.Windows.Point * bool * bool -&gt; unit" Usage="streamGeometryContext.BeginFigure (startPoint, isFilled, isClosed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPoint" Type="System.Windows.Point" />
        <Parameter Name="isFilled" Type="System.Boolean" />
        <Parameter Name="isClosed" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="startPoint">
          <see cref="T:System.Windows.Point" /> Gdzie rozpoczyna się rysunku.</param>
        <param name="isFilled">
          <see langword="true" /> Aby użyć obszaru zawarte przez tę wartość do testowania trafień, renderowania i wycinka; w przeciwnym razie <see langword="false" />.</param>
        <param name="isClosed">
          <see langword="true" /> Aby zamknąć rysunek; w przeciwnym razie <see langword="false" />. Na przykład, jeśli dwa wiersze do nawiązywania połączenia są rysowane i <c>isClosed</c> ustawiono <see langword="false" />, rysunek tylko będzie mieć dwa wiersze, ale jeśli <c>isClosed</c> jest równa <see langword="true" />, dwa wiersze zostaną zamknięte, aby Utwórz trójkąt.</param>
        <summary>Określa punkt początkowy dla nowych rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przez wywołanie tej metody wielokrotnie, można utworzyć wielu wartości (niezależna kształtów geometrycznych) w ramach tej <xref:System.Windows.Media.StreamGeometryContext>.  
  
 A <xref:System.Windows.Media.StreamGeometry> nie może być serializowany, jeśli zawiera on <xref:System.Windows.Media.Transform> lub dowolnego innego niż malowania lub bez segmentów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BezierTo">
      <MemberSignature Language="C#" Value="public abstract void BezierTo (System.Windows.Point point1, System.Windows.Point point2, System.Windows.Point point3, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BezierTo(valuetype System.Windows.Point point1, valuetype System.Windows.Point point2, valuetype System.Windows.Point point3, bool isStroked, bool isSmoothJoin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.StreamGeometryContext.BezierTo(System.Windows.Point,System.Windows.Point,System.Windows.Point,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub BezierTo (point1 As Point, point2 As Point, point3 As Point, isStroked As Boolean, isSmoothJoin As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void BezierTo(System::Windows::Point point1, System::Windows::Point point2, System::Windows::Point point3, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="F#" Value="abstract member BezierTo : System.Windows.Point * System.Windows.Point * System.Windows.Point * bool * bool -&gt; unit" Usage="streamGeometryContext.BezierTo (point1, point2, point3, isStroked, isSmoothJoin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point1" Type="System.Windows.Point" />
        <Parameter Name="point2" Type="System.Windows.Point" />
        <Parameter Name="point3" Type="System.Windows.Point" />
        <Parameter Name="isStroked" Type="System.Boolean" />
        <Parameter Name="isSmoothJoin" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="point1">Pierwszy punkt kontrolny, używany do określenia kształtu krzywej.</param>
        <param name="point2">Drugi punkt kontrolny, używany do określenia kształtu krzywej.</param>
        <param name="point3">Docelowy punkt końcowy krzywej.</param>
        <param name="isStroked">
          <see langword="true" /> zapewnienie segmentu malowania, kiedy <see cref="T:System.Windows.Media.Pen" /> jest używany do renderowania segmentu; w przeciwnym razie <see langword="false" />.</param>
        <param name="isSmoothJoin">
          <see langword="true" /> traktowanie sprzężenie ten segment i poprzedniego segmentu jako rogu podczas malowania z <see cref="T:System.Windows.Media.Pen" />; w przeciwnym razie <see langword="false" />.</param>
        <summary>Rysuje krzywą Beziera w określonym punkcie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Krzywą Beziera trzeciego stopnia jest definiowany przez punkt początkowy i punkt końcowy, dwa punkty kontrolne. Pierwszy punkt kontrolny określa krzywiznę przez pierwszą połowę segmentu, a drugi punkt kontrolny określa krzywiznę w drugiej połowie segmentu.  
  
 Ta metoda używa punktu końcowego poprzedniego segmentu jako punktu początkowego. Jeśli jest to pierwszy segment na ilustracji, używa punktu określonego przez <xref:System.Windows.Media.StreamGeometryContext.BeginFigure%2A> metodę jako jego punkt początkowy.  
  
 A <xref:System.Windows.Media.StreamGeometry> nie może być serializowany, jeśli zawiera on <xref:System.Windows.Media.Transform> lub dowolnego innego niż malowania lub bez segmentów.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak rysowanie krzywej Beziera przy użyciu <xref:System.Windows.Media.StreamGeometryContext.BezierTo%2A> metody.  
  
 [!code-csharp[GeometriesMiscSnippets_procedural_snip#StreamGeometryBezierToExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/CSharp/StreamGeometryBezierToExample.cs#streamgeometrybeziertoexamplewholepage)]
 [!code-vb[GeometriesMiscSnippets_procedural_snip#StreamGeometryBezierToExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/visualbasic/streamgeometrybeziertoexample.vb#streamgeometrybeziertoexamplewholepage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aby dodać segment bez uruchamiania rysunku, wywołując nastąpiła próba <see cref="M:System.Windows.Media.StreamGeometryContext.BeginFigure(System.Windows.Point,System.Boolean,System.Boolean)" /> metody.</exception>
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.ArcTo(System.Windows.Point,System.Windows.Size,System.Double,System.Boolean,System.Windows.Media.SweepDirection,System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.PolyBezierTo(System.Collections.Generic.IList{System.Windows.Point},System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.QuadraticBezierTo(System.Windows.Point,System.Windows.Point,System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.PolyQuadraticBezierTo(System.Collections.Generic.IList{System.Windows.Point},System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.StreamGeometryContext.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="streamGeometryContext.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamknięcie tego kontekstu i opróżnia jego zawartości, dzięki czemu mogą być renderowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zamknięciu kontekście nie można modyfikować. Kontekst muszą zostać zamknięte przed jego zawartość może być renderowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten kontekst została już zamknięta lub usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="LineTo">
      <MemberSignature Language="C#" Value="public abstract void LineTo (System.Windows.Point point, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LineTo(valuetype System.Windows.Point point, bool isStroked, bool isSmoothJoin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.StreamGeometryContext.LineTo(System.Windows.Point,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void LineTo(System::Windows::Point point, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="F#" Value="abstract member LineTo : System.Windows.Point * bool * bool -&gt; unit" Usage="streamGeometryContext.LineTo (point, isStroked, isSmoothJoin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="isStroked" Type="System.Boolean" />
        <Parameter Name="isSmoothJoin" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="point">Docelowy punkt końcowy linii.</param>
        <param name="isStroked">
          <see langword="true" /> zapewnienie segmentu malowania, kiedy <see cref="T:System.Windows.Media.Pen" /> jest używany do renderowania segmentu; w przeciwnym razie <see langword="false" />.</param>
        <param name="isSmoothJoin">
          <see langword="true" /> traktowanie sprzężenie ten segment i poprzedniego segmentu jako rogu podczas malowania z <see cref="T:System.Windows.Media.Pen" />; w przeciwnym razie <see langword="false" />.</param>
        <summary>Rysuje linię prostą określonej <see cref="T:System.Windows.Point" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa punktu końcowego poprzedniego segmentu jako punktu początkowego. Jeśli jest to pierwszy segment na ilustracji, używa punktu określonego przez <xref:System.Windows.Media.StreamGeometryContext.BeginFigure%2A> metodę jako jego punkt początkowy.  
  
 A <xref:System.Windows.Media.StreamGeometry> nie może być serializowany, jeśli zawiera on <xref:System.Windows.Media.Transform> lub dowolnego innego niż malowania lub bez segmentów.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak rysowanie trójkąt przy użyciu <xref:System.Windows.Media.StreamGeometryContext.LineTo%2A> metody.  
  
 [!code-csharp[GeometriesMiscSnippets_procedural_snip#StreamGeometryTriangleExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/CSharp/StreamGeometryTriangleExample.cs#streamgeometrytriangleexamplewholepage)]
 [!code-vb[GeometriesMiscSnippets_procedural_snip#StreamGeometryTriangleExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/visualbasic/streamgeometrytriangleexample.vb#streamgeometrytriangleexamplewholepage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aby dodać segment bez uruchamiania rysunku, wywołując nastąpiła próba <see cref="M:System.Windows.Media.StreamGeometryContext.BeginFigure(System.Windows.Point,System.Boolean,System.Boolean)" /> metody.</exception>
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.PolyLineTo(System.Collections.Generic.IList{System.Windows.Point},System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PolyBezierTo">
      <MemberSignature Language="C#" Value="public abstract void PolyBezierTo (System.Collections.Generic.IList&lt;System.Windows.Point&gt; points, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PolyBezierTo(class System.Collections.Generic.IList`1&lt;valuetype System.Windows.Point&gt; points, bool isStroked, bool isSmoothJoin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.StreamGeometryContext.PolyBezierTo(System.Collections.Generic.IList{System.Windows.Point},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PolyBezierTo (points As IList(Of Point), isStroked As Boolean, isSmoothJoin As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PolyBezierTo(System::Collections::Generic::IList&lt;System::Windows::Point&gt; ^ points, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="F#" Value="abstract member PolyBezierTo : System.Collections.Generic.IList&lt;System.Windows.Point&gt; * bool * bool -&gt; unit" Usage="streamGeometryContext.PolyBezierTo (points, isStroked, isSmoothJoin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Collections.Generic.IList&lt;System.Windows.Point&gt;" />
        <Parameter Name="isStroked" Type="System.Boolean" />
        <Parameter Name="isSmoothJoin" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="points">Lista punktów, które określają punkty kontrolne i punkty docelowym dla co najmniej jeden krzywych Beziera. Liczba punktów na tej liście powinna być wielokrotnością liczby 3.</param>
        <param name="isStroked">
          <see langword="true" /> zapewnienie segmentu malowania, kiedy <see cref="T:System.Windows.Media.Pen" /> jest używany do renderowania segmentu; w przeciwnym razie <see langword="false" />.</param>
        <param name="isSmoothJoin">
          <see langword="true" /> traktowanie sprzężenie ten segment i poprzedniego segmentu jako rogu podczas malowania z <see cref="T:System.Windows.Media.Pen" />; w przeciwnym razie <see langword="false" />.</param>
        <summary>Rysuje co najmniej jeden połączone krzywych Beziera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pierwszy punkt `points` Określa pierwszy punkt kontrolny następnego określa drugi punkt kontrolny, trzeci punktu określa punkt końcowy, następny punkt Określa pierwszy punkt kontrolny krzywej dalej, i tak dalej.  
  
 Ta metoda używa punktu końcowego poprzedniego segmentu jako punktu początkowego. Jeśli jest to pierwszy segment na ilustracji, używa punktu określonego przez <xref:System.Windows.Media.StreamGeometryContext.BeginFigure%2A> metodę jako jego punkt początkowy.  
  
 A <xref:System.Windows.Media.StreamGeometry> nie może być serializowany, jeśli zawiera on <xref:System.Windows.Media.Transform> lub dowolnego innego niż malowania lub bez segmentów.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak narysować wiele połączonych krzywych Beziera przy użyciu <xref:System.Windows.Media.StreamGeometryContext.PolyBezierTo%2A> metody.  
  
 [!code-csharp[GeometriesMiscSnippets_procedural_snip#StreamGeometryPolyBezierToExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/CSharp/StreamGeometryPolyBezierToExample.cs#streamgeometrypolybeziertoexamplewholepage)]
 [!code-vb[GeometriesMiscSnippets_procedural_snip#StreamGeometryPolyBezierToExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/visualbasic/streamgeometrypolybeziertoexample.vb#streamgeometrypolybeziertoexamplewholepage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aby dodać segment bez uruchamiania rysunku, wywołując nastąpiła próba <see cref="M:System.Windows.Media.StreamGeometryContext.BeginFigure(System.Windows.Point,System.Boolean,System.Boolean)" /> metody.</exception>
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.ArcTo(System.Windows.Point,System.Windows.Size,System.Double,System.Boolean,System.Windows.Media.SweepDirection,System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.BezierTo(System.Windows.Point,System.Windows.Point,System.Windows.Point,System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.QuadraticBezierTo(System.Windows.Point,System.Windows.Point,System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.PolyQuadraticBezierTo(System.Collections.Generic.IList{System.Windows.Point},System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PolyLineTo">
      <MemberSignature Language="C#" Value="public abstract void PolyLineTo (System.Collections.Generic.IList&lt;System.Windows.Point&gt; points, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PolyLineTo(class System.Collections.Generic.IList`1&lt;valuetype System.Windows.Point&gt; points, bool isStroked, bool isSmoothJoin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.StreamGeometryContext.PolyLineTo(System.Collections.Generic.IList{System.Windows.Point},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PolyLineTo (points As IList(Of Point), isStroked As Boolean, isSmoothJoin As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PolyLineTo(System::Collections::Generic::IList&lt;System::Windows::Point&gt; ^ points, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="F#" Value="abstract member PolyLineTo : System.Collections.Generic.IList&lt;System.Windows.Point&gt; * bool * bool -&gt; unit" Usage="streamGeometryContext.PolyLineTo (points, isStroked, isSmoothJoin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Collections.Generic.IList&lt;System.Windows.Point&gt;" />
        <Parameter Name="isStroked" Type="System.Boolean" />
        <Parameter Name="isSmoothJoin" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="points">Kolekcję punktów, które określają punkty docelowe dla jednego lub kilku połączone linie proste.</param>
        <param name="isStroked">
          <see langword="true" /> zapewnienie segmentu malowania, kiedy <see cref="T:System.Windows.Media.Pen" /> jest używany do renderowania segmentu; w przeciwnym razie <see langword="false" />.</param>
        <param name="isSmoothJoin">
          <see langword="true" /> traktowanie sprzężenie ten segment i poprzedniego segmentu jako rogu podczas malowania z <see cref="T:System.Windows.Media.Pen" />; w przeciwnym razie <see langword="false" />.</param>
        <summary>Rysuje co najmniej jeden połączone linie proste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa punktu końcowego poprzedniego segmentu jako punktu początkowego. Jeśli jest to pierwszy segment na ilustracji, używa punktu określonego przez <xref:System.Windows.Media.StreamGeometryContext.BeginFigure%2A> metodę jako jego punkt początkowy.  
  
 A <xref:System.Windows.Media.StreamGeometry> nie może być serializowany, jeśli zawiera on <xref:System.Windows.Media.Transform> lub dowolnego innego niż malowania lub bez segmentów.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak rysowanie trójkąt przy użyciu <xref:System.Windows.Media.StreamGeometryContext.PolyLineTo%2A> metody.  
  
 [!code-csharp[GeometriesMiscSnippets_procedural_snip#StreamGeometryPolyLineToExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/CSharp/StreamGeometryPolyLineToExample.cs#streamgeometrypolylinetoexamplewholepage)]
 [!code-vb[GeometriesMiscSnippets_procedural_snip#StreamGeometryPolyLineToExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/visualbasic/streamgeometrypolylinetoexample.vb#streamgeometrypolylinetoexamplewholepage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aby dodać segment bez uruchamiania rysunku, wywołując nastąpiła próba <see cref="M:System.Windows.Media.StreamGeometryContext.BeginFigure(System.Windows.Point,System.Boolean,System.Boolean)" /> metody.</exception>
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.LineTo(System.Windows.Point,System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PolyQuadraticBezierTo">
      <MemberSignature Language="C#" Value="public abstract void PolyQuadraticBezierTo (System.Collections.Generic.IList&lt;System.Windows.Point&gt; points, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PolyQuadraticBezierTo(class System.Collections.Generic.IList`1&lt;valuetype System.Windows.Point&gt; points, bool isStroked, bool isSmoothJoin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.StreamGeometryContext.PolyQuadraticBezierTo(System.Collections.Generic.IList{System.Windows.Point},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PolyQuadraticBezierTo (points As IList(Of Point), isStroked As Boolean, isSmoothJoin As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PolyQuadraticBezierTo(System::Collections::Generic::IList&lt;System::Windows::Point&gt; ^ points, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="F#" Value="abstract member PolyQuadraticBezierTo : System.Collections.Generic.IList&lt;System.Windows.Point&gt; * bool * bool -&gt; unit" Usage="streamGeometryContext.PolyQuadraticBezierTo (points, isStroked, isSmoothJoin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Collections.Generic.IList&lt;System.Windows.Point&gt;" />
        <Parameter Name="isStroked" Type="System.Boolean" />
        <Parameter Name="isSmoothJoin" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="points">Kolekcja punktów, które określają punkty kontrolne i punkty docelowym dla co najmniej jeden krzywe Beziera drugiego stopnia. Pierwszym punktem na liście określa punkt kontrolny krzywej, następny punkt Określa docelowy punkt następnego punktu określa punkt kontrolny krzywej dalej, i tak dalej. Lista musi zawierać parzystą liczbę punktów.</param>
        <param name="isStroked">
          <see langword="true" /> zapewnienie segmentu malowania, kiedy <see cref="T:System.Windows.Media.Pen" /> jest używany do renderowania segmentu; w przeciwnym razie <see langword="false" />.</param>
        <param name="isSmoothJoin">
          <see langword="true" /> traktowanie sprzężenie ten segment i poprzedniego segmentu jako rogu podczas malowania z <see cref="T:System.Windows.Media.Pen" />; w przeciwnym razie <see langword="false" />.</param>
        <summary>Rysuje co najmniej jeden połączone krzywe Beziera drugiego stopnia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa punktu końcowego poprzedniego segmentu jako punktu początkowego. Jeśli jest to pierwszy segment na ilustracji, używa punktu określonego przez <xref:System.Windows.Media.StreamGeometryContext.BeginFigure%2A> metodę jako jego punkt początkowy.  
  
 A <xref:System.Windows.Media.StreamGeometry> nie może być serializowany, jeśli zawiera on <xref:System.Windows.Media.Transform> lub dowolnego innego niż malowania lub bez segmentów.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak narysować wiele połączonych krzywe Beziera drugiego stopnia przy użyciu <xref:System.Windows.Media.StreamGeometryContext.PolyQuadraticBezierTo%2A> metody.  
  
 [!code-csharp[GeometriesMiscSnippets_procedural_snip#StreamGeometryPolyQuadraticBezierToExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/CSharp/StreamGeometryPolyQuadraticBezierToExample.cs#streamgeometrypolyquadraticbeziertoexamplewholepage)]
 [!code-vb[GeometriesMiscSnippets_procedural_snip#StreamGeometryPolyQuadraticBezierToExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/visualbasic/streamgeometrypolyquadraticbeziertoexample.vb#streamgeometrypolyquadraticbeziertoexamplewholepage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aby dodać segment bez uruchamiania rysunku, wywołując nastąpiła próba <see cref="M:System.Windows.Media.StreamGeometryContext.BeginFigure(System.Windows.Point,System.Boolean,System.Boolean)" /> metody.</exception>
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.ArcTo(System.Windows.Point,System.Windows.Size,System.Double,System.Boolean,System.Windows.Media.SweepDirection,System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.BezierTo(System.Windows.Point,System.Windows.Point,System.Windows.Point,System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.PolyBezierTo(System.Collections.Generic.IList{System.Windows.Point},System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.QuadraticBezierTo(System.Windows.Point,System.Windows.Point,System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="QuadraticBezierTo">
      <MemberSignature Language="C#" Value="public abstract void QuadraticBezierTo (System.Windows.Point point1, System.Windows.Point point2, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void QuadraticBezierTo(valuetype System.Windows.Point point1, valuetype System.Windows.Point point2, bool isStroked, bool isSmoothJoin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.StreamGeometryContext.QuadraticBezierTo(System.Windows.Point,System.Windows.Point,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub QuadraticBezierTo (point1 As Point, point2 As Point, isStroked As Boolean, isSmoothJoin As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void QuadraticBezierTo(System::Windows::Point point1, System::Windows::Point point2, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="F#" Value="abstract member QuadraticBezierTo : System.Windows.Point * System.Windows.Point * bool * bool -&gt; unit" Usage="streamGeometryContext.QuadraticBezierTo (point1, point2, isStroked, isSmoothJoin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point1" Type="System.Windows.Point" />
        <Parameter Name="point2" Type="System.Windows.Point" />
        <Parameter Name="isStroked" Type="System.Boolean" />
        <Parameter Name="isSmoothJoin" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="point1">Punkt kontrolny, używany do określenia kształtu krzywej.</param>
        <param name="point2">Docelowy punkt końcowy krzywej.</param>
        <param name="isStroked">
          <see langword="true" /> zapewnienie segmentu malowania, kiedy <see cref="T:System.Windows.Media.Pen" /> jest używany do renderowania segmentu; w przeciwnym razie <see langword="false" />.</param>
        <param name="isSmoothJoin">
          <see langword="true" /> traktowanie sprzężenie ten segment i poprzedniego segmentu jako rogu podczas malowania z <see cref="T:System.Windows.Media.Pen" />; w przeciwnym razie <see langword="false" />.</param>
        <summary>Rysuje krzywą Beziera drugiego stopnia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od krzywą Beziera trzeciego stopnia, która używa dwóch punktów kontrolnych, drugiego stopnia krzywą Beziera trzeciego stopnia używa punktu pojedynczego formantu.  
  
 Ta metoda używa punktu końcowego poprzedniego segmentu jako punktu początkowego. Jeśli jest to pierwszy segment na ilustracji, używa punktu określonego przez <xref:System.Windows.Media.StreamGeometryContext.BeginFigure%2A> metodę jako jego punkt początkowy.  
  
 A <xref:System.Windows.Media.StreamGeometry> nie może być serializowany, jeśli zawiera on <xref:System.Windows.Media.Transform> lub dowolnego innego niż malowania lub bez segmentów.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak rysowanie drugiego stopnia krzywej Beziera, przy użyciu <xref:System.Windows.Media.StreamGeometryContext.QuadraticBezierTo%2A> metody.  
  
 [!code-csharp[GeometriesMiscSnippets_procedural_snip#StreamGeometryQuadraticBezierToExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/CSharp/StreamGeometryQuadraticBezierToExample.cs#streamgeometryquadraticbeziertoexamplewholepage)]
 [!code-vb[GeometriesMiscSnippets_procedural_snip#StreamGeometryQuadraticBezierToExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/visualbasic/streamgeometryquadraticbeziertoexample.vb#streamgeometryquadraticbeziertoexamplewholepage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aby dodać segment bez uruchamiania rysunku, wywołując nastąpiła próba <see cref="M:System.Windows.Media.StreamGeometryContext.BeginFigure(System.Windows.Point,System.Boolean,System.Boolean)" /> metody.</exception>
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.ArcTo(System.Windows.Point,System.Windows.Size,System.Double,System.Boolean,System.Windows.Media.SweepDirection,System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.BezierTo(System.Windows.Point,System.Windows.Point,System.Windows.Point,System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.PolyBezierTo(System.Collections.Generic.IList{System.Windows.Point},System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.PolyQuadraticBezierTo(System.Collections.Generic.IList{System.Windows.Point},System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.StreamGeometryContext.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ten element członkowski obsługuje [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastrukturę i nie jest przeznaczona do użycia bezpośrednio w kodzie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
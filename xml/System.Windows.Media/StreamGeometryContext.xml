<Type Name="StreamGeometryContext" FullName="System.Windows.Media.StreamGeometryContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c514e9cb88f8c4b4efc6bbb57edaf6e75580abe6" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69435951" /></Metadata><TypeSignature Language="C#" Value="public abstract class StreamGeometryContext : System.Windows.Threading.DispatcherObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit StreamGeometryContext extends System.Windows.Threading.DispatcherObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.StreamGeometryContext" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class StreamGeometryContext&#xA;Inherits DispatcherObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class StreamGeometryContext abstract : System::Windows::Threading::DispatcherObject, IDisposable" />
  <TypeSignature Language="F#" Value="type StreamGeometryContext = class&#xA;    inherit DispatcherObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Zawiera opis geometrii przy użyciu poleceń rysowania. Ta klasa jest używana z <see cref="T:System.Windows.Media.StreamGeometry" /> klasą do tworzenia lekkiej geometrii, która nie obsługuje powiązań danych, animacji ani modyfikacji.</summary>
    <remarks>To be added.</remarks>
    <exception cref="T:System.InvalidOperationException">Podjęto próbę dodania segmentu bez rozpoczynania się przez wywołanie <see cref="M:System.Windows.Media.StreamGeometryContext.BeginFigure(System.Windows.Point,System.Boolean,System.Boolean)" /> metody.</exception>
    <altmember cref="T:System.Windows.Media.StreamGeometry" />
    <altmember cref="T:System.Windows.Media.PathGeometry" />
  </Docs>
  <Members>
    <Member MemberName="ArcTo">
      <MemberSignature Language="C#" Value="public abstract void ArcTo (System.Windows.Point point, System.Windows.Size size, double rotationAngle, bool isLargeArc, System.Windows.Media.SweepDirection sweepDirection, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ArcTo(valuetype System.Windows.Point point, valuetype System.Windows.Size size, float64 rotationAngle, bool isLargeArc, valuetype System.Windows.Media.SweepDirection sweepDirection, bool isStroked, bool isSmoothJoin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.StreamGeometryContext.ArcTo(System.Windows.Point,System.Windows.Size,System.Double,System.Boolean,System.Windows.Media.SweepDirection,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ArcTo(System::Windows::Point point, System::Windows::Size size, double rotationAngle, bool isLargeArc, System::Windows::Media::SweepDirection sweepDirection, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="F#" Value="abstract member ArcTo : System.Windows.Point * System.Windows.Size * double * bool * System.Windows.Media.SweepDirection * bool * bool -&gt; unit" Usage="streamGeometryContext.ArcTo (point, size, rotationAngle, isLargeArc, sweepDirection, isStroked, isSmoothJoin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="size" Type="System.Windows.Size" />
        <Parameter Name="rotationAngle" Type="System.Double" />
        <Parameter Name="isLargeArc" Type="System.Boolean" />
        <Parameter Name="sweepDirection" Type="System.Windows.Media.SweepDirection" />
        <Parameter Name="isStroked" Type="System.Boolean" />
        <Parameter Name="isSmoothJoin" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="point">Punkt docelowy końca łuku.</param>
        <param name="size">Promienie (połowa szerokości i połowę wysokości) elipsy, której obwód jest używany do rysowania kąta. Jeśli owal jest bardzo zaokrąglony we wszystkich kierunkach, łuk zostanie zaokrąglony, jeśli jest niemal płaski, dlatego będzie łuk. Na przykład bardzo duża szerokość i wysokość będzie reprezentować bardzo duży owal, co zapewni niewielką krzywiznę kąta.</param>
        <param name="rotationAngle">Kąt obrotu owalu, który określa krzywą. Krzywizna łuku można obrócić z tym parametrem.</param>
        <param name="isLargeArc"><see langword="true" />Aby narysować łuk większy niż 180 stopni; w przeciwnym razie. <see langword="false" /></param>
        <param name="sweepDirection">Wartość wskazująca, czy łuk jest rysowany w <see cref="F:System.Windows.Media.SweepDirection.Clockwise" /> kierunku lub. <see cref="F:System.Windows.Media.SweepDirection.Counterclockwise" /></param>
        <param name="isStroked"><see langword="true" />Aby segment był rysowany, <see cref="T:System.Windows.Media.Pen" /> <see langword="false" />gdy jest używany do renderowania segmentu; w przeciwnym razie.</param>
        <param name="isSmoothJoin"><see langword="true" />w celu traktowania sprzężenia między tym segmentem a poprzednim segmentem w przypadku pociągnięcia z <see cref="T:System.Windows.Media.Pen" />; <see langword="false" />w przeciwnym razie.</param>
        <summary>Rysuje łuk do określonego punktu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa punktu końcowego poprzedniego segmentu jako punktu początkowego. Jeśli jest to pierwszy segment na rysunku, używa punktu określonego przez <xref:System.Windows.Media.StreamGeometryContext.BeginFigure%2A> metodę jako punktu początkowego.  
  
 Nie <xref:System.Windows.Media.StreamGeometry> można serializować elementu, jeśli <xref:System.Windows.Media.Transform> zawiera on lub wszystkie segmenty pociągnięcia lub niewypełnione.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Media.StreamGeometryContext.ArcTo%2A> jak narysować łuk przy użyciu metody.  
  
 [!code-csharp[GeometriesMiscSnippets_procedural_snip#StreamGeometryArcToExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/CSharp/StreamGeometryArcToExample.cs#streamgeometryarctoexamplewholepage)]
 [!code-vb[GeometriesMiscSnippets_procedural_snip#StreamGeometryArcToExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/visualbasic/streamgeometryarctoexample.vb#streamgeometryarctoexamplewholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.BezierTo(System.Windows.Point,System.Windows.Point,System.Windows.Point,System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.PolyBezierTo(System.Collections.Generic.IList{System.Windows.Point},System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.QuadraticBezierTo(System.Windows.Point,System.Windows.Point,System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.PolyQuadraticBezierTo(System.Collections.Generic.IList{System.Windows.Point},System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="BeginFigure">
      <MemberSignature Language="C#" Value="public abstract void BeginFigure (System.Windows.Point startPoint, bool isFilled, bool isClosed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginFigure(valuetype System.Windows.Point startPoint, bool isFilled, bool isClosed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.StreamGeometryContext.BeginFigure(System.Windows.Point,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub BeginFigure (startPoint As Point, isFilled As Boolean, isClosed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void BeginFigure(System::Windows::Point startPoint, bool isFilled, bool isClosed);" />
      <MemberSignature Language="F#" Value="abstract member BeginFigure : System.Windows.Point * bool * bool -&gt; unit" Usage="streamGeometryContext.BeginFigure (startPoint, isFilled, isClosed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPoint" Type="System.Windows.Point" />
        <Parameter Name="isFilled" Type="System.Boolean" />
        <Parameter Name="isClosed" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="startPoint"><see cref="T:System.Windows.Point" /> Gdzie zaczyna się rysunek.</param>
        <param name="isFilled"><see langword="true" />Aby użyć obszaru zawartego na rysunku na potrzeby testowania trafień, renderowania i przycinania. w przeciwnym razie. <see langword="false" /></param>
        <param name="isClosed"><see langword="true" />Aby zamknąć rysunek; w przeciwnym razie. <see langword="false" /> Na przykład, jeśli dwa łączące linie są rysowane i <paramref name="isClosed" /> są ustawione na <see langword="false" />, rysunek będzie się znajdować w dwóch wierszach, <paramref name="isClosed" /> ale jeśli jest <see langword="true" />ustawiona na, dwa wiersze zostaną zamknięte, aby utworzyć trójkąt.</param>
        <summary>Określa punkt początkowy dla nowego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przez wywołanie tej metody wiele razy, można w tym <xref:System.Windows.Media.StreamGeometryContext>celu utworzyć wiele ilustracji (własne kształty geometryczne).  
  
 Nie <xref:System.Windows.Media.StreamGeometry> można serializować elementu, jeśli <xref:System.Windows.Media.Transform> zawiera on lub wszystkie segmenty pociągnięcia lub niewypełnione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BezierTo">
      <MemberSignature Language="C#" Value="public abstract void BezierTo (System.Windows.Point point1, System.Windows.Point point2, System.Windows.Point point3, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BezierTo(valuetype System.Windows.Point point1, valuetype System.Windows.Point point2, valuetype System.Windows.Point point3, bool isStroked, bool isSmoothJoin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.StreamGeometryContext.BezierTo(System.Windows.Point,System.Windows.Point,System.Windows.Point,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub BezierTo (point1 As Point, point2 As Point, point3 As Point, isStroked As Boolean, isSmoothJoin As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void BezierTo(System::Windows::Point point1, System::Windows::Point point2, System::Windows::Point point3, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="F#" Value="abstract member BezierTo : System.Windows.Point * System.Windows.Point * System.Windows.Point * bool * bool -&gt; unit" Usage="streamGeometryContext.BezierTo (point1, point2, point3, isStroked, isSmoothJoin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point1" Type="System.Windows.Point" />
        <Parameter Name="point2" Type="System.Windows.Point" />
        <Parameter Name="point3" Type="System.Windows.Point" />
        <Parameter Name="isStroked" Type="System.Boolean" />
        <Parameter Name="isSmoothJoin" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="point1">Pierwszy punkt kontrolny służący do określania kształtu krzywej.</param>
        <param name="point2">Drugi punkt kontrolny służący do określania kształtu krzywej.</param>
        <param name="point3">Punkt docelowy na końcu krzywej.</param>
        <param name="isStroked"><see langword="true" />Aby segment był rysowany, <see cref="T:System.Windows.Media.Pen" /> <see langword="false" />gdy jest używany do renderowania segmentu; w przeciwnym razie.</param>
        <param name="isSmoothJoin"><see langword="true" />w celu traktowania sprzężenia między tym segmentem a poprzednim segmentem w przypadku pociągnięcia z <see cref="T:System.Windows.Media.Pen" />; <see langword="false" />w przeciwnym razie.</param>
        <summary>Rysuje krzywą Beziera w określonym punkcie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Krzywa Beziera w sześciennym jest definiowana przez punkt początkowy, punkt końcowy i dwa punkty kontrolne. Pierwszy punkt kontrolny określa krzywiznę pierwszej połowy segmentu, a drugi punkt kontrolny określa krzywiznę drugiej połowy segmentu.  
  
 Ta metoda używa punktu końcowego poprzedniego segmentu jako punktu początkowego. Jeśli jest to pierwszy segment na rysunku, używa punktu określonego przez <xref:System.Windows.Media.StreamGeometryContext.BeginFigure%2A> metodę jako punktu początkowego.  
  
 Nie <xref:System.Windows.Media.StreamGeometry> można serializować elementu, jeśli <xref:System.Windows.Media.Transform> zawiera on lub wszystkie segmenty pociągnięcia lub niewypełnione.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak narysować krzywą Beziera przy <xref:System.Windows.Media.StreamGeometryContext.BezierTo%2A> użyciu metody.  
  
 [!code-csharp[GeometriesMiscSnippets_procedural_snip#StreamGeometryBezierToExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/CSharp/StreamGeometryBezierToExample.cs#streamgeometrybeziertoexamplewholepage)]
 [!code-vb[GeometriesMiscSnippets_procedural_snip#StreamGeometryBezierToExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/visualbasic/streamgeometrybeziertoexample.vb#streamgeometrybeziertoexamplewholepage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę dodania segmentu bez rozpoczynania się przez wywołanie <see cref="M:System.Windows.Media.StreamGeometryContext.BeginFigure(System.Windows.Point,System.Boolean,System.Boolean)" /> metody.</exception>
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.ArcTo(System.Windows.Point,System.Windows.Size,System.Double,System.Boolean,System.Windows.Media.SweepDirection,System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.PolyBezierTo(System.Collections.Generic.IList{System.Windows.Point},System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.QuadraticBezierTo(System.Windows.Point,System.Windows.Point,System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.PolyQuadraticBezierTo(System.Collections.Generic.IList{System.Windows.Point},System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.StreamGeometryContext.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="streamGeometryContext.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka ten kontekst i opróżnia jego zawartość, aby można było go renderować.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zamknięciu kontekstu nie można modyfikować. Kontekst musi być zamknięty, aby można było renderować jego zawartość.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten kontekst został już zamknięty lub usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="LineTo">
      <MemberSignature Language="C#" Value="public abstract void LineTo (System.Windows.Point point, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LineTo(valuetype System.Windows.Point point, bool isStroked, bool isSmoothJoin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.StreamGeometryContext.LineTo(System.Windows.Point,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void LineTo(System::Windows::Point point, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="F#" Value="abstract member LineTo : System.Windows.Point * bool * bool -&gt; unit" Usage="streamGeometryContext.LineTo (point, isStroked, isSmoothJoin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="isStroked" Type="System.Boolean" />
        <Parameter Name="isSmoothJoin" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="point">Punkt docelowy końca wiersza.</param>
        <param name="isStroked"><see langword="true" />Aby segment był rysowany, <see cref="T:System.Windows.Media.Pen" /> <see langword="false" />gdy jest używany do renderowania segmentu; w przeciwnym razie.</param>
        <param name="isSmoothJoin"><see langword="true" />w celu traktowania sprzężenia między tym segmentem a poprzednim segmentem w przypadku pociągnięcia z <see cref="T:System.Windows.Media.Pen" />; <see langword="false" />w przeciwnym razie.</param>
        <summary>Rysuje linię prostą do określonego <see cref="T:System.Windows.Point" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa punktu końcowego poprzedniego segmentu jako punktu początkowego. Jeśli jest to pierwszy segment na rysunku, używa punktu określonego przez <xref:System.Windows.Media.StreamGeometryContext.BeginFigure%2A> metodę jako punktu początkowego.  
  
 Nie <xref:System.Windows.Media.StreamGeometry> można serializować elementu, jeśli <xref:System.Windows.Media.Transform> zawiera on lub wszystkie segmenty pociągnięcia lub niewypełnione.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Media.StreamGeometryContext.LineTo%2A> jak narysować Trójkąt przy użyciu metody.  
  
 [!code-csharp[GeometriesMiscSnippets_procedural_snip#StreamGeometryTriangleExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/CSharp/StreamGeometryTriangleExample.cs#streamgeometrytriangleexamplewholepage)]
 [!code-vb[GeometriesMiscSnippets_procedural_snip#StreamGeometryTriangleExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/visualbasic/streamgeometrytriangleexample.vb#streamgeometrytriangleexamplewholepage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę dodania segmentu bez rozpoczynania się przez wywołanie <see cref="M:System.Windows.Media.StreamGeometryContext.BeginFigure(System.Windows.Point,System.Boolean,System.Boolean)" /> metody.</exception>
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.PolyLineTo(System.Collections.Generic.IList{System.Windows.Point},System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PolyBezierTo">
      <MemberSignature Language="C#" Value="public abstract void PolyBezierTo (System.Collections.Generic.IList&lt;System.Windows.Point&gt; points, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PolyBezierTo(class System.Collections.Generic.IList`1&lt;valuetype System.Windows.Point&gt; points, bool isStroked, bool isSmoothJoin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.StreamGeometryContext.PolyBezierTo(System.Collections.Generic.IList{System.Windows.Point},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PolyBezierTo (points As IList(Of Point), isStroked As Boolean, isSmoothJoin As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PolyBezierTo(System::Collections::Generic::IList&lt;System::Windows::Point&gt; ^ points, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="F#" Value="abstract member PolyBezierTo : System.Collections.Generic.IList&lt;System.Windows.Point&gt; * bool * bool -&gt; unit" Usage="streamGeometryContext.PolyBezierTo (points, isStroked, isSmoothJoin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Collections.Generic.IList&lt;System.Windows.Point&gt;" />
        <Parameter Name="isStroked" Type="System.Boolean" />
        <Parameter Name="isSmoothJoin" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="points">Lista punktów, które określają punkty kontrolne i punkty docelowe dla co najmniej jednej krzywej Beziera. Liczba punktów na tej liście powinna być wielokrotnością trzech.</param>
        <param name="isStroked"><see langword="true" />Aby segment był rysowany, <see cref="T:System.Windows.Media.Pen" /> <see langword="false" />gdy jest używany do renderowania segmentu; w przeciwnym razie.</param>
        <param name="isSmoothJoin"><see langword="true" />w celu traktowania sprzężenia między tym segmentem a poprzednim segmentem w przypadku pociągnięcia z <see cref="T:System.Windows.Media.Pen" />; <see langword="false" />w przeciwnym razie.</param>
        <summary>Rysuje co najmniej jedną połączoną krzywą Beziera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pierwszy punkt w programie `points` określa pierwszy punkt kontrolny, a następne Określa drugi punkt kontrolny, trzeci punkt określa punkt końcowy, następny punkt określa pierwszy punkt kontrolny następnej krzywej itd.  
  
 Ta metoda używa punktu końcowego poprzedniego segmentu jako punktu początkowego. Jeśli jest to pierwszy segment na rysunku, używa punktu określonego przez <xref:System.Windows.Media.StreamGeometryContext.BeginFigure%2A> metodę jako punktu początkowego.  
  
 Nie <xref:System.Windows.Media.StreamGeometry> można serializować elementu, jeśli <xref:System.Windows.Media.Transform> zawiera on lub wszystkie segmenty pociągnięcia lub niewypełnione.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Media.StreamGeometryContext.PolyBezierTo%2A> jak narysować wiele połączonych krzywych Beziera przy użyciu metody.  
  
 [!code-csharp[GeometriesMiscSnippets_procedural_snip#StreamGeometryPolyBezierToExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/CSharp/StreamGeometryPolyBezierToExample.cs#streamgeometrypolybeziertoexamplewholepage)]
 [!code-vb[GeometriesMiscSnippets_procedural_snip#StreamGeometryPolyBezierToExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/visualbasic/streamgeometrypolybeziertoexample.vb#streamgeometrypolybeziertoexamplewholepage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę dodania segmentu bez rozpoczynania się przez wywołanie <see cref="M:System.Windows.Media.StreamGeometryContext.BeginFigure(System.Windows.Point,System.Boolean,System.Boolean)" /> metody.</exception>
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.ArcTo(System.Windows.Point,System.Windows.Size,System.Double,System.Boolean,System.Windows.Media.SweepDirection,System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.BezierTo(System.Windows.Point,System.Windows.Point,System.Windows.Point,System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.QuadraticBezierTo(System.Windows.Point,System.Windows.Point,System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.PolyQuadraticBezierTo(System.Collections.Generic.IList{System.Windows.Point},System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PolyLineTo">
      <MemberSignature Language="C#" Value="public abstract void PolyLineTo (System.Collections.Generic.IList&lt;System.Windows.Point&gt; points, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PolyLineTo(class System.Collections.Generic.IList`1&lt;valuetype System.Windows.Point&gt; points, bool isStroked, bool isSmoothJoin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.StreamGeometryContext.PolyLineTo(System.Collections.Generic.IList{System.Windows.Point},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PolyLineTo (points As IList(Of Point), isStroked As Boolean, isSmoothJoin As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PolyLineTo(System::Collections::Generic::IList&lt;System::Windows::Point&gt; ^ points, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="F#" Value="abstract member PolyLineTo : System.Collections.Generic.IList&lt;System.Windows.Point&gt; * bool * bool -&gt; unit" Usage="streamGeometryContext.PolyLineTo (points, isStroked, isSmoothJoin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Collections.Generic.IList&lt;System.Windows.Point&gt;" />
        <Parameter Name="isStroked" Type="System.Boolean" />
        <Parameter Name="isSmoothJoin" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="points">Kolekcja punktów, które określają punkty docelowe dla co najmniej jednej połączonej linii prostej.</param>
        <param name="isStroked"><see langword="true" />Aby segment był rysowany, <see cref="T:System.Windows.Media.Pen" /> <see langword="false" />gdy jest używany do renderowania segmentu; w przeciwnym razie.</param>
        <param name="isSmoothJoin"><see langword="true" />w celu traktowania sprzężenia między tym segmentem a poprzednim segmentem w przypadku pociągnięcia z <see cref="T:System.Windows.Media.Pen" />; <see langword="false" />w przeciwnym razie.</param>
        <summary>Rysuje co najmniej jedną podłączoną linię prostą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa punktu końcowego poprzedniego segmentu jako punktu początkowego. Jeśli jest to pierwszy segment na rysunku, używa punktu określonego przez <xref:System.Windows.Media.StreamGeometryContext.BeginFigure%2A> metodę jako punktu początkowego.  
  
 Nie <xref:System.Windows.Media.StreamGeometry> można serializować elementu, jeśli <xref:System.Windows.Media.Transform> zawiera on lub wszystkie segmenty pociągnięcia lub niewypełnione.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Media.StreamGeometryContext.PolyLineTo%2A> jak narysować Trójkąt przy użyciu metody.  
  
 [!code-csharp[GeometriesMiscSnippets_procedural_snip#StreamGeometryPolyLineToExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/CSharp/StreamGeometryPolyLineToExample.cs#streamgeometrypolylinetoexamplewholepage)]
 [!code-vb[GeometriesMiscSnippets_procedural_snip#StreamGeometryPolyLineToExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/visualbasic/streamgeometrypolylinetoexample.vb#streamgeometrypolylinetoexamplewholepage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę dodania segmentu bez rozpoczynania się przez wywołanie <see cref="M:System.Windows.Media.StreamGeometryContext.BeginFigure(System.Windows.Point,System.Boolean,System.Boolean)" /> metody.</exception>
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.LineTo(System.Windows.Point,System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PolyQuadraticBezierTo">
      <MemberSignature Language="C#" Value="public abstract void PolyQuadraticBezierTo (System.Collections.Generic.IList&lt;System.Windows.Point&gt; points, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PolyQuadraticBezierTo(class System.Collections.Generic.IList`1&lt;valuetype System.Windows.Point&gt; points, bool isStroked, bool isSmoothJoin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.StreamGeometryContext.PolyQuadraticBezierTo(System.Collections.Generic.IList{System.Windows.Point},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PolyQuadraticBezierTo (points As IList(Of Point), isStroked As Boolean, isSmoothJoin As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PolyQuadraticBezierTo(System::Collections::Generic::IList&lt;System::Windows::Point&gt; ^ points, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="F#" Value="abstract member PolyQuadraticBezierTo : System.Collections.Generic.IList&lt;System.Windows.Point&gt; * bool * bool -&gt; unit" Usage="streamGeometryContext.PolyQuadraticBezierTo (points, isStroked, isSmoothJoin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Collections.Generic.IList&lt;System.Windows.Point&gt;" />
        <Parameter Name="isStroked" Type="System.Boolean" />
        <Parameter Name="isSmoothJoin" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="points">Kolekcja punktów, które określają punkty kontrolne i punkty docelowe dla jednej lub więcej krzywych Beziera kwadratowego. Pierwszy punkt na liście określa punkt kontrolny krzywej, kolejny punkt określa punkt docelowy, następny punkt określa punkt kontrolny następnej krzywej itd. Lista musi zawierać parzystą liczbę punktów.</param>
        <param name="isStroked"><see langword="true" />Aby segment był rysowany, <see cref="T:System.Windows.Media.Pen" /> <see langword="false" />gdy jest używany do renderowania segmentu; w przeciwnym razie.</param>
        <param name="isSmoothJoin"><see langword="true" />w celu traktowania sprzężenia między tym segmentem a poprzednim segmentem w przypadku pociągnięcia z <see cref="T:System.Windows.Media.Pen" />; <see langword="false" />w przeciwnym razie.</param>
        <summary>Rysuje co najmniej jedną krzywą Beziera połączonego kwadratu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa punktu końcowego poprzedniego segmentu jako punktu początkowego. Jeśli jest to pierwszy segment na rysunku, używa punktu określonego przez <xref:System.Windows.Media.StreamGeometryContext.BeginFigure%2A> metodę jako punktu początkowego.  
  
 Nie <xref:System.Windows.Media.StreamGeometry> można serializować elementu, jeśli <xref:System.Windows.Media.Transform> zawiera on lub wszystkie segmenty pociągnięcia lub niewypełnione.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak narysować wiele połączonych krzywych Beziera kwadratowego przy użyciu <xref:System.Windows.Media.StreamGeometryContext.PolyQuadraticBezierTo%2A> metody.  
  
 [!code-csharp[GeometriesMiscSnippets_procedural_snip#StreamGeometryPolyQuadraticBezierToExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/CSharp/StreamGeometryPolyQuadraticBezierToExample.cs#streamgeometrypolyquadraticbeziertoexamplewholepage)]
 [!code-vb[GeometriesMiscSnippets_procedural_snip#StreamGeometryPolyQuadraticBezierToExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/visualbasic/streamgeometrypolyquadraticbeziertoexample.vb#streamgeometrypolyquadraticbeziertoexamplewholepage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę dodania segmentu bez rozpoczynania się przez wywołanie <see cref="M:System.Windows.Media.StreamGeometryContext.BeginFigure(System.Windows.Point,System.Boolean,System.Boolean)" /> metody.</exception>
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.ArcTo(System.Windows.Point,System.Windows.Size,System.Double,System.Boolean,System.Windows.Media.SweepDirection,System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.BezierTo(System.Windows.Point,System.Windows.Point,System.Windows.Point,System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.PolyBezierTo(System.Collections.Generic.IList{System.Windows.Point},System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.QuadraticBezierTo(System.Windows.Point,System.Windows.Point,System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="QuadraticBezierTo">
      <MemberSignature Language="C#" Value="public abstract void QuadraticBezierTo (System.Windows.Point point1, System.Windows.Point point2, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void QuadraticBezierTo(valuetype System.Windows.Point point1, valuetype System.Windows.Point point2, bool isStroked, bool isSmoothJoin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.StreamGeometryContext.QuadraticBezierTo(System.Windows.Point,System.Windows.Point,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub QuadraticBezierTo (point1 As Point, point2 As Point, isStroked As Boolean, isSmoothJoin As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void QuadraticBezierTo(System::Windows::Point point1, System::Windows::Point point2, bool isStroked, bool isSmoothJoin);" />
      <MemberSignature Language="F#" Value="abstract member QuadraticBezierTo : System.Windows.Point * System.Windows.Point * bool * bool -&gt; unit" Usage="streamGeometryContext.QuadraticBezierTo (point1, point2, isStroked, isSmoothJoin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point1" Type="System.Windows.Point" />
        <Parameter Name="point2" Type="System.Windows.Point" />
        <Parameter Name="isStroked" Type="System.Boolean" />
        <Parameter Name="isSmoothJoin" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="point1">Punkt kontrolny służący do określania kształtu krzywej.</param>
        <param name="point2">Punkt docelowy na końcu krzywej.</param>
        <param name="isStroked"><see langword="true" />Aby segment był rysowany, <see cref="T:System.Windows.Media.Pen" /> <see langword="false" />gdy jest używany do renderowania segmentu; w przeciwnym razie.</param>
        <param name="isSmoothJoin"><see langword="true" />w celu traktowania sprzężenia między tym segmentem a poprzednim segmentem w przypadku pociągnięcia z <see cref="T:System.Windows.Media.Pen" />; <see langword="false" />w przeciwnym razie.</param>
        <summary>Rysuje krzywą Beziera kwadratowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do zakrzywionej krzywej Beziera, która używa dwóch punktów kontrolnych, kwadratowa krzywa Beziera jest używa jednego punktu kontrolnego.  
  
 Ta metoda używa punktu końcowego poprzedniego segmentu jako punktu początkowego. Jeśli jest to pierwszy segment na rysunku, używa punktu określonego przez <xref:System.Windows.Media.StreamGeometryContext.BeginFigure%2A> metodę jako punktu początkowego.  
  
 Nie <xref:System.Windows.Media.StreamGeometry> można serializować elementu, jeśli <xref:System.Windows.Media.Transform> zawiera on lub wszystkie segmenty pociągnięcia lub niewypełnione.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak narysować krzywą Beziera kwadratowego <xref:System.Windows.Media.StreamGeometryContext.QuadraticBezierTo%2A> przy użyciu metody.  
  
 [!code-csharp[GeometriesMiscSnippets_procedural_snip#StreamGeometryQuadraticBezierToExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/CSharp/StreamGeometryQuadraticBezierToExample.cs#streamgeometryquadraticbeziertoexamplewholepage)]
 [!code-vb[GeometriesMiscSnippets_procedural_snip#StreamGeometryQuadraticBezierToExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometriesMiscSnippets_procedural_snip/visualbasic/streamgeometryquadraticbeziertoexample.vb#streamgeometryquadraticbeziertoexamplewholepage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę dodania segmentu bez rozpoczynania się przez wywołanie <see cref="M:System.Windows.Media.StreamGeometryContext.BeginFigure(System.Windows.Point,System.Boolean,System.Boolean)" /> metody.</exception>
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.ArcTo(System.Windows.Point,System.Windows.Size,System.Double,System.Boolean,System.Windows.Media.SweepDirection,System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.BezierTo(System.Windows.Point,System.Windows.Point,System.Windows.Point,System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.PolyBezierTo(System.Collections.Generic.IList{System.Windows.Point},System.Boolean,System.Boolean)" />
        <altmember cref="M:System.Windows.Media.StreamGeometryContext.PolyQuadraticBezierTo(System.Collections.Generic.IList{System.Windows.Point},System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.StreamGeometryContext.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ten element członkowski obsługuje [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastrukturę i nie jest przeznaczony do użycia bezpośrednio w kodzie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

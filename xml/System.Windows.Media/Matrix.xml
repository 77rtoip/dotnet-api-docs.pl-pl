<Type Name="Matrix" FullName="System.Windows.Media.Matrix">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="92482b7a1cc4ccd88a8cc95b8a9a1044e1b59735" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36467738" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Matrix : IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Matrix extends System.ValueType implements class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Matrix" />
  <TypeSignature Language="VB.NET" Value="Public Structure Matrix&#xA;Implements IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Matrix : IFormattable" />
  <TypeSignature Language="F#" Value="type Matrix = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Media.MatrixConverter))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.Media.Converters.MatrixValueSerializer))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje macierz affine — przekształcenia 3 x 3 używany do przekształcenia przestrzeni 2-D.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Macierz 3 x 3 służy do przekształcenia w [!INCLUDE[TLA2#tla_2d](~/includes/tla2sharptla-2d-md.md)] płaszczyzny x i y. Affine — przekształcenia macierzy mnożona można tworzyć dowolną liczbę linear — przekształcenia, takie jak obrotu i pochylenia (Ścinanie), a następnie tłumaczenia. Affine — przekształcenia macierzy ma jego ostatniej kolumny równa się (0, 0, 1), dlatego tylko elementy członkowskie trzeba najpierw dwie kolumny można określić.  Należy pamiętać, że wektory są wyrażane jako wektory wiersza, nie wektory kolumny.  
  
 A [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.Media.Matrix> jest przechowywany przy użyciu kolejności wierszy i ma następującą strukturę:  
  
||||  
|-|-|-|  
|<xref:System.Windows.Media.Matrix.M11%2A>|<xref:System.Windows.Media.Matrix.M12%2A>|0|  
|<xref:System.Windows.Media.Matrix.M21%2A>|<xref:System.Windows.Media.Matrix.M22%2A>|0|  
|<xref:System.Windows.Media.Matrix.OffsetX%2A>|<xref:System.Windows.Media.Matrix.OffsetY%2A>|1|  
  
 Elementy członkowskie w ostatnim wierszu <xref:System.Windows.Media.Matrix.OffsetX%2A> i <xref:System.Windows.Media.Matrix.OffsetY%2A>, reprezentują wartości, tłumaczenia.  
  
 Metod i właściwości macierzy transformacji jest zazwyczaj określony jako wektora z sześciu tylko członków, w następujący sposób:  
  
 (<xref:System.Windows.Media.Matrix.M11%2A>, <xref:System.Windows.Media.Matrix.M12%2A>, <xref:System.Windows.Media.Matrix.M21%2A>, <xref:System.Windows.Media.Matrix.M22%2A>, <xref:System.Windows.Media.Matrix.OffsetX%2A>, <xref:System.Windows.Media.Matrix.OffsetY%2A>)  
  
 Chociaż można używać <xref:System.Windows.Media.Matrix> struktury bezpośrednio do tłumaczenia poszczególnych punktów lub <xref:System.Windows.Media.MatrixTransform> do przekształcania obiektów, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] udostępnia również zestaw klas, które umożliwiają przekształcanie obiektów bez Praca bezpośrednio z macierzy: <xref:System.Windows.Media.RotateTransform>, <xref:System.Windows.Media.ScaleTransform>, <xref:System.Windows.Media.SkewTransform>, i <xref:System.Windows.Media.TranslateTransform>.  
  
<a name="xamlAttributeUsage_Matrix"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="m11, m12, m21, m22, offsetX, offsetY"/>  
- or -  
<object property="Identity"/>  
```  
  
<a name="xamlValues_Matrix"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *m11*  
 <xref:System.Double?displayProperty=nameWithType>  
  
 Wartość w pierwszym wierszu i pierwszej kolumny tego <xref:System.Windows.Media.Matrix>. Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Media.Matrix.M11%2A> właściwości.  
  
 *m12*  
 <xref:System.Double?displayProperty=nameWithType>  
  
 Wartość w pierwszym wierszu i drugiej kolumny. Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Media.Matrix.M12%2A> właściwości.  
  
 *m21*  
 <xref:System.Double?displayProperty=nameWithType>  
  
 Wartość w drugim wierszu i pierwszej kolumny. Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Media.Matrix.M21%2A> właściwości.  
  
 *m22*  
 <xref:System.Double?displayProperty=nameWithType>  
  
 Wartość w drugim wierszu i drugiej kolumny. Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Media.Matrix.M22%2A> właściwości.  
  
 *offsetX*  
 <xref:System.Double?displayProperty=nameWithType>  
  
 Wartość w pierwszej kolumnie i trzeciego wiersza. Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Media.Matrix.OffsetX%2A> właściwości.  
  
 *offsetY*  
 <xref:System.Double?displayProperty=nameWithType>  
  
 Wartość trzeciego wiersza i drugiej kolumny. Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Media.Matrix.OffsetY%2A> właściwości.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Matrix (double m11, double m12, double m21, double m22, double offsetX, double offsetY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 m11, float64 m12, float64 m21, float64 m22, float64 offsetX, float64 offsetY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (m11 As Double, m12 As Double, m21 As Double, m22 As Double, offsetX As Double, offsetY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Matrix(double m11, double m12, double m21, double m22, double offsetX, double offsetY);" />
      <MemberSignature Language="F#" Value="new System.Windows.Media.Matrix : double * double * double * double * double * double -&gt; System.Windows.Media.Matrix" Usage="new System.Windows.Media.Matrix (m11, m12, m21, m22, offsetX, offsetY)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="m11" Type="System.Double" />
        <Parameter Name="m12" Type="System.Double" />
        <Parameter Name="m21" Type="System.Double" />
        <Parameter Name="m22" Type="System.Double" />
        <Parameter Name="offsetX" Type="System.Double" />
        <Parameter Name="offsetY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="m11">Nowy <see cref="T:System.Windows.Media.Matrix" /> struktury <see cref="P:System.Windows.Media.Matrix.M11" /> współczynnik.</param>
        <param name="m12">Nowy <see cref="T:System.Windows.Media.Matrix" /> struktury <see cref="P:System.Windows.Media.Matrix.M12" /> współczynnik.</param>
        <param name="m21">Nowy <see cref="T:System.Windows.Media.Matrix" /> struktury <see cref="P:System.Windows.Media.Matrix.M21" /> współczynnik.</param>
        <param name="m22">Nowy <see cref="T:System.Windows.Media.Matrix" /> struktury <see cref="P:System.Windows.Media.Matrix.M22" /> współczynnik.</param>
        <param name="offsetX">Nowy <see cref="T:System.Windows.Media.Matrix" /> struktury <see cref="P:System.Windows.Media.Matrix.OffsetX" /> współczynnik.</param>
        <param name="offsetY">Nowy <see cref="T:System.Windows.Media.Matrix" /> struktury <see cref="P:System.Windows.Media.Matrix.OffsetY" /> współczynnik.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Windows.Media.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(valuetype System.Windows.Media.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Append(System.Windows.Media.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Windows::Media::Matrix matrix);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Windows.Media.Matrix -&gt; unit" Usage="matrix.Append matrix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Windows.Media.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">
          <see cref="T:System.Windows.Media.Matrix" /> Struktury, które mają zostać dołączone do tego <see cref="T:System.Windows.Media.Matrix" /> struktury.</param>
        <summary>Dołącza określony <see cref="T:System.Windows.Media.Matrix" /> struktury tej <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja jest taki sam, jak to pomnożenie <xref:System.Windows.Media.Matrix> struktury przez parametr `matrix`.  Mnożenie macierzy nie jest przemienne, dlatego ta operacja nie jest taka sama jak pomnożenie parametr `matrix` to <xref:System.Windows.Media.Matrix> struktury; oznacza to, że (to * `matrix`) nie jest taka sama jak (`matrix` * to).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak dołączyć <xref:System.Windows.Media.Matrix> struktury do innego <xref:System.Windows.Media.Matrix> struktury.  
  
 [!code-csharp[MatrixExamples_snip#MatrixRotateAboutPointExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixrotateaboutpointexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.Multiply(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
        <altmember cref="M:System.Windows.Media.Matrix.op_Multiply(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
        <altmember cref="M:System.Windows.Media.Matrix.Prepend(System.Windows.Media.Matrix)" />
      </Docs>
    </Member>
    <Member MemberName="Determinant">
      <MemberSignature Language="C#" Value="public double Determinant { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Determinant" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Matrix.Determinant" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Determinant As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Determinant { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Determinant : double" Usage="System.Windows.Media.Matrix.Determinant" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera cyfr to <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <value>Cyfr to <see cref="T:System.Windows.Media.Matrix" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie pokazano, jak pobrać cyfr <xref:System.Windows.Media.Matrix>.  
  
 [!code-csharp[MatrixExamples_snip#MatrixDeterminantExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixdeterminantexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy dwa określone <see cref="T:System.Windows.Media.Matrix" /> struktury mają takie same wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A <xref:System.Windows.Media.Matrix> jako symulacyjnych są przechowywane jego wartości. Ponieważ wartość <xref:System.Double> mogą tracić dokładność podczas operacji arytmetycznych na niej porównanie między dwoma <xref:System.Double> struktur, które są logicznie równe może zakończyć się niepowodzeniem.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób sprawdzić dwa <xref:System.Windows.Media.Matrix> struktury pod kątem równości.  
  
 [!code-csharp[MatrixExamples_snip#MatrixEqualityExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixequalityexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="matrix.Equals o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <see cref="T:System.Object" /> Do porównania.</param>
        <summary>Określa, czy określony <see cref="T:System.Object" /> jest <see cref="T:System.Windows.Media.Matrix" /> struktury, która jest taka sama jak to <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="o" /> jest <see cref="T:System.Windows.Media.Matrix" /> struktury, która jest taka sama jak to <see cref="T:System.Windows.Media.Matrix" /> struktury; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A <xref:System.Windows.Media.Matrix> jako symulacyjnych są przechowywane jego wartości. Ponieważ wartość <xref:System.Double> mogą tracić dokładność podczas operacji arytmetycznych na niej porównanie między dwoma <xref:System.Double> struktur, które są logicznie równe może zakończyć się niepowodzeniem.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób sprawdzić dwa <xref:System.Windows.Media.Matrix> struktury pod kątem równości.  
  
 [!code-csharp[MatrixExamples_snip#MatrixEqualityExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixequalityexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.op_Equality(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Windows.Media.Matrix value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.Windows.Media.Matrix value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Equals(System.Windows.Media.Matrix)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Matrix) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Windows::Media::Matrix value);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Windows.Media.Matrix -&gt; bool" Usage="matrix.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Media.Matrix" />
      </Parameters>
      <Docs>
        <param name="value">Wystąpienie <see cref="T:System.Windows.Media.Matrix" /> do porównania z tym wystąpieniem.</param>
        <summary>Określa, czy określony <see cref="T:System.Windows.Media.Matrix" /> struktura jest taki sam jak to wystąpienie.</summary>
        <returns>
          <see langword="true" /> Jeśli wystąpienia są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A <xref:System.Windows.Media.Matrix> jako symulacyjnych są przechowywane jego wartości. Ponieważ wartość <xref:System.Double> mogą tracić dokładność podczas operacji arytmetycznych na niej porównanie między dwoma <xref:System.Double> struktur, które są logicznie równe może zakończyć się niepowodzeniem.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób sprawdzić dwa <xref:System.Windows.Media.Matrix> struktury pod kątem równości.  
  
 [!code-csharp[MatrixExamples_snip#MatrixEqualityExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixequalityexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.op_Equality(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (System.Windows.Media.Matrix matrix1, System.Windows.Media.Matrix matrix2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(valuetype System.Windows.Media.Matrix matrix1, valuetype System.Windows.Media.Matrix matrix2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Equals(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (matrix1 As Matrix, matrix2 As Matrix) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Windows::Media::Matrix matrix1, System::Windows::Media::Matrix matrix2);" />
      <MemberSignature Language="F#" Value="static member Equals : System.Windows.Media.Matrix * System.Windows.Media.Matrix -&gt; bool" Usage="System.Windows.Media.Matrix.Equals (matrix1, matrix2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix1" Type="System.Windows.Media.Matrix" />
        <Parameter Name="matrix2" Type="System.Windows.Media.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix1">Pierwszy <see cref="T:System.Windows.Media.Matrix" /> struktury do porównania.</param>
        <param name="matrix2">Drugi <see cref="T:System.Windows.Media.Matrix" /> struktury do porównania.</param>
        <summary>Określa, czy dwa określone <see cref="T:System.Windows.Media.Matrix" /> struktury są identyczne.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="matrix1" /> i <paramref name="matrix2" /> są identyczne, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A <xref:System.Windows.Media.Matrix> jako symulacyjnych są przechowywane jego wartości. Ponieważ wartość <xref:System.Double> mogą tracić dokładność podczas operacji arytmetycznych na niej porównanie między dwoma <xref:System.Double> struktur, które są logicznie równe może zakończyć się niepowodzeniem.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.op_Equality(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="matrix.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla tego <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <returns>Kod skrótu dla tego wystąpienia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasInverse">
      <MemberSignature Language="C#" Value="public bool HasInverse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasInverse" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Matrix.HasInverse" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasInverse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasInverse { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasInverse : bool" Usage="System.Windows.Media.Matrix.HasInverse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Windows.Media.Matrix" /> struktura jest nieodwracalna.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Windows.Media.Matrix" /> ma odwrotność; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Następujące testy przykład czy <xref:System.Windows.Media.Matrix> się odwracalne. Jeśli to się odwracalne, <xref:System.Windows.Media.Matrix> jest odwrócony.  
  
 [!code-csharp[MatrixExamples_snip#MatrixInverseExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixinverseexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Identity">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.Matrix Identity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Media.Matrix Identity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Matrix.Identity" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Identity As Matrix" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Media::Matrix Identity { System::Windows::Media::Matrix get(); };" />
      <MemberSignature Language="F#" Value="member this.Identity : System.Windows.Media.Matrix" Usage="System.Windows.Media.Matrix.Identity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Matrix</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera tożsamość <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <value>Macierz tożsamości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Macierzą ma wartość 1 w szeregach [1,1], [2,2], [3,3], a wartość 0 w pozostałej części współczynników. To są powiązane z ustawienie <xref:System.Windows.Media.Matrix.M11%2A> i <xref:System.Windows.Media.Matrix.M22%2A> 1 i <xref:System.Windows.Media.Matrix.M12%2A>, <xref:System.Windows.Media.Matrix.M21%2A>, <xref:System.Windows.Media.Matrix.OffsetX%2A>, i <xref:System.Windows.Media.Matrix.OffsetY%2A> na 0. W macierzy podobne, która jest implementacja który [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] używa <xref:System.Windows.Media.Matrix>, struktury, współczynników [3,1], [3,2], [3.3] niejawnego są zawsze miały odpowiednio wartości 0,0,1.  
  
||||  
|-|-|-|  
|1|0|0|  
|0|1|0|  
|0|0|1|  
  
 Macierzy tożsamości <xref:System.Windows.Media.Matrix.ToString%2A> metoda zwraca ciąg "Tożsamość" zamiast współczynników <xref:System.Windows.Media.Matrix>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób pobrać <xref:System.Windows.Media.Matrix.Identity%2A> macierzy.  
  
 [!code-csharp[MatrixExamples_snip#MatrixIdentityExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixidentityexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.SetIdentity" />
        <altmember cref="P:System.Windows.Media.Matrix.IsIdentity" />
      </Docs>
    </Member>
    <Member MemberName="Invert">
      <MemberSignature Language="C#" Value="public void Invert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Invert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invert();" />
      <MemberSignature Language="F#" Value="member this.Invert : unit -&gt; unit" Usage="matrix.Invert " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odwraca wybór to <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład umożliwia sprawdzenie, czy <xref:System.Windows.Media.Matrix> struktura jest nieodwracalna. Jeśli to się odwracalne, <xref:System.Windows.Media.Matrix> struktura jest odwrócony.  
  
 [!code-csharp[MatrixExamples_snip#MatrixInverseExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixinverseexample_csharp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Windows.Media.Matrix" /> Struktury nie jest odwracalne.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsIdentity">
      <MemberSignature Language="C#" Value="public bool IsIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Matrix.IsIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIdentity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIdentity { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIdentity : bool" Usage="System.Windows.Media.Matrix.IsIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Windows.Media.Matrix" /> struktura jest macierzą.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Windows.Media.Matrix" /> struktura jest macierzą; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Macierzą ma wartość 1 w szeregach [1,1], [2,2], [3,3], a wartość 0 w pozostałej części współczynników. To są powiązane z ustawienie <xref:System.Windows.Media.Matrix.M11%2A> i <xref:System.Windows.Media.Matrix.M22%2A> 1 i <xref:System.Windows.Media.Matrix.M12%2A>, <xref:System.Windows.Media.Matrix.M21%2A>, <xref:System.Windows.Media.Matrix.OffsetX%2A>, i <xref:System.Windows.Media.Matrix.OffsetY%2A> na 0. W macierzy podobne, która jest implementacja który [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] używa <xref:System.Windows.Media.Matrix> struktury współczynników [3,1], [3,2], [3.3] niejawnego są zawsze miały odpowiednio wartości 0,0,1.  
  
||||  
|-|-|-|  
|1|0|0|  
|0|1|0|  
|0|0|1|  
  
 Macierzy tożsamości <xref:System.Windows.Media.Matrix.ToString%2A> metoda zwraca ciąg "Tożsamości", zamiast współczynników <xref:System.Windows.Media.Matrix>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Matrix.Identity" />
        <altmember cref="M:System.Windows.Media.Matrix.SetIdentity" />
      </Docs>
    </Member>
    <Member MemberName="M11">
      <MemberSignature Language="C#" Value="public double M11 { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 M11" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Matrix.M11" />
      <MemberSignature Language="VB.NET" Value="Public Property M11 As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double M11 { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.M11 : double with get, set" Usage="System.Windows.Media.Matrix.M11" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość pierwszego wiersza i pierwszej kolumny tego <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <value>Wartość pierwszego wiersza i pierwszej kolumny tego <see cref="T:System.Windows.Media.Matrix" />. Wartość domyślna to 1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób pomnożyć dwa <xref:System.Windows.Media.Matrix> struktury i jak można przypisać wartości do <xref:System.Windows.Media.Matrix> gdy jest on zadeklarowany jako, a po strukturze zadeklarowano.  
  
 [!code-csharp[MatrixExamples_snip#MatrixMultiplicationExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixmultiplicationexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="M12">
      <MemberSignature Language="C#" Value="public double M12 { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 M12" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Matrix.M12" />
      <MemberSignature Language="VB.NET" Value="Public Property M12 As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double M12 { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.M12 : double with get, set" Usage="System.Windows.Media.Matrix.M12" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość pierwszej kolumny wiersza i sekundę tego <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <value>Wartość pierwszej kolumny wiersza i sekundę tego <see cref="T:System.Windows.Media.Matrix" />. Wartość domyślna to 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono układ <xref:System.Windows.Media.Matrix>.  
  
||||  
|-|-|-|  
|<xref:System.Windows.Media.Matrix.M11%2A>|<xref:System.Windows.Media.Matrix.M12%2A>|0|  
|<xref:System.Windows.Media.Matrix.M21%2A>|<xref:System.Windows.Media.Matrix.M22%2A>|0|  
|<xref:System.Windows.Media.Matrix.OffsetX%2A>|<xref:System.Windows.Media.Matrix.OffsetY%2A>|1|  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób pomnożyć dwa <xref:System.Windows.Media.Matrix> struktury i jak można przypisać wartości do <xref:System.Windows.Media.Matrix> gdy jest on zadeklarowany jako, a po strukturze zadeklarowano.  
  
 [!code-csharp[MatrixExamples_snip#MatrixMultiplicationExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixmultiplicationexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="M21">
      <MemberSignature Language="C#" Value="public double M21 { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 M21" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Matrix.M21" />
      <MemberSignature Language="VB.NET" Value="Public Property M21 As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double M21 { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.M21 : double with get, set" Usage="System.Windows.Media.Matrix.M21" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość drugiego wiersza i pierwszej kolumny tego <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <value>Wartość drugiego wiersza i pierwszej kolumny tego <see cref="T:System.Windows.Media.Matrix" />. Wartość domyślna to 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono układ <xref:System.Windows.Media.Matrix>.  
  
||||  
|-|-|-|  
|<xref:System.Windows.Media.Matrix.M11%2A>|<xref:System.Windows.Media.Matrix.M12%2A>|0|  
|<xref:System.Windows.Media.Matrix.M21%2A>|<xref:System.Windows.Media.Matrix.M22%2A>|0|  
|<xref:System.Windows.Media.Matrix.OffsetX%2A>|<xref:System.Windows.Media.Matrix.OffsetY%2A>|1|  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób pomnożyć dwa <xref:System.Windows.Media.Matrix> struktury i jak można przypisać wartości do <xref:System.Windows.Media.Matrix> gdy jest on zadeklarowany jako, a po strukturze zadeklarowano.  
  
 [!code-csharp[MatrixExamples_snip#MatrixMultiplicationExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixmultiplicationexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="M22">
      <MemberSignature Language="C#" Value="public double M22 { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 M22" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Matrix.M22" />
      <MemberSignature Language="VB.NET" Value="Public Property M22 As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double M22 { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.M22 : double with get, set" Usage="System.Windows.Media.Matrix.M22" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość w drugiej kolumnie wierszy i sekundę tego <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <value>Wartość w drugiej kolumnie wierszy i sekundę tego <see cref="T:System.Windows.Media.Matrix" /> struktury. Wartość domyślna to 1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono układ <xref:System.Windows.Media.Matrix> struktury.  
  
||||  
|-|-|-|  
|<xref:System.Windows.Media.Matrix.M11%2A>|<xref:System.Windows.Media.Matrix.M12%2A>|0|  
|<xref:System.Windows.Media.Matrix.M21%2A>|<xref:System.Windows.Media.Matrix.M22%2A>|0|  
|<xref:System.Windows.Media.Matrix.OffsetX%2A>|<xref:System.Windows.Media.Matrix.OffsetY%2A>|1|  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób pomnożyć dwa <xref:System.Windows.Media.Matrix> struktury i jak można przypisać wartości do <xref:System.Windows.Media.Matrix> gdy jest on zadeklarowany jako, a po strukturze zadeklarowano.  
  
 [!code-csharp[MatrixExamples_snip#MatrixMultiplicationExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixmultiplicationexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.Matrix Multiply (System.Windows.Media.Matrix trans1, System.Windows.Media.Matrix trans2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Media.Matrix Multiply(valuetype System.Windows.Media.Matrix trans1, valuetype System.Windows.Media.Matrix trans2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Multiply(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (trans1 As Matrix, trans2 As Matrix) As Matrix" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::Matrix Multiply(System::Windows::Media::Matrix trans1, System::Windows::Media::Matrix trans2);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Windows.Media.Matrix * System.Windows.Media.Matrix -&gt; System.Windows.Media.Matrix" Usage="System.Windows.Media.Matrix.Multiply (trans1, trans2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Matrix</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trans1" Type="System.Windows.Media.Matrix" />
        <Parameter Name="trans2" Type="System.Windows.Media.Matrix" />
      </Parameters>
      <Docs>
        <param name="trans1">Pierwszy <see cref="T:System.Windows.Media.Matrix" /> struktury, należy pomnożyć.</param>
        <param name="trans2">Drugi <see cref="T:System.Windows.Media.Matrix" /> struktury, należy pomnożyć.</param>
        <summary>Mnoży <see cref="T:System.Windows.Media.Matrix" /> struktury przez inną <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <returns>Wynik mnożenia <paramref name="trans1" /> przez <paramref name="trans2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mnożenie macierzy nie jest przemienne. Pomnożenie `trans1` przez `trans2` nie jest taka sama jak pomnożenie `trans2` przez `trans1`.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób pomnożyć dwa <xref:System.Windows.Media.Matrix> struktury.  
  
 [!code-csharp[MatrixExamples_snip#MatrixMultiplicationExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixmultiplicationexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.op_Multiply(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
        <altmember cref="M:System.Windows.Media.Matrix.Prepend(System.Windows.Media.Matrix)" />
        <altmember cref="M:System.Windows.Media.Matrix.Append(System.Windows.Media.Matrix)" />
      </Docs>
    </Member>
    <Member MemberName="OffsetX">
      <MemberSignature Language="C#" Value="public double OffsetX { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 OffsetX" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Matrix.OffsetX" />
      <MemberSignature Language="VB.NET" Value="Public Property OffsetX As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double OffsetX { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.OffsetX : double with get, set" Usage="System.Windows.Media.Matrix.OffsetX" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość trzeciego wiersza i pierwszej kolumny tego <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <value>Wartość trzeciego wiersza i pierwszej kolumny tego <see cref="T:System.Windows.Media.Matrix" /> struktury. Wartość domyślna to 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Matrix.OffsetX%2A> Tak nosi właściwości, ponieważ określa ona tłumaczenie przestrzeni współrzędnych wzdłuż osi x.  
  
 W poniższej tabeli przedstawiono układ <xref:System.Windows.Media.Matrix>.  
  
||||  
|-|-|-|  
|<xref:System.Windows.Media.Matrix.M11%2A>|<xref:System.Windows.Media.Matrix.M12%2A>|0|  
|<xref:System.Windows.Media.Matrix.M21%2A>|<xref:System.Windows.Media.Matrix.M22%2A>|0|  
|<xref:System.Windows.Media.Matrix.OffsetX%2A>|<xref:System.Windows.Media.Matrix.OffsetY%2A>|1|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OffsetY">
      <MemberSignature Language="C#" Value="public double OffsetY { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 OffsetY" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Matrix.OffsetY" />
      <MemberSignature Language="VB.NET" Value="Public Property OffsetY As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double OffsetY { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.OffsetY : double with get, set" Usage="System.Windows.Media.Matrix.OffsetY" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość trzeciej kolumny wiersza i sekundę tego <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <value>Wartość trzeciej kolumny wiersza i sekundę tego <see cref="T:System.Windows.Media.Matrix" /> struktury. Wartość domyślna to 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Matrix.OffsetY%2A> Tak nosi właściwości, ponieważ określa ona tłumaczenie przestrzeni współrzędnych wzdłuż osi y.  
  
 W poniższej tabeli przedstawiono układ <xref:System.Windows.Media.Matrix>.  
  
||||  
|-|-|-|  
|<xref:System.Windows.Media.Matrix.M11%2A>|<xref:System.Windows.Media.Matrix.M12%2A>|0|  
|<xref:System.Windows.Media.Matrix.M21%2A>|<xref:System.Windows.Media.Matrix.M22%2A>|0|  
|<xref:System.Windows.Media.Matrix.OffsetX%2A>|<xref:System.Windows.Media.Matrix.OffsetY%2A>|1|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Media.Matrix matrix1, System.Windows.Media.Matrix matrix2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Windows.Media.Matrix matrix1, valuetype System.Windows.Media.Matrix matrix2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.op_Equality(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (matrix1 As Matrix, matrix2 As Matrix) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Media::Matrix matrix1, System::Windows::Media::Matrix matrix2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.Media.Matrix * System.Windows.Media.Matrix -&gt; bool" Usage="matrix1 = matrix2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix1" Type="System.Windows.Media.Matrix" />
        <Parameter Name="matrix2" Type="System.Windows.Media.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix1">Pierwszy <see cref="T:System.Windows.Media.Matrix" /> struktury do porównania.</param>
        <param name="matrix2">Drugi <see cref="T:System.Windows.Media.Matrix" /> struktury do porównania.</param>
        <summary>Określa, czy dwa określone <see cref="T:System.Windows.Media.Matrix" /> struktury są identyczne.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="matrix1" /> i <paramref name="matrix2" /> są identyczne, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A <xref:System.Windows.Media.Matrix> jako symulacyjnych są przechowywane jego wartości. Ponieważ wartość <xref:System.Double> mogą tracić dokładność podczas operacji arytmetycznych na niej porównanie między dwoma <xref:System.Double> struktur, które są logicznie równe może zakończyć się niepowodzeniem.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób sprawdzić dwa <xref:System.Windows.Media.Matrix> struktury pod kątem równości.  
  
 [!code-csharp[MatrixExamples_snip#MatrixEqualityExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixequalityexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Media.Matrix.Equals" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Media.Matrix matrix1, System.Windows.Media.Matrix matrix2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Windows.Media.Matrix matrix1, valuetype System.Windows.Media.Matrix matrix2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.op_Inequality(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (matrix1 As Matrix, matrix2 As Matrix) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Media::Matrix matrix1, System::Windows::Media::Matrix matrix2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.Media.Matrix * System.Windows.Media.Matrix -&gt; bool" Usage="System.Windows.Media.Matrix.op_Inequality (matrix1, matrix2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix1" Type="System.Windows.Media.Matrix" />
        <Parameter Name="matrix2" Type="System.Windows.Media.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix1">Pierwszy <see cref="T:System.Windows.Media.Matrix" /> struktury do porównania.</param>
        <param name="matrix2">Drugi <see cref="T:System.Windows.Media.Matrix" /> struktury do porównania.</param>
        <summary>Określa, czy dwa określone <see cref="T:System.Windows.Media.Matrix" /> struktur nie są identyczne.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="matrix1" /> i <paramref name="matrix2" /> nie są identyczne, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A <xref:System.Windows.Media.Matrix> jako symulacyjnych są przechowywane jego wartości. Ponieważ wartość <xref:System.Double> mogą tracić dokładność podczas operacji arytmetycznych na niej porównanie między dwoma <xref:System.Double> struktur, które są logicznie równe może zakończyć się niepowodzeniem.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób sprawdzić dwa <xref:System.Windows.Media.Matrix> struktury pod kątem równości.  
  
 [!code-csharp[MatrixExamples_snip#MatrixEqualityExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixequalityexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.Matrix operator * (System.Windows.Media.Matrix trans1, System.Windows.Media.Matrix trans2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Windows.Media.Matrix op_Multiply(valuetype System.Windows.Media.Matrix trans1, valuetype System.Windows.Media.Matrix trans2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.op_Multiply(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (trans1 As Matrix, trans2 As Matrix) As Matrix" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::Matrix operator *(System::Windows::Media::Matrix trans1, System::Windows::Media::Matrix trans2);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Windows.Media.Matrix * System.Windows.Media.Matrix -&gt; System.Windows.Media.Matrix" Usage="trans1 * trans2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Matrix</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trans1" Type="System.Windows.Media.Matrix" />
        <Parameter Name="trans2" Type="System.Windows.Media.Matrix" />
      </Parameters>
      <Docs>
        <param name="trans1">Pierwszy <see cref="T:System.Windows.Media.Matrix" /> struktury, należy pomnożyć.</param>
        <param name="trans2">Drugi <see cref="T:System.Windows.Media.Matrix" /> struktury, należy pomnożyć.</param>
        <summary>Mnoży <see cref="T:System.Windows.Media.Matrix" /> struktury przez inną <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <returns>Wynik mnożenia <paramref name="trans1" /> przez <paramref name="trans2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mnożenie macierzy nie jest przemienne. Pomnożenie `trans1` przez `trans2` nie jest taka sama jak pomnożenie `trans2` przez `trans1`.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób pomnożyć dwa <xref:System.Windows.Media.Matrix> struktury.  
  
 [!code-csharp[MatrixExamples_snip#MatrixMultiplicationExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixmultiplicationexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.Multiply(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
        <altmember cref="M:System.Windows.Media.Matrix.Prepend(System.Windows.Media.Matrix)" />
        <altmember cref="M:System.Windows.Media.Matrix.Append(System.Windows.Media.Matrix)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.Matrix Parse (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Media.Matrix Parse(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (source As String) As Matrix" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::Matrix Parse(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Windows.Media.Matrix" Usage="System.Windows.Media.Matrix.Parse source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Matrix</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">
          <see cref="T:System.String" /> Reprezentację macierzy.</param>
        <summary>Konwertuje <see cref="T:System.String" /> reprezentację macierzy na równoważne <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <returns>Odpowiednik <see cref="T:System.Windows.Media.Matrix" /> struktury.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak przekonwertować reprezentację ciągu macierzy do <xref:System.Windows.Media.Matrix> struktury.  
  
 [!code-csharp[MatrixExamples_snip#MatrixParseExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixparseexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prepend">
      <MemberSignature Language="C#" Value="public void Prepend (System.Windows.Media.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Prepend(valuetype System.Windows.Media.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Prepend(System.Windows.Media.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Prepend(System::Windows::Media::Matrix matrix);" />
      <MemberSignature Language="F#" Value="member this.Prepend : System.Windows.Media.Matrix -&gt; unit" Usage="matrix.Prepend matrix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Windows.Media.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">
          <see cref="T:System.Windows.Media.Matrix" /> Struktury dołączy do tego <see cref="T:System.Windows.Media.Matrix" /> struktury.</param>
        <summary>Dołącza określony <see cref="T:System.Windows.Media.Matrix" /> struktury na to <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja jest taka sama jak pomnożenie parametr `matrix` to <xref:System.Windows.Media.Matrix> struktury. Mnożenie macierzy nie jest przemienne, jednak, dlatego ta operacja nie jest taka sama, jak to pomnożenie <xref:System.Windows.Media.Matrix> struktury przez parametr `matrix`, `matrix` * nie jest taka sama, jak to * `matrix`.  
  
 W złożonych przekształcania ważne jest kolejność pojedyncze przekształcenia. Na przykład jeśli należy najpierw obracanie, skalowanie, a następnie wykonuje, możesz uzyskać różne wyniki niż Jeśli najpierw tłumaczenia, obracanie, następnie skalowania. Powodem, dla którego kolejność jest ważna jest, że przekształcenia, takie jak obracanie i skalowanie są wykonywane względem źródła współrzędnych. Skalowanie obiektu, który skupia się na początku daje różne wyniki niż skalowania obiektu, który został przeniesiony poza źródła. Podobnie obrót obiektu, który skupia się na początku daje różne wyniki niż Obracanie obiektu, który został przeniesiony poza źródła.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób dołączy <xref:System.Windows.Media.Matrix> na inny <xref:System.Windows.Media.Matrix>.  
  
 [!code-csharp[MatrixExamples_snip#MatrixPrependExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixprependexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.Multiply(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
        <altmember cref="M:System.Windows.Media.Matrix.op_Multiply(System.Windows.Media.Matrix,System.Windows.Media.Matrix)" />
        <altmember cref="M:System.Windows.Media.Matrix.Append(System.Windows.Media.Matrix)" />
      </Docs>
    </Member>
    <Member MemberName="Rotate">
      <MemberSignature Language="C#" Value="public void Rotate (double angle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Rotate(float64 angle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Rotate(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rotate (angle As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Rotate(double angle);" />
      <MemberSignature Language="F#" Value="member this.Rotate : double -&gt; unit" Usage="matrix.Rotate angle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="angle" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="angle">Kąt obrotu.</param>
        <summary>Stosuje Obrót o określony kąt wokół miejsca początkowego to <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób Obróć <xref:System.Windows.Media.Matrix>.  
  
 [!code-csharp[MatrixExamples_snip#MatrixRotateExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixrotateexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.RotatePrepend(System.Double)" />
        <altmember cref="M:System.Windows.Media.Matrix.RotateAt(System.Double,System.Double,System.Double)" />
        <altmember cref="M:System.Windows.Media.Matrix.RotateAtPrepend(System.Double,System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="RotateAt">
      <MemberSignature Language="C#" Value="public void RotateAt (double angle, double centerX, double centerY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RotateAt(float64 angle, float64 centerX, float64 centerY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.RotateAt(System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RotateAt (angle As Double, centerX As Double, centerY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RotateAt(double angle, double centerX, double centerY);" />
      <MemberSignature Language="F#" Value="member this.RotateAt : double * double * double -&gt; unit" Usage="matrix.RotateAt (angle, centerX, centerY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="angle" Type="System.Double" />
        <Parameter Name="centerX" Type="System.Double" />
        <Parameter Name="centerY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="angle">Kąt w stopniach, za pomocą którego można obracać tej macierzy.</param>
        <param name="centerX">Współrzędna x punktu o tym, które można obracać tej macierzy.</param>
        <param name="centerY">Współrzędna y punktu o tym, które można obracać tej macierzy.</param>
        <summary>Obraca tej macierzy. informacje o punkcie określony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób Obróć <xref:System.Windows.Media.Matrix> o określonym punkcie.  
  
 [!code-csharp[MatrixExamples_snip#MatrixRotateAboutPointExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixrotateaboutpointexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RotateAtPrepend">
      <MemberSignature Language="C#" Value="public void RotateAtPrepend (double angle, double centerX, double centerY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RotateAtPrepend(float64 angle, float64 centerX, float64 centerY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.RotateAtPrepend(System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RotateAtPrepend (angle As Double, centerX As Double, centerY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RotateAtPrepend(double angle, double centerX, double centerY);" />
      <MemberSignature Language="F#" Value="member this.RotateAtPrepend : double * double * double -&gt; unit" Usage="matrix.RotateAtPrepend (angle, centerX, centerY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="angle" Type="System.Double" />
        <Parameter Name="centerX" Type="System.Double" />
        <Parameter Name="centerY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="angle">Kąt obrotu w stopniach.</param>
        <param name="centerX">Współrzędna x środka obrotu.</param>
        <param name="centerY">Współrzędna y środka obrotu.</param>
        <summary>Dołącza obrotu kąta określonego w określonym punkcie to <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W złożonych przekształcania ważne jest kolejność pojedyncze przekształcenia. Na przykład jeśli należy najpierw obracanie, skalowanie, a następnie wykonuje, możesz uzyskać różne wyniki niż Jeśli najpierw tłumaczenia, obracanie, następnie skalowania. Powodem, dla którego kolejność jest ważna jest, że przekształcenia, takie jak obracanie i skalowanie są wykonywane względem źródła współrzędnych. Skalowanie obiektu, który skupia się na początku daje różne wyniki niż skalowania obiektu, który został przeniesiony poza źródła. Podobnie obrót obiektu, który skupia się na początku daje różne wyniki niż Obracanie obiektu, który został przeniesiony poza źródła.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób dołączy obrót do <xref:System.Windows.Media.Matrix>.  
  
 [!code-csharp[MatrixExamples_snip#MatrixPrependRotateExamples_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixprependrotateexamples_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RotatePrepend">
      <MemberSignature Language="C#" Value="public void RotatePrepend (double angle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RotatePrepend(float64 angle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.RotatePrepend(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RotatePrepend (angle As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RotatePrepend(double angle);" />
      <MemberSignature Language="F#" Value="member this.RotatePrepend : double -&gt; unit" Usage="matrix.RotatePrepend angle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="angle" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="angle">Kąt obrotu dołączenie wartości.</param>
        <summary>Dołącza Obrót o określony kąt <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W złożonych przekształcania ważne jest kolejność pojedyncze przekształcenia. Na przykład jeśli należy najpierw obracanie, skalowanie, a następnie wykonuje, możesz uzyskać różne wyniki niż Jeśli najpierw tłumaczenia, obracanie, następnie skalowania. Powodem, dla którego kolejność jest ważna jest, że przekształcenia, takie jak obracanie i skalowanie są wykonywane względem źródła współrzędnych. Skalowanie obiektu, który skupia się na początku daje różne wyniki niż skalowania obiektu, który został przeniesiony poza źródła. Podobnie obrót obiektu, który skupia się na początku daje różne wyniki niż Obracanie obiektu, który został przeniesiony poza źródła.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób dołączy obrót do <xref:System.Windows.Media.Matrix>.  
  
 [!code-csharp[MatrixExamples_snip#MatrixPrependRotateExamples_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixprependrotateexamples_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.Rotate(System.Double)" />
        <altmember cref="M:System.Windows.Media.Matrix.RotateAt(System.Double,System.Double,System.Double)" />
        <altmember cref="M:System.Windows.Media.Matrix.RotateAtPrepend(System.Double,System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (double scaleX, double scaleY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(float64 scaleX, float64 scaleY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Scale(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (scaleX As Double, scaleY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(double scaleX, double scaleY);" />
      <MemberSignature Language="F#" Value="member this.Scale : double * double -&gt; unit" Usage="matrix.Scale (scaleX, scaleY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scaleX" Type="System.Double" />
        <Parameter Name="scaleY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="scaleX">Wartość, według której można skalować to <see cref="T:System.Windows.Media.Matrix" /> wzdłuż osi x.</param>
        <param name="scaleY">Wartość, według której można skalować to <see cref="T:System.Windows.Media.Matrix" /> wzdłuż osi y.</param>
        <summary>Dołącza wektor określona Skala tej <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób skalowania <xref:System.Windows.Media.Matrix> struktury.  
  
 [!code-csharp[MatrixExamples_snip#MatrixScaleExamples_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixscaleexamples_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.ScaleAt(System.Double,System.Double,System.Double,System.Double)" />
        <altmember cref="M:System.Windows.Media.Matrix.ScaleAtPrepend(System.Double,System.Double,System.Double,System.Double)" />
        <altmember cref="M:System.Windows.Media.Matrix.ScalePrepend(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="ScaleAt">
      <MemberSignature Language="C#" Value="public void ScaleAt (double scaleX, double scaleY, double centerX, double centerY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScaleAt(float64 scaleX, float64 scaleY, float64 centerX, float64 centerY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.ScaleAt(System.Double,System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScaleAt (scaleX As Double, scaleY As Double, centerX As Double, centerY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScaleAt(double scaleX, double scaleY, double centerX, double centerY);" />
      <MemberSignature Language="F#" Value="member this.ScaleAt : double * double * double * double -&gt; unit" Usage="matrix.ScaleAt (scaleX, scaleY, centerX, centerY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scaleX" Type="System.Double" />
        <Parameter Name="scaleY" Type="System.Double" />
        <Parameter Name="centerX" Type="System.Double" />
        <Parameter Name="centerY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="scaleX">Wartość, o którą można skalować to <see cref="T:System.Windows.Media.Matrix" /> wzdłuż osi x.</param>
        <param name="scaleY">Wartość, o którą można skalować to <see cref="T:System.Windows.Media.Matrix" /> wzdłuż osi y.</param>
        <param name="centerX">Współrzędna x punktu centralnego operacji skalowania.</param>
        <param name="centerY">Współrzędna y punktu centralnego operacji skalowania.</param>
        <summary>Skaluje to <see cref="T:System.Windows.Media.Matrix" /> przy określonym określonego punktu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób skalowania <xref:System.Windows.Media.Matrix> struktury.  
  
 [!code-csharp[MatrixExamples_snip#MatrixScaleExamples_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixscaleexamples_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleAtPrepend">
      <MemberSignature Language="C#" Value="public void ScaleAtPrepend (double scaleX, double scaleY, double centerX, double centerY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScaleAtPrepend(float64 scaleX, float64 scaleY, float64 centerX, float64 centerY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.ScaleAtPrepend(System.Double,System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScaleAtPrepend (scaleX As Double, scaleY As Double, centerX As Double, centerY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScaleAtPrepend(double scaleX, double scaleY, double centerX, double centerY);" />
      <MemberSignature Language="F#" Value="member this.ScaleAtPrepend : double * double * double * double -&gt; unit" Usage="matrix.ScaleAtPrepend (scaleX, scaleY, centerX, centerY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scaleX" Type="System.Double" />
        <Parameter Name="scaleY" Type="System.Double" />
        <Parameter Name="centerX" Type="System.Double" />
        <Parameter Name="centerY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="scaleX">Współczynnik skali osi x.</param>
        <param name="scaleY">Współczynnik skali osi y.</param>
        <param name="centerX">Współrzędna x punktu, o którym wykonywana jest operacja skalowania.</param>
        <param name="centerY">Współrzędna y punktu, o którym wykonywana jest operacja skalowania.</param>
        <summary>Dołącza określona Skala określonego punktu to <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W złożonych przekształcania ważne jest kolejność pojedyncze przekształcenia. Na przykład jeśli należy najpierw obracanie, skalowanie, a następnie wykonuje, możesz uzyskać różne wyniki niż Jeśli najpierw tłumaczenia, obracanie, następnie skalowania. Powodem, dla którego kolejność jest ważna jest, że przekształcenia, takie jak obracanie i skalowanie są wykonywane względem źródła współrzędnych. Skalowanie obiektu, który skupia się na początku daje różne wyniki niż skalowania obiektu, który został przeniesiony poza źródła. Podobnie obrót obiektu, który skupia się na początku daje różne wyniki niż Obracanie obiektu, który został przeniesiony poza źródła.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób dołączenie wartości skali do <xref:System.Windows.Media.Matrix>.  
  
 [!code-csharp[MatrixExamples_snip#MatrixPrependScaleExamples_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixprependscaleexamples_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScalePrepend">
      <MemberSignature Language="C#" Value="public void ScalePrepend (double scaleX, double scaleY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScalePrepend(float64 scaleX, float64 scaleY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.ScalePrepend(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScalePrepend (scaleX As Double, scaleY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScalePrepend(double scaleX, double scaleY);" />
      <MemberSignature Language="F#" Value="member this.ScalePrepend : double * double -&gt; unit" Usage="matrix.ScalePrepend (scaleX, scaleY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scaleX" Type="System.Double" />
        <Parameter Name="scaleY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="scaleX">Wartość, według której można skalować to <see cref="T:System.Windows.Media.Matrix" /> struktury wzdłuż osi x.</param>
        <param name="scaleY">Wartość, według której można skalować to <see cref="T:System.Windows.Media.Matrix" /> struktury wzdłuż osi y.</param>
        <summary>Dołącza wektor określona Skala tej <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W złożonych przekształcania ważne jest kolejność pojedyncze przekształcenia. Na przykład jeśli należy najpierw obracanie, skalowanie, a następnie wykonuje, możesz uzyskać różne wyniki niż Jeśli najpierw tłumaczenia, obracanie, następnie skalowania. Powodem, dla którego kolejność jest ważna jest, że przekształcenia, takie jak obracanie i skalowanie są wykonywane względem źródła współrzędnych. Skalowanie obiektu, który skupia się na początku daje różne wyniki niż skalowania obiektu, który został przeniesiony poza źródła. Podobnie obrót obiektu, który skupia się na początku daje różne wyniki niż Obracanie obiektu, który został przeniesiony poza źródła.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób dołączenie wartości skali do <xref:System.Windows.Media.Matrix> struktury.  
  
 [!code-csharp[MatrixExamples_snip#MatrixPrependScaleExamples_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixprependscaleexamples_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.ScaleAtPrepend(System.Double,System.Double,System.Double,System.Double)" />
        <altmember cref="M:System.Windows.Media.Matrix.Scale(System.Double,System.Double)" />
        <altmember cref="M:System.Windows.Media.Matrix.ScaleAt(System.Double,System.Double,System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="SetIdentity">
      <MemberSignature Language="C#" Value="public void SetIdentity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIdentity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.SetIdentity" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIdentity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIdentity();" />
      <MemberSignature Language="F#" Value="member this.SetIdentity : unit -&gt; unit" Usage="matrix.SetIdentity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zmienia to <see cref="T:System.Windows.Media.Matrix" /> struktury w macierzy tożsamości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Macierzą ma wartość 1 w szeregach [1,1], [2,2], [3,3], a wartość 0 w pozostałej części współczynników. To są powiązane z ustawienie <xref:System.Windows.Media.Matrix.M11%2A> i <xref:System.Windows.Media.Matrix.M22%2A> 1 i <xref:System.Windows.Media.Matrix.M12%2A>, <xref:System.Windows.Media.Matrix.M21%2A>, <xref:System.Windows.Media.Matrix.OffsetX%2A>, i <xref:System.Windows.Media.Matrix.OffsetY%2A> na 0. W macierzy podobne, która jest implementacja który [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] używa <xref:System.Windows.Media.Matrix> struktury współczynników [3,1], [3,2], [3.3] niejawnego są zawsze miały odpowiednio wartości 0,0,1.  
  
||||  
|-|-|-|  
|1|0|0|  
|0|1|0|  
|0|0|1|  
  
 Macierzy tożsamości <xref:System.Windows.Media.Matrix.ToString%2A> metoda zwraca ciąg "Tożsamości", zamiast współczynników <xref:System.Windows.Media.Matrix>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak włączyć <xref:System.Windows.Media.Matrix> struktury w macierzy tożsamości.  
  
 [!code-csharp[MatrixExamples_snip#MatrixIdentityExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixidentityexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Matrix.Identity" />
        <altmember cref="P:System.Windows.Media.Matrix.IsIdentity" />
      </Docs>
    </Member>
    <Member MemberName="Skew">
      <MemberSignature Language="C#" Value="public void Skew (double skewX, double skewY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Skew(float64 skewX, float64 skewY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Skew(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Skew (skewX As Double, skewY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Skew(double skewX, double skewY);" />
      <MemberSignature Language="F#" Value="member this.Skew : double * double -&gt; unit" Usage="matrix.Skew (skewX, skewY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="skewX" Type="System.Double" />
        <Parameter Name="skewY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="skewX">Kąt w wymiarze x za pomocą którego fałszować to <see cref="T:System.Windows.Media.Matrix" />.</param>
        <param name="skewY">Kąt w wymiarze y za pomocą którego fałszować to <see cref="T:System.Windows.Media.Matrix" />.</param>
        <summary>Dołącza zegara określonego stopni w x i y wymiarów tej <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie pokazano, jak pochylanie <xref:System.Windows.Media.Matrix> struktury.  
  
 [!code-csharp[MatrixExamples_snip#MatrixSkewExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixskewexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.SkewPrepend(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="SkewPrepend">
      <MemberSignature Language="C#" Value="public void SkewPrepend (double skewX, double skewY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkewPrepend(float64 skewX, float64 skewY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.SkewPrepend(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkewPrepend (skewX As Double, skewY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkewPrepend(double skewX, double skewY);" />
      <MemberSignature Language="F#" Value="member this.SkewPrepend : double * double -&gt; unit" Usage="matrix.SkewPrepend (skewX, skewY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="skewX" Type="System.Double" />
        <Parameter Name="skewY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="skewX">Kąt w wymiarze x za pomocą którego fałszować to <see cref="T:System.Windows.Media.Matrix" />.</param>
        <param name="skewY">Kąt w wymiarze y za pomocą którego fałszować to <see cref="T:System.Windows.Media.Matrix" />.</param>
        <summary>Dołącza zegara określonego stopni w x i y wymiarów tej <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W złożonych przekształcania ważne jest kolejność pojedyncze przekształcenia. Na przykład jeśli należy najpierw obracanie, skalowanie, a następnie wykonuje, możesz uzyskać różne wyniki niż Jeśli najpierw tłumaczenia, obracanie, następnie skalowania. Powodem, dla którego kolejność jest ważna jest, że przekształcenia, takie jak obracanie i skalowanie są wykonywane względem źródła współrzędnych. Skalowanie obiektu, który skupia się na początku daje różne wyniki niż skalowania obiektu, który został przeniesiony poza źródła. Podobnie obrót obiektu, który skupia się na początku daje różne wyniki niż Obracanie obiektu, który został przeniesiony poza źródła.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono dołączana zegara, aby <xref:System.Windows.Media.Matrix> struktury.  
  
 [!code-csharp[MatrixExamples_snip#MatrixSkewPrependExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixskewprependexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.Skew(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="System.IFormattable.ToString">
      <MemberSignature Language="C#" Value="string IFormattable.ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IFormattable.ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.System#IFormattable#ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (format As String, provider As IFormatProvider) As String Implements IFormattable.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IFormattable.ToString(System::String ^ format, IFormatProvider ^ provider) = IFormattable::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Format, który ma być używany.  - lub - odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic) Aby użyć domyślnego formatu zdefiniowany dla typu <see cref="T:System.IFormattable" /> implementacji.</param>
        <param name="provider">Dostawcę, który ma być używany do formatowania wartości.  - lub - odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic) można uzyskać informacji formatujące z bieżących ustawień regionalnych systemu operacyjnego.</param>
        <summary>Formatuje wartość bieżącego wystąpienia przy użyciu określonego formatu.</summary>
        <returns>Wartość bieżącego wystąpienia w określonym formacie.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.IFormatProvider" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.String" /> to reprezentacja <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta <xref:System.Windows.Media.Matrix> struktura jest macierzą, zostanie zwrócony ciąg "Identity".  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="matrix.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy <see cref="T:System.String" /> to reprezentacja <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <returns>A <see cref="T:System.String" /> zawierający <see cref="P:System.Windows.Media.Matrix.M11" />, <see cref="P:System.Windows.Media.Matrix.M12" />, <see cref="P:System.Windows.Media.Matrix.M21" />, <see cref="P:System.Windows.Media.Matrix.M22" />, <see cref="P:System.Windows.Media.Matrix.OffsetX" />, i <see cref="P:System.Windows.Media.Matrix.OffsetY" /> wartości to <see cref="T:System.Windows.Media.Matrix" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Media.Matrix> jest <xref:System.Windows.Media.Matrix.Identity%2A> macierzy, ten ciąg jest zwracana "Identity".  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="matrix.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Formatowanie informacje specyficzne dla kultury.</param>
        <summary>Tworzy <see cref="T:System.String" /> to reprezentacja <see cref="T:System.Windows.Media.Matrix" /> struktury formatowania informacje specyficzne dla kultury.</summary>
        <returns>A <see cref="T:System.String" /> zawierający <see cref="P:System.Windows.Media.Matrix.M11" />, <see cref="P:System.Windows.Media.Matrix.M12" />, <see cref="P:System.Windows.Media.Matrix.M21" />, <see cref="P:System.Windows.Media.Matrix.M22" />, <see cref="P:System.Windows.Media.Matrix.OffsetX" />, i <see cref="P:System.Windows.Media.Matrix.OffsetY" /> wartości to <see cref="T:System.Windows.Media.Matrix" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta <xref:System.Windows.Media.Matrix> struktura jest macierzą, zostanie zwrócony ciąg "Identity".  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Transform">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przekształca określony punkt tablicy punktów, wektora lub tablicy wektorów to <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W przykładzie poniżej przedstawia sposób użycia <xref:System.Windows.Media.Matrix> do przekształcania punktów i wektory.  
  
 [!code-csharp[MatrixExamples_snip#MatrixTransformExamples_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixtransformexamples_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public System.Windows.Point Transform (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Point Transform(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Transform(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Point Transform(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="member this.Transform : System.Windows.Point -&gt; System.Windows.Point" Usage="matrix.Transform point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Punkt transformacji.</param>
        <summary>Przekształca określony punkt przez <see cref="T:System.Windows.Media.Matrix" /> i zwraca wynik.</summary>
        <returns>Wynik transformacji <paramref name="point" /> to <see cref="T:System.Windows.Media.Matrix" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W przykładzie poniżej przedstawia sposób użycia <xref:System.Windows.Media.Matrix> do przekształcania punktów i wektory.  
  
 [!code-csharp[MatrixExamples_snip#MatrixTransformExamples_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixtransformexamples_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public void Transform (System.Windows.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transform(valuetype System.Windows.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Transform(System.Windows.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transform (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transform(cli::array &lt;System::Windows::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.Transform : System.Windows.Point[] -&gt; unit" Usage="matrix.Transform points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Windows.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Punkty do przekształcenia. Oryginalny punktów w tablicy są zastępowane przez ich przekształcone wartości.</param>
        <summary>Przekształca określony wskazuje to <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W przykładzie poniżej przedstawia sposób użycia <xref:System.Windows.Media.Matrix> do przekształcania punktów i wektory.  
  
 [!code-csharp[MatrixExamples_snip#MatrixTransformExamples_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixtransformexamples_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public System.Windows.Vector Transform (System.Windows.Vector vector);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Vector Transform(valuetype System.Windows.Vector vector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Transform(System.Windows.Vector)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Vector Transform(System::Windows::Vector vector);" />
      <MemberSignature Language="F#" Value="member this.Transform : System.Windows.Vector -&gt; System.Windows.Vector" Usage="matrix.Transform vector" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Vector</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="vector" Type="System.Windows.Vector" />
      </Parameters>
      <Docs>
        <param name="vector">Wektor do przekształcenia.</param>
        <summary>Przekształca określony wektor to <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <returns>Wynik transformacji <paramref name="vector" /> to <see cref="T:System.Windows.Media.Matrix" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W przykładzie poniżej przedstawia sposób użycia <xref:System.Windows.Media.Matrix> do przekształcania punktów i wektory.  
  
 [!code-csharp[MatrixExamples_snip#MatrixTransformExamples_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixtransformexamples_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public void Transform (System.Windows.Vector[] vectors);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transform(valuetype System.Windows.Vector[] vectors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Transform(System.Windows.Vector[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transform (vectors As Vector())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transform(cli::array &lt;System::Windows::Vector&gt; ^ vectors);" />
      <MemberSignature Language="F#" Value="member this.Transform : System.Windows.Vector[] -&gt; unit" Usage="matrix.Transform vectors" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="vectors" Type="System.Windows.Vector[]" />
      </Parameters>
      <Docs>
        <param name="vectors">Wektorów do przekształcenia. Oryginalny wektory w tablicy są zastępowane przez ich przekształcone wartości.</param>
        <summary>Przekształca określony wektory to <see cref="T:System.Windows.Media.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W przykładzie poniżej przedstawia sposób użycia <xref:System.Windows.Media.Matrix> do przekształcania punktów i wektory.  
  
 [!code-csharp[MatrixExamples_snip#MatrixTransformExamples_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixtransformexamples_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public void Translate (double offsetX, double offsetY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Translate(float64 offsetX, float64 offsetY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.Translate(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Translate (offsetX As Double, offsetY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Translate(double offsetX, double offsetY);" />
      <MemberSignature Language="F#" Value="member this.Translate : double * double -&gt; unit" Usage="matrix.Translate (offsetX, offsetY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offsetX" Type="System.Double" />
        <Parameter Name="offsetY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="offsetX">Wielkość przesunięcia to <see cref="T:System.Windows.Media.Matrix" /> wzdłuż osi x.</param>
        <param name="offsetY">Wielkość przesunięcia to <see cref="T:System.Windows.Media.Matrix" /> wzdłuż osi y.</param>
        <summary>Dołącza tłumaczenia określonych przesunięć tej <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie przedstawiono sposób dołączenia tłumaczenia na <xref:System.Windows.Media.Matrix> struktury.  
  
 [!code-csharp[MatrixExamples_snip#MatrixTranslateExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixtranslateexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.TranslatePrepend(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="TranslatePrepend">
      <MemberSignature Language="C#" Value="public void TranslatePrepend (double offsetX, double offsetY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TranslatePrepend(float64 offsetX, float64 offsetY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Matrix.TranslatePrepend(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TranslatePrepend (offsetX As Double, offsetY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TranslatePrepend(double offsetX, double offsetY);" />
      <MemberSignature Language="F#" Value="member this.TranslatePrepend : double * double -&gt; unit" Usage="matrix.TranslatePrepend (offsetX, offsetY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offsetX" Type="System.Double" />
        <Parameter Name="offsetY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="offsetX">Wielkość przesunięcia to <see cref="T:System.Windows.Media.Matrix" /> wzdłuż osi x.</param>
        <param name="offsetY">Wielkość przesunięcia to <see cref="T:System.Windows.Media.Matrix" /> wzdłuż osi y.</param>
        <summary>Dołącza tłumaczenia określonych przesunięć tej <see cref="T:System.Windows.Media.Matrix" /> struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W złożonych przekształcania ważne jest kolejność pojedyncze przekształcenia. Na przykład jeśli należy najpierw obracanie, skalowanie, a następnie wykonuje, możesz uzyskać różne wyniki niż Jeśli najpierw tłumaczenia, obracanie, następnie skalowania. Powodem, dla którego kolejność jest ważna jest, że przekształcenia, takie jak obracanie i skalowanie są wykonywane względem źródła współrzędnych. Skalowanie obiektu, który skupia się na początku daje różne wyniki niż skalowania obiektu, który został przeniesiony poza źródła. Podobnie obrót obiektu, który skupia się na początku daje różne wyniki niż Obracanie obiektu, który został przeniesiony poza źródła.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono dołączana jak translacji na <xref:System.Windows.Media.Matrix> struktury.  
  
 [!code-csharp[MatrixExamples_snip#MatrixTranslatePrependExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/MatrixExamples_snip/CSharp/MatrixExample.cs#matrixtranslateprependexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Matrix.Translate(System.Double,System.Double)" />
      </Docs>
    </Member>
  </Members>
</Type>
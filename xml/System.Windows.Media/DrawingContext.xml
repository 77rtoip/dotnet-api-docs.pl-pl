<Type Name="DrawingContext" FullName="System.Windows.Media.DrawingContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6775383b12d681fb174a0d295abb23ff4c26a28f" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69436630" /></Metadata><TypeSignature Language="C#" Value="public abstract class DrawingContext : System.Windows.Threading.DispatcherObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit DrawingContext extends System.Windows.Threading.DispatcherObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.DrawingContext" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DrawingContext&#xA;Inherits DispatcherObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DrawingContext abstract : System::Windows::Threading::DispatcherObject, IDisposable" />
  <TypeSignature Language="F#" Value="type DrawingContext = class&#xA;    inherit DispatcherObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Opisuje wizualną zawartość za pomocą poleceń rysowania, wypychania i pop.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj, <xref:System.Windows.Media.DrawingContext> aby <xref:System.Windows.Media.Visual> wypełnić zawartość wizualną <xref:System.Windows.Media.Drawing> lub.  
  
 Chociaż metody <xref:System.Drawing.Graphics?displayProperty=nameWithType> <xref:System.Windows.Media.DrawingContext> <xref:System.Drawing.Graphics?displayProperty=nameWithType> rysowania wyglądają podobnie jak metody rysowania typu, działają bardzo inaczej: jest używana z systemem grafiki w trybie zachowanym, podczas gdy typ jest używany z trybem bezpośrednim <xref:System.Windows.Media.DrawingContext> System grafiki. Gdy używasz <xref:System.Windows.Media.DrawingContext> poleceń rysowania obiektu, w rzeczywistości zapisujesz zestaw instrukcji renderowania (Chociaż dokładny mechanizm magazynowania zależy od typu obiektu, który <xref:System.Windows.Media.DrawingContext>dostarcza), który będzie później używany przez system grafiki. nie są rysowane na ekranie w czasie rzeczywistym. Aby uzyskać więcej informacji na temat działania systemu grafiki Windows Presentation Foundation (WPF), zobacz [Omówienie renderowania grafiki WPF](~/docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
 Nigdy nie tworzysz bezpośrednio wystąpienia <xref:System.Windows.Media.DrawingContext>. Możesz jednak uzyskać kontekst rysowania z określonych metod, takich jak <xref:System.Windows.Media.DrawingGroup.Open%2A?displayProperty=nameWithType> i <xref:System.Windows.Media.DrawingVisual.RenderOpen%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład pobiera <xref:System.Windows.Media.DrawingContext> a <xref:System.Windows.Media.DrawingVisual> z i używa go do rysowania prostokąta.  
  
 [!code-csharp[drawingvisualsample#101](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingVisualSample/CSharp/Window1.xaml.cs#101)]
 [!code-vb[drawingvisualsample#101](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingVisualSample/visualbasic/window1.xaml.vb#101)]  
  
 W następnym przykładzie pokazano <xref:System.Windows.Media.DrawingContext.PushOpacity%2A>polecenia, <xref:System.Windows.Media.DrawingContext.PushEffect%2A>i. <xref:System.Windows.Media.DrawingContext.Pop%2A> Jest uzyskiwany <xref:System.Windows.Media.DrawingGroup> z i wyświetlany przy użyciu <xref:System.Windows.Controls.Image> kontrolki. <xref:System.Windows.Media.DrawingContext>  
  
 [!code-csharp[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingContext_procedural_snip/CSharp/PushEffectExample.cs#pusheffectexamplewholepage)]
 [!code-vb[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingContext_procedural_snip/visualbasic/pusheffectexample.vb#pusheffectexamplewholepage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Media.DrawingGroup" />
    <altmember cref="T:System.Windows.Media.Drawing" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public abstract void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.Close" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit" Usage="drawingContext.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Media.DrawingContext" /> Zamyka i opróżnia zawartość. <see cref="T:System.Windows.Media.DrawingContext" /> Później nie można modyfikować.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby można było renderować zawartość, należyjązamknąć,alepojejzamknięciuniemożnajejmodyfikować.<xref:System.Windows.Media.DrawingContext> To wywołanie nie wymaga, aby wszystkie wywołania wypychane były zdjęte.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został już zamknięty lub usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisposeCore">
      <MemberSignature Language="C#" Value="protected abstract void DisposeCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DisposeCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DisposeCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub DisposeCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void DisposeCore();" />
      <MemberSignature Language="F#" Value="abstract member DisposeCore : unit -&gt; unit" Usage="drawingContext.DisposeCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez <see cref="T:System.Windows.Media.DrawingContext" />program.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie wywołuj tej metody bezpośrednio z poziomu kodu; Zamiast tego użyj metody. <xref:System.Windows.Media.DrawingContext.System%23IDisposable%23Dispose%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Obiekt został już zamknięty lub usunięty.</exception>
        <altmember cref="M:System.Windows.Media.DrawingContext.System#IDisposable#Dispose" />
      </Docs>
    </Member>
    <Member MemberName="DrawDrawing">
      <MemberSignature Language="C#" Value="public abstract void DrawDrawing (System.Windows.Media.Drawing drawing);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawDrawing(class System.Windows.Media.Drawing drawing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawDrawing(System.Windows.Media.Drawing)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawDrawing(System::Windows::Media::Drawing ^ drawing);" />
      <MemberSignature Language="F#" Value="abstract member DrawDrawing : System.Windows.Media.Drawing -&gt; unit" Usage="drawingContext.DrawDrawing drawing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drawing" Type="System.Windows.Media.Drawing" />
      </Parameters>
      <Docs>
        <param name="drawing">Rysunek do dołączenia.</param>
        <summary>Rysuje określony <see cref="T:System.Windows.Media.Drawing" /> obiekt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawEllipse">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rysuje elipsę.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public abstract void DrawEllipse (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Point center, double radiusX, double radiusY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawEllipse(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Point center, float64 radiusX, float64 radiusY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawEllipse(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Point,System.Double,System.Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawEllipse(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Point center, double radiusX, double radiusY);" />
      <MemberSignature Language="F#" Value="abstract member DrawEllipse : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Point * double * double -&gt; unit" Usage="drawingContext.DrawEllipse (brush, pen, center, radiusX, radiusY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="center" Type="System.Windows.Point" />
        <Parameter Name="radiusX" Type="System.Double" />
        <Parameter Name="radiusY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="brush">Pędzel, za pomocą którego ma zostać wypełniona Elipsa.  Jest to opcjonalne i może być <see langword="null" />. Jeśli pędzel <see langword="null" />nie jest, wypełnienie nie jest rysowane.</param>
        <param name="pen">Pióro, z którym ma zostać narysowana Elipsa.  Jest to opcjonalne i może być <see langword="null" />. Jeśli pióro jest <see langword="null" />, nie jest rysowane żadne naciśnięcie.</param>
        <param name="center">Lokalizacja środka wielokropka.</param>
        <param name="radiusX">Promień w poziomie elipsy.</param>
        <param name="radiusY">Promień w pionie elipsy.</param>
        <summary>Rysuje elipsę z określonym <see cref="T:System.Windows.Media.Brush" /> i <see cref="T:System.Windows.Media.Pen" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oba pędzle mogą być `null`jednocześnie.  Jeśli pędzel jest `null`, to nie jest wykonywane żadne wypełnienie.  Jeśli pióro to `null`, Stoke nie jest wykonywane.  Jeśli zarówno pióro `null`, jak i Pędzel, rysunek nie jest widoczny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public abstract void DrawEllipse (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Point center, System.Windows.Media.Animation.AnimationClock centerAnimations, double radiusX, System.Windows.Media.Animation.AnimationClock radiusXAnimations, double radiusY, System.Windows.Media.Animation.AnimationClock radiusYAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawEllipse(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Point center, class System.Windows.Media.Animation.AnimationClock centerAnimations, float64 radiusX, class System.Windows.Media.Animation.AnimationClock radiusXAnimations, float64 radiusY, class System.Windows.Media.Animation.AnimationClock radiusYAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawEllipse(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Point,System.Windows.Media.Animation.AnimationClock,System.Double,System.Windows.Media.Animation.AnimationClock,System.Double,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawEllipse(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Point center, System::Windows::Media::Animation::AnimationClock ^ centerAnimations, double radiusX, System::Windows::Media::Animation::AnimationClock ^ radiusXAnimations, double radiusY, System::Windows::Media::Animation::AnimationClock ^ radiusYAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawEllipse : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Point * System.Windows.Media.Animation.AnimationClock * double * System.Windows.Media.Animation.AnimationClock * double * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawEllipse (brush, pen, center, centerAnimations, radiusX, radiusXAnimations, radiusY, radiusYAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="center" Type="System.Windows.Point" />
        <Parameter Name="centerAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="radiusX" Type="System.Double" />
        <Parameter Name="radiusXAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="radiusY" Type="System.Double" />
        <Parameter Name="radiusYAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="brush">Pędzel, za pomocą którego ma zostać wypełniona Elipsa.  Jest to opcjonalne i może być <see langword="null" />. Jeśli pędzel <see langword="null" />nie jest, wypełnienie nie jest rysowane.</param>
        <param name="pen">Pióro, z którym ma zostać narysowana Elipsa.  Jest to opcjonalne i może być <see langword="null" />. Jeśli pióro jest <see langword="null" />, nie jest rysowane żadne naciśnięcie.</param>
        <param name="center">Lokalizacja środka wielokropka.</param>
        <param name="centerAnimations">Zegar służący do animowania położenia środka elipsy lub <see langword="null" /> braku animacji. Ten zegar należy utworzyć na podstawie elementu <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> , który może <see cref="T:System.Windows.Point" /> animować obiekty.</param>
        <param name="radiusX">Promień w poziomie elipsy.</param>
        <param name="radiusXAnimations">Zegar, za pomocą którego ma być animowany x-RADIUS elipsy <see langword="null" /> , lub bez animacji. Ten zegar należy utworzyć na podstawie elementu <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> , który może <see cref="T:System.Double" /> animować obiekty.</param>
        <param name="radiusY">Promień w pionie elipsy.</param>
        <param name="radiusYAnimations">Zegar, za pomocą którego ma być animowany znak x-promienia <see langword="null" /> elipsy, lub brak animacji. Ten zegar należy utworzyć na podstawie elementu <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> , który może <see cref="T:System.Double" /> animować obiekty.</param>
        <summary>Rysuje elipsę z określonym <see cref="T:System.Windows.Media.Brush" /> i <see cref="T:System.Windows.Media.Pen" /> i stosuje określone zegary animacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oba pędzle mogą być `null`jednocześnie.  Jeśli pędzel jest `null`, to nie jest wykonywane żadne wypełnienie.  Jeśli pióro to `null`, Stoke nie jest wykonywane.  Jeśli zarówno pióro `null`, jak i Pędzel, rysunek nie jest widoczny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawGeometry">
      <MemberSignature Language="C#" Value="public abstract void DrawGeometry (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Media.Geometry geometry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawGeometry(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, class System.Windows.Media.Geometry geometry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawGeometry(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Media.Geometry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawGeometry(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Media::Geometry ^ geometry);" />
      <MemberSignature Language="F#" Value="abstract member DrawGeometry : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Media.Geometry -&gt; unit" Usage="drawingContext.DrawGeometry (brush, pen, geometry)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="geometry" Type="System.Windows.Media.Geometry" />
      </Parameters>
      <Docs>
        <param name="brush">, <see cref="T:System.Windows.Media.Brush" /> Za pomocą którego ma zostać <see cref="T:System.Windows.Media.Geometry" />wypełniona. Jest to opcjonalne i może być <see langword="null" />. Jeśli pędzel <see langword="null" />nie jest, wypełnienie nie jest rysowane.</param>
        <param name="pen">, <see cref="T:System.Windows.Media.Pen" /> Z którym ma zostać <see cref="T:System.Windows.Media.Geometry" />narysowana linia. Jest to opcjonalne i może być <see langword="null" />. Jeśli pióro jest <see langword="null" />, nie jest rysowane żadne naciśnięcie.</param>
        <param name="geometry"><see cref="T:System.Windows.Media.Geometry" /> Do rysowania.</param>
        <summary>Rysuje określony <see cref="T:System.Windows.Media.Geometry" /> przy użyciu określonych <see cref="T:System.Windows.Media.Brush" /> i <see cref="T:System.Windows.Media.Pen" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawGlyphRun">
      <MemberSignature Language="C#" Value="public abstract void DrawGlyphRun (System.Windows.Media.Brush foregroundBrush, System.Windows.Media.GlyphRun glyphRun);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawGlyphRun(class System.Windows.Media.Brush foregroundBrush, class System.Windows.Media.GlyphRun glyphRun) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawGlyphRun(System.Windows.Media.Brush,System.Windows.Media.GlyphRun)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawGlyphRun(System::Windows::Media::Brush ^ foregroundBrush, System::Windows::Media::GlyphRun ^ glyphRun);" />
      <MemberSignature Language="F#" Value="abstract member DrawGlyphRun : System.Windows.Media.Brush * System.Windows.Media.GlyphRun -&gt; unit" Usage="drawingContext.DrawGlyphRun (foregroundBrush, glyphRun)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="foregroundBrush" Type="System.Windows.Media.Brush" />
        <Parameter Name="glyphRun" Type="System.Windows.Media.GlyphRun" />
      </Parameters>
      <Docs>
        <param name="foregroundBrush">Pędzel używany do malowania tekstem.</param>
        <param name="glyphRun">Tekst do narysowania.</param>
        <summary>Rysuje określony tekst.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawImage">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rysuje obraz w regionie zdefiniowanym przez określony <see cref="T:System.Windows.Rect" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public abstract void DrawImage (System.Windows.Media.ImageSource imageSource, System.Windows.Rect rectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawImage(class System.Windows.Media.ImageSource imageSource, valuetype System.Windows.Rect rectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawImage(System.Windows.Media.ImageSource,System.Windows.Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawImage(System::Windows::Media::ImageSource ^ imageSource, System::Windows::Rect rectangle);" />
      <MemberSignature Language="F#" Value="abstract member DrawImage : System.Windows.Media.ImageSource * System.Windows.Rect -&gt; unit" Usage="drawingContext.DrawImage (imageSource, rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageSource" Type="System.Windows.Media.ImageSource" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="imageSource">Obraz do narysowania.</param>
        <param name="rectangle">Region, w którym należy narysować <c>BitmapSource</c>.</param>
        <summary>Rysuje obraz w regionie zdefiniowanym przez określony <see cref="T:System.Windows.Rect" />.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.MediaPermission">do wyświetlania obrazów, do których nie masz <see cref="T:System.Net.WebPermission" /> lub <see cref="T:System.Security.Permissions.FileIOPermission" /> nie ma dostępu. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.MediaPermissionImage.SafeImage" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public abstract void DrawImage (System.Windows.Media.ImageSource imageSource, System.Windows.Rect rectangle, System.Windows.Media.Animation.AnimationClock rectangleAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawImage(class System.Windows.Media.ImageSource imageSource, valuetype System.Windows.Rect rectangle, class System.Windows.Media.Animation.AnimationClock rectangleAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawImage(System.Windows.Media.ImageSource,System.Windows.Rect,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawImage(System::Windows::Media::ImageSource ^ imageSource, System::Windows::Rect rectangle, System::Windows::Media::Animation::AnimationClock ^ rectangleAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawImage : System.Windows.Media.ImageSource * System.Windows.Rect * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawImage (imageSource, rectangle, rectangleAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageSource" Type="System.Windows.Media.ImageSource" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="rectangleAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="imageSource">Obraz do narysowania.</param>
        <param name="rectangle">Region, w którym należy narysować <c>BitmapSource</c>.</param>
        <param name="rectangleAnimations">Zegar, za pomocą którego ma być animowany rozmiar i wymiary prostokąta <see langword="null" /> lub brak animacji. Ten zegar należy utworzyć na podstawie elementu <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> , który może <see cref="T:System.Windows.Rect" /> animować obiekty.</param>
        <summary>Rysuje obraz w regionie zdefiniowanym przez określony <see cref="T:System.Windows.Rect" /> i stosuje określony zegar animacji.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.MediaPermission">do wyświetlania obrazów, do których nie masz <see cref="T:System.Net.WebPermission" /> lub <see cref="T:System.Security.Permissions.FileIOPermission" /> nie ma dostępu. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.MediaPermissionImage.SafeImage" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawLine">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rysuje linię z określonym <see cref="T:System.Windows.Media.Pen" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public abstract void DrawLine (System.Windows.Media.Pen pen, System.Windows.Point point0, System.Windows.Point point1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawLine(class System.Windows.Media.Pen pen, valuetype System.Windows.Point point0, valuetype System.Windows.Point point1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawLine(System.Windows.Media.Pen,System.Windows.Point,System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawLine(System::Windows::Media::Pen ^ pen, System::Windows::Point point0, System::Windows::Point point1);" />
      <MemberSignature Language="F#" Value="abstract member DrawLine : System.Windows.Media.Pen * System.Windows.Point * System.Windows.Point -&gt; unit" Usage="drawingContext.DrawLine (pen, point0, point1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="point0" Type="System.Windows.Point" />
        <Parameter Name="point1" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="pen">Pióro, z którym ma zostać narysowana linia.</param>
        <param name="point0">Punkt początkowy wiersza.</param>
        <param name="point1">Punkt końcowy wiersza.</param>
        <summary>Rysuje linię między określonymi punktami przy użyciu określonego <see cref="T:System.Windows.Media.Pen" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public abstract void DrawLine (System.Windows.Media.Pen pen, System.Windows.Point point0, System.Windows.Media.Animation.AnimationClock point0Animations, System.Windows.Point point1, System.Windows.Media.Animation.AnimationClock point1Animations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawLine(class System.Windows.Media.Pen pen, valuetype System.Windows.Point point0, class System.Windows.Media.Animation.AnimationClock point0Animations, valuetype System.Windows.Point point1, class System.Windows.Media.Animation.AnimationClock point1Animations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawLine(System.Windows.Media.Pen,System.Windows.Point,System.Windows.Media.Animation.AnimationClock,System.Windows.Point,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawLine(System::Windows::Media::Pen ^ pen, System::Windows::Point point0, System::Windows::Media::Animation::AnimationClock ^ point0Animations, System::Windows::Point point1, System::Windows::Media::Animation::AnimationClock ^ point1Animations);" />
      <MemberSignature Language="F#" Value="abstract member DrawLine : System.Windows.Media.Pen * System.Windows.Point * System.Windows.Media.Animation.AnimationClock * System.Windows.Point * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawLine (pen, point0, point0Animations, point1, point1Animations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="point0" Type="System.Windows.Point" />
        <Parameter Name="point0Animations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="point1" Type="System.Windows.Point" />
        <Parameter Name="point1Animations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="pen">Pióro, aby pociągnięcia linię.</param>
        <param name="point0">Punkt początkowy wiersza.</param>
        <param name="point0Animations">Zegar, dla którego ma być animowany punkt początkowy wiersza, lub <see langword="null" /> brak animacji. Ten zegar należy utworzyć na podstawie elementu <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> , który może <see cref="T:System.Windows.Point" /> animować obiekty.</param>
        <param name="point1">Punkt końcowy wiersza.</param>
        <param name="point1Animations">Zegar, za pomocą którego ma być animowany punkt końcowy wiersza, lub <see langword="null" /> brak animacji. Ten zegar należy utworzyć na podstawie elementu <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> , który może <see cref="T:System.Windows.Point" /> animować obiekty.</param>
        <summary>Rysuje linię między określonymi punktami przy użyciu określonego <see cref="T:System.Windows.Media.Pen" /> i stosuje określone zegary animacji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawRectangle">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rysuje prostokąt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public abstract void DrawRectangle (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Rect rectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRectangle(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Rect rectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawRectangle(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawRectangle(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Rect rectangle);" />
      <MemberSignature Language="F#" Value="abstract member DrawRectangle : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Rect -&gt; unit" Usage="drawingContext.DrawRectangle (brush, pen, rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="brush">Pędzel, za pomocą którego ma zostać wypełniony prostokąt.  Jest to opcjonalne i może być <see langword="null" />. Jeśli pędzel <see langword="null" />nie jest, wypełnienie nie jest rysowane.</param>
        <param name="pen">Pióro, z którego ma zostać porysowany prostokąt.  Jest to opcjonalne i może być <see langword="null" />. Jeśli pióro jest <see langword="null" />, nie jest rysowane żadne naciśnięcie.</param>
        <param name="rectangle">Prostokąt do rysowania.</param>
        <summary>Rysuje prostokąt z określonym <see cref="T:System.Windows.Media.Brush" /> i. <see cref="T:System.Windows.Media.Pen" /> Może to być <see langword="null" />pióro i pędzel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oba pędzle mogą być `null`jednocześnie.  Jeśli pędzel jest `null`, to nie jest wykonywane żadne wypełnienie.  Jeśli pióro to `null`, Stoke nie jest wykonywane.  Jeśli zarówno pióro `null`, jak i Pędzel, rysunek nie jest widoczny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public abstract void DrawRectangle (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Rect rectangle, System.Windows.Media.Animation.AnimationClock rectangleAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRectangle(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Rect rectangle, class System.Windows.Media.Animation.AnimationClock rectangleAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawRectangle(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Rect,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawRectangle(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Rect rectangle, System::Windows::Media::Animation::AnimationClock ^ rectangleAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawRectangle : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Rect * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawRectangle (brush, pen, rectangle, rectangleAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="rectangleAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="brush">Pędzel, za pomocą którego ma zostać wypełniony prostokąt.  Jest to opcjonalne i może być <see langword="null" />. Jeśli pędzel <see langword="null" />nie jest, wypełnienie nie jest rysowane.</param>
        <param name="pen">Pióro, z którego ma zostać porysowany prostokąt.  Jest to opcjonalne i może być <see langword="null" />. Jeśli pióro jest <see langword="null" />, nie jest rysowane żadne naciśnięcie.</param>
        <param name="rectangle">Prostokąt do rysowania.</param>
        <param name="rectangleAnimations">Zegar, za pomocą którego ma być animowany rozmiar i wymiary prostokąta <see langword="null" /> lub brak animacji. Ten zegar należy utworzyć na podstawie elementu <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> , który może <see cref="T:System.Windows.Rect" /> animować obiekty.</param>
        <summary>Rysuje prostokąt z określonym <see cref="T:System.Windows.Media.Brush" /> i <see cref="T:System.Windows.Media.Pen" /> i stosuje określone zegary animacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oba pędzle mogą być `null`jednocześnie.  Jeśli pędzel jest `null`, to nie jest wykonywane żadne wypełnienie.  Jeśli pióro to `null`, Stoke nie jest wykonywane.  Jeśli zarówno pióro `null`, jak i Pędzel, rysunek nie jest widoczny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawRoundedRectangle">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rysuje prostokąt zaokrąglony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawRoundedRectangle">
      <MemberSignature Language="C#" Value="public abstract void DrawRoundedRectangle (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Rect rectangle, double radiusX, double radiusY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRoundedRectangle(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Rect rectangle, float64 radiusX, float64 radiusY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawRoundedRectangle(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Rect,System.Double,System.Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawRoundedRectangle(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Rect rectangle, double radiusX, double radiusY);" />
      <MemberSignature Language="F#" Value="abstract member DrawRoundedRectangle : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Rect * double * double -&gt; unit" Usage="drawingContext.DrawRoundedRectangle (brush, pen, rectangle, radiusX, radiusY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="radiusX" Type="System.Double" />
        <Parameter Name="radiusY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="brush">Pędzel używany do wypełnienia prostokąta.</param>
        <param name="pen">Pióro używane do rysowania prostokąta.</param>
        <param name="rectangle">Prostokąt do rysowania.</param>
        <param name="radiusX">Promień w wymiarze X zaokrąglonych rogów.  Ta wartość zostanie zamocowana do zakresu od 0 do <see cref="P:System.Windows.Rect.Width" />/2.</param>
        <param name="radiusY">Promień w wymiarze Y zaokrąglonych rogów.  Ta wartość zostanie zamocowana do wartości z przedziału <see cref="P:System.Windows.Rect.Height" />od 0 do/2.</param>
        <summary>Rysuje zaokrąglony prostokąt z określonym <see cref="T:System.Windows.Media.Brush" /> i <see cref="T:System.Windows.Media.Pen" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oba pędzle mogą być `null`jednocześnie.  Jeśli pędzel jest `null`, to nie jest wykonywane żadne wypełnienie.  Jeśli pióro to `null`, Stoke nie jest wykonywane.  Jeśli zarówno pióro `null`, jak i Pędzel, rysunek nie jest widoczny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawRoundedRectangle">
      <MemberSignature Language="C#" Value="public abstract void DrawRoundedRectangle (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Rect rectangle, System.Windows.Media.Animation.AnimationClock rectangleAnimations, double radiusX, System.Windows.Media.Animation.AnimationClock radiusXAnimations, double radiusY, System.Windows.Media.Animation.AnimationClock radiusYAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRoundedRectangle(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Rect rectangle, class System.Windows.Media.Animation.AnimationClock rectangleAnimations, float64 radiusX, class System.Windows.Media.Animation.AnimationClock radiusXAnimations, float64 radiusY, class System.Windows.Media.Animation.AnimationClock radiusYAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawRoundedRectangle(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Rect,System.Windows.Media.Animation.AnimationClock,System.Double,System.Windows.Media.Animation.AnimationClock,System.Double,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawRoundedRectangle(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Rect rectangle, System::Windows::Media::Animation::AnimationClock ^ rectangleAnimations, double radiusX, System::Windows::Media::Animation::AnimationClock ^ radiusXAnimations, double radiusY, System::Windows::Media::Animation::AnimationClock ^ radiusYAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawRoundedRectangle : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Rect * System.Windows.Media.Animation.AnimationClock * double * System.Windows.Media.Animation.AnimationClock * double * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawRoundedRectangle (brush, pen, rectangle, rectangleAnimations, radiusX, radiusXAnimations, radiusY, radiusYAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="rectangleAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="radiusX" Type="System.Double" />
        <Parameter Name="radiusXAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="radiusY" Type="System.Double" />
        <Parameter Name="radiusYAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="brush">Pędzel używany do wypełnienia prostokąta lub <see langword="null" /> bez wypełnienia.</param>
        <param name="pen">Pióro używane do rysowania prostokąta lub <see langword="null" /> bez pociągnięć.</param>
        <param name="rectangle">Prostokąt do rysowania.</param>
        <param name="rectangleAnimations">Zegar, za pomocą którego ma być animowany rozmiar i wymiary prostokąta <see langword="null" /> lub brak animacji. Ten zegar należy utworzyć na podstawie elementu <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> , który może <see cref="T:System.Windows.Rect" /> animować obiekty.</param>
        <param name="radiusX">Promień w wymiarze X zaokrąglonych rogów.  Ta wartość zostanie zamocowana do zakresu od 0 do <see cref="P:System.Windows.Rect.Width" />/2.</param>
        <param name="radiusXAnimations">Zegar służący do animowania <paramref name="radiusX" /> wartości prostokąta lub <see langword="null" /> braku animacji. Ten zegar należy utworzyć na podstawie <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> , który może animować <see cref="T:System.Double" /> wartości.</param>
        <param name="radiusY">Promień w wymiarze Y zaokrąglonych rogów.  Ta wartość zostanie zamocowana do wartości z przedziału <see cref="P:System.Windows.Rect.Height" />od 0 do/2.</param>
        <param name="radiusYAnimations">Zegar służący do animowania <paramref name="radiusY" /> wartości prostokąta lub <see langword="null" /> braku animacji. Ten zegar należy utworzyć na podstawie <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> , który może animować <see cref="T:System.Double" /> wartości.</param>
        <summary>Rysuje zaokrąglony prostokąt z określonym <see cref="T:System.Windows.Media.Brush" /> i <see cref="T:System.Windows.Media.Pen" /> i stosuje określone zegary animacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oba pędzle mogą być `null`jednocześnie.  Jeśli pędzel jest `null`, to nie jest wykonywane żadne wypełnienie.  Jeśli pióro to `null`, Stoke nie jest wykonywane.  Jeśli zarówno pióro `null`, jak i Pędzel, rysunek nie jest widoczny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawText">
      <MemberSignature Language="C#" Value="public void DrawText (System.Windows.Media.FormattedText formattedText, System.Windows.Point origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawText(class System.Windows.Media.FormattedText formattedText, valuetype System.Windows.Point origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawText(System.Windows.Media.FormattedText,System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawText(System::Windows::Media::FormattedText ^ formattedText, System::Windows::Point origin);" />
      <MemberSignature Language="F#" Value="member this.DrawText : System.Windows.Media.FormattedText * System.Windows.Point -&gt; unit" Usage="drawingContext.DrawText (formattedText, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="formattedText" Type="System.Windows.Media.FormattedText" />
        <Parameter Name="origin" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="formattedText">Sformatowany tekst do narysowania.</param>
        <param name="origin">Lokalizacja, w której ma zostać narysowany tekst.</param>
        <summary>Rysuje sformatowany tekst w określonej lokalizacji.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Obiekt został już zamknięty lub usunięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawVideo">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Narysuj wideo w określonym regionie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawVideo">
      <MemberSignature Language="C#" Value="public abstract void DrawVideo (System.Windows.Media.MediaPlayer player, System.Windows.Rect rectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawVideo(class System.Windows.Media.MediaPlayer player, valuetype System.Windows.Rect rectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawVideo(System.Windows.Media.MediaPlayer,System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawVideo (player As MediaPlayer, rectangle As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawVideo(System::Windows::Media::MediaPlayer ^ player, System::Windows::Rect rectangle);" />
      <MemberSignature Language="F#" Value="abstract member DrawVideo : System.Windows.Media.MediaPlayer * System.Windows.Rect -&gt; unit" Usage="drawingContext.DrawVideo (player, rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="player" Type="System.Windows.Media.MediaPlayer" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="player">Nośnik do narysowania.</param>
        <param name="rectangle">Region, w którym należy narysować <paramref name="player" />.</param>
        <summary>Rysuje wideo w określonym regionie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy zauważyć, że nośnik zostanie rozciągnięty w celu dopasowania do obszaru zdefiniowanego przez parametr prostokąta. Jeśli prostokąt i nośnik mają różne proporcje, nastąpi zniekształcenie. Aby uzyskać większą kontrolę nad sposobem, w jaki nośnik jest używany do wypełnienia obszaru <xref:System.Windows.Media.DrawingContext.DrawRectangle%2A> , użyj polecenia, aby narysować prostokąt i wypełnić <xref:System.Windows.Media.VisualBrush> go zawierającym multimedia.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.MediaPermission">Aby wyświetlić multimedia, do których nie masz <see cref="T:System.Net.WebPermission" /> lub <see cref="T:System.Security.Permissions.FileIOPermission" /> nie masz dostępu. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.MediaPermissionImage.SafeImage" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DrawVideo">
      <MemberSignature Language="C#" Value="public abstract void DrawVideo (System.Windows.Media.MediaPlayer player, System.Windows.Rect rectangle, System.Windows.Media.Animation.AnimationClock rectangleAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawVideo(class System.Windows.Media.MediaPlayer player, valuetype System.Windows.Rect rectangle, class System.Windows.Media.Animation.AnimationClock rectangleAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawVideo(System.Windows.Media.MediaPlayer,System.Windows.Rect,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawVideo (player As MediaPlayer, rectangle As Rect, rectangleAnimations As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawVideo(System::Windows::Media::MediaPlayer ^ player, System::Windows::Rect rectangle, System::Windows::Media::Animation::AnimationClock ^ rectangleAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawVideo : System.Windows.Media.MediaPlayer * System.Windows.Rect * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawVideo (player, rectangle, rectangleAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="player" Type="System.Windows.Media.MediaPlayer" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="rectangleAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="player">Nośnik do narysowania.</param>
        <param name="rectangle">Obszar, w którym ma zostać narysowany nośnik.</param>
        <param name="rectangleAnimations">Zegar, za pomocą którego ma być animowany rozmiar i wymiary prostokąta <see langword="null" /> lub brak animacji. Ten zegar należy utworzyć na podstawie elementu <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> , który może <see cref="T:System.Windows.Rect" /> animować obiekty.</param>
        <summary>Rysuje wideo w określonym regionie i stosuje określony zegar animacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy zauważyć, że nośnik zostanie rozciągnięty w celu dopasowania do obszaru zdefiniowanego przez parametr prostokąta. Jeśli prostokąt i nośnik mają różne proporcje, nastąpi zniekształcenie. Aby uzyskać większą kontrolę nad sposobem, w jaki nośnik jest używany do wypełnienia obszaru <xref:System.Windows.Media.DrawingContext.DrawRectangle%2A> , użyj polecenia, aby narysować prostokąt i wypełnić <xref:System.Windows.Media.VisualBrush> go zawierającym multimedia.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.MediaPermission">Aby wyświetlić multimedia, do których nie masz <see cref="T:System.Net.WebPermission" /> lub <see cref="T:System.Security.Permissions.FileIOPermission" /> nie masz dostępu. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.MediaPermissionImage.SafeImage" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public abstract void Pop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Pop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.Pop" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Pop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Pop();" />
      <MemberSignature Language="F#" Value="abstract member Pop : unit -&gt; unit" Usage="drawingContext.Pop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pop ostatnią nieprzezroczystą maskę, nieprzezroczystość, wycinek, efekt lub transformację, która została przekazana do kontekstu rysowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy operacja zostanie zdjęte, nie jest już stosowana do kolejnych poleceń rysowania.  
  
   
  
## Examples  
 Poniższy przykład pokazuje efekt <xref:System.Windows.Media.DrawingContext.Pop%2A> polecenia.  
  
 [!code-csharp[DrawingContext_procedural_snip#PopExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingContext_procedural_snip/CSharp/PopExample.cs#popexamplewholepage)]
 [!code-vb[DrawingContext_procedural_snip#PopExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingContext_procedural_snip/visualbasic/popexample.vb#popexamplewholepage)]  
  
 Na poniższej ilustracji przedstawiono dane wyjściowe tego przykładu:  
  
 ![Prostokąty rysowane z różnymi wartościami] nieprzezroczystości (~/add/media/graphicsmm-drawingcontextpopexample.gif "Prostokąty rysowane z różnymi wartościami") nieprzezroczystości  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushClip">
      <MemberSignature Language="C#" Value="public abstract void PushClip (System.Windows.Media.Geometry clipGeometry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushClip(class System.Windows.Media.Geometry clipGeometry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushClip(System.Windows.Media.Geometry)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushClip (clipGeometry As Geometry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushClip(System::Windows::Media::Geometry ^ clipGeometry);" />
      <MemberSignature Language="F#" Value="abstract member PushClip : System.Windows.Media.Geometry -&gt; unit" Usage="drawingContext.PushClip clipGeometry" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipGeometry" Type="System.Windows.Media.Geometry" />
      </Parameters>
      <Docs>
        <param name="clipGeometry">Region klipu, który ma zostać zastosowany do kolejnych poleceń rysowania.</param>
        <summary>Wypchnij określony region przycinania do kontekstu rysowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Region przycinania ma zastosowanie do wszystkich kolejnych poleceń rysowania, dopóki nie zostanie usunięty <xref:System.Windows.Media.DrawingContext.Pop%2A> przez polecenie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushEffect">
      <MemberSignature Language="C#" Value="public abstract void PushEffect (System.Windows.Media.Effects.BitmapEffect effect, System.Windows.Media.Effects.BitmapEffectInput effectInput);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushEffect(class System.Windows.Media.Effects.BitmapEffect effect, class System.Windows.Media.Effects.BitmapEffectInput effectInput) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushEffect(System.Windows.Media.Effects.BitmapEffect,System.Windows.Media.Effects.BitmapEffectInput)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushEffect (effect As BitmapEffect, effectInput As BitmapEffectInput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushEffect(System::Windows::Media::Effects::BitmapEffect ^ effect, System::Windows::Media::Effects::BitmapEffectInput ^ effectInput);" />
      <MemberSignature Language="F#" Value="abstract member PushEffect : System.Windows.Media.Effects.BitmapEffect * System.Windows.Media.Effects.BitmapEffectInput -&gt; unit" Usage="drawingContext.PushEffect (effect, effectInput)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="effect" Type="System.Windows.Media.Effects.BitmapEffect" />
        <Parameter Name="effectInput" Type="System.Windows.Media.Effects.BitmapEffectInput" />
      </Parameters>
      <Docs>
        <param name="effect">Efekt zastosowania do kolejnych rysunków.</param>
        <param name="effectInput">Obszar, do którego zastosowano efekt, lub <see langword="null" /> jeśli efekt ma zostać zastosowany do całego obszaru kolejnych rysunków.</param>
        <summary>Wypchnięcie określonego <see cref="T:System.Windows.Media.Effects.BitmapEffect" /> elementu do kontekstu rysowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Efekt jest stosowany do wszystkich kolejnych operacji rysowania do momentu usunięcia go przez <xref:System.Windows.Media.DrawingContext.Pop%2A> polecenie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Windows.Media.DrawingContext.PushOpacity%2A>polecenia, <xref:System.Windows.Media.DrawingContext.PushEffect%2A>i. <xref:System.Windows.Media.DrawingContext.Pop%2A>  
  
 [!code-csharp[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingContext_procedural_snip/CSharp/PushEffectExample.cs#pusheffectexamplewholepage)]
 [!code-vb[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingContext_procedural_snip/visualbasic/pusheffectexample.vb#pusheffectexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushGuidelineSet">
      <MemberSignature Language="C#" Value="public abstract void PushGuidelineSet (System.Windows.Media.GuidelineSet guidelines);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushGuidelineSet(class System.Windows.Media.GuidelineSet guidelines) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushGuidelineSet(System.Windows.Media.GuidelineSet)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushGuidelineSet (guidelines As GuidelineSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushGuidelineSet(System::Windows::Media::GuidelineSet ^ guidelines);" />
      <MemberSignature Language="F#" Value="abstract member PushGuidelineSet : System.Windows.Media.GuidelineSet -&gt; unit" Usage="drawingContext.PushGuidelineSet guidelines" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guidelines" Type="System.Windows.Media.GuidelineSet" />
      </Parameters>
      <Docs>
        <param name="guidelines">Wytyczne, które mają zastosowanie do kolejnych poleceń rysowania.</param>
        <summary>Wypchnięcie określonego <see cref="T:System.Windows.Media.GuidelineSet" /> elementu do kontekstu rysowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw wytycznych stosuje się do wszystkich kolejnych poleceń rysowania, dopóki nie zostanie usunięty przez <xref:System.Windows.Media.DrawingContext.Pop%2A> operację.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.GuidelineSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PushOpacity">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wypchnięcie określonego ustawienia zmętnienia do kontekstu rysowania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PushOpacity">
      <MemberSignature Language="C#" Value="public abstract void PushOpacity (double opacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushOpacity(float64 opacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushOpacity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushOpacity (opacity As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushOpacity(double opacity);" />
      <MemberSignature Language="F#" Value="abstract member PushOpacity : double -&gt; unit" Usage="drawingContext.PushOpacity opacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opacity" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="opacity">Współczynnik nieprzezroczystości, który ma zostać zastosowany do kolejnych poleceń rysowania. Ten czynnik jest skumulowany z <see cref="M:System.Windows.Media.DrawingContext.PushOpacity(System.Double)" /> poprzednimi operacjami.</param>
        <summary>Wypchnięcie określonego ustawienia zmętnienia do kontekstu rysowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nieprzezroczystość jest przełączana do wszystkich kolejnych poleceń rysowania, dopóki nie zostanie <xref:System.Windows.Media.DrawingContext.Pop%2A> usunięta przez polecenie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Windows.Media.DrawingContext.PushOpacity%2A>polecenia, <xref:System.Windows.Media.DrawingContext.PushEffect%2A>i. <xref:System.Windows.Media.DrawingContext.Pop%2A>  
  
 [!code-csharp[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingContext_procedural_snip/CSharp/PushEffectExample.cs#pusheffectexamplewholepage)]
 [!code-vb[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingContext_procedural_snip/visualbasic/pusheffectexample.vb#pusheffectexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushOpacity">
      <MemberSignature Language="C#" Value="public abstract void PushOpacity (double opacity, System.Windows.Media.Animation.AnimationClock opacityAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushOpacity(float64 opacity, class System.Windows.Media.Animation.AnimationClock opacityAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushOpacity(System.Double,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushOpacity (opacity As Double, opacityAnimations As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushOpacity(double opacity, System::Windows::Media::Animation::AnimationClock ^ opacityAnimations);" />
      <MemberSignature Language="F#" Value="abstract member PushOpacity : double * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.PushOpacity (opacity, opacityAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opacity" Type="System.Double" />
        <Parameter Name="opacityAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="opacity">Współczynnik nieprzezroczystości, który ma zostać zastosowany do kolejnych poleceń rysowania. Ten czynnik jest skumulowany z <see cref="M:System.Windows.Media.DrawingContext.PushOpacity(System.Double)" /> poprzednimi operacjami.</param>
        <param name="opacityAnimations">Zegar, za pomocą którego ma być animowana wartość nieprzezroczystości lub <see langword="null" /> brak animacji. Ten zegar należy utworzyć na podstawie <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> , który może animować <see cref="T:System.Double" /> wartości.</param>
        <summary>Wypchnięcie określonego ustawienia zmętnienia do kontekstu rysowania i stosuje określony zegar animacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nieprzezroczystość jest przełączana do wszystkich kolejnych poleceń rysowania, dopóki nie zostanie <xref:System.Windows.Media.DrawingContext.Pop%2A> usunięta przez polecenie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushOpacityMask">
      <MemberSignature Language="C#" Value="public abstract void PushOpacityMask (System.Windows.Media.Brush opacityMask);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushOpacityMask(class System.Windows.Media.Brush opacityMask) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushOpacityMask(System.Windows.Media.Brush)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushOpacityMask (opacityMask As Brush)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushOpacityMask(System::Windows::Media::Brush ^ opacityMask);" />
      <MemberSignature Language="F#" Value="abstract member PushOpacityMask : System.Windows.Media.Brush -&gt; unit" Usage="drawingContext.PushOpacityMask opacityMask" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opacityMask" Type="System.Windows.Media.Brush" />
      </Parameters>
      <Docs>
        <param name="opacityMask">Maska nieprzezroczystości, która ma zostać zastosowana do kolejnych rysunków. Wartości alfa tego pędzla określają nieprzezroczystość rysowania, do którego jest stosowana.</param>
        <summary>Wypchnij określoną maskę nieprzezroczystość do kontekstu rysowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Maska jest stosowana do wszystkich kolejnych poleceń rysowania, dopóki nie zostanie usunięta przez <xref:System.Windows.Media.DrawingContext.Pop%2A> operację.  
  
 Aby uzyskać więcej informacji na temat tworzenia masek nieprzezroczystości, zobacz [Omówienie masek kryjących](~/docs/framework/wpf/graphics-multimedia/opacity-masks-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushTransform">
      <MemberSignature Language="C#" Value="public abstract void PushTransform (System.Windows.Media.Transform transform);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushTransform(class System.Windows.Media.Transform transform) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushTransform(System.Windows.Media.Transform)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushTransform(System::Windows::Media::Transform ^ transform);" />
      <MemberSignature Language="F#" Value="abstract member PushTransform : System.Windows.Media.Transform -&gt; unit" Usage="drawingContext.PushTransform transform" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transform" Type="System.Windows.Media.Transform" />
      </Parameters>
      <Docs>
        <param name="transform">Transformacja, która ma zostać zastosowana do kolejnych poleceń rysowania.</param>
        <summary>Wypchnięcie określonego <see cref="T:System.Windows.Media.Transform" /> elementu do kontekstu rysowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transformacja dotyczy wszystkich kolejnych poleceń rysowania, dopóki nie zostanie usunięta przez <xref:System.Windows.Media.DrawingContext.Pop%2A> polecenie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ten element członkowski obsługuje [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastrukturę i nie jest przeznaczony do użycia bezpośrednio w kodzie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerifyApiNonstructuralChange">
      <MemberSignature Language="C#" Value="protected virtual void VerifyApiNonstructuralChange ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void VerifyApiNonstructuralChange() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.VerifyApiNonstructuralChange" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub VerifyApiNonstructuralChange ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void VerifyApiNonstructuralChange();" />
      <MemberSignature Language="F#" Value="abstract member VerifyApiNonstructuralChange : unit -&gt; unit&#xA;override this.VerifyApiNonstructuralChange : unit -&gt; unit" Usage="drawingContext.VerifyApiNonstructuralChange " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ten element członkowski obsługuje [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] infrastrukturę i nie jest przeznaczony do użycia bezpośrednio w kodzie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

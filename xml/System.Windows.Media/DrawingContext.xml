<Type Name="DrawingContext" FullName="System.Windows.Media.DrawingContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="317c6ce1dfa68dab059c21c4e77d7a450d75043a" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32695221" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class DrawingContext : System.Windows.Threading.DispatcherObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit DrawingContext extends System.Windows.Threading.DispatcherObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.DrawingContext" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DrawingContext&#xA;Inherits DispatcherObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DrawingContext abstract : System::Windows::Threading::DispatcherObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>W tym artykule opisano za pomocą poleceń pop, wypychania i rysowania zawartości wizualnej.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Media.DrawingContext> do wypełnienia <xref:System.Windows.Media.Visual> lub <xref:System.Windows.Media.Drawing> z zawartością visual.  
  
 Mimo że <xref:System.Windows.Media.DrawingContext> metody rysowania wyglądać podobnie do metody rysowania <xref:System.Drawing.Graphics?displayProperty=nameWithType> typu funkcjonują inaczej bardzo: <xref:System.Windows.Media.DrawingContext> jest używany z systemu grafiki zachowanych trybie, podczas gdy <xref:System.Drawing.Graphics?displayProperty=nameWithType> typ jest używany w trybie bezpośrednim system grafiki. Jeśli używasz <xref:System.Windows.Media.DrawingContext> polecenia rysowania obiektu, zestaw instrukcji renderowania faktycznie są przechowywane (chociaż mechanizmu magazynowania dokładne zależy od typu obiektu, który dostarcza <xref:System.Windows.Media.DrawingContext>) który później będzie używany przez grafiki systemu; nie pobierają do ekranu w czasie rzeczywistym. Aby uzyskać więcej informacji na temat działania systemu grafiki Windows Presentation Foundation (WPF), zobacz [Przegląd renderowania grafiki WPF](~/docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
 Użytkownik nigdy nie bezpośrednio utworzyć wystąpienia <xref:System.Windows.Media.DrawingContext>; można jednak uzyskać rysowania kontekstu z niektórych metod, takich jak <xref:System.Windows.Media.DrawingGroup.Open%2A?displayProperty=nameWithType> i <xref:System.Windows.Media.DrawingVisual.RenderOpen%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład pobiera <xref:System.Windows.Media.DrawingContext> z <xref:System.Windows.Media.DrawingVisual> i używa go do rysowania prostokąta.  
  
 [!code-csharp[drawingvisualsample#101](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingVisualSample/CSharp/Window1.xaml.cs#101)]
 [!code-vb[drawingvisualsample#101](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingVisualSample/visualbasic/window1.xaml.vb#101)]  
  
 W następnym przykładzie pokazano <xref:System.Windows.Media.DrawingContext.PushOpacity%2A>, <xref:System.Windows.Media.DrawingContext.PushEffect%2A>, i <xref:System.Windows.Media.DrawingContext.Pop%2A> poleceń. <xref:System.Windows.Media.DrawingContext> Są uzyskiwane z <xref:System.Windows.Media.DrawingGroup> i wyświetlane przy użyciu <xref:System.Windows.Controls.Image> formantu.  
  
 [!code-csharp[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingContext_procedural_snip/CSharp/PushEffectExample.cs#pusheffectexamplewholepage)]
 [!code-vb[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingContext_procedural_snip/visualbasic/pusheffectexample.vb#pusheffectexamplewholepage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Media.DrawingGroup" />
    <altmember cref="T:System.Windows.Media.Drawing" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public abstract void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.Close" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka <see cref="T:System.Windows.Media.DrawingContext" /> i opróżnia zawartości. W efekcie <see cref="T:System.Windows.Media.DrawingContext" /> nie może być modyfikowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Media.DrawingContext> muszą zostać zamknięte przed jego zawartość może być renderowana, ale po został zamknięty, nie może być modyfikowany. To wywołanie nie wymaga wszystkie wywołania wypychania ma zostały zdjęte ze stosu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został już zamknięty lub usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisposeCore">
      <MemberSignature Language="C#" Value="protected abstract void DisposeCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DisposeCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DisposeCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub DisposeCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void DisposeCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez <see cref="T:System.Windows.Media.DrawingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie wywołuj tej metody bezpośrednio w kodzie; Użyj <xref:System.Windows.Media.DrawingContext.System%23IDisposable%23Dispose%2A> metody zamiast tego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Obiekt ma już zamknięty lub usunięty.</exception>
        <altmember cref="M:System.Windows.Media.DrawingContext.System#IDisposable#Dispose" />
      </Docs>
    </Member>
    <Member MemberName="DrawDrawing">
      <MemberSignature Language="C#" Value="public abstract void DrawDrawing (System.Windows.Media.Drawing drawing);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawDrawing(class System.Windows.Media.Drawing drawing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawDrawing(System.Windows.Media.Drawing)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawDrawing(System::Windows::Media::Drawing ^ drawing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drawing" Type="System.Windows.Media.Drawing" />
      </Parameters>
      <Docs>
        <param name="drawing">Rysunek do dołączenia.</param>
        <summary>Rysuje określonego <see cref="T:System.Windows.Media.Drawing" /> obiektu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawEllipse">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rysuje elipsę.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public abstract void DrawEllipse (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Point center, double radiusX, double radiusY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawEllipse(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Point center, float64 radiusX, float64 radiusY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawEllipse(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Point,System.Double,System.Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawEllipse(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Point center, double radiusX, double radiusY);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="center" Type="System.Windows.Point" />
        <Parameter Name="radiusX" Type="System.Double" />
        <Parameter Name="radiusY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="brush">Pędzel, z którą ma zostać wypełnienia elipsy.  To jest opcjonalna i może być <see langword="null" />. Jeśli jest pędzla <see langword="null" />, wypełnienie nie jest rysowane.</param>
        <param name="pen">Pióra, z którą ma zostać obrysu elipsy.  To jest opcjonalna i może być <see langword="null" />. Jeśli jest pióra <see langword="null" />, obrysu nie jest rysowane.</param>
        <param name="center">Lokalizacja środka elipsy.</param>
        <param name="radiusX">Promień elipsy w poziomie.</param>
        <param name="radiusY">Promień w pionie elipsy.</param>
        <summary>Rysuje elipsę z określonym <see cref="T:System.Windows.Media.Brush" /> i <see cref="T:System.Windows.Media.Pen" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pędzel i pióra może mieć `null`.  Jeśli jest pędzla `null`, a następnie odbywa się bez wypełnienia.  W przypadku pióra `null`, a następnie obrys nie jest wykonywane.  W przypadku pióra i pędzla `null`, a następnie rysunek nie jest widoczny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public abstract void DrawEllipse (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Point center, System.Windows.Media.Animation.AnimationClock centerAnimations, double radiusX, System.Windows.Media.Animation.AnimationClock radiusXAnimations, double radiusY, System.Windows.Media.Animation.AnimationClock radiusYAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawEllipse(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Point center, class System.Windows.Media.Animation.AnimationClock centerAnimations, float64 radiusX, class System.Windows.Media.Animation.AnimationClock radiusXAnimations, float64 radiusY, class System.Windows.Media.Animation.AnimationClock radiusYAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawEllipse(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Point,System.Windows.Media.Animation.AnimationClock,System.Double,System.Windows.Media.Animation.AnimationClock,System.Double,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawEllipse(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Point center, System::Windows::Media::Animation::AnimationClock ^ centerAnimations, double radiusX, System::Windows::Media::Animation::AnimationClock ^ radiusXAnimations, double radiusY, System::Windows::Media::Animation::AnimationClock ^ radiusYAnimations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="center" Type="System.Windows.Point" />
        <Parameter Name="centerAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="radiusX" Type="System.Double" />
        <Parameter Name="radiusXAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="radiusY" Type="System.Double" />
        <Parameter Name="radiusYAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="brush">Pędzel, z którą ma zostać wypełnienia elipsy.  To jest opcjonalna i może być <see langword="null" />. Jeśli jest pędzla <see langword="null" />, wypełnienie nie jest rysowane.</param>
        <param name="pen">Pióra, z którą ma zostać obrysu elipsy.  To jest opcjonalna i może być <see langword="null" />. Jeśli jest pióra <see langword="null" />, obrysu nie jest rysowane.</param>
        <param name="center">Lokalizacja środka elipsy.</param>
        <param name="centerAnimations">Zegar umożliwiające animować pozycji center elipsy lub <see langword="null" /> nie animacji. Ten zegar musi być utworzone na podstawie <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> który można animować <see cref="T:System.Windows.Point" /> obiektów.</param>
        <param name="radiusX">Promień elipsy w poziomie.</param>
        <param name="radiusXAnimations">Zegara, z którą ma zostać animować x elipsy-radius, lub <see langword="null" /> nie animacji. Ten zegar musi być utworzone na podstawie <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> który można animować <see cref="T:System.Double" /> obiektów.</param>
        <param name="radiusY">Promień w pionie elipsy.</param>
        <param name="radiusYAnimations">Zegara, z którą ma zostać animować y elipsy-radius, lub <see langword="null" /> nie animacji. Ten zegar musi być utworzone na podstawie <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> który można animować <see cref="T:System.Double" /> obiektów.</param>
        <summary>Rysuje elipsę z określonym <see cref="T:System.Windows.Media.Brush" /> i <see cref="T:System.Windows.Media.Pen" /> i stosuje zegary określonego animacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pędzel i pióra może mieć `null`.  Jeśli jest pędzla `null`, a następnie odbywa się bez wypełnienia.  W przypadku pióra `null`, a następnie obrys nie jest wykonywane.  W przypadku pióra i pędzla `null`, a następnie rysunek nie jest widoczny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawGeometry">
      <MemberSignature Language="C#" Value="public abstract void DrawGeometry (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Media.Geometry geometry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawGeometry(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, class System.Windows.Media.Geometry geometry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawGeometry(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Media.Geometry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawGeometry(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Media::Geometry ^ geometry);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="geometry" Type="System.Windows.Media.Geometry" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Windows.Media.Brush" /> Umożliwiające wypełnienia <see cref="T:System.Windows.Media.Geometry" />. To jest opcjonalna i może być <see langword="null" />. Jeśli jest pędzla <see langword="null" />, wypełnienie nie jest rysowane.</param>
        <param name="pen">
          <see cref="T:System.Windows.Media.Pen" /> Umożliwiające obrysu <see cref="T:System.Windows.Media.Geometry" />. To jest opcjonalna i może być <see langword="null" />. Jeśli jest pióra <see langword="null" />, obrysu nie jest rysowane.</param>
        <param name="geometry">
          <see cref="T:System.Windows.Media.Geometry" /> Do rysowania.</param>
        <summary>Rysuje określonego <see cref="T:System.Windows.Media.Geometry" /> przy użyciu określonego <see cref="T:System.Windows.Media.Brush" /> i <see cref="T:System.Windows.Media.Pen" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawGlyphRun">
      <MemberSignature Language="C#" Value="public abstract void DrawGlyphRun (System.Windows.Media.Brush foregroundBrush, System.Windows.Media.GlyphRun glyphRun);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawGlyphRun(class System.Windows.Media.Brush foregroundBrush, class System.Windows.Media.GlyphRun glyphRun) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawGlyphRun(System.Windows.Media.Brush,System.Windows.Media.GlyphRun)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawGlyphRun(System::Windows::Media::Brush ^ foregroundBrush, System::Windows::Media::GlyphRun ^ glyphRun);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="foregroundBrush" Type="System.Windows.Media.Brush" />
        <Parameter Name="glyphRun" Type="System.Windows.Media.GlyphRun" />
      </Parameters>
      <Docs>
        <param name="foregroundBrush">Pędzel używany do rysowania tekstu.</param>
        <param name="glyphRun">Tekst do rysowania.</param>
        <summary>Rysuje określony tekst.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawImage">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rysuje obraz w region zdefiniowany przez określony <see cref="T:System.Windows.Rect" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public abstract void DrawImage (System.Windows.Media.ImageSource imageSource, System.Windows.Rect rectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawImage(class System.Windows.Media.ImageSource imageSource, valuetype System.Windows.Rect rectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawImage(System.Windows.Media.ImageSource,System.Windows.Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawImage(System::Windows::Media::ImageSource ^ imageSource, System::Windows::Rect rectangle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageSource" Type="System.Windows.Media.ImageSource" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="imageSource">Obraz do rysowania.</param>
        <param name="rectangle">Regionu, w którym ma zostać narysowany <c>bitmapSource</c>.</param>
        <summary>Rysuje obraz w region zdefiniowany przez określony <see cref="T:System.Windows.Rect" />.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.MediaPermission">do wyświetlania obrazów, które nie mają <see cref="T:System.Net.WebPermission" /> lub <see cref="T:System.Security.Permissions.FileIOPermission" /> dostępu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.MediaPermissionImage.SafeImage" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public abstract void DrawImage (System.Windows.Media.ImageSource imageSource, System.Windows.Rect rectangle, System.Windows.Media.Animation.AnimationClock rectangleAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawImage(class System.Windows.Media.ImageSource imageSource, valuetype System.Windows.Rect rectangle, class System.Windows.Media.Animation.AnimationClock rectangleAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawImage(System.Windows.Media.ImageSource,System.Windows.Rect,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawImage(System::Windows::Media::ImageSource ^ imageSource, System::Windows::Rect rectangle, System::Windows::Media::Animation::AnimationClock ^ rectangleAnimations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageSource" Type="System.Windows.Media.ImageSource" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="rectangleAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="imageSource">Obraz do rysowania.</param>
        <param name="rectangle">Regionu, w którym ma zostać narysowany <c>bitmapSource</c>.</param>
        <param name="rectangleAnimations">Zegar umożliwiające animować rozmiaru i wymiarów, prostokąta lub <see langword="null" /> nie animacji. Ten zegar musi być utworzone na podstawie <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> który można animować <see cref="T:System.Windows.Rect" /> obiektów.</param>
        <summary>Rysuje obraz w region zdefiniowany przez określony <see cref="T:System.Windows.Rect" /> i stosuje zegara określonego animacji.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.MediaPermission">do wyświetlania obrazów, które nie mają <see cref="T:System.Net.WebPermission" /> lub <see cref="T:System.Security.Permissions.FileIOPermission" /> dostępu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.MediaPermissionImage.SafeImage" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawLine">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rysuje linię z określonym <see cref="T:System.Windows.Media.Pen" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public abstract void DrawLine (System.Windows.Media.Pen pen, System.Windows.Point point0, System.Windows.Point point1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawLine(class System.Windows.Media.Pen pen, valuetype System.Windows.Point point0, valuetype System.Windows.Point point1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawLine(System.Windows.Media.Pen,System.Windows.Point,System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawLine(System::Windows::Media::Pen ^ pen, System::Windows::Point point0, System::Windows::Point point1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="point0" Type="System.Windows.Point" />
        <Parameter Name="point1" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="pen">Pióra, z którą ma zostać obrysu wiersza.</param>
        <param name="point0">Punkt początkowy wiersza.</param>
        <param name="point1">Punkt końcowy linii.</param>
        <summary>Rysuje linię między punktami określony przy użyciu określonego <see cref="T:System.Windows.Media.Pen" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public abstract void DrawLine (System.Windows.Media.Pen pen, System.Windows.Point point0, System.Windows.Media.Animation.AnimationClock point0Animations, System.Windows.Point point1, System.Windows.Media.Animation.AnimationClock point1Animations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawLine(class System.Windows.Media.Pen pen, valuetype System.Windows.Point point0, class System.Windows.Media.Animation.AnimationClock point0Animations, valuetype System.Windows.Point point1, class System.Windows.Media.Animation.AnimationClock point1Animations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawLine(System.Windows.Media.Pen,System.Windows.Point,System.Windows.Media.Animation.AnimationClock,System.Windows.Point,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawLine(System::Windows::Media::Pen ^ pen, System::Windows::Point point0, System::Windows::Media::Animation::AnimationClock ^ point0Animations, System::Windows::Point point1, System::Windows::Media::Animation::AnimationClock ^ point1Animations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="point0" Type="System.Windows.Point" />
        <Parameter Name="point0Animations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="point1" Type="System.Windows.Point" />
        <Parameter Name="point1Animations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="pen">Pióra obrysu wiersza.</param>
        <param name="point0">Punkt początkowy wiersza.</param>
        <param name="point0Animations">Zegara, z którą ma zostać animować punkt początkowy dla wiersza, lub <see langword="null" /> nie animacji. Ten zegar musi być utworzone na podstawie <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> który można animować <see cref="T:System.Windows.Point" /> obiektów.</param>
        <param name="point1">Punkt końcowy linii.</param>
        <param name="point1Animations">Zegara, z którą ma zostać animować punkt końcowy linii, lub <see langword="null" /> nie animacji. Ten zegar musi być utworzone na podstawie <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> który można animować <see cref="T:System.Windows.Point" /> obiektów.</param>
        <summary>Rysuje linię między punktami określony przy użyciu określonego <see cref="T:System.Windows.Media.Pen" /> i stosuje zegary określonego animacji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawRectangle">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rysuje prostokąt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public abstract void DrawRectangle (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Rect rectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRectangle(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Rect rectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawRectangle(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawRectangle(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Rect rectangle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="brush">Pędzel, z którą ma zostać wypełnić.  To jest opcjonalna i może być <see langword="null" />. Jeśli jest pędzla <see langword="null" />, wypełnienie nie jest rysowane.</param>
        <param name="pen">Pióra, z którą ma zostać obrysu prostokąta.  To jest opcjonalna i może być <see langword="null" />. Jeśli jest pióra <see langword="null" />, obrysu nie jest rysowane.</param>
        <param name="rectangle">Prostokąt do rysowania.</param>
        <summary>Rysuje prostokąt z określonym <see cref="T:System.Windows.Media.Brush" /> i <see cref="T:System.Windows.Media.Pen" />. Pióro i pędzla może być <see langword="null" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pędzel i pióra może mieć `null`.  Jeśli jest pędzla `null`, a następnie odbywa się bez wypełnienia.  W przypadku pióra `null`, a następnie obrys nie jest wykonywane.  W przypadku pióra i pędzla `null`, a następnie rysunek nie jest widoczny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public abstract void DrawRectangle (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Rect rectangle, System.Windows.Media.Animation.AnimationClock rectangleAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRectangle(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Rect rectangle, class System.Windows.Media.Animation.AnimationClock rectangleAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawRectangle(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Rect,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawRectangle(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Rect rectangle, System::Windows::Media::Animation::AnimationClock ^ rectangleAnimations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="rectangleAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="brush">Pędzel, z którą ma zostać wypełnić.  To jest opcjonalna i może być <see langword="null" />. Jeśli jest pędzla <see langword="null" />, wypełnienie nie jest rysowane.</param>
        <param name="pen">Pióra, z którą ma zostać obrysu prostokąta.  To jest opcjonalna i może być <see langword="null" />. Jeśli jest pióra <see langword="null" />, obrysu nie jest rysowane.</param>
        <param name="rectangle">Prostokąt do rysowania.</param>
        <param name="rectangleAnimations">Zegar umożliwiające animować rozmiaru i wymiarów, prostokąta lub <see langword="null" /> nie animacji. Ten zegar musi być utworzone na podstawie <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> który można animować <see cref="T:System.Windows.Rect" /> obiektów.</param>
        <summary>Rysuje prostokąt z określonym <see cref="T:System.Windows.Media.Brush" /> i <see cref="T:System.Windows.Media.Pen" /> i stosuje zegary określonego animacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pędzel i pióra może mieć `null`.  Jeśli jest pędzla `null`, a następnie odbywa się bez wypełnienia.  W przypadku pióra `null`, a następnie obrys nie jest wykonywane.  W przypadku pióra i pędzla `null`, a następnie rysunek nie jest widoczny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawRoundedRectangle">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rysuje zaokrąglony prostokąt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawRoundedRectangle">
      <MemberSignature Language="C#" Value="public abstract void DrawRoundedRectangle (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Rect rectangle, double radiusX, double radiusY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRoundedRectangle(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Rect rectangle, float64 radiusX, float64 radiusY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawRoundedRectangle(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Rect,System.Double,System.Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawRoundedRectangle(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Rect rectangle, double radiusX, double radiusY);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="radiusX" Type="System.Double" />
        <Parameter Name="radiusY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="brush">Pędzel używany do wypełnienia prostokąta.</param>
        <param name="pen">Pióro umożliwia obrysu prostokąta.</param>
        <param name="rectangle">Prostokąt do rysowania.</param>
        <param name="radiusX">Radius w wymiarze X zaokrąglone narożniki.  Ta wartość będzie być zablokowane za pomocą do zakresu od 0 do  <see cref="P:System.Windows.Rect.Width" /> /2.</param>
        <param name="radiusY">Radius w wymiarze Y zaokrąglone narożniki.  Ta wartość będzie być zablokowane za pomocą wartości z zakresu od 0 do  <see cref="P:System.Windows.Rect.Height" /> /2.</param>
        <summary>Rysuje zaokrąglony prostokąt z określonym <see cref="T:System.Windows.Media.Brush" /> i <see cref="T:System.Windows.Media.Pen" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pędzel i pióra może mieć `null`.  Jeśli jest pędzla `null`, a następnie odbywa się bez wypełnienia.  W przypadku pióra `null`, a następnie obrys nie jest wykonywane.  W przypadku pióra i pędzla `null`, a następnie rysunek nie jest widoczny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawRoundedRectangle">
      <MemberSignature Language="C#" Value="public abstract void DrawRoundedRectangle (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Rect rectangle, System.Windows.Media.Animation.AnimationClock rectangleAnimations, double radiusX, System.Windows.Media.Animation.AnimationClock radiusXAnimations, double radiusY, System.Windows.Media.Animation.AnimationClock radiusYAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRoundedRectangle(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Rect rectangle, class System.Windows.Media.Animation.AnimationClock rectangleAnimations, float64 radiusX, class System.Windows.Media.Animation.AnimationClock radiusXAnimations, float64 radiusY, class System.Windows.Media.Animation.AnimationClock radiusYAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawRoundedRectangle(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Rect,System.Windows.Media.Animation.AnimationClock,System.Double,System.Windows.Media.Animation.AnimationClock,System.Double,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawRoundedRectangle(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Rect rectangle, System::Windows::Media::Animation::AnimationClock ^ rectangleAnimations, double radiusX, System::Windows::Media::Animation::AnimationClock ^ radiusXAnimations, double radiusY, System::Windows::Media::Animation::AnimationClock ^ radiusYAnimations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="rectangleAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="radiusX" Type="System.Double" />
        <Parameter Name="radiusXAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="radiusY" Type="System.Double" />
        <Parameter Name="radiusYAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="brush">Pędzel używany do wypełnienia prostokąta lub <see langword="null" /> do wypełnienia.</param>
        <param name="pen">Pióro umożliwia obrysu prostokąta lub <see langword="null" /> dla żadnego obrysu.</param>
        <param name="rectangle">Prostokąt do rysowania.</param>
        <param name="rectangleAnimations">Zegar umożliwiające animować rozmiaru i wymiarów, prostokąta lub <see langword="null" /> nie animacji. Ten zegar musi być utworzone na podstawie <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> który można animować <see cref="T:System.Windows.Rect" /> obiektów.</param>
        <param name="radiusX">Radius w wymiarze X zaokrąglone narożniki.  Ta wartość będzie być zablokowane za pomocą do zakresu od 0 do  <see cref="P:System.Windows.Rect.Width" /> /2</param>
        <param name="radiusXAnimations">Zegara, z którą ma zostać animować prostokąta <c>radiusX</c> wartość, lub <see langword="null" /> nie animacji. Ten zegar musi być utworzone na podstawie <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> który można animować <see cref="T:System.Double" /> wartości.</param>
        <param name="radiusY">Radius w wymiarze Y zaokrąglone narożniki.  Ta wartość będzie być zablokowane za pomocą wartości z zakresu od 0 do  <see cref="P:System.Windows.Rect.Height" /> /2.</param>
        <param name="radiusYAnimations">Zegara, z którą ma zostać animować prostokąta <c>radiusY</c> wartość, lub <see langword="null" /> nie animacji. Ten zegar musi być utworzone na podstawie <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> który można animować <see cref="T:System.Double" /> wartości.</param>
        <summary>Rysuje zaokrąglony prostokąt z określonym <see cref="T:System.Windows.Media.Brush" /> i <see cref="T:System.Windows.Media.Pen" /> i stosuje zegary określonego animacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pędzel i pióra może mieć `null`.  Jeśli jest pędzla `null`, a następnie odbywa się bez wypełnienia.  W przypadku pióra `null`, a następnie obrys nie jest wykonywane.  W przypadku pióra i pędzla `null`, a następnie rysunek nie jest widoczny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawText">
      <MemberSignature Language="C#" Value="public void DrawText (System.Windows.Media.FormattedText formattedText, System.Windows.Point origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawText(class System.Windows.Media.FormattedText formattedText, valuetype System.Windows.Point origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawText(System.Windows.Media.FormattedText,System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawText(System::Windows::Media::FormattedText ^ formattedText, System::Windows::Point origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="formattedText" Type="System.Windows.Media.FormattedText" />
        <Parameter Name="origin" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="formattedText">Tekst sformatowany do narysowania.</param>
        <param name="origin">Lokalizacja, w którym ma zostać narysowany tekst.</param>
        <summary>Rysuje sformatowanego tekstu w określonej lokalizacji.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Obiekt ma już zamknięty lub usunięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawVideo">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rysuj wideo w wybranym regionie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawVideo">
      <MemberSignature Language="C#" Value="public abstract void DrawVideo (System.Windows.Media.MediaPlayer player, System.Windows.Rect rectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawVideo(class System.Windows.Media.MediaPlayer player, valuetype System.Windows.Rect rectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawVideo(System.Windows.Media.MediaPlayer,System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawVideo (player As MediaPlayer, rectangle As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawVideo(System::Windows::Media::MediaPlayer ^ player, System::Windows::Rect rectangle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="player" Type="System.Windows.Media.MediaPlayer" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="player">Nośnik do rysowania.</param>
        <param name="rectangle">Regionu, w którym ma zostać narysowany <c>player</c>.</param>
        <summary>Rysuje wideo w wybranym regionie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że aby zmieścić się w obszarze zdefiniowanym przez parametr prostokąt będzie rozciągany nośnika. Jeśli prostokąt i nośnika mają różne proporcje, zostanie przeprowadzona zakłóceń. Aby uzyskać większą kontrolę nad jak nośniki są używane w celu wypełnienia obszaru, użyj <xref:System.Windows.Media.DrawingContext.DrawRectangle%2A> polecenie, aby narysować prostokąt i wypełnić ją z <xref:System.Windows.Media.VisualBrush> zawierający nośnika.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.MediaPermission">Aby wyświetlić nośnik, który nie ma <see cref="T:System.Net.WebPermission" /> lub <see cref="T:System.Security.Permissions.FileIOPermission" /> dostępu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.MediaPermissionImage.SafeImage" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DrawVideo">
      <MemberSignature Language="C#" Value="public abstract void DrawVideo (System.Windows.Media.MediaPlayer player, System.Windows.Rect rectangle, System.Windows.Media.Animation.AnimationClock rectangleAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawVideo(class System.Windows.Media.MediaPlayer player, valuetype System.Windows.Rect rectangle, class System.Windows.Media.Animation.AnimationClock rectangleAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawVideo(System.Windows.Media.MediaPlayer,System.Windows.Rect,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawVideo (player As MediaPlayer, rectangle As Rect, rectangleAnimations As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawVideo(System::Windows::Media::MediaPlayer ^ player, System::Windows::Rect rectangle, System::Windows::Media::Animation::AnimationClock ^ rectangleAnimations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="player" Type="System.Windows.Media.MediaPlayer" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="rectangleAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="player">Nośnik do rysowania.</param>
        <param name="rectangle">Obszar rysowania nośnika.</param>
        <param name="rectangleAnimations">Zegar umożliwiające animować rozmiaru i wymiarów, prostokąta lub <see langword="null" /> nie animacji. Ten zegar musi być utworzone na podstawie <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> który można animować <see cref="T:System.Windows.Rect" /> obiektów.</param>
        <summary>Rysuje wideo w wybranym regionie i stosuje zegara określonego animacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że aby zmieścić się w obszarze zdefiniowanym przez parametr prostokąt będzie rozciągany nośnika. Jeśli prostokąt i nośnika mają różne proporcje, zostanie przeprowadzona zakłóceń. Aby uzyskać większą kontrolę nad jak nośniki są używane w celu wypełnienia obszaru, użyj <xref:System.Windows.Media.DrawingContext.DrawRectangle%2A> polecenie, aby narysować prostokąt i wypełnić ją z <xref:System.Windows.Media.VisualBrush> zawierający nośnika.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.MediaPermission">Aby wyświetlić nośnik, który nie ma <see cref="T:System.Net.WebPermission" /> lub <see cref="T:System.Security.Permissions.FileIOPermission" /> dostępu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.MediaPermissionImage.SafeImage" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public abstract void Pop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Pop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.Pop" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Pop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Pop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>POP ostatniego maskę przezroczystości, nieprzezroczystość, klip, efekt lub operacji przekształcania, który został przypisany do rysowania kontekstu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po operacji jest zdjęte ze stosu, nie jest już stosowany kolejne polecenia rysowania.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wynik <xref:System.Windows.Media.DrawingContext.Pop%2A> polecenia.  
  
 [!code-csharp[DrawingContext_procedural_snip#PopExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingContext_procedural_snip/CSharp/PopExample.cs#popexamplewholepage)]
 [!code-vb[DrawingContext_procedural_snip#PopExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingContext_procedural_snip/visualbasic/popexample.vb#popexamplewholepage)]  
  
 Na poniższej ilustracji przedstawiono w tym przykładzie danych wyjściowych:  
  
 ![Prostokąty narysowane o różnych wartościach nieprzezroczystości](~/add/media/graphicsmm-drawingcontextpopexample.gif "prostokąty narysowane o różnych wartościach nieprzezroczystości")  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushClip">
      <MemberSignature Language="C#" Value="public abstract void PushClip (System.Windows.Media.Geometry clipGeometry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushClip(class System.Windows.Media.Geometry clipGeometry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushClip(System.Windows.Media.Geometry)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushClip (clipGeometry As Geometry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushClip(System::Windows::Media::Geometry ^ clipGeometry);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipGeometry" Type="System.Windows.Media.Geometry" />
      </Parameters>
      <Docs>
        <param name="clipGeometry">Obszar przycinania do zastosowania do kolejnych poleceniach rysowania.</param>
        <summary>Wypycha obszar przycinania określony na rysunku kontekstu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar przycinania ma zastosowanie do wszystkich kolejnych poleceń rysowania do momentu usunięcia ich przez <xref:System.Windows.Media.DrawingContext.Pop%2A> polecenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushEffect">
      <MemberSignature Language="C#" Value="public abstract void PushEffect (System.Windows.Media.Effects.BitmapEffect effect, System.Windows.Media.Effects.BitmapEffectInput effectInput);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushEffect(class System.Windows.Media.Effects.BitmapEffect effect, class System.Windows.Media.Effects.BitmapEffectInput effectInput) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushEffect(System.Windows.Media.Effects.BitmapEffect,System.Windows.Media.Effects.BitmapEffectInput)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushEffect (effect As BitmapEffect, effectInput As BitmapEffectInput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushEffect(System::Windows::Media::Effects::BitmapEffect ^ effect, System::Windows::Media::Effects::BitmapEffectInput ^ effectInput);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="effect" Type="System.Windows.Media.Effects.BitmapEffect" />
        <Parameter Name="effectInput" Type="System.Windows.Media.Effects.BitmapEffectInput" />
      </Parameters>
      <Docs>
        <param name="effect">Efekt do zastosowania do rysunków kolejne.</param>
        <param name="effectInput">Obszar, do którego jest stosowany efekt, lub <see langword="null" /> jeśli ma zostać zastosowany do cały obszar kolejnych rysunki efekt.</param>
        <summary>Wypchnięcia określonego <see cref="T:System.Windows.Media.Effects.BitmapEffect" /> na rysunku kontekstu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Efekt jest stosowany do wszystkich kolejnych operacji rysowania do momentu usunięcia ich przez <xref:System.Windows.Media.DrawingContext.Pop%2A> polecenia.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Windows.Media.DrawingContext.PushOpacity%2A>, <xref:System.Windows.Media.DrawingContext.PushEffect%2A>, i <xref:System.Windows.Media.DrawingContext.Pop%2A> poleceń.  
  
 [!code-csharp[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingContext_procedural_snip/CSharp/PushEffectExample.cs#pusheffectexamplewholepage)]
 [!code-vb[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingContext_procedural_snip/visualbasic/pusheffectexample.vb#pusheffectexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushGuidelineSet">
      <MemberSignature Language="C#" Value="public abstract void PushGuidelineSet (System.Windows.Media.GuidelineSet guidelines);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushGuidelineSet(class System.Windows.Media.GuidelineSet guidelines) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushGuidelineSet(System.Windows.Media.GuidelineSet)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushGuidelineSet (guidelines As GuidelineSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushGuidelineSet(System::Windows::Media::GuidelineSet ^ guidelines);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guidelines" Type="System.Windows.Media.GuidelineSet" />
      </Parameters>
      <Docs>
        <param name="guidelines">Wskazówek dotyczących ustawioną dotyczą kolejne polecenia rysowania.</param>
        <summary>Wypchnięcia określonego <see cref="T:System.Windows.Media.GuidelineSet" /> na rysunku kontekstu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw wytyczne dotyczą wszystkie kolejne polecenia rysowania do momentu usunięcia ich przez <xref:System.Windows.Media.DrawingContext.Pop%2A> operacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.GuidelineSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PushOpacity">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wypycha ustawienie nieprzezroczystość określony na rysunku kontekstu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PushOpacity">
      <MemberSignature Language="C#" Value="public abstract void PushOpacity (double opacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushOpacity(float64 opacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushOpacity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushOpacity (opacity As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushOpacity(double opacity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opacity" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="opacity">Współczynnik przezroczystości do zastosowania do kolejnych poleceniach rysowania. Współczynnik to jest zbiorcza z poprzednim <see cref="M:System.Windows.Media.DrawingContext.PushOpacity(System.Double)" /> operacji.</param>
        <summary>Wypycha ustawienie nieprzezroczystość określony na rysunku kontekstu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nieprzezroczystość mieszania na wszystkie kolejne polecenia rysowania do momentu usunięcia ich przez <xref:System.Windows.Media.DrawingContext.Pop%2A> polecenia.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Windows.Media.DrawingContext.PushOpacity%2A>, <xref:System.Windows.Media.DrawingContext.PushEffect%2A>, i <xref:System.Windows.Media.DrawingContext.Pop%2A> poleceń.  
  
 [!code-csharp[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingContext_procedural_snip/CSharp/PushEffectExample.cs#pusheffectexamplewholepage)]
 [!code-vb[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingContext_procedural_snip/visualbasic/pusheffectexample.vb#pusheffectexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushOpacity">
      <MemberSignature Language="C#" Value="public abstract void PushOpacity (double opacity, System.Windows.Media.Animation.AnimationClock opacityAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushOpacity(float64 opacity, class System.Windows.Media.Animation.AnimationClock opacityAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushOpacity(System.Double,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushOpacity (opacity As Double, opacityAnimations As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushOpacity(double opacity, System::Windows::Media::Animation::AnimationClock ^ opacityAnimations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opacity" Type="System.Double" />
        <Parameter Name="opacityAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="opacity">Współczynnik przezroczystości do zastosowania do kolejnych poleceniach rysowania. Współczynnik to jest zbiorcza z poprzednim <see cref="M:System.Windows.Media.DrawingContext.PushOpacity(System.Double)" /> operacji.</param>
        <param name="opacityAnimations">Zegara, z którą ma zostać animować wartość nieprzezroczystości lub <see langword="null" /> nie animacji. Ten zegar musi być utworzone na podstawie <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> który można animować <see cref="T:System.Double" /> wartości.</param>
        <summary>Wypchnięcia ustawienie nieprzezroczystość określony na rysunku kontekstu i stosuje zegara określonego animacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nieprzezroczystość mieszania na wszystkie kolejne polecenia rysowania do momentu usunięcia ich przez <xref:System.Windows.Media.DrawingContext.Pop%2A> polecenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushOpacityMask">
      <MemberSignature Language="C#" Value="public abstract void PushOpacityMask (System.Windows.Media.Brush opacityMask);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushOpacityMask(class System.Windows.Media.Brush opacityMask) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushOpacityMask(System.Windows.Media.Brush)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushOpacityMask (opacityMask As Brush)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushOpacityMask(System::Windows::Media::Brush ^ opacityMask);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opacityMask" Type="System.Windows.Media.Brush" />
      </Parameters>
      <Docs>
        <param name="opacityMask">Maskę przezroczystości do zastosowania do rysunków kolejne. Wartości alfa tego pędzla ustalić nieprzezroczystość rysunku, do których są stosowane.</param>
        <summary>Wypycha maska nieprzezroczystość określony na rysunku kontekstu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest stosowana do wszystkich kolejnych poleceń rysowania do momentu usunięcia ich przez <xref:System.Windows.Media.DrawingContext.Pop%2A> operacji.  
  
 Aby uzyskać więcej informacji o tworzeniu nieprzezroczystość maski, zobacz [omówienie maski nieprzezroczystość](~/docs/framework/wpf/graphics-multimedia/opacity-masks-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushTransform">
      <MemberSignature Language="C#" Value="public abstract void PushTransform (System.Windows.Media.Transform transform);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushTransform(class System.Windows.Media.Transform transform) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushTransform(System.Windows.Media.Transform)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushTransform(System::Windows::Media::Transform ^ transform);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transform" Type="System.Windows.Media.Transform" />
      </Parameters>
      <Docs>
        <param name="transform">Przekształcenie do zastosowania do kolejnych poleceniach rysowania.</param>
        <summary>Wypchnięcia określonego <see cref="T:System.Windows.Media.Transform" /> na rysunku kontekstu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przekształcenia ma zastosowanie do wszystkich kolejnych poleceń rysowania do momentu usunięcia ich przez <xref:System.Windows.Media.DrawingContext.Pop%2A> polecenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ten element członkowski obsługuje [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastrukturę i nie jest przeznaczona do użycia bezpośrednio w kodzie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerifyApiNonstructuralChange">
      <MemberSignature Language="C#" Value="protected virtual void VerifyApiNonstructuralChange ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void VerifyApiNonstructuralChange() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.VerifyApiNonstructuralChange" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub VerifyApiNonstructuralChange ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void VerifyApiNonstructuralChange();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ten element członkowski obsługuje [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] infrastrukturę i nie jest przeznaczona do użycia bezpośrednio w kodzie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
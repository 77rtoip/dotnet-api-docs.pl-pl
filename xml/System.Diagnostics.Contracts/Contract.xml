<Type Name="Contract" FullName="System.Diagnostics.Contracts.Contract">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2f21917a6853fe4b567375e9f2268571d3f1e053" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36677087" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Contract" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Contract extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Contracts.Contract" />
  <TypeSignature Language="VB.NET" Value="Public Class Contract" />
  <TypeSignature Language="C++ CLI" Value="public ref class Contract abstract sealed" />
  <TypeSignature Language="F#" Value="type Contract = class" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zawiera metody statyczne reprezentujący program kontrakty, takie jak warunki wstępne, postconditions i invariants obiektu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy kontraktu kodu pozwalają określić warunki wstępne, postconditions i invariants obiektu w kodzie. Warunki wstępne są wymagania, które muszą zostać spełnione, wprowadzając metody lub właściwości. Postconditions opisano oczekiwań w czasie, który zamyka kodu metody lub właściwości. Obiekt invariants opisano oczekiwanym stanem dla klasy, która nie ma warunku problemów. Aby uzyskać więcej informacji o warunkach wstępnych, postconditions i invariants obiektu, zobacz [kontraktów kodu](~/docs/framework/debug-trace-profile/code-contracts.md).  
  
 Narzędzia i szczegółowe instrukcje dotyczące używania kontraktów kodu, zobacz [kontraktów kodu](http://go.microsoft.com/fwlink/?LinkId=152461) w witrynie MSDN DevLabs.  
  
> [!IMPORTANT]
>  Należy użyć binarne funkcji ponownego zapisu do wstawienia środowiska wykonawczego egzekwowania umów. W przeciwnym razie umów takich jak <xref:System.Diagnostics.Contracts.Contract.Ensures%2A?displayProperty=nameWithType> metody tylko można przetestować statycznie i nie zgłosi wyjątków w czasie wykonywania w przypadku naruszenia Umowy. Binarny funkcji ponownego zapisu CCRewrite można pobrać z [kontraktów kodu](http://go.microsoft.com/fwlink/?LinkId=152461) w witrynie MSDN DevLabs. CCRewrite pochodzi z dodatek Visual Studio, który umożliwia aktywowanie wymuszania kontraktu czasu wykonywania w projekcie **właściwości** strony. Binarny funkcji ponownego zapisu i dodatek Visual Studio nie są dostarczane z [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] lub zestawu Windows SDK.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Assert">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W kompilacjach do debugowania wykonuje test czasu wykonywania dla określonego warunku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition);" />
      <MemberSignature Language="F#" Value="static member Assert : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assert condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">Wyrażenie warunkowe do testowania.</param>
        <summary>Sprawdza, czy warunek; Jeśli warunek nie jest <see langword="false" />, następuje zasady eskalacji dla analizatora.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślne zasady eskalacji to Powiadom dołączony debuger o niepowodzeniu kontraktu lub wyświetlić **Assert** okno dialogowe, jeśli nie jest dołączony debuger. Opcjonalnie analizatora należy poinstruować, aby zgłosić wyjątek.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Assert : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assert (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">Wyrażenie warunkowe do testowania.</param>
        <param name="userMessage">Komunikat do wyświetlenia, jeśli nie jest spełniony warunek.</param>
        <summary>Sprawdza, czy warunek; Jeśli warunek nie jest <see langword="false" />, następuje zasady eskalacji ustawione przez analizatora i wyświetla określony komunikat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślne zasady eskalacji to Powiadom dołączony debuger o niepowodzeniu kontraktu lub wyświetlić **Assert** okno dialogowe, jeśli nie jest dołączony debuger. Opcjonalnie analizatora należy poinstruować, aby zgłosić wyjątek. `userMessage` Parametr jest przekazywany do danych wyjściowych debugera. Jeśli `userMessage` nie jest ciągiem stałym literału, narzędzia nie można go odczytać.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Assume">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Powoduje, że narzędzi analizy kodu do wniosku, że warunek jest <see langword="true" />, nawet jeśli nie statycznie sprawdzone zawsze być <see langword="true" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assume">
      <MemberSignature Language="C#" Value="public static void Assume (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assume(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assume (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assume(bool condition);" />
      <MemberSignature Language="F#" Value="static member Assume : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assume condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">Wyrażenie warunkowe do wniosku <see langword="true" />.</param>
        <summary>Powoduje, że narzędzi analizy kodu do wniosku, że jest określony warunek <see langword="true" />, nawet jeśli nie statycznie sprawdzone zawsze być <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W czasie wykonywania, za pomocą tej metody jest odpowiednikiem przy użyciu <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assume">
      <MemberSignature Language="C#" Value="public static void Assume (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assume(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assume (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assume(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Assume : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assume (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">Wyrażenie warunkowe do wniosku <see langword="true" />.</param>
        <param name="userMessage">Komunikat do opublikowania Jeśli założeniu nie powiedzie się.</param>
        <summary>Nakazuje narzędzi analizy kodu do wniosku, że warunek jest <see langword="true" />, nawet jeśli nie statycznie sprawdzone zawsze być <see langword="true" />i wyświetla komunikat, jeśli założeniu nie powiedzie się.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `userMessage` nie jest ciągiem stałym literału, kontrakt nie może być rozpoznawany przez narzędzia.  
  
 W czasie wykonywania, za pomocą tej metody jest odpowiednikiem przy użyciu <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%2CSystem.String%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContractFailed">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt; ContractFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Diagnostics.Contracts.ContractFailedEventArgs&gt; ContractFailed" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Contracts.Contract.ContractFailed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ContractFailed As EventHandler(Of ContractFailedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Diagnostics::Contracts::ContractFailedEventArgs ^&gt; ^ ContractFailed;" />
      <MemberSignature Language="F#" Value="member this.ContractFailed : EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt; " Usage="member this.ContractFailed : System.EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy kontrakt nie powiedzie się.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informacje dotyczące zdarzenia dla tego zdarzenia jest dostarczana przez <xref:System.Diagnostics.Contracts.ContractFailedEventArgs?displayProperty=nameWithType> obiekt, który zostanie przekazany do obsługi zdarzeń. To zdarzenie powiadamia środowisku zarządzanej aplikacji, takich jak interakcyjne interpreter lub hosta przeglądarki sieci Web, który kontrakt nie powiodło się. Przed dokonaniem, zgłosi zdarzenie, które może obsłużyć aplikacja, jak za stosowny. Na przykład jeśli kod jest uruchamiana w ramach testowania, możesz zalogować niepowodzenia testu i następnie zakończyć test.  
  
 Domyślna implementacja <xref:System.Diagnostics.Contracts.Internal.ContractHelper.RaiseContractFailedEvent%2A> metody w bibliotece klas programu .NET Framework jest wywołanie każdy program obsługi, która jest zarejestrowana <xref:System.Diagnostics.Contracts.Contract.ContractFailed> zdarzeń. Wyjątki generowane przez programy obsługi są ignorowane, ale każdy program obsługi może wskazać, czy błąd jest obsługiwana przez wywołanie metody <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled%2A> metody dla argumentów zdarzenia. Jeśli wszystkie obsługi ustawia niepowodzenia obsługi, metoda zwraca `null` i są wykonywane nie dalsze działania. Alternatywnie można wywołać procedury obsługi <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind%2A> metody nakazać kod operacji unwind. W takim przypadku jest zwracany wyjątek, po wykonaniu wszystkich programów obsługi.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="EndContractBlock">
      <MemberSignature Language="C#" Value="public static void EndContractBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndContractBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EndContractBlock" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndContractBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndContractBlock();" />
      <MemberSignature Language="F#" Value="static member EndContractBlock : unit -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.EndContractBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Oznacza koniec sekcji kontraktu, gdy metoda kontraktów zawiera tylko warunki wstępne w <see langword="if" /> - <see langword="then" /> - <see langword="throw" /> formularza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Większość kodu zawiera już niektóre sprawdzanie poprawności parametru w postaci `if` - `then` - `throw` kodu. Rozpoznaje narzędzia kontraktu `if` - `then` - `throw` instrukcje jako warunki wstępne, gdy instrukcje występować jako pierwszy wewnątrz metody, a cały zestaw takich instrukcji następuje jawne<xref:System.Diagnostics.Contracts.Contract> wywołanie metody, takie jak <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, lub <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>.  
  
 Gdy `if` - `then` - `throw` instrukcje pojawiają się w tym formularzu narzędzia kontraktu rozpoznaje je jako starszych-wymagają instrukcje. <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> Formularz jest używany tylko wtedy, gdy nie ma innych umów wykonaj `if` - `then` - `throw` sekwencji, ale nadal powinien oznaczone jako starszych-wymaga.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ensures">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa kontrakt postcondition otaczającego metody lub właściwości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ensures">
      <MemberSignature Language="C#" Value="public static void Ensures (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ensures(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ensures (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Ensures(bool condition);" />
      <MemberSignature Language="F#" Value="static member Ensures : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Ensures condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">Wyrażenie warunkowe do testowania. Wyrażenie, które mogą obejmować <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />, <see cref="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" />, i <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> wartości.</param>
        <summary>Określa kontrakt postcondition otaczającego metody lub właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `condition` Parametr określa warunku końcowego, który ma być `true` po otaczającego metody lub właściwości zwraca normalnie.  
  
-   Wywołanie tej metody należy na początku metody lub właściwości przed innymi kodu.  
  
-   Należy użyć binarne funkcji ponownego zapisu (dostępne pod adresem [kontraktów kodu](http://go.microsoft.com/fwlink/?LinkId=152461) w witrynie MSDN DevLabs) do środowiska wykonawczego stosowania tego warunku końcowego.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> metody, aby upewnić się, że jest zwracana wartość oczekiwana. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Diagnostics.Contracts.ContractClassAttribute> klasy.  
  
 [!code-csharp[ContractExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#3)]
 [!code-vb[ContractExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ensures">
      <MemberSignature Language="C#" Value="public static void Ensures (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ensures(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ensures (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Ensures(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Ensures : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Ensures (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">Wyrażenie warunkowe do testowania. Wyrażenie, które mogą obejmować <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /> i <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> wartości.</param>
        <param name="userMessage">Komunikat wyświetlany, jeśli wyrażenie nie jest <see langword="true" />.</param>
        <summary>Określa kontrakt postcondition warunku exit podana i komunikat do wyświetlenia, jeśli wynikiem warunku jest <see langword="false" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `condition` Parametr określa warunku końcowego, który ma być `true` po otaczającego metody lub właściwości zwraca normalnie.  
  
-   Wywołanie tej metody należy na początku metody lub właściwości przed innymi kodu.  
  
-   Niniejsza Umowa jest widoczne dla klientów; w związku z tym musi tylko odwołanie do elementów członkowskich, które są co najmniej jako widoczna jako metody otaczającej.  
  
-   Należy użyć binarne funkcji ponownego zapisu (dostępne pod adresem [kontraktów kodu](http://go.microsoft.com/fwlink/?LinkId=152461) w witrynie MSDN DevLabs) do środowiska wykonawczego stosowania tego warunku końcowego.  
  
-   Jeśli `userMessage` nie jest ciągiem stałym literału, kontrakt nie może być rozpoznawany przez narzędzia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnsuresOnThrow&lt;TException&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa kontrakt postcondition dla otaczającego metody lub właściwości na podstawie podanych wyjątku i warunku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnsuresOnThrow&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void EnsuresOnThrow&lt;TException&gt; (bool condition) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsuresOnThrow&lt;(class System.Exception) TException&gt;(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsuresOnThrow(Of TException As Exception) (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void EnsuresOnThrow(bool condition);" />
      <MemberSignature Language="F#" Value="static member EnsuresOnThrow : bool -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.EnsuresOnThrow condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TException">Typ wyjątku, który wywołuje postcondition wyboru.</typeparam>
        <param name="condition">Wyrażenie warunkowe do testowania.</param>
        <summary>Określa kontrakt postcondition dla otaczającego metody lub właściwości, na podstawie podanych wyjątku i warunek.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `condition` Parametr określa warunku końcowego, który ma być `true` po otaczającego metody lub właściwości nieprawidłowo kończy działanie i wystąpił wyjątek typu `TException` jest generowany.  
  
-   Wywołanie tej metody należy na początku metody lub właściwości przed innymi kodu.  
  
-   Niniejsza Umowa jest widoczne dla klientów; w związku z tym musi tylko odwołanie do elementów członkowskich, które są co najmniej jako widoczna jako metody otaczającej.  
  
-   Dla środowiska wykonawczego stosowania tego warunku końcowego, należy użyć binarne funkcji ponownego zapisu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsuresOnThrow&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void EnsuresOnThrow&lt;TException&gt; (bool condition, string userMessage) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsuresOnThrow&lt;(class System.Exception) TException&gt;(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsuresOnThrow(Of TException As Exception) (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void EnsuresOnThrow(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member EnsuresOnThrow : bool * string -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.EnsuresOnThrow (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TException">Typ wyjątku, który wywołuje postcondition wyboru.</typeparam>
        <param name="condition">Wyrażenie warunkowe do testowania.</param>
        <param name="userMessage">Komunikat wyświetlany, jeśli wyrażenie jest <see langword="false" />.</param>
        <summary>Określa kontrakt postcondition i komunikat do wyświetlenia, jeśli wynikiem warunku jest <see langword="false" /> otaczającego metody lub właściwości, na podstawie podanych wyjątku i warunek.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `condition` Parametr określa warunku końcowego, który ma być `true` po otaczającego metody lub właściwości nieprawidłowo kończy działanie i wystąpił wyjątek typu `TException` jest generowany. `message` Parametr określa komunikat wyświetlany, jeśli wynikiem warunku jest `false`.  
  
-   Wywołanie tej metody należy na początku metody lub właściwości przed innymi kodu.  
  
-   Niniejsza Umowa jest widoczne dla klientów; w związku z tym musi tylko odwołanie do elementów członkowskich, które są co najmniej jako widoczna jako metody otaczającej.  
  
-   Dla środowiska wykonawczego stosowania tego warunku końcowego, należy użyć binarne funkcji ponownego zapisu.  
  
-   Jeśli `userMessage` nie jest ciągiem stałym literału, kontrakt nie może być rozpoznawany przez narzędzia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (int fromInclusive, int toExclusive, Predicate&lt;int&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(int32 fromInclusive, int32 toExclusive, class System.Predicate`1&lt;int32&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (fromInclusive As Integer, toExclusive As Integer, predicate As Predicate(Of Integer)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(int fromInclusive, int toExclusive, Predicate&lt;int&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Exists : int * int * Predicate&lt;int&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.Exists (fromInclusive, toExclusive, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="predicate" Type="System.Predicate&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Pierwszej liczby całkowitej do przekazania do <c>predykatu</c>.</param>
        <param name="toExclusive">Co więcej niż ostatni liczby całkowitej w celu przekazania do <c>predykatu</c>.</param>
        <param name="predicate">Funkcja, która ma zostać obliczone dla wartości liczb całkowitych w określonym zakresie.</param>
        <summary>Określa, czy określony test jest wartość true dla dowolnej liczby całkowitej zakresu liczb całkowitych.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="predicate" /> zwraca <see langword="true" /> dla dowolnej liczby całkowite począwszy od <paramref name="fromInclusive" /> do <paramref name="toExclusive" /> - 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `toExclusive` Parametr jest jednym więcej niż ostatni liczby całkowitej w celu ułatwienia przy użyciu długości zakresu liczb całkowitych, zaczynając od 0. Na przykład czy można ustawić na wartość 5 liczb całkowitych od 0 do 4.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="predicate" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="toExclusive" /> jest mniejsza niż <paramref name="fromInclusive" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; collection, class System.Predicate`1&lt;!!T&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (collection As IEnumerable(Of T), predicate As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, Predicate&lt;T&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Exists : seq&lt;'T&gt; * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.Exists (collection, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="predicate" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ, który jest zawarty w <c>kolekcji</c>.</typeparam>
        <param name="collection">Do kolekcji elementów typu <c>T</c> będzie rysowany do przekazania do <c>predykatu</c>.</param>
        <param name="predicate">Funkcja, która ma zostać obliczone dla elementu w <c>kolekcji</c>.</param>
        <summary>Określa, czy element w kolekcji elementów istnieje w funkcji.</summary>
        <returns>
          <see langword="true" /> tylko wtedy, gdy <paramref name="predicate" /> zwraca <see langword="true" /> dla każdego elementu typu <paramref name="T" /> w <paramref name="collection" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      </Docs>
    </Member>
    <Member MemberName="ForAll">
      <MemberSignature Language="C#" Value="public static bool ForAll (int fromInclusive, int toExclusive, Predicate&lt;int&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ForAll(int32 fromInclusive, int32 toExclusive, class System.Predicate`1&lt;int32&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForAll (fromInclusive As Integer, toExclusive As Integer, predicate As Predicate(Of Integer)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ForAll(int fromInclusive, int toExclusive, Predicate&lt;int&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member ForAll : int * int * Predicate&lt;int&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.ForAll (fromInclusive, toExclusive, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="predicate" Type="System.Predicate&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Pierwszej liczby całkowitej do przekazania do <c>predykatu</c>.</param>
        <param name="toExclusive">Co więcej niż ostatni liczby całkowitej w celu przekazania do <c>predykatu</c>.</param>
        <param name="predicate">Funkcja do oceny istnienie liczb całkowitych w określonym zakresie.</param>
        <summary>Określa, czy określony warunek jest nieprawidłowy dla wszystkich liczb całkowitych w określonym zakresie.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="predicate" /> zwraca <see langword="true" /> dla wszystkich liczby całkowite począwszy od <paramref name="fromInclusive" /> do <paramref name="toExclusive" /> - 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `toExclusive` Parametr jest jednym więcej niż ostatni liczby całkowitej w celu ułatwienia przy użyciu długości zakresu liczb całkowitych, zaczynając od 0. Na przykład czy można ustawić na wartość 5 liczb całkowitych od 0 do 4.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> metodę, aby określić, czy tablica zawiera element o wartości null.  
  
 [!code-csharp[Contract.ForAllExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/contract.forallexample/cs/program.cs#1)]
 [!code-vb[Contract.ForAllExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/contract.forallexample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="predicate" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="toExclusive" /> jest mniejsza niż <paramref name="fromInclusive" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      </Docs>
    </Member>
    <Member MemberName="ForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool ForAll&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ForAll&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; collection, class System.Predicate`1&lt;!!T&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForAll(Of T) (collection As IEnumerable(Of T), predicate As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool ForAll(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, Predicate&lt;T&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member ForAll : seq&lt;'T&gt; * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.ForAll (collection, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="predicate" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ, który jest zawarty w <c>kolekcji</c>.</typeparam>
        <param name="collection">Do kolekcji elementów typu <c>T</c> będzie rysowany do przekazania do <c>predykatu</c>.</param>
        <param name="predicate">Funkcja do oceny istnienie wszystkie elementy w <c>kolekcji</c>.</param>
        <summary>Określa, czy wszystkie elementy w kolekcji istnieje w funkcji.</summary>
        <returns>
          <see langword="true" /> tylko wtedy, gdy <paramref name="predicate" /> zwraca <see langword="true" /> dla wszystkich elementów tego typu <paramref name="T" /> w <paramref name="collection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> metodę, aby określić, czy kolekcja zawiera element o wartości null.  
  
 [!code-csharp[Contract.ForAllExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/contract.forallexample/cs/program.cs#1)]
 [!code-vb[Contract.ForAllExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/contract.forallexample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> lub <paramref name="predicate" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invariant">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa kontrakt dla otaczającego metody lub właściwości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invariant">
      <MemberSignature Language="C#" Value="public static void Invariant (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invariant(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invariant (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invariant(bool condition);" />
      <MemberSignature Language="F#" Value="static member Invariant : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Invariant condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">Wyrażenie warunkowe do testowania.</param>
        <summary>Określa niezmienną kontraktu dla otaczającego metody lub właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Contracts.Contract.Invariant%2A> Kontrakty są zawarte w metodę, która jest określana przez <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> atrybutu; zazwyczaj nosi nazwę metody `ObjectInvariant`.  
  
-   Ten kontrakt można określić tylko w dedykowanym niezmiennej metodę, która jest zadeklarowana w klasie. Jeśli metoda nie jest zapieczętowany, tak aby podklasy mogą Pamiętaj zachować invariants powinni zapoznać tylko do chronionych elementów członkowskich nie prywatne elementy członkowskie.  
  
-   Niniejsza Umowa nie jest widoczne dla klientów; w związku z tym go może odwoływać się elementy członkowskie, które są widoczne mniej niż metoda otaczającej.  
  
-   Należy użyć binarne funkcji ponownego zapisu tym niezmiennej wykonania czasu wykonywania.  
  
-   Warunkowo invariants są zdefiniowane w zależności od obecności `CONTRACTS FULL` symbolu. Podczas sprawdzania czasu wykonywania, invariants są sprawdzane na końcu każdej metody publicznej. Jeśli niezmiennej nazwa publiczną metodę w tej samej klasie, niezmiennej Sprawdź, czy czy zwykle odbywa się na końcu metody publicznej jest wyłączona, zaznaczone tylko na końcu wywołania metody zewnętrznych do tej klasy. Dzieje się również, jeśli klasa jest wprowadzono ponownie z powodu wywołanie do metody w klasie innej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invariant">
      <MemberSignature Language="C#" Value="public static void Invariant (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invariant(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invariant (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invariant(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Invariant : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Invariant (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">Wyrażenie warunkowe do testowania.</param>
        <param name="userMessage">Komunikat wyświetlany, jeśli wynikiem warunku jest <see langword="false" />.</param>
        <summary>Określa niezmienną kontraktu dla otaczającego metody lub właściwości, a następnie wyświetla komunikat, jeśli warunek dla kontraktu nie powiedzie się.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Contracts.Contract.Invariant%2A> Kontrakty są zawarte w metodę, która jest określana przez <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> atrybutu; zazwyczaj nosi nazwę metody `ObjectInvariant`.  
  
-   Ten kontrakt można określić tylko w dedykowanym niezmiennej metodę, która jest zadeklarowana w klasie.  
  
-   Niniejsza Umowa nie jest widoczne dla klientów; w związku z tym go może odwoływać się elementy członkowskie, które są widoczne mniej niż metoda otaczającej.  
  
-   Należy użyć binarne funkcji ponownego zapisu tym niezmiennej wykonania czasu wykonywania.  
  
-   Invariants warunkowo są zdefiniowane w `CONTRACTS FULL` symbolu. Podczas sprawdzania czasu wykonywania, invariants są sprawdzane na końcu każdej metody publicznej. Jeśli niezmiennej nazwa publiczną metodę w tej samej klasie, niezmiennej Sprawdź, czy czy zwykle odbywa się na końcu metody publicznej jest wyłączona, zaznaczone tylko na końcu wywołania metody zewnętrznych do tej klasy. Dzieje się również, jeśli klasa jest wprowadzono ponownie z powodu wywołanie do metody w klasie innej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OldValue&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T OldValue&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T OldValue&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OldValue(Of T) (value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T OldValue(T value);" />
      <MemberSignature Language="F#" Value="static member OldValue : 'T -&gt; 'T" Usage="System.Diagnostics.Contracts.Contract.OldValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ wartości.</typeparam>
        <param name="value">Wartość do reprezentowania (pola lub parametru).</param>
        <summary>Reprezentuje wartości, jakie były na początku metody lub właściwości.</summary>
        <returns>Wartość parametru lub pola na początku metody lub właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody można użyć tylko w wyrażeniu warunkowym dla <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> kontraktu.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono użycie <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> metodę, aby upewnić się czy liczba został zaktualizowany. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Diagnostics.Contracts.ContractClassAttribute> klasy.  
  
 [!code-csharp[ContractExample#5](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#5)]
 [!code-vb[ContractExample#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Requires">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa kontrakt warunek wstępny dla otaczającego metody lub właściwości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Requires">
      <MemberSignature Language="C#" Value="public static void Requires (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Requires(bool condition);" />
      <MemberSignature Language="F#" Value="static member Requires : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Requires condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">Wyrażenie warunkowe do testowania.</param>
        <summary>Określa kontrakt warunek wstępny dla otaczającego metody lub właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   Wywołanie tej metody należy na początku metody lub właściwości przed innymi kodu.  
  
-   Niniejsza Umowa jest widoczne dla klientów; w związku z tym musi tylko odwołanie do elementów członkowskich, które są co najmniej jako widoczna jako metody otaczającej.  
  
-   Użyj tej metody zamiast <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%29?displayProperty=nameWithType> metodą podczas zgodności z poprzednimi wersjami nie wymusza throw określonego wyjątku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires">
      <MemberSignature Language="C#" Value="public static void Requires (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Requires(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Requires : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Requires (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">Wyrażenie warunkowe do testowania.</param>
        <param name="userMessage">Komunikat wyświetlany, jeśli wynikiem warunku jest <see langword="false" />.</param>
        <summary>Określa kontrakt warunek wstępny dla otaczającego metody lub właściwości, a następnie wyświetla komunikat, jeśli warunek dla kontraktu nie powiedzie się.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   Wywołanie tej metody należy na początku metody lub właściwości przed innymi kodu.  
  
-   Niniejsza Umowa jest widoczne dla klientów; w związku z tym musi tylko odwołanie do elementów członkowskich, które są co najmniej jako widoczna jako metody otaczającej.  
  
-   Użyj tej metody zamiast <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> metodą podczas zgodności z poprzednimi wersjami nie wymusza throw określonego wyjątku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void Requires&lt;TException&gt; (bool condition) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires&lt;(class System.Exception) TException&gt;(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires(Of TException As Exception) (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void Requires(bool condition);" />
      <MemberSignature Language="F#" Value="static member Requires : bool -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.Requires condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TException">Wyjątek do zgłoszenia, jeśli wynikiem warunku jest <see langword="false" />.</typeparam>
        <param name="condition">Wyrażenie warunkowe do testowania.</param>
        <summary>Określa kontrakt warunek wstępny dla otaczającego metody lub właściwości i zgłasza wyjątek, jeśli warunek dla kontraktu nie powiedzie się.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Należy włączyć czasu wykonywania sprawdzania <xref:System.Diagnostics.Contracts.Contract.Requires%2A> metody. Jeśli sprawdzanie czasu wykonywania jest wyłączone, proces zostanie zakończony. Aby uzyskać narzędzia do sprawdzania środowiska uruchomieniowego, zobacz [kontraktów kodu](http://go.microsoft.com/fwlink/?LinkId=152461) w witrynie MSDN DevLabs.  
  
-   Wywołanie tej metody należy na początku metody lub właściwości przed innymi kodu.  
  
-   Niniejsza Umowa jest widoczne dla klientów; w związku z tym musi tylko odwołanie do elementów członkowskich, które są co najmniej jako widoczna jako metody otaczającej.  
  
-   Użyj tej metody zamiast <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%29?displayProperty=nameWithType> metody, jeśli chcesz zgłosić wyjątek, jeśli warunki wstępne nie powiedzie się.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void Requires&lt;TException&gt; (bool condition, string userMessage) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires&lt;(class System.Exception) TException&gt;(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires(Of TException As Exception) (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void Requires(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Requires : bool * string -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.Requires (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TException">Wyjątek do zgłoszenia, jeśli wynikiem warunku jest <see langword="false" />.</typeparam>
        <param name="condition">Wyrażenie warunkowe do testowania.</param>
        <param name="userMessage">Komunikat wyświetlany, jeśli wynikiem warunku jest <see langword="false" />.</param>
        <summary>Określa kontrakt warunek wstępny dla otaczającego metody lub właściwości i zgłasza wyjątek z komunikatem podany, jeśli warunek dla kontraktu nie powiedzie się.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   > [!IMPORTANT]
    >  Należy włączyć czasu wykonywania sprawdzania <xref:System.Diagnostics.Contracts.Contract.Requires%2A> metody. Jeśli sprawdzanie czasu wykonywania jest wyłączone, proces zostanie zakończony. Aby uzyskać narzędzia do sprawdzania środowiska uruchomieniowego, zobacz [kontraktów kodu](http://go.microsoft.com/fwlink/?LinkId=152461) w witrynie MSDN DevLabs.  
  
     Wywołanie tej metody należy na początku metody lub właściwości przed innymi kodu.  
  
-   Niniejsza Umowa jest widoczne dla klientów; w związku z tym musi tylko odwołanie do elementów członkowskich, które są co najmniej jako widoczna jako metody otaczającej.  
  
-   Użyj tej metody zamiast <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> metody, jeśli chcesz zgłosić wyjątek, jeśli warunki wstępne nie powiedzie się.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Result&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Result&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Result&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Result``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Result(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Result();" />
      <MemberSignature Language="F#" Value="static member Result : unit -&gt; 'T" Usage="System.Diagnostics.Contracts.Contract.Result " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Typ zwracanej wartości otaczającego metody lub właściwości.</typeparam>
        <summary>Reprezentuje wartość zwracana metody lub właściwości.</summary>
        <returns>Wartość zwracana otaczającego metody lub właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody można użyć tylko w wyrażeniu warunkowym dla <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> kontraktu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Diagnostics.Contracts.Contract.Result%2A> metodę, aby określić oczekiwanej wartości zwracanej. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Diagnostics.Contracts.ContractClassAttribute> klasy.  
  
 [!code-csharp[ContractExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#3)]
 [!code-vb[ContractExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueAtReturn&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T ValueAtReturn&lt;T&gt; (out T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T ValueAtReturn&lt;T&gt;([out] !!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ValueAtReturn(Of T) (ByRef value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T ValueAtReturn([Runtime::InteropServices::Out] T % value);" />
      <MemberSignature Language="F#" Value="static member ValueAtReturn :  -&gt; 'T" Usage="System.Diagnostics.Contracts.Contract.ValueAtReturn value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ <see langword="out" /> parametru.</typeparam>
        <param name="value">
          <see langword="out" /> Parametru.</param>
        <summary>Reprezentuje wartość końcowa (dane wyjściowe) <see langword="out" /> parametru, gdy zwracany z metody.</summary>
        <returns>Wartość danych wyjściowych <see langword="out" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody można użyć tylko w wyrażeniu warunkowym dla <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> kontraktu. Jak <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> metody, można pominąć parametr typu ogólnego zawsze, gdy kompilator jest w stanie wywnioskować jej typu. Kontrakt funkcji ponownego zapisu zastępuje wywołanie metody wartość `out` parametru. <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> Metody może występować tylko w postconditions. Argument do metody musi być `out` pola struktury lub parametr `out` parametru. Drugie polecenie jest również przydatne podczas odwoływania się do pól w warunku końcowego konstruktora struktury.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
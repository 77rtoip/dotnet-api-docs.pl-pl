<Type Name="Contract" FullName="System.Diagnostics.Contracts.Contract">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2f21917a6853fe4b567375e9f2268571d3f1e053" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36677087" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Contract" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Contract extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Contracts.Contract" />
  <TypeSignature Language="VB.NET" Value="Public Class Contract" />
  <TypeSignature Language="C++ CLI" Value="public ref class Contract abstract sealed" />
  <TypeSignature Language="F#" Value="type Contract = class" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="c673e-101">Zawiera metody statyczne reprezentujący program kontrakty, takie jak warunki wstępne, postconditions i invariants obiektu.</span>
      <span class="sxs-lookup">
        <span data-stu-id="c673e-101">Contains static methods for representing program contracts such as preconditions, postconditions, and object invariants.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c673e-102">Klasy kontraktu kodu pozwalają określić warunki wstępne, postconditions i invariants obiektu w kodzie.</span><span class="sxs-lookup"><span data-stu-id="c673e-102">Code contract classes let you specify preconditions, postconditions, and object invariants in your code.</span></span> <span data-ttu-id="c673e-103">Warunki wstępne są wymagania, które muszą zostać spełnione, wprowadzając metody lub właściwości.</span><span class="sxs-lookup"><span data-stu-id="c673e-103">Preconditions are requirements that must be met when entering a method or property.</span></span> <span data-ttu-id="c673e-104">Postconditions opisano oczekiwań w czasie, który zamyka kodu metody lub właściwości.</span><span class="sxs-lookup"><span data-stu-id="c673e-104">Postconditions describe expectations at the time the method or property code exits.</span></span> <span data-ttu-id="c673e-105">Obiekt invariants opisano oczekiwanym stanem dla klasy, która nie ma warunku problemów.</span><span class="sxs-lookup"><span data-stu-id="c673e-105">Object invariants describe the expected state for a class that has no condition problems.</span></span> <span data-ttu-id="c673e-106">Aby uzyskać więcej informacji o warunkach wstępnych, postconditions i invariants obiektu, zobacz [kontraktów kodu](~/docs/framework/debug-trace-profile/code-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="c673e-106">For more information about preconditions, postconditions, and object invariants, see [Code Contracts](~/docs/framework/debug-trace-profile/code-contracts.md).</span></span>  
  
 <span data-ttu-id="c673e-107">Narzędzia i szczegółowe instrukcje dotyczące używania kontraktów kodu, zobacz [kontraktów kodu](http://go.microsoft.com/fwlink/?LinkId=152461) w witrynie MSDN DevLabs.</span><span class="sxs-lookup"><span data-stu-id="c673e-107">For tools and detailed instructions for using code contracts, see [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c673e-108">Należy użyć binarne funkcji ponownego zapisu do wstawienia środowiska wykonawczego egzekwowania umów.</span><span class="sxs-lookup"><span data-stu-id="c673e-108">You must use a binary rewriter to insert run-time enforcement of contracts.</span></span> <span data-ttu-id="c673e-109">W przeciwnym razie umów takich jak <xref:System.Diagnostics.Contracts.Contract.Ensures%2A?displayProperty=nameWithType> metody tylko można przetestować statycznie i nie zgłosi wyjątków w czasie wykonywania w przypadku naruszenia Umowy.</span><span class="sxs-lookup"><span data-stu-id="c673e-109">Otherwise, contracts such as the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A?displayProperty=nameWithType> method can only be tested statically and will not throw exceptions during run time if a contract is violated.</span></span> <span data-ttu-id="c673e-110">Binarny funkcji ponownego zapisu CCRewrite można pobrać z [kontraktów kodu](http://go.microsoft.com/fwlink/?LinkId=152461) w witrynie MSDN DevLabs.</span><span class="sxs-lookup"><span data-stu-id="c673e-110">You can download the binary rewriter CCRewrite from [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span> <span data-ttu-id="c673e-111">CCRewrite pochodzi z dodatek Visual Studio, który umożliwia aktywowanie wymuszania kontraktu czasu wykonywania w projekcie **właściwości** strony.</span><span class="sxs-lookup"><span data-stu-id="c673e-111">CCRewrite comes with a Visual Studio add-in that enables you to activate run-time contract enforcement from the project **Properties** page.</span></span> <span data-ttu-id="c673e-112">Binarny funkcji ponownego zapisu i dodatek Visual Studio nie są dostarczane z [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] lub zestawu Windows SDK.</span><span class="sxs-lookup"><span data-stu-id="c673e-112">The binary rewriter and the Visual Studio add-in do not ship with [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] or the Windows SDK.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Assert">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="c673e-113">W kompilacjach do debugowania wykonuje test czasu wykonywania dla określonego warunku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-113">In debug builds, performs a run-time test for a specified condition.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition);" />
      <MemberSignature Language="F#" Value="static member Assert : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assert condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="c673e-114">Wyrażenie warunkowe do testowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-114">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c673e-115">Sprawdza, czy warunek; Jeśli warunek nie jest <see langword="false" />, następuje zasady eskalacji dla analizatora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-115">Checks for a condition; if the condition is <see langword="false" />, follows the escalation policy set for the analyzer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c673e-116">Domyślne zasady eskalacji to Powiadom dołączony debuger o niepowodzeniu kontraktu lub wyświetlić **Assert** okno dialogowe, jeśli nie jest dołączony debuger.</span><span class="sxs-lookup"><span data-stu-id="c673e-116">The default escalation policy is to notify the attached debugger about a contract failure or to display an **Assert** dialog box if a debugger is not attached.</span></span> <span data-ttu-id="c673e-117">Opcjonalnie analizatora należy poinstruować, aby zgłosić wyjątek.</span><span class="sxs-lookup"><span data-stu-id="c673e-117">Optionally, the analyzer can be instructed to throw an exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Assert : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assert (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="c673e-118">Wyrażenie warunkowe do testowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-118">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="c673e-119">Komunikat do wyświetlenia, jeśli nie jest spełniony warunek.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-119">A message to display if the condition is not met.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c673e-120">Sprawdza, czy warunek; Jeśli warunek nie jest <see langword="false" />, następuje zasady eskalacji ustawione przez analizatora i wyświetla określony komunikat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-120">Checks for a condition; if the condition is <see langword="false" />, follows the escalation policy set by the analyzer and displays the specified message.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c673e-121">Domyślne zasady eskalacji to Powiadom dołączony debuger o niepowodzeniu kontraktu lub wyświetlić **Assert** okno dialogowe, jeśli nie jest dołączony debuger.</span><span class="sxs-lookup"><span data-stu-id="c673e-121">The default escalation policy is to notify the attached debugger about a contract failure or to display an **Assert** dialog box if a debugger is not attached.</span></span> <span data-ttu-id="c673e-122">Opcjonalnie analizatora należy poinstruować, aby zgłosić wyjątek.</span><span class="sxs-lookup"><span data-stu-id="c673e-122">Optionally, the analyzer can be instructed to throw an exception.</span></span> <span data-ttu-id="c673e-123">`userMessage` Parametr jest przekazywany do danych wyjściowych debugera.</span><span class="sxs-lookup"><span data-stu-id="c673e-123">The `userMessage` parameter is passed to the debugger output.</span></span> <span data-ttu-id="c673e-124">Jeśli `userMessage` nie jest ciągiem stałym literału, narzędzia nie można go odczytać.</span><span class="sxs-lookup"><span data-stu-id="c673e-124">If `userMessage` is not a constant string literal, tools may not be able to read it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Assume">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="c673e-125">Powoduje, że narzędzi analizy kodu do wniosku, że warunek jest <see langword="true" />, nawet jeśli nie statycznie sprawdzone zawsze być <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-125">Instructs code analysis tools to assume that a condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assume">
      <MemberSignature Language="C#" Value="public static void Assume (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assume(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assume (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assume(bool condition);" />
      <MemberSignature Language="F#" Value="static member Assume : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assume condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="c673e-126">Wyrażenie warunkowe do wniosku <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-126">The conditional expression to assume <see langword="true" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c673e-127">Powoduje, że narzędzi analizy kodu do wniosku, że jest określony warunek <see langword="true" />, nawet jeśli nie statycznie sprawdzone zawsze być <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-127">Instructs code analysis tools to assume that the specified condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c673e-128">W czasie wykonywania, za pomocą tej metody jest odpowiednikiem przy użyciu <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%29> metody.</span><span class="sxs-lookup"><span data-stu-id="c673e-128">At run time, using this method is equivalent to using the <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%29> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assume">
      <MemberSignature Language="C#" Value="public static void Assume (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assume(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assume (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assume(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Assume : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assume (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="c673e-129">Wyrażenie warunkowe do wniosku <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-129">The conditional expression to assume <see langword="true" />.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="c673e-130">Komunikat do opublikowania Jeśli założeniu nie powiedzie się.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-130">The message to post if the assumption fails.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c673e-131">Nakazuje narzędzi analizy kodu do wniosku, że warunek jest <see langword="true" />, nawet jeśli nie statycznie sprawdzone zawsze być <see langword="true" />i wyświetla komunikat, jeśli założeniu nie powiedzie się.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-131">Instructs code analysis tools to assume that a condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />, and displays a message if the assumption fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c673e-132">Jeśli `userMessage` nie jest ciągiem stałym literału, kontrakt nie może być rozpoznawany przez narzędzia.</span><span class="sxs-lookup"><span data-stu-id="c673e-132">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 <span data-ttu-id="c673e-133">W czasie wykonywania, za pomocą tej metody jest odpowiednikiem przy użyciu <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%2CSystem.String%29> metody.</span><span class="sxs-lookup"><span data-stu-id="c673e-133">At run time, using this method is equivalent to using the <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%2CSystem.String%29> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContractFailed">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt; ContractFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Diagnostics.Contracts.ContractFailedEventArgs&gt; ContractFailed" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Contracts.Contract.ContractFailed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ContractFailed As EventHandler(Of ContractFailedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Diagnostics::Contracts::ContractFailedEventArgs ^&gt; ^ ContractFailed;" />
      <MemberSignature Language="F#" Value="member this.ContractFailed : EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt; " Usage="member this.ContractFailed : System.EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c673e-134">Występuje, gdy kontrakt nie powiedzie się.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-134">Occurs when a contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c673e-135">Informacje dotyczące zdarzenia dla tego zdarzenia jest dostarczana przez <xref:System.Diagnostics.Contracts.ContractFailedEventArgs?displayProperty=nameWithType> obiekt, który zostanie przekazany do obsługi zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="c673e-135">The event information for this event is supplied by the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs?displayProperty=nameWithType> object that is passed to the event handler.</span></span> <span data-ttu-id="c673e-136">To zdarzenie powiadamia środowisku zarządzanej aplikacji, takich jak interakcyjne interpreter lub hosta przeglądarki sieci Web, który kontrakt nie powiodło się.</span><span class="sxs-lookup"><span data-stu-id="c673e-136">This event notifies a managed application environment such as an interactive interpreter or a Web browser host that a contract has failed.</span></span> <span data-ttu-id="c673e-137">Przed dokonaniem, zgłosi zdarzenie, które może obsłużyć aplikacja, jak za stosowny.</span><span class="sxs-lookup"><span data-stu-id="c673e-137">Before doing so, it will raise an event that an application can handle as it sees fit.</span></span> <span data-ttu-id="c673e-138">Na przykład jeśli kod jest uruchamiana w ramach testowania, możesz zalogować niepowodzenia testu i następnie zakończyć test.</span><span class="sxs-lookup"><span data-stu-id="c673e-138">For example, if code is being run in a testing framework, you can log a test failure and then end the test.</span></span>  
  
 <span data-ttu-id="c673e-139">Domyślna implementacja <xref:System.Diagnostics.Contracts.Internal.ContractHelper.RaiseContractFailedEvent%2A> metody w bibliotece klas programu .NET Framework jest wywołanie każdy program obsługi, która jest zarejestrowana <xref:System.Diagnostics.Contracts.Contract.ContractFailed> zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="c673e-139">The default implementation of the <xref:System.Diagnostics.Contracts.Internal.ContractHelper.RaiseContractFailedEvent%2A> method in the .NET Framework class library is to call each handler that is registered with the <xref:System.Diagnostics.Contracts.Contract.ContractFailed> event.</span></span> <span data-ttu-id="c673e-140">Wyjątki generowane przez programy obsługi są ignorowane, ale każdy program obsługi może wskazać, czy błąd jest obsługiwana przez wywołanie metody <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled%2A> metody dla argumentów zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="c673e-140">Exceptions thrown by handlers are ignored, but each handler can indicate whether the failure is handled by calling the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled%2A> method for the event arguments.</span></span> <span data-ttu-id="c673e-141">Jeśli wszystkie obsługi ustawia niepowodzenia obsługi, metoda zwraca `null` i są wykonywane nie dalsze działania.</span><span class="sxs-lookup"><span data-stu-id="c673e-141">If any handler sets the failure as handled, the method returns `null` and no further action is taken.</span></span> <span data-ttu-id="c673e-142">Alternatywnie można wywołać procedury obsługi <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind%2A> metody nakazać kod operacji unwind.</span><span class="sxs-lookup"><span data-stu-id="c673e-142">Alternatively, handlers can call the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind%2A> method to instruct the code to unwind.</span></span> <span data-ttu-id="c673e-143">W takim przypadku jest zwracany wyjątek, po wykonaniu wszystkich programów obsługi.</span><span class="sxs-lookup"><span data-stu-id="c673e-143">In that case, an exception is thrown after all handlers have executed.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="c673e-144">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-144">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="c673e-145">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-145">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="EndContractBlock">
      <MemberSignature Language="C#" Value="public static void EndContractBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndContractBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EndContractBlock" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndContractBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndContractBlock();" />
      <MemberSignature Language="F#" Value="static member EndContractBlock : unit -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.EndContractBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="c673e-146">Oznacza koniec sekcji kontraktu, gdy metoda kontraktów zawiera tylko warunki wstępne w <see langword="if" /> - <see langword="then" /> - <see langword="throw" /> formularza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-146">Marks the end of the contract section when a method's contracts contain only preconditions in the <see langword="if" />-<see langword="then" />-<see langword="throw" /> form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c673e-147">Większość kodu zawiera już niektóre sprawdzanie poprawności parametru w postaci `if` - `then` - `throw` kodu.</span><span class="sxs-lookup"><span data-stu-id="c673e-147">Most code already contains some parameter validation in the form of `if`-`then`-`throw` code.</span></span> <span data-ttu-id="c673e-148">Rozpoznaje narzędzia kontraktu `if` - `then` - `throw` instrukcje jako warunki wstępne, gdy instrukcje występować jako pierwszy wewnątrz metody, a cały zestaw takich instrukcji następuje jawne<xref:System.Diagnostics.Contracts.Contract> wywołanie metody, takie jak <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, lub <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>.</span><span class="sxs-lookup"><span data-stu-id="c673e-148">The contract tools recognize `if`-`then`-`throw` statements as preconditions when the statements appear first inside a method, and the entire set of such statements is followed by an explicit <xref:System.Diagnostics.Contracts.Contract> method call, such as a <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, or <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>.</span></span>  
  
 <span data-ttu-id="c673e-149">Gdy `if` - `then` - `throw` instrukcje pojawiają się w tym formularzu narzędzia kontraktu rozpoznaje je jako starszych-wymagają instrukcje.</span><span class="sxs-lookup"><span data-stu-id="c673e-149">When `if`-`then`-`throw` statements appear in this form, the contract tools recognize them as legacy-require statements.</span></span> <span data-ttu-id="c673e-150"><xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> Formularz jest używany tylko wtedy, gdy nie ma innych umów wykonaj `if` - `then` - `throw` sekwencji, ale nadal powinien oznaczone jako starszych-wymaga.</span><span class="sxs-lookup"><span data-stu-id="c673e-150">The <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> form is used only if no other contracts follow the `if`-`then`-`throw` sequences, but they should still be tagged as legacy-requires.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ensures">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="c673e-151">Określa kontrakt postcondition otaczającego metody lub właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-151">Specifies a postcondition contract for the enclosing method or property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ensures">
      <MemberSignature Language="C#" Value="public static void Ensures (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ensures(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ensures (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Ensures(bool condition);" />
      <MemberSignature Language="F#" Value="static member Ensures : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Ensures condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="c673e-152">Wyrażenie warunkowe do testowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-152">The conditional expression to test.</span>
          </span>
          <span data-ttu-id="c673e-153">Wyrażenie, które mogą obejmować <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />, <see cref="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" />, i <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-153">The expression may include <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />, <see cref="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" />, and <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c673e-154">Określa kontrakt postcondition otaczającego metody lub właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-154">Specifies a postcondition contract for the enclosing method or property.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c673e-155">`condition` Parametr określa warunku końcowego, który ma być `true` po otaczającego metody lub właściwości zwraca normalnie.</span><span class="sxs-lookup"><span data-stu-id="c673e-155">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property returns normally.</span></span>  
  
-   <span data-ttu-id="c673e-156">Wywołanie tej metody należy na początku metody lub właściwości przed innymi kodu.</span><span class="sxs-lookup"><span data-stu-id="c673e-156">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="c673e-157">Należy użyć binarne funkcji ponownego zapisu (dostępne pod adresem [kontraktów kodu](http://go.microsoft.com/fwlink/?LinkId=152461) w witrynie MSDN DevLabs) do środowiska wykonawczego stosowania tego warunku końcowego.</span><span class="sxs-lookup"><span data-stu-id="c673e-157">You must use the binary rewriter (available at [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site) for run-time enforcement of this postcondition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c673e-158">Poniższy przykład przedstawia użycie <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> metody, aby upewnić się, że jest zwracana wartość oczekiwana.</span><span class="sxs-lookup"><span data-stu-id="c673e-158">The following example shows how to use the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> method to ensure that an expected value is returned.</span></span> <span data-ttu-id="c673e-159">Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Diagnostics.Contracts.ContractClassAttribute> klasy.</span><span class="sxs-lookup"><span data-stu-id="c673e-159">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#3)]
 [!code-vb[ContractExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ensures">
      <MemberSignature Language="C#" Value="public static void Ensures (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ensures(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ensures (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Ensures(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Ensures : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Ensures (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="c673e-160">Wyrażenie warunkowe do testowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-160">The conditional expression to test.</span>
          </span>
          <span data-ttu-id="c673e-161">Wyrażenie, które mogą obejmować <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /> i <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-161">The expression may include <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /> and <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> values.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="c673e-162">Komunikat wyświetlany, jeśli wyrażenie nie jest <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-162">The message to display if the expression is not <see langword="true" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c673e-163">Określa kontrakt postcondition warunku exit podana i komunikat do wyświetlenia, jeśli wynikiem warunku jest <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-163">Specifies a postcondition contract for a provided exit condition and a message to display if the condition is <see langword="false" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c673e-164">`condition` Parametr określa warunku końcowego, który ma być `true` po otaczającego metody lub właściwości zwraca normalnie.</span><span class="sxs-lookup"><span data-stu-id="c673e-164">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property returns normally.</span></span>  
  
-   <span data-ttu-id="c673e-165">Wywołanie tej metody należy na początku metody lub właściwości przed innymi kodu.</span><span class="sxs-lookup"><span data-stu-id="c673e-165">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="c673e-166">Niniejsza Umowa jest widoczne dla klientów; w związku z tym musi tylko odwołanie do elementów członkowskich, które są co najmniej jako widoczna jako metody otaczającej.</span><span class="sxs-lookup"><span data-stu-id="c673e-166">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="c673e-167">Należy użyć binarne funkcji ponownego zapisu (dostępne pod adresem [kontraktów kodu](http://go.microsoft.com/fwlink/?LinkId=152461) w witrynie MSDN DevLabs) do środowiska wykonawczego stosowania tego warunku końcowego.</span><span class="sxs-lookup"><span data-stu-id="c673e-167">You must use the binary rewriter (available at [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site) for run-time enforcement of this postcondition.</span></span>  
  
-   <span data-ttu-id="c673e-168">Jeśli `userMessage` nie jest ciągiem stałym literału, kontrakt nie może być rozpoznawany przez narzędzia.</span><span class="sxs-lookup"><span data-stu-id="c673e-168">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnsuresOnThrow&lt;TException&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="c673e-169">Określa kontrakt postcondition dla otaczającego metody lub właściwości na podstawie podanych wyjątku i warunku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-169">Specifies a postcondition contract for the enclosing method or property based on the provided exception and condition.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnsuresOnThrow&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void EnsuresOnThrow&lt;TException&gt; (bool condition) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsuresOnThrow&lt;(class System.Exception) TException&gt;(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsuresOnThrow(Of TException As Exception) (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void EnsuresOnThrow(bool condition);" />
      <MemberSignature Language="F#" Value="static member EnsuresOnThrow : bool -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.EnsuresOnThrow condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TException">
          <span data-ttu-id="c673e-170">Typ wyjątku, który wywołuje postcondition wyboru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-170">The type of exception that invokes the postcondition check.</span>
          </span>
        </typeparam>
        <param name="condition">
          <span data-ttu-id="c673e-171">Wyrażenie warunkowe do testowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-171">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c673e-172">Określa kontrakt postcondition dla otaczającego metody lub właściwości, na podstawie podanych wyjątku i warunek.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-172">Specifies a postcondition contract for the enclosing method or property, based on the provided exception and condition.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c673e-173">`condition` Parametr określa warunku końcowego, który ma być `true` po otaczającego metody lub właściwości nieprawidłowo kończy działanie i wystąpił wyjątek typu `TException` jest generowany.</span><span class="sxs-lookup"><span data-stu-id="c673e-173">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property terminates abnormally and an exception of type `TException` is thrown.</span></span>  
  
-   <span data-ttu-id="c673e-174">Wywołanie tej metody należy na początku metody lub właściwości przed innymi kodu.</span><span class="sxs-lookup"><span data-stu-id="c673e-174">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="c673e-175">Niniejsza Umowa jest widoczne dla klientów; w związku z tym musi tylko odwołanie do elementów członkowskich, które są co najmniej jako widoczna jako metody otaczającej.</span><span class="sxs-lookup"><span data-stu-id="c673e-175">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="c673e-176">Dla środowiska wykonawczego stosowania tego warunku końcowego, należy użyć binarne funkcji ponownego zapisu.</span><span class="sxs-lookup"><span data-stu-id="c673e-176">You must use the binary rewriter for run-time enforcement of this postcondition.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsuresOnThrow&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void EnsuresOnThrow&lt;TException&gt; (bool condition, string userMessage) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsuresOnThrow&lt;(class System.Exception) TException&gt;(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsuresOnThrow(Of TException As Exception) (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void EnsuresOnThrow(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member EnsuresOnThrow : bool * string -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.EnsuresOnThrow (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TException">
          <span data-ttu-id="c673e-177">Typ wyjątku, który wywołuje postcondition wyboru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-177">The type of exception that invokes the postcondition check.</span>
          </span>
        </typeparam>
        <param name="condition">
          <span data-ttu-id="c673e-178">Wyrażenie warunkowe do testowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-178">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="c673e-179">Komunikat wyświetlany, jeśli wyrażenie jest <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-179">The message to display if the expression is <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c673e-180">Określa kontrakt postcondition i komunikat do wyświetlenia, jeśli wynikiem warunku jest <see langword="false" /> otaczającego metody lub właściwości, na podstawie podanych wyjątku i warunek.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-180">Specifies a postcondition contract and a message to display if the condition is <see langword="false" /> for the enclosing method or property, based on the provided exception and condition.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c673e-181">`condition` Parametr określa warunku końcowego, który ma być `true` po otaczającego metody lub właściwości nieprawidłowo kończy działanie i wystąpił wyjątek typu `TException` jest generowany.</span><span class="sxs-lookup"><span data-stu-id="c673e-181">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property terminates abnormally and an exception of type `TException` is thrown.</span></span> <span data-ttu-id="c673e-182">`message` Parametr określa komunikat wyświetlany, jeśli wynikiem warunku jest `false`.</span><span class="sxs-lookup"><span data-stu-id="c673e-182">The `message` parameter specifies a message to display if the condition is `false`.</span></span>  
  
-   <span data-ttu-id="c673e-183">Wywołanie tej metody należy na początku metody lub właściwości przed innymi kodu.</span><span class="sxs-lookup"><span data-stu-id="c673e-183">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="c673e-184">Niniejsza Umowa jest widoczne dla klientów; w związku z tym musi tylko odwołanie do elementów członkowskich, które są co najmniej jako widoczna jako metody otaczającej.</span><span class="sxs-lookup"><span data-stu-id="c673e-184">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="c673e-185">Dla środowiska wykonawczego stosowania tego warunku końcowego, należy użyć binarne funkcji ponownego zapisu.</span><span class="sxs-lookup"><span data-stu-id="c673e-185">You must use the binary rewriter for run-time enforcement of this postcondition.</span></span>  
  
-   <span data-ttu-id="c673e-186">Jeśli `userMessage` nie jest ciągiem stałym literału, kontrakt nie może być rozpoznawany przez narzędzia.</span><span class="sxs-lookup"><span data-stu-id="c673e-186">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (int fromInclusive, int toExclusive, Predicate&lt;int&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(int32 fromInclusive, int32 toExclusive, class System.Predicate`1&lt;int32&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (fromInclusive As Integer, toExclusive As Integer, predicate As Predicate(Of Integer)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(int fromInclusive, int toExclusive, Predicate&lt;int&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Exists : int * int * Predicate&lt;int&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.Exists (fromInclusive, toExclusive, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="predicate" Type="System.Predicate&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">
          <span data-ttu-id="c673e-187">Pierwszej liczby całkowitej do przekazania do <c>predykatu</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-187">The first integer to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="toExclusive">
          <span data-ttu-id="c673e-188">Co więcej niż ostatni liczby całkowitej w celu przekazania do <c>predykatu</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-188">One more than the last integer to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="predicate">
          <span data-ttu-id="c673e-189">Funkcja, która ma zostać obliczone dla wartości liczb całkowitych w określonym zakresie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-189">The function to evaluate for any value of the integer in the specified range.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c673e-190">Określa, czy określony test jest wartość true dla dowolnej liczby całkowitej zakresu liczb całkowitych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-190">Determines whether a specified test is true for any integer within a range of integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c673e-191">
            <see langword="true" /> Jeśli <paramref name="predicate" /> zwraca <see langword="true" /> dla dowolnej liczby całkowite począwszy od <paramref name="fromInclusive" /> do <paramref name="toExclusive" /> - 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-191">
              <see langword="true" /> if <paramref name="predicate" /> returns <see langword="true" /> for any integer starting from <paramref name="fromInclusive" /> to <paramref name="toExclusive" /> - 1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c673e-192">`toExclusive` Parametr jest jednym więcej niż ostatni liczby całkowitej w celu ułatwienia przy użyciu długości zakresu liczb całkowitych, zaczynając od 0.</span><span class="sxs-lookup"><span data-stu-id="c673e-192">The `toExclusive` parameter is one more than the last integer to facilitate using the length of a range of integers starting at 0.</span></span> <span data-ttu-id="c673e-193">Na przykład czy można ustawić na wartość 5 liczb całkowitych od 0 do 4.</span><span class="sxs-lookup"><span data-stu-id="c673e-193">For example, it would be set to 5 for integers 0 through 4.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="c673e-194">
            <paramref name="predicate" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-194">
              <paramref name="predicate" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="c673e-195">
            <paramref name="toExclusive" /> jest mniejsza niż <paramref name="fromInclusive" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-195">
              <paramref name="toExclusive" /> is less than <paramref name="fromInclusive" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; collection, class System.Predicate`1&lt;!!T&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (collection As IEnumerable(Of T), predicate As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, Predicate&lt;T&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Exists : seq&lt;'T&gt; * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.Exists (collection, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="predicate" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="c673e-196">Typ, który jest zawarty w <c>kolekcji</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-196">The type that is contained in <c>collection</c>.</span>
          </span>
        </typeparam>
        <param name="collection">
          <span data-ttu-id="c673e-197">Do kolekcji elementów typu <c>T</c> będzie rysowany do przekazania do <c>predykatu</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-197">The collection from which elements of type <c>T</c> will be drawn to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="predicate">
          <span data-ttu-id="c673e-198">Funkcja, która ma zostać obliczone dla elementu w <c>kolekcji</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-198">The function to evaluate for an element in <c>collection</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c673e-199">Określa, czy element w kolekcji elementów istnieje w funkcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-199">Determines whether an element within a collection of elements exists within a function.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c673e-200">
            <see langword="true" /> tylko wtedy, gdy <paramref name="predicate" /> zwraca <see langword="true" /> dla każdego elementu typu <paramref name="T" /> w <paramref name="collection" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-200">
              <see langword="true" /> if and only if <paramref name="predicate" /> returns <see langword="true" /> for any element of type <paramref name="T" /> in <paramref name="collection" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="c673e-201">
            <paramref name="collection" /> lub <paramref name="predicate" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-201">
              <paramref name="collection" /> or <paramref name="predicate" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      </Docs>
    </Member>
    <Member MemberName="ForAll">
      <MemberSignature Language="C#" Value="public static bool ForAll (int fromInclusive, int toExclusive, Predicate&lt;int&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ForAll(int32 fromInclusive, int32 toExclusive, class System.Predicate`1&lt;int32&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForAll (fromInclusive As Integer, toExclusive As Integer, predicate As Predicate(Of Integer)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ForAll(int fromInclusive, int toExclusive, Predicate&lt;int&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member ForAll : int * int * Predicate&lt;int&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.ForAll (fromInclusive, toExclusive, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="predicate" Type="System.Predicate&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">
          <span data-ttu-id="c673e-202">Pierwszej liczby całkowitej do przekazania do <c>predykatu</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-202">The first integer to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="toExclusive">
          <span data-ttu-id="c673e-203">Co więcej niż ostatni liczby całkowitej w celu przekazania do <c>predykatu</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-203">One more than the last integer to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="predicate">
          <span data-ttu-id="c673e-204">Funkcja do oceny istnienie liczb całkowitych w określonym zakresie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-204">The function to evaluate for the existence of the integers in the specified range.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c673e-205">Określa, czy określony warunek jest nieprawidłowy dla wszystkich liczb całkowitych w określonym zakresie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-205">Determines whether a particular condition is valid for all integers in a specified range.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c673e-206">
            <see langword="true" /> Jeśli <paramref name="predicate" /> zwraca <see langword="true" /> dla wszystkich liczby całkowite począwszy od <paramref name="fromInclusive" /> do <paramref name="toExclusive" /> - 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-206">
              <see langword="true" /> if <paramref name="predicate" /> returns <see langword="true" /> for all integers starting from <paramref name="fromInclusive" /> to <paramref name="toExclusive" /> - 1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c673e-207">`toExclusive` Parametr jest jednym więcej niż ostatni liczby całkowitej w celu ułatwienia przy użyciu długości zakresu liczb całkowitych, zaczynając od 0.</span><span class="sxs-lookup"><span data-stu-id="c673e-207">The `toExclusive` parameter is one more than the last integer to facilitate using the length of a range of integers starting at 0.</span></span> <span data-ttu-id="c673e-208">Na przykład czy można ustawić na wartość 5 liczb całkowitych od 0 do 4.</span><span class="sxs-lookup"><span data-stu-id="c673e-208">For example, it would be set to 5 for integers 0 through 4.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c673e-209">W poniższym przykładzie pokazano sposób użycia <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> metodę, aby określić, czy tablica zawiera element o wartości null.</span><span class="sxs-lookup"><span data-stu-id="c673e-209">The following example demonstrates how to use the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> method to determine whether an array has a null element.</span></span>  
  
 [!code-csharp[Contract.ForAllExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/contract.forallexample/cs/program.cs#1)]
 [!code-vb[Contract.ForAllExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/contract.forallexample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="c673e-210">
            <paramref name="predicate" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-210">
              <paramref name="predicate" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="c673e-211">
            <paramref name="toExclusive" /> jest mniejsza niż <paramref name="fromInclusive" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-211">
              <paramref name="toExclusive" /> is less than <paramref name="fromInclusive" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      </Docs>
    </Member>
    <Member MemberName="ForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool ForAll&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ForAll&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; collection, class System.Predicate`1&lt;!!T&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForAll(Of T) (collection As IEnumerable(Of T), predicate As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool ForAll(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, Predicate&lt;T&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member ForAll : seq&lt;'T&gt; * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.ForAll (collection, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="predicate" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="c673e-212">Typ, który jest zawarty w <c>kolekcji</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-212">The type that is contained in <c>collection</c>.</span>
          </span>
        </typeparam>
        <param name="collection">
          <span data-ttu-id="c673e-213">Do kolekcji elementów typu <c>T</c> będzie rysowany do przekazania do <c>predykatu</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-213">The collection from which elements of type <c>T</c> will be drawn to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="predicate">
          <span data-ttu-id="c673e-214">Funkcja do oceny istnienie wszystkie elementy w <c>kolekcji</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-214">The function to evaluate for the existence of all the elements in <c>collection</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c673e-215">Określa, czy wszystkie elementy w kolekcji istnieje w funkcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-215">Determines whether all the elements in a collection exist within a function.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c673e-216">
            <see langword="true" /> tylko wtedy, gdy <paramref name="predicate" /> zwraca <see langword="true" /> dla wszystkich elementów tego typu <paramref name="T" /> w <paramref name="collection" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-216">
              <see langword="true" /> if and only if <paramref name="predicate" /> returns <see langword="true" /> for all elements of type <paramref name="T" /> in <paramref name="collection" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="c673e-217">W poniższym przykładzie pokazano sposób użycia <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> metodę, aby określić, czy kolekcja zawiera element o wartości null.</span><span class="sxs-lookup"><span data-stu-id="c673e-217">The following example demonstrates how to use the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> method to determine whether a collection has a null element.</span></span>  
  
 [!code-csharp[Contract.ForAllExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/contract.forallexample/cs/program.cs#1)]
 [!code-vb[Contract.ForAllExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/contract.forallexample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="c673e-218">
            <paramref name="collection" /> lub <paramref name="predicate" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-218">
              <paramref name="collection" /> or <paramref name="predicate" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invariant">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="c673e-219">Określa kontrakt dla otaczającego metody lub właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-219">Specifies a contract for an enclosing method or property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invariant">
      <MemberSignature Language="C#" Value="public static void Invariant (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invariant(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invariant (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invariant(bool condition);" />
      <MemberSignature Language="F#" Value="static member Invariant : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Invariant condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="c673e-220">Wyrażenie warunkowe do testowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-220">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c673e-221">Określa niezmienną kontraktu dla otaczającego metody lub właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-221">Specifies an invariant contract for the enclosing method or property.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c673e-222"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> Kontrakty są zawarte w metodę, która jest określana przez <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> atrybutu; zazwyczaj nosi nazwę metody `ObjectInvariant`.</span><span class="sxs-lookup"><span data-stu-id="c673e-222"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> contracts are contained within a method that is identified by the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute; typically, the method is named `ObjectInvariant`.</span></span>  
  
-   <span data-ttu-id="c673e-223">Ten kontrakt można określić tylko w dedykowanym niezmiennej metodę, która jest zadeklarowana w klasie.</span><span class="sxs-lookup"><span data-stu-id="c673e-223">This contract can be specified only in a dedicated invariant method that is declared on a class.</span></span> <span data-ttu-id="c673e-224">Jeśli metoda nie jest zapieczętowany, tak aby podklasy mogą Pamiętaj zachować invariants powinni zapoznać tylko do chronionych elementów członkowskich nie prywatne elementy członkowskie.</span><span class="sxs-lookup"><span data-stu-id="c673e-224">If the method is not sealed, it should refer only to protected members, not private members, so that subclasses can be sure to maintain the invariants.</span></span>  
  
-   <span data-ttu-id="c673e-225">Niniejsza Umowa nie jest widoczne dla klientów; w związku z tym go może odwoływać się elementy członkowskie, które są widoczne mniej niż metoda otaczającej.</span><span class="sxs-lookup"><span data-stu-id="c673e-225">This contract is not exposed to clients; therefore, it may reference members that are less visible than the enclosing method.</span></span>  
  
-   <span data-ttu-id="c673e-226">Należy użyć binarne funkcji ponownego zapisu tym niezmiennej wykonania czasu wykonywania.</span><span class="sxs-lookup"><span data-stu-id="c673e-226">You must use the binary rewriter for run-time enforcement of this invariant.</span></span>  
  
-   <span data-ttu-id="c673e-227">Warunkowo invariants są zdefiniowane w zależności od obecności `CONTRACTS FULL` symbolu.</span><span class="sxs-lookup"><span data-stu-id="c673e-227">Invariants are conditionally defined based on the presence of the `CONTRACTS FULL` symbol.</span></span> <span data-ttu-id="c673e-228">Podczas sprawdzania czasu wykonywania, invariants są sprawdzane na końcu każdej metody publicznej.</span><span class="sxs-lookup"><span data-stu-id="c673e-228">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="c673e-229">Jeśli niezmiennej nazwa publiczną metodę w tej samej klasie, niezmiennej Sprawdź, czy czy zwykle odbywa się na końcu metody publicznej jest wyłączona, zaznaczone tylko na końcu wywołania metody zewnętrznych do tej klasy.</span><span class="sxs-lookup"><span data-stu-id="c673e-229">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled and checked only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="c673e-230">Dzieje się również, jeśli klasa jest wprowadzono ponownie z powodu wywołanie do metody w klasie innej.</span><span class="sxs-lookup"><span data-stu-id="c673e-230">This also happens if the class is re-entered because of a call to a method on another class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invariant">
      <MemberSignature Language="C#" Value="public static void Invariant (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invariant(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invariant (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invariant(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Invariant : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Invariant (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="c673e-231">Wyrażenie warunkowe do testowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-231">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="c673e-232">Komunikat wyświetlany, jeśli wynikiem warunku jest <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-232">The message to display if the condition is <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c673e-233">Określa niezmienną kontraktu dla otaczającego metody lub właściwości, a następnie wyświetla komunikat, jeśli warunek dla kontraktu nie powiedzie się.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-233">Specifies an invariant contract for the enclosing method or property, and displays a message if the condition for the contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c673e-234"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> Kontrakty są zawarte w metodę, która jest określana przez <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> atrybutu; zazwyczaj nosi nazwę metody `ObjectInvariant`.</span><span class="sxs-lookup"><span data-stu-id="c673e-234"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> contracts are contained within a method that is identified by the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute; typically, the method is named `ObjectInvariant`.</span></span>  
  
-   <span data-ttu-id="c673e-235">Ten kontrakt można określić tylko w dedykowanym niezmiennej metodę, która jest zadeklarowana w klasie.</span><span class="sxs-lookup"><span data-stu-id="c673e-235">This contract can be specified only in a dedicated invariant method that is declared on a class.</span></span>  
  
-   <span data-ttu-id="c673e-236">Niniejsza Umowa nie jest widoczne dla klientów; w związku z tym go może odwoływać się elementy członkowskie, które są widoczne mniej niż metoda otaczającej.</span><span class="sxs-lookup"><span data-stu-id="c673e-236">This contract is not exposed to clients; therefore, it may reference members that are less visible than the enclosing method.</span></span>  
  
-   <span data-ttu-id="c673e-237">Należy użyć binarne funkcji ponownego zapisu tym niezmiennej wykonania czasu wykonywania.</span><span class="sxs-lookup"><span data-stu-id="c673e-237">You must use the binary rewriter for run-time enforcement of this invariant.</span></span>  
  
-   <span data-ttu-id="c673e-238">Invariants warunkowo są zdefiniowane w `CONTRACTS FULL` symbolu.</span><span class="sxs-lookup"><span data-stu-id="c673e-238">Invariants are conditionally defined on the `CONTRACTS FULL` symbol.</span></span> <span data-ttu-id="c673e-239">Podczas sprawdzania czasu wykonywania, invariants są sprawdzane na końcu każdej metody publicznej.</span><span class="sxs-lookup"><span data-stu-id="c673e-239">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="c673e-240">Jeśli niezmiennej nazwa publiczną metodę w tej samej klasie, niezmiennej Sprawdź, czy czy zwykle odbywa się na końcu metody publicznej jest wyłączona, zaznaczone tylko na końcu wywołania metody zewnętrznych do tej klasy.</span><span class="sxs-lookup"><span data-stu-id="c673e-240">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled and checked only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="c673e-241">Dzieje się również, jeśli klasa jest wprowadzono ponownie z powodu wywołanie do metody w klasie innej.</span><span class="sxs-lookup"><span data-stu-id="c673e-241">This also happens if the class is re-entered because of a call to a method on another class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OldValue&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T OldValue&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T OldValue&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OldValue(Of T) (value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T OldValue(T value);" />
      <MemberSignature Language="F#" Value="static member OldValue : 'T -&gt; 'T" Usage="System.Diagnostics.Contracts.Contract.OldValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="c673e-242">Typ wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-242">The type of value.</span>
          </span>
        </typeparam>
        <param name="value">
          <span data-ttu-id="c673e-243">Wartość do reprezentowania (pola lub parametru).</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-243">The value to represent (field or parameter).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c673e-244">Reprezentuje wartości, jakie były na początku metody lub właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-244">Represents values as they were at the start of a method or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c673e-245">Wartość parametru lub pola na początku metody lub właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-245">The value of the parameter or field at the start of a method or property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c673e-246">Tej metody można użyć tylko w wyrażeniu warunkowym dla <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> kontraktu.</span><span class="sxs-lookup"><span data-stu-id="c673e-246">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c673e-247">W poniższym przykładzie przedstawiono użycie <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> metodę, aby upewnić się czy liczba został zaktualizowany.</span><span class="sxs-lookup"><span data-stu-id="c673e-247">The following example shows the use of the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method to ensure that a count has been updated.</span></span> <span data-ttu-id="c673e-248">Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Diagnostics.Contracts.ContractClassAttribute> klasy.</span><span class="sxs-lookup"><span data-stu-id="c673e-248">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#5](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#5)]
 [!code-vb[ContractExample#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Requires">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="c673e-249">Określa kontrakt warunek wstępny dla otaczającego metody lub właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-249">Specifies a precondition contract for an enclosing method or property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Requires">
      <MemberSignature Language="C#" Value="public static void Requires (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Requires(bool condition);" />
      <MemberSignature Language="F#" Value="static member Requires : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Requires condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="c673e-250">Wyrażenie warunkowe do testowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-250">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c673e-251">Określa kontrakt warunek wstępny dla otaczającego metody lub właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-251">Specifies a precondition contract for the enclosing method or property.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   <span data-ttu-id="c673e-252">Wywołanie tej metody należy na początku metody lub właściwości przed innymi kodu.</span><span class="sxs-lookup"><span data-stu-id="c673e-252">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="c673e-253">Niniejsza Umowa jest widoczne dla klientów; w związku z tym musi tylko odwołanie do elementów członkowskich, które są co najmniej jako widoczna jako metody otaczającej.</span><span class="sxs-lookup"><span data-stu-id="c673e-253">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="c673e-254">Użyj tej metody zamiast <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%29?displayProperty=nameWithType> metodą podczas zgodności z poprzednimi wersjami nie wymusza throw określonego wyjątku.</span><span class="sxs-lookup"><span data-stu-id="c673e-254">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%29?displayProperty=nameWithType> method when backward compatibility does not force you to throw a particular exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires">
      <MemberSignature Language="C#" Value="public static void Requires (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Requires(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Requires : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Requires (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="c673e-255">Wyrażenie warunkowe do testowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-255">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="c673e-256">Komunikat wyświetlany, jeśli wynikiem warunku jest <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-256">The message to display if the condition is <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c673e-257">Określa kontrakt warunek wstępny dla otaczającego metody lub właściwości, a następnie wyświetla komunikat, jeśli warunek dla kontraktu nie powiedzie się.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-257">Specifies a precondition contract for the enclosing method or property, and displays a message if the condition for the contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   <span data-ttu-id="c673e-258">Wywołanie tej metody należy na początku metody lub właściwości przed innymi kodu.</span><span class="sxs-lookup"><span data-stu-id="c673e-258">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="c673e-259">Niniejsza Umowa jest widoczne dla klientów; w związku z tym musi tylko odwołanie do elementów członkowskich, które są co najmniej jako widoczna jako metody otaczającej.</span><span class="sxs-lookup"><span data-stu-id="c673e-259">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="c673e-260">Użyj tej metody zamiast <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> metodą podczas zgodności z poprzednimi wersjami nie wymusza throw określonego wyjątku.</span><span class="sxs-lookup"><span data-stu-id="c673e-260">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> method when backward compatibility does not force you to throw a particular exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void Requires&lt;TException&gt; (bool condition) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires&lt;(class System.Exception) TException&gt;(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires(Of TException As Exception) (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void Requires(bool condition);" />
      <MemberSignature Language="F#" Value="static member Requires : bool -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.Requires condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TException">
          <span data-ttu-id="c673e-261">Wyjątek do zgłoszenia, jeśli wynikiem warunku jest <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-261">The exception to throw if the condition is <see langword="false" />.</span>
          </span>
        </typeparam>
        <param name="condition">
          <span data-ttu-id="c673e-262">Wyrażenie warunkowe do testowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-262">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c673e-263">Określa kontrakt warunek wstępny dla otaczającego metody lub właściwości i zgłasza wyjątek, jeśli warunek dla kontraktu nie powiedzie się.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-263">Specifies a precondition contract for the enclosing method or property, and throws an exception if the condition for the contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="c673e-264">Należy włączyć czasu wykonywania sprawdzania <xref:System.Diagnostics.Contracts.Contract.Requires%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="c673e-264">You must turn on run-time checking to use the <xref:System.Diagnostics.Contracts.Contract.Requires%2A> method.</span></span> <span data-ttu-id="c673e-265">Jeśli sprawdzanie czasu wykonywania jest wyłączone, proces zostanie zakończony.</span><span class="sxs-lookup"><span data-stu-id="c673e-265">If run-time checking is turned off, the process will be terminated.</span></span> <span data-ttu-id="c673e-266">Aby uzyskać narzędzia do sprawdzania środowiska uruchomieniowego, zobacz [kontraktów kodu](http://go.microsoft.com/fwlink/?LinkId=152461) w witrynie MSDN DevLabs.</span><span class="sxs-lookup"><span data-stu-id="c673e-266">To obtain the tools for runtime checking, see [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span>  
  
-   <span data-ttu-id="c673e-267">Wywołanie tej metody należy na początku metody lub właściwości przed innymi kodu.</span><span class="sxs-lookup"><span data-stu-id="c673e-267">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="c673e-268">Niniejsza Umowa jest widoczne dla klientów; w związku z tym musi tylko odwołanie do elementów członkowskich, które są co najmniej jako widoczna jako metody otaczającej.</span><span class="sxs-lookup"><span data-stu-id="c673e-268">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="c673e-269">Użyj tej metody zamiast <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%29?displayProperty=nameWithType> metody, jeśli chcesz zgłosić wyjątek, jeśli warunki wstępne nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="c673e-269">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%29?displayProperty=nameWithType> method when you want to throw an exception if the precondition fails.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void Requires&lt;TException&gt; (bool condition, string userMessage) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires&lt;(class System.Exception) TException&gt;(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires(Of TException As Exception) (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void Requires(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Requires : bool * string -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.Requires (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TException">
          <span data-ttu-id="c673e-270">Wyjątek do zgłoszenia, jeśli wynikiem warunku jest <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-270">The exception to throw if the condition is <see langword="false" />.</span>
          </span>
        </typeparam>
        <param name="condition">
          <span data-ttu-id="c673e-271">Wyrażenie warunkowe do testowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-271">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="c673e-272">Komunikat wyświetlany, jeśli wynikiem warunku jest <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-272">The message to display if the condition is <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c673e-273">Określa kontrakt warunek wstępny dla otaczającego metody lub właściwości i zgłasza wyjątek z komunikatem podany, jeśli warunek dla kontraktu nie powiedzie się.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-273">Specifies a precondition contract for the enclosing method or property, and throws an exception with the provided message if the condition for the contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   > [!IMPORTANT]
    >  <span data-ttu-id="c673e-274">Należy włączyć czasu wykonywania sprawdzania <xref:System.Diagnostics.Contracts.Contract.Requires%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="c673e-274">You must turn on run-time checking to use the <xref:System.Diagnostics.Contracts.Contract.Requires%2A> method.</span></span> <span data-ttu-id="c673e-275">Jeśli sprawdzanie czasu wykonywania jest wyłączone, proces zostanie zakończony.</span><span class="sxs-lookup"><span data-stu-id="c673e-275">If run-time checking is turned off, the process will be terminated.</span></span> <span data-ttu-id="c673e-276">Aby uzyskać narzędzia do sprawdzania środowiska uruchomieniowego, zobacz [kontraktów kodu](http://go.microsoft.com/fwlink/?LinkId=152461) w witrynie MSDN DevLabs.</span><span class="sxs-lookup"><span data-stu-id="c673e-276">To obtain the tools for runtime checking, see [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span>  
  
     <span data-ttu-id="c673e-277">Wywołanie tej metody należy na początku metody lub właściwości przed innymi kodu.</span><span class="sxs-lookup"><span data-stu-id="c673e-277">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="c673e-278">Niniejsza Umowa jest widoczne dla klientów; w związku z tym musi tylko odwołanie do elementów członkowskich, które są co najmniej jako widoczna jako metody otaczającej.</span><span class="sxs-lookup"><span data-stu-id="c673e-278">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="c673e-279">Użyj tej metody zamiast <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> metody, jeśli chcesz zgłosić wyjątek, jeśli warunki wstępne nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="c673e-279">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> method when you want to throw an exception if the precondition fails.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Result&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Result&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Result&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Result``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Result(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Result();" />
      <MemberSignature Language="F#" Value="static member Result : unit -&gt; 'T" Usage="System.Diagnostics.Contracts.Contract.Result " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="c673e-280">Typ zwracanej wartości otaczającego metody lub właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-280">Type of return value of the enclosing method or property.</span>
          </span>
        </typeparam>
        <summary>
          <span data-ttu-id="c673e-281">Reprezentuje wartość zwracana metody lub właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-281">Represents the return value of a method or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c673e-282">Wartość zwracana otaczającego metody lub właściwości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-282">Return value of the enclosing method or property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c673e-283">Tej metody można użyć tylko w wyrażeniu warunkowym dla <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> kontraktu.</span><span class="sxs-lookup"><span data-stu-id="c673e-283">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c673e-284">Poniższy przykład przedstawia użycie <xref:System.Diagnostics.Contracts.Contract.Result%2A> metodę, aby określić oczekiwanej wartości zwracanej.</span><span class="sxs-lookup"><span data-stu-id="c673e-284">The following example shows how to use the <xref:System.Diagnostics.Contracts.Contract.Result%2A> method to specify an expected return value.</span></span> <span data-ttu-id="c673e-285">Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Diagnostics.Contracts.ContractClassAttribute> klasy.</span><span class="sxs-lookup"><span data-stu-id="c673e-285">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#3)]
 [!code-vb[ContractExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueAtReturn&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T ValueAtReturn&lt;T&gt; (out T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T ValueAtReturn&lt;T&gt;([out] !!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ValueAtReturn(Of T) (ByRef value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T ValueAtReturn([Runtime::InteropServices::Out] T % value);" />
      <MemberSignature Language="F#" Value="static member ValueAtReturn :  -&gt; 'T" Usage="System.Diagnostics.Contracts.Contract.ValueAtReturn value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="c673e-286">Typ <see langword="out" /> parametru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-286">The type of the <see langword="out" /> parameter.</span>
          </span>
        </typeparam>
        <param name="value">
          <span data-ttu-id="c673e-287">
            <see langword="out" /> Parametru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-287">The <see langword="out" /> parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c673e-288">Reprezentuje wartość końcowa (dane wyjściowe) <see langword="out" /> parametru, gdy zwracany z metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-288">Represents the final (output) value of an <see langword="out" /> parameter when returning from a method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c673e-289">Wartość danych wyjściowych <see langword="out" /> parametru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c673e-289">The output value of the <see langword="out" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c673e-290">Tej metody można użyć tylko w wyrażeniu warunkowym dla <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> kontraktu.</span><span class="sxs-lookup"><span data-stu-id="c673e-290">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span> <span data-ttu-id="c673e-291">Jak <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> metody, można pominąć parametr typu ogólnego zawsze, gdy kompilator jest w stanie wywnioskować jej typu.</span><span class="sxs-lookup"><span data-stu-id="c673e-291">As with the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method, you can omit the generic type parameter whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="c673e-292">Kontrakt funkcji ponownego zapisu zastępuje wywołanie metody wartość `out` parametru.</span><span class="sxs-lookup"><span data-stu-id="c673e-292">The contract rewriter replaces the method call with the value of the `out` parameter.</span></span> <span data-ttu-id="c673e-293"><xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> Metody może występować tylko w postconditions.</span><span class="sxs-lookup"><span data-stu-id="c673e-293">The <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method may appear only in postconditions.</span></span> <span data-ttu-id="c673e-294">Argument do metody musi być `out` pola struktury lub parametr `out` parametru.</span><span class="sxs-lookup"><span data-stu-id="c673e-294">The argument to the method must be an `out` parameter or a field of a structure `out` parameter.</span></span> <span data-ttu-id="c673e-295">Drugie polecenie jest również przydatne podczas odwoływania się do pól w warunku końcowego konstruktora struktury.</span><span class="sxs-lookup"><span data-stu-id="c673e-295">The latter is also useful when referring to fields in the postcondition of a structure constructor.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
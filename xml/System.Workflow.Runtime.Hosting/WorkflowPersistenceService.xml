<Type Name="WorkflowPersistenceService" FullName="System.Workflow.Runtime.Hosting.WorkflowPersistenceService">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ec1eb1e036001431540c10b6cc57bb283cfb6ce8" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30741689" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WorkflowPersistenceService : System.Workflow.Runtime.Hosting.WorkflowRuntimeService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit WorkflowPersistenceService extends System.Workflow.Runtime.Hosting.WorkflowRuntimeService" />
  <TypeSignature Language="DocId" Value="T:System.Workflow.Runtime.Hosting.WorkflowPersistenceService" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WorkflowPersistenceService&#xA;Inherits WorkflowRuntimeService" />
  <TypeSignature Language="C++ CLI" Value="public ref class WorkflowPersistenceService abstract : System::Workflow::Runtime::Hosting::WorkflowRuntimeService" />
  <AssemblyInfo>
    <AssemblyName>System.Workflow.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Workflow.Runtime.Hosting.WorkflowRuntimeService</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Obsolete("The System.Workflow.* types are deprecated.  Instead, please use the new types from System.Activities.*")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Abstrakcyjna klasa podstawowa, z których wszystkie trwałości są uzyskiwane usług.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  [!INCLUDE[DeprecatedContent](~/includes/deprecatedcontent-md.md)]  
  
 Gdy określone warunki są wykonywane, gdy jest uruchomiony przepływ pracy, aparatu wykonawczego workflow utrzymuje informacje o stanie dotyczące wystąpienia przepływu pracy. Trwałość mogą wystąpić, na przykład po zakończeniu transakcji atomic podczas wystąpienia przepływu pracy staje się bezczynności, gdy host wywołuje <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A?displayProperty=nameWithType> w wystąpieniu przepływu pracy lub gdy wystąpienia przepływu pracy zostało zakończone lub zakończeniu. Podczas semantykę aparat środowiska uruchomieniowego przepływu pracy dyktowania, że powinno nastąpić trwałości, aparatu wykonawczego workflow wywołuje metody, które są dostarczane przez usługę trwałości, aby zapisać informacje o stanie dotyczące wystąpienia przepływu pracy. Podobnie gdy aparat środowiska uruchomieniowego przepływu pracy musi przywrócić wystąpienia przepływu pracy utrwalonych wcześniej, wywołuje metody, które są dostarczane przez usługę trwałości można załadować informacji o stanie. Aparatu wykonawczego workflow obsługuje wszystkie semantyki dotyczące przeprowadzania trwałości. Usługa trwałości obsługuje faktycznie zapisywanie i ładowanie informacji stanu przepływu pracy do lub z magazynu danych.  
  
 Można utworzyć usługi utrwalania wyprowadzanie klasy z <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService> klasy.  Można dodać usługi trwałości do aparatu wykonawczego workflow przez wywołanie metody <xref:System.Workflow.Runtime.WorkflowRuntime.AddService%2A> lub tworząc odpowiedni wpis w pliku konfiguracyjnym aplikacji. <xref:System.Workflow.Runtime.WorkflowRuntime> Powinna zawierać tylko jedną usługę trwałości. Windows Workflow Foundation udostępnia <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService> klasy usługi trwałości out-of-box, którego można użyć jako jest lub rozszerzenia.  
  
 Aparat środowiska uruchomieniowego przepływu pracy ma semantykę blokowania informacje o stanie przepływu pracy do użytku w środowiskach, w którym usług trwałości, które działają w różnych procesów może mieć dostępu do magazynu danych. <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService> Klasy oferuje możliwość obsługują tę funkcję, aparatu środowiska uruchomieniowego przepływu pracy, podając parametr <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A> Określa, czy informacje o stanie wystąpienia przepływu pracy powinna zostać odblokowany w magazynie danych i Dzięki udostępnieniu metod <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnlockWorkflowInstanceState%2A> do odblokowania wcześniej zablokowane informacje o stanie przepływu pracy. Usługi trwałości, który implementuje blokowania wywołanie <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadWorkflowInstanceState%2A> powinna zablokować informacje o stanie dla wystąpienia przepływu pracy.  
  
 Usługi trwałości powinien zgłosić <xref:System.Workflow.Runtime.Hosting.PersistenceException> jeśli jej nie powiedzie się zapisać informacje o stanie do jego magazynu danych lub załadować informacji o stanie z magazynu danych. Aparatu wykonawczego workflow oczekuje to zachowanie.  
  
 Przetwarzanie wsadowe mechanizm jest dostępna dla usług, które korzystają z magazynu trwałego można zapisać informacji o stanie przepływu pracy. Jest ważne w tych przypadkach do zapewniania spójności między trwałe magazynu, który jest używany przez usługę trwałości i wewnętrzny stan klasy aparatu wykonawczego workflow. Można dodać funkcje zdefiniowane przez <xref:System.Workflow.Runtime.IPendingWork> interfejsu z usługą, a następnie uczestniczyć w partie transakcji przepływu pracy udostępniane przez <xref:System.Workflow.Runtime.Hosting.WorkflowCommitWorkBatchService> przez dodanie zmiany do magazynu danych jako elementów roboczych w celu <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A>. Trwałe samego magazynu powinien implementować <xref:System.Transactions.IEnlistmentNotification> interfejsu, dzięki czemu informacje o przepływie pracy nie jest trwały nieprawidłowo w przypadku wycofywania transakcji. Aby uzyskać więcej informacji, zobacz <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveCompletedContextActivity%2A> lub <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WorkflowPersistenceService ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WorkflowPersistenceService();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej inicjuje nowe wystąpienie klasy <see cref="T:System.Workflow.Runtime.Hosting.WorkflowPersistenceService" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano tworzenie wystąpienia `SqlWorkflowPersistenceService` klasy (pochodną `WorkflowPersistenceService`). W tym przykładzie jest z próbki zagnieżdżone SDK programy obsługi wyjątków, z klasy Program.cs.  Aby uzyskać więcej informacji, zobacz [zagnieżdżone przykładowe programy obsługi wyjątków](http://msdn.microsoft.com/library/d1da0209-842b-41c8-9b7c-0cbaa1034265).  
  
 [!code-csharp[WF_Samples#161](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets11.cs#161)]
 [!code-vb[WF_Samples#161](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets11.vb#161)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultSerializedForm">
      <MemberSignature Language="C#" Value="protected static byte[] GetDefaultSerializedForm (System.Workflow.ComponentModel.Activity activity);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig unsigned int8[] GetDefaultSerializedForm(class System.Workflow.ComponentModel.Activity activity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetDefaultSerializedForm(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static cli::array &lt;System::Byte&gt; ^ GetDefaultSerializedForm(System::Workflow::ComponentModel::Activity ^ activity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="activity">
          <see cref="T:System.Workflow.ComponentModel.Activity" /> Których serializacji formularza jest wymagane.</param>
        <summary>Pobiera serializacji domyślnego formularza z <see cref="T:System.Workflow.ComponentModel.Activity" />.</summary>
        <returns>Zserializowany domyślnego formularza z <see cref="T:System.Workflow.ComponentModel.Activity" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsBlocked">
      <MemberSignature Language="C#" Value="protected internal static bool GetIsBlocked (System.Workflow.ComponentModel.Activity rootActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool GetIsBlocked(class System.Workflow.ComponentModel.Activity rootActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetIsBlocked(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Function GetIsBlocked (rootActivity As Activity) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool GetIsBlocked(System::Workflow::ComponentModel::Activity ^ rootActivity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="rootActivity">Działanie główne wystąpienia przepływu pracy.</param>
        <summary>Wskazuje, czy dane działanie jest zablokowany.</summary>
        <returns>
          <see langword="true" /> Jeśli dane działanie jest zablokowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSuspendOrTerminateInfo">
      <MemberSignature Language="C#" Value="protected internal static string GetSuspendOrTerminateInfo (System.Workflow.ComponentModel.Activity rootActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig string GetSuspendOrTerminateInfo(class System.Workflow.ComponentModel.Activity rootActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetSuspendOrTerminateInfo(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Function GetSuspendOrTerminateInfo (rootActivity As Activity) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static System::String ^ GetSuspendOrTerminateInfo(System::Workflow::ComponentModel::Activity ^ rootActivity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="rootActivity">Działanie główne wystąpienia przepływu pracy.</param>
        <summary>Pobiera przerwanie lub wstrzymać informacji danego działania.</summary>
        <returns>A <see cref="T:System.String" /> zawiera przerwanie albo zawiesić informacji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowStatus">
      <MemberSignature Language="C#" Value="protected internal static System.Workflow.Runtime.WorkflowStatus GetWorkflowStatus (System.Workflow.ComponentModel.Activity rootActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig valuetype System.Workflow.Runtime.WorkflowStatus GetWorkflowStatus(class System.Workflow.ComponentModel.Activity rootActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetWorkflowStatus(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Function GetWorkflowStatus (rootActivity As Activity) As WorkflowStatus" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static System::Workflow::Runtime::WorkflowStatus GetWorkflowStatus(System::Workflow::ComponentModel::Activity ^ rootActivity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="rootActivity">Działanie główne wystąpienia przepływu pracy.</param>
        <summary>Pobiera stan przepływu pracy.</summary>
        <returns>A <see cref="T:System.Workflow.Runtime.WorkflowStatus" /> wartości wyliczenia, które wskazuje stan przepływu pracy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadCompletedContextActivity">
      <MemberSignature Language="C#" Value="protected internal abstract System.Workflow.ComponentModel.Activity LoadCompletedContextActivity (Guid scopeId, System.Workflow.ComponentModel.Activity outerActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Workflow.ComponentModel.Activity LoadCompletedContextActivity(valuetype System.Guid scopeId, class System.Workflow.ComponentModel.Activity outerActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadCompletedContextActivity(System.Guid,System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Function LoadCompletedContextActivity (scopeId As Guid, outerActivity As Activity) As Activity" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract System::Workflow::ComponentModel::Activity ^ LoadCompletedContextActivity(Guid scopeId, System::Workflow::ComponentModel::Activity ^ outerActivity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopeId" Type="System.Guid" />
        <Parameter Name="outerActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="scopeId">
          <see cref="T:System.Guid" /> Ukończone zakresu.</param>
        <param name="outerActivity">
          <see cref="T:System.Workflow.ComponentModel.Activity" /> Reprezentujący działanie, które umieszcza ukończone zakresu.</param>
        <summary>Po zaimplementowaniu w klasie pochodnej, ładuje określony zakres ukończone do pamięci.</summary>
        <returns>
          <see cref="T:System.Workflow.ComponentModel.Activity" /> Reprezentujący ukończone zakresu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używa aparatu wykonawczego workflow <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadCompletedContextActivity%2A> do zaimplementowania kompensacji. Należy przywrócić identyczne kopię ukończonego zakresu. Aby to zrobić, należy przywrócić prawidłową <xref:System.IO.Stream> z Twojej reprezentację ukończone zakres danych magazynu. Następnie należy przekazać to <xref:System.IO.Stream> do jednego z przeciążonej metody <xref:System.Workflow.ComponentModel.Activity.Load%2A> do wykonania deserializacji zakresu.  
  
 Jeśli usługi utrwalania nie można załadować zakresu ukończone z magazynu danych, powinien zgłosić <xref:System.Workflow.Runtime.Hosting.PersistenceException> z odpowiedni komunikat.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano implementacja `LoadCompletedContextActivity` metody. W tym przykładzie jest z próbki niestandardowe usługi utrwalania, z pliku FilePersistenceService.cs. Aby uzyskać więcej informacji, zobacz [przykład usługi trwałości niestandardowe](http://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#269](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#269)]
 [!code-vb[WF_Samples#269](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#269)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadWorkflowInstanceState">
      <MemberSignature Language="C#" Value="protected internal abstract System.Workflow.ComponentModel.Activity LoadWorkflowInstanceState (Guid instanceId);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Workflow.ComponentModel.Activity LoadWorkflowInstanceState(valuetype System.Guid instanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadWorkflowInstanceState(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Function LoadWorkflowInstanceState (instanceId As Guid) As Activity" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract System::Workflow::ComponentModel::Activity ^ LoadWorkflowInstanceState(Guid instanceId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="instanceId">
          <see cref="T:System.Guid" /> Głównego działania wystąpienia przepływu pracy.</param>
        <summary>Po zaimplementowaniu w klasie pochodnej, ładuje określonego stanu wystąpienia przepływu pracy do pamięci.</summary>
        <returns>
          <see cref="T:System.Workflow.ComponentModel.Activity" /> Reprezentujący działanie główne wystąpienia przepływu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przywrócić identyczne kopię działania. Aby to zrobić, należy przywrócić prawidłową <xref:System.IO.Stream> z Twojej reprezentacja wystąpienia przepływu pracy w magazynie danych; następnie trzeba przekazać to <xref:System.IO.Stream> do jednego z przeciążone <xref:System.Workflow.ComponentModel.Activity.Load%2A> stan wystąpienia metody deserializować przepływu pracy. Jeśli usługi utrwalania nie można załadować stanu wystąpienia przepływu pracy z magazynu danych, powinien zgłosić <xref:System.Workflow.Runtime.Hosting.PersistenceException> z odpowiedni komunikat.  
  
 Aparatu wykonawczego workflow implementuje semantykę blokowania, aby ograniczyć dostęp do stanu wystąpienia przepływu pracy, który jest zapisany w magazynie danych. To jest możliwy za usług trwałości, które działają w wielu procesów. Semantyka blokowania zapobiegające usług trwałości, które działają w dwóch różnych procesów ładowania tego samego wystąpienia przepływu pracy do pamięci w tym samym czasie. W zależności od typu środowiska zaprojektowano usługi trwałości do obsługi, można wybrać opcję obsługują tę funkcję. Jeśli wybierzesz do obsługi środowiska uruchomieniowego semantyką blokowania, jeśli ten przepływ pracy wystąpienie stanu został wcześniej zablokowany przez inny proces, a następnie powinien zgłosić <xref:System.Workflow.Runtime.WorkflowOwnershipException>. W przeciwnym razie należy zablokować dostęp do stanu wystąpienia przepływu pracy w magazynie danych. Stan wystąpienia przepływu pracy może zostać odblokowany przez wywołanie do <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnlockWorkflowInstanceState%2A> lub wywołanie <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A> z parametrem unlock ustawioną `true`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano implementacja `LoadWorkflowInstanceState` metody. W tym przykładzie jest z próbki niestandardowe usługi utrwalania, z pliku FilePersistenceService.cs. Aby uzyskać więcej informacji, zobacz [przykład usługi trwałości niestandardowe](http://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#266](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#266)]
 [!code-vb[WF_Samples#266](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#266)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreFromDefaultSerializedForm">
      <MemberSignature Language="C#" Value="protected static System.Workflow.ComponentModel.Activity RestoreFromDefaultSerializedForm (byte[] activityBytes, System.Workflow.ComponentModel.Activity outerActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Workflow.ComponentModel.Activity RestoreFromDefaultSerializedForm(unsigned int8[] activityBytes, class System.Workflow.ComponentModel.Activity outerActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.RestoreFromDefaultSerializedForm(System.Byte[],System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function RestoreFromDefaultSerializedForm (activityBytes As Byte(), outerActivity As Activity) As Activity" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Workflow::ComponentModel::Activity ^ RestoreFromDefaultSerializedForm(cli::array &lt;System::Byte&gt; ^ activityBytes, System::Workflow::ComponentModel::Activity ^ outerActivity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activityBytes" Type="System.Byte[]" />
        <Parameter Name="outerActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="activityBytes">Zserializowany formę <see cref="T:System.Workflow.ComponentModel.Activity" />.</param>
        <param name="outerActivity">Zewnętrznego <see cref="T:System.Workflow.ComponentModel.Activity" />, zawierającego <see cref="T:System.Workflow.ComponentModel.Activity" /> do przywrócenia.</param>
        <summary>Przywraca <see cref="T:System.Workflow.ComponentModel.Activity" /> z jego serializacji formularza.</summary>
        <returns>Przywróconej <see cref="T:System.Workflow.ComponentModel.Activity" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano implementacja `RestoreFromDefaultSerializedForm` metody. W tym przykładzie jest z próbki niestandardowe usługi utrwalania, z pliku FilePersistenceService.cs. Aby uzyskać więcej informacji, zobacz [przykład usługi trwałości niestandardowe](http://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#269](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#269)]
 [!code-vb[WF_Samples#269](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#269)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveCompletedContextActivity">
      <MemberSignature Language="C#" Value="protected internal abstract void SaveCompletedContextActivity (System.Workflow.ComponentModel.Activity activity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SaveCompletedContextActivity(class System.Workflow.ComponentModel.Activity activity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveCompletedContextActivity(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void SaveCompletedContextActivity(System::Workflow::ComponentModel::Activity ^ activity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="activity">
          <see cref="T:System.Workflow.ComponentModel.Activity" /> Reprezentujący ukończone zakresu.</param>
        <summary>Po zaimplementowaniu w klasie pochodnej, zapisuje określony zakres ukończone w magazynie danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aparatu wykonawczego workflow zapisuje stan ukończonych zakres działań w celu wdrożenia kompensacji. Należy wywołać z przeciążone <xref:System.Workflow.ComponentModel.Activity.Save%2A> metod do serializacji `activity` do <xref:System.IO.Stream>; można następnie dodatkowo przetworzyć <xref:System.IO.Stream> przed zapisaniem go do magazynu danych. Jednakże, gdy aparatu wykonawczego workflow wywołuje <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadCompletedContextActivity%2A>, należy przywrócić identyczne kopię działania.  
  
 Użytkownik musi mieć możliwość skojarzenia zakresu ukończone z otaczającym wystąpienia przepływu pracy, tak aby oznaczyć zakresu jako niepotrzebnych w magazynie danych po zakończeniu działania wystąpienia przepływu pracy lub przerwane. Dlatego też należy zapisać <xref:System.Guid> wystąpienia przepływu pracy, który jest skojarzony z zakresem ukończone; to można uzyskać z <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> właściwość <xref:System.Workflow.Runtime.WorkflowInstance> skojarzone z `activity`.  
  
 <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadCompletedContextActivity%2A> Trwa <xref:System.Guid> ukończone zakresu jako parametr. Dlatego też należy zapisać <xref:System.Workflow.ComponentModel.ActivityExecutionContext.ContextGuid%2A> właściwości skojarzonej z `activity`. Ta właściwość może być przywoływany przez <xref:System.Workflow.ComponentModel.Activity.ActivityContextGuidProperty> pole `activity`.  
  
 W przypadku wdrażania usługi utrwalania, która używa magazynu trwałego, aby zachować spójność z wewnętrzny stan klasy środowiska uruchomieniowego przepływu powinny uczestniczyć w partie odroczenia rzeczywiste zapisu do magazynu trwałego do transakcji przepływu pracy przepływ pracy zatwierdzania punktu. Aby wziąć udział w przetwarzaniu wsadowym, Dodaj element roboczy do <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A> właściwość, która reprezentuje oczekujące zmiany do bazy danych i wdrożenie <xref:System.Workflow.Runtime.IPendingWork> interfejsu w usłudze trwałości.  
  
 Jeśli ukończono zakresu nie może zapisać do magazynu danych, powinien zgłosić <xref:System.Workflow.Runtime.Hosting.PersistenceException> odpowiedni komunikat o błędzie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano implementacja `SaveCompletedContextActivity` metody. W tym przykładzie jest z próbki niestandardowe usługi utrwalania, z pliku FilePersistenceService.cs. Aby uzyskać więcej informacji, zobacz [przykład usługi trwałości niestandardowe](http://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#268](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#268)]
 [!code-vb[WF_Samples#268](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#268)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveWorkflowInstanceState">
      <MemberSignature Language="C#" Value="protected internal abstract void SaveWorkflowInstanceState (System.Workflow.ComponentModel.Activity rootActivity, bool unlock);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SaveWorkflowInstanceState(class System.Workflow.ComponentModel.Activity rootActivity, bool unlock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState(System.Workflow.ComponentModel.Activity,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Sub SaveWorkflowInstanceState (rootActivity As Activity, unlock As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void SaveWorkflowInstanceState(System::Workflow::ComponentModel::Activity ^ rootActivity, bool unlock);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
        <Parameter Name="unlock" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rootActivity">Działanie główne wystąpienia przepływu pracy.</param>
        <param name="unlock">
          <see langword="true" /> Jeśli wystąpienie przepływu pracy nie ma zostać zablokowana; <see langword="false" /> Jeśli wystąpienia przepływu pracy ma być zablokowana.</param>
        <summary>Po zaimplementowaniu w klasie pochodnej, zapisuje stan wystąpienia przepływu pracy w magazynie danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy wywołać z przeciążone <xref:System.Workflow.ComponentModel.Activity.Save%2A> metod do serializacji `rootActivity` do <xref:System.IO.Stream>. Następnie użytkownik może także przetwarzać <xref:System.IO.Stream> przed zapisaniem go do magazynu danych. Jednakże, gdy aparatu wykonawczego workflow wywołuje <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadWorkflowInstanceState%2A>, należy przywrócić identyczne kopię działania głównego. Jeśli nie można zapisać stanu wystąpienia przepływu pracy do magazynu danych, powinien zgłosić <xref:System.Workflow.Runtime.Hosting.PersistenceException> odpowiedni komunikat o błędzie.  
  
 Aparat środowiska uruchomieniowego przepływu pracy zawiera semantyką blokowania, aby ograniczyć dostęp do stanu wystąpienia przepływu pracy, który jest zapisany w magazynie danych. To są dostępne przez trwałości usługi uruchomione na wielu hostach i wskazujący tego samego magazynu danych. Semantyka blokowania zapobiegające usług trwałości, które działają w dwóch różnych przepływu pracy środowiska uruchomieniowe ładowania tego samego wystąpienia przepływu pracy do pamięci w tym samym czasie. W zależności od typu środowiska, które umożliwia obsługę usługi trwałości możesz wybrać, czy do obsługi tej funkcji. Jeśli wybierzesz do obsługi semantykę blokowania środowiska uruchomieniowego, a następnie, jeśli usługa trwałości próbuje zapisać stan wystąpienia przepływu pracy, który wcześniej został zablokowany przez inną usługę trwałości, powinien zgłosić <xref:System.Workflow.Runtime.WorkflowOwnershipException>. Jeśli `unlock` jest `true`, należy odblokować dostęp do stanu wystąpienia przepływu pracy po jego zapisaniu.  
  
 <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadWorkflowInstanceState%2A> Trwa <xref:System.Guid> wystąpienia przepływu pracy jako parametr. W związku z tym należy zapisać to <xref:System.Guid>. Możesz także użyć tej funkcji <xref:System.Guid> do skojarzenia z zapisanymi stanami jego zakresów ukończone wystąpienia przepływu pracy. Należy to zrobić, ponieważ użytkownik musi mieć możliwość tych zakresów ukończone zostać oznaczone jako niepotrzebne, gdy ukończy wystąpienia przepływu pracy.  
  
 Wywołania aparat środowiska uruchomieniowego przepływu pracy <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A> końcowego czasu, gdy wystąpienie przepływu pracy jest wykonana lub zakończona. W związku z tym jeśli <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetWorkflowStatus%2A> jest równa <xref:System.Workflow.Runtime.WorkflowStatus.Completed> lub <xref:System.Workflow.Runtime.WorkflowStatus.Terminated>, można bezpiecznie usunąć wystąpienia przepływu pracy i jego skojarzony zakresy ukończone z magazynu danych. Alternatywnie można subskrybować <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowCompleted> lub <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowTerminated> zdarzeń w celu określenia, kiedy jest bezpiecznie usunąć rekordy skojarzone z wystąpieniem przepływu pracy. Czy rzeczywiście Usuń rekordy z magazynu danych, zależy od implementacji.  
  
 Jeśli wdrożenie usługi utrwalania, która używa magazynu trwałego, aby zachować spójność z wewnętrzny stan klasy środowiska uruchomieniowego przepływu, powinny uczestniczyć w transakcji przepływu pracy, przetwarzanie wsadowe odroczenia rzeczywiste zapisu do magazynu trwałego do przepływ pracy zatwierdzania punktu. Aby wziąć udział w przetwarzaniu wsadowym, Dodaj element roboczy, który reprezentuje oczekujące zmiany do magazynu trwałego na <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A> właściwości i wdrożenie <xref:System.Workflow.Runtime.IPendingWork> interfejsu w usłudze trwałości.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano implementacja `SaveWorkflowInstanceState` metody. W tym przykładzie jest z próbki niestandardowe usługi utrwalania, z pliku FilePersistenceService.cs. Aby uzyskać więcej informacji, zobacz [przykład usługi trwałości niestandardowe](http://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#264](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#264)]
 [!code-vb[WF_Samples#264](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#264)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadOnIdle">
      <MemberSignature Language="C#" Value="protected internal abstract bool UnloadOnIdle (System.Workflow.ComponentModel.Activity activity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool UnloadOnIdle(class System.Workflow.ComponentModel.Activity activity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnloadOnIdle(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract bool UnloadOnIdle(System::Workflow::ComponentModel::Activity ^ activity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="activity">
          <see cref="T:System.Workflow.ComponentModel.Activity" /> Reprezentujący ukończone zakresu.</param>
        <summary>Określa, czy przepływ pracy ma być zwolniony podczas bezczynności.</summary>
        <returns>Jeśli <see langword="true" />, aparatu wykonawczego workflow zwalnia określonego przepływu pracy, gdy stanie się bezczynności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano implementacja `UnloadOnIdle` metody. W tym przykładzie jest z próbki niestandardowe usługi utrwalania, z pliku FilePersistenceService.cs. Aby uzyskać więcej informacji, zobacz [przykład usługi trwałości niestandardowe](http://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#270](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#270)]
 [!code-vb[WF_Samples#270](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#270)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnlockWorkflowInstanceState">
      <MemberSignature Language="C#" Value="protected internal abstract void UnlockWorkflowInstanceState (System.Workflow.ComponentModel.Activity rootActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void UnlockWorkflowInstanceState(class System.Workflow.ComponentModel.Activity rootActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnlockWorkflowInstanceState(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Sub UnlockWorkflowInstanceState (rootActivity As Activity)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void UnlockWorkflowInstanceState(System::Workflow::ComponentModel::Activity ^ rootActivity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="rootActivity">Działanie główne wystąpienia przepływu pracy.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, odblokowuje stanu wystąpienia przepływu pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest abstrakcyjna, więc nie zawiera domyślną implementację na blokowanie i odblokowywanie.  
  
 Podczas wdrożenia usługi utrwalania niestandardowe, aby zaimplementować blokowania schematu należy przesłonić tę metodę i udostępniają mechanizm blokowania odblokowywania w <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A> metoda oparta na wartości parametru unlock.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano implementacja `UnlockWorkflowInstanceState` metody. W tym przykładzie jest z próbki niestandardowe usługi utrwalania, z pliku FilePersistenceService.cs. Aby uzyskać więcej informacji, zobacz [przykład usługi trwałości niestandardowe](http://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#267](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#267)]
 [!code-vb[WF_Samples#267](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#267)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="WorkflowPersistenceService" FullName="System.Workflow.Runtime.Hosting.WorkflowPersistenceService">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="89c26523c05346ffee71943e0117ab5d1ebaa453" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37735222" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WorkflowPersistenceService : System.Workflow.Runtime.Hosting.WorkflowRuntimeService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit WorkflowPersistenceService extends System.Workflow.Runtime.Hosting.WorkflowRuntimeService" />
  <TypeSignature Language="DocId" Value="T:System.Workflow.Runtime.Hosting.WorkflowPersistenceService" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WorkflowPersistenceService&#xA;Inherits WorkflowRuntimeService" />
  <TypeSignature Language="C++ CLI" Value="public ref class WorkflowPersistenceService abstract : System::Workflow::Runtime::Hosting::WorkflowRuntimeService" />
  <TypeSignature Language="F#" Value="type WorkflowPersistenceService = class&#xA;    inherit WorkflowRuntimeService" />
  <AssemblyInfo>
    <AssemblyName>System.Workflow.Runtime</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Workflow.Runtime.Hosting.WorkflowRuntimeService</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Obsolete("The System.Workflow.* types are deprecated.  Instead, please use the new types from System.Activities.*")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Abstrakcyjna klasa bazowa, z których wszystkie trwałości wywodzą się usług.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  [!INCLUDE[DeprecatedContent](~/includes/deprecatedcontent-md.md)]  
  
 W przypadku wystąpienia określonych warunków po uruchomieniu przepływu pracy aparatu wykonawczego przepływów pracy utrzymuje informacje o stanie dotyczące wystąpienia przepływu pracy. Stan trwały może wystąpić, na przykład po zakończeniu transakcji niepodzielnej gdy wystąpienie przepływu pracy staje się nieaktywna, gdy host wywołuje <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A?displayProperty=nameWithType> w wystąpieniu przepływu pracy, lub gdy wystąpienie przepływu pracy jest zakończone lub zakończeniu. Gdy semantykę aparat środowiska uruchomieniowego przepływu pracy określają, czy powinno nastąpić trwałości, aparatu wykonawczego przepływów pracy wywołuje metody, które są dostarczane przez usługę trwałość, aby zapisać informacje o stanie dotyczące wystąpienia przepływu pracy. Podobnie gdy aparat środowiska uruchomieniowego przepływu pracy musi przywrócić uprzednio utrwalonego wystąpienia przepływu pracy, wywołuje metody, które są dostarczane przez usługę trwałości można załadować informacji o stanie. Aparatu wykonawczego przepływów pracy obsługuje wszystkie semantyki dotyczące przeprowadzania trwałości. Usługa trwałości obsługuje faktycznie zapisywanie i ładowanie informacje o stanie przepływu pracy do lub z magazynu danych.  
  
 Można utworzyć usługi trwałości, wyprowadzanie klasy z <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService> klasy.  Twoje usługi trwałości można dodawać do aparatu wykonawczego przepływów pracy, wywołując <xref:System.Workflow.Runtime.WorkflowRuntime.AddService%2A> lub tworząc odpowiedni wpis w pliku konfiguracyjnym aplikacji. <xref:System.Workflow.Runtime.WorkflowRuntime> Może zawierać tylko jedną usługę trwałości. Windows Workflow Foundation udostępnia <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService> klasy usługi trwałości out-of-box, którego można użyć w pierwotnej formie lub rozszerzyć.  
  
 Aparatu wykonawczego przepływów pracy ma semantykę blokowania informacje o stanie przepływu pracy do użytku w środowiskach, w którym usługi trwałości, które są uruchamiane w różnych procesach może mieć dostępu do pojedynczym magazynie danych. <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService> Klasa udostępnia możliwość obsługi tej funkcji aparatu wykonawczego przepływów pracy, podając parametr <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A> określająca, czy informacje o stanie wystąpienia przepływu pracy powinny zostać odblokowany w magazynie danych i Dzięki udostępnieniu metod <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnlockWorkflowInstanceState%2A> wcześniej odblokować zablokowany informacje o stanie przepływu pracy. Usługi trwałości, który implementuje, blokowanie, wywołanie <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadWorkflowInstanceState%2A> należy zablokować informacje o stanie dla wystąpienia przepływu pracy.  
  
 Usługa trwałości powinno zgłosić <xref:System.Workflow.Runtime.Hosting.PersistenceException> ich powodzenia zapisać informacje o stanie do jego magazynu danych lub załadować informacji o stanie z magazynu danych. Aparatu wykonawczego przepływów pracy oczekuje, że to zachowanie.  
  
 Mechanizm łączenia we wsady jest udostępniana dla usług korzystających z magazynu trwałego można zapisać informacji o stanie przepływu pracy. Jest to istotne w takich przypadkach, aby zachować spójność między trwałych magazynach, które jest używane przez usługę trwałości i wewnętrzny stan aparatu wykonawczego przepływów pracy. Można dodawać funkcjonalność, zdefiniowane przez <xref:System.Workflow.Runtime.IPendingWork> interfejsu do usługi, a następnie uczestniczyć w przepływ pracy transakcja tworzenia plików wsadowych dostarczone przez <xref:System.Workflow.Runtime.Hosting.WorkflowCommitWorkBatchService> , dodając zmiany ze swoim magazynem danych jako elementy robocze do <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A>. Samego magazynu trwałego należy zaimplementować <xref:System.Transactions.IEnlistmentNotification> interfejsu, tak aby informacje o przepływie pracy nie jest trwały nieprawidłowo w przypadku wycofywania transakcji. Aby uzyskać więcej informacji, zobacz <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveCompletedContextActivity%2A> lub <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WorkflowPersistenceService ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WorkflowPersistenceService();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej, inicjuje nowe wystąpienie klasy <see cref="T:System.Workflow.Runtime.Hosting.WorkflowPersistenceService" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano tworzenie wystąpienia `SqlWorkflowPersistenceService` klasy (pochodną `WorkflowPersistenceService`). W tym przykładzie pochodzi z przykładu zagnieżdżone SDK programów obsługi wyjątków z klasy w pliku Program.cs.  Aby uzyskać więcej informacji, zobacz [zagnieżdżone przykładowe programy obsługi wyjątków](http://msdn.microsoft.com/library/d1da0209-842b-41c8-9b7c-0cbaa1034265).  
  
 [!code-csharp[WF_Samples#161](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets11.cs#161)]
 [!code-vb[WF_Samples#161](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets11.vb#161)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultSerializedForm">
      <MemberSignature Language="C#" Value="protected static byte[] GetDefaultSerializedForm (System.Workflow.ComponentModel.Activity activity);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig unsigned int8[] GetDefaultSerializedForm(class System.Workflow.ComponentModel.Activity activity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetDefaultSerializedForm(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static cli::array &lt;System::Byte&gt; ^ GetDefaultSerializedForm(System::Workflow::ComponentModel::Activity ^ activity);" />
      <MemberSignature Language="F#" Value="static member GetDefaultSerializedForm : System.Workflow.ComponentModel.Activity -&gt; byte[]" Usage="System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetDefaultSerializedForm activity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="activity">
          <see cref="T:System.Workflow.ComponentModel.Activity" /> Którego postaci serializowanej jest wymagane.</param>
        <summary>Pobiera serializacji domyślnego formularza programu <see cref="T:System.Workflow.ComponentModel.Activity" />.</summary>
        <returns>Zserializowany domyślnego formularza programu <see cref="T:System.Workflow.ComponentModel.Activity" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsBlocked">
      <MemberSignature Language="C#" Value="protected internal static bool GetIsBlocked (System.Workflow.ComponentModel.Activity rootActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool GetIsBlocked(class System.Workflow.ComponentModel.Activity rootActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetIsBlocked(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Function GetIsBlocked (rootActivity As Activity) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool GetIsBlocked(System::Workflow::ComponentModel::Activity ^ rootActivity);" />
      <MemberSignature Language="F#" Value="static member GetIsBlocked : System.Workflow.ComponentModel.Activity -&gt; bool" Usage="System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetIsBlocked rootActivity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="rootActivity">Działania głównego wystąpienia przepływu pracy.</param>
        <summary>Wskazuje, czy dane działanie zostanie zablokowana.</summary>
        <returns>
          <see langword="true" /> Jeśli dane działanie jest zablokowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSuspendOrTerminateInfo">
      <MemberSignature Language="C#" Value="protected internal static string GetSuspendOrTerminateInfo (System.Workflow.ComponentModel.Activity rootActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig string GetSuspendOrTerminateInfo(class System.Workflow.ComponentModel.Activity rootActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetSuspendOrTerminateInfo(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Function GetSuspendOrTerminateInfo (rootActivity As Activity) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static System::String ^ GetSuspendOrTerminateInfo(System::Workflow::ComponentModel::Activity ^ rootActivity);" />
      <MemberSignature Language="F#" Value="static member GetSuspendOrTerminateInfo : System.Workflow.ComponentModel.Activity -&gt; string" Usage="System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetSuspendOrTerminateInfo rootActivity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="rootActivity">Działania głównego wystąpienia przepływu pracy.</param>
        <summary>Pobiera przerwanie lub zawiesić informacji danego działania.</summary>
        <returns>A <see cref="T:System.String" /> , zawiera przerwanie lub zawiesić informacji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowStatus">
      <MemberSignature Language="C#" Value="protected internal static System.Workflow.Runtime.WorkflowStatus GetWorkflowStatus (System.Workflow.ComponentModel.Activity rootActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig valuetype System.Workflow.Runtime.WorkflowStatus GetWorkflowStatus(class System.Workflow.ComponentModel.Activity rootActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetWorkflowStatus(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Function GetWorkflowStatus (rootActivity As Activity) As WorkflowStatus" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static System::Workflow::Runtime::WorkflowStatus GetWorkflowStatus(System::Workflow::ComponentModel::Activity ^ rootActivity);" />
      <MemberSignature Language="F#" Value="static member GetWorkflowStatus : System.Workflow.ComponentModel.Activity -&gt; System.Workflow.Runtime.WorkflowStatus" Usage="System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetWorkflowStatus rootActivity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="rootActivity">Działania głównego wystąpienia przepływu pracy.</param>
        <summary>Pobiera stan przepływu pracy.</summary>
        <returns>A <see cref="T:System.Workflow.Runtime.WorkflowStatus" /> wartości wyliczenia, które wskazuje stan przepływu pracy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadCompletedContextActivity">
      <MemberSignature Language="C#" Value="protected internal abstract System.Workflow.ComponentModel.Activity LoadCompletedContextActivity (Guid scopeId, System.Workflow.ComponentModel.Activity outerActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Workflow.ComponentModel.Activity LoadCompletedContextActivity(valuetype System.Guid scopeId, class System.Workflow.ComponentModel.Activity outerActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadCompletedContextActivity(System.Guid,System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Function LoadCompletedContextActivity (scopeId As Guid, outerActivity As Activity) As Activity" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract System::Workflow::ComponentModel::Activity ^ LoadCompletedContextActivity(Guid scopeId, System::Workflow::ComponentModel::Activity ^ outerActivity);" />
      <MemberSignature Language="F#" Value="abstract member LoadCompletedContextActivity : Guid * System.Workflow.ComponentModel.Activity -&gt; System.Workflow.ComponentModel.Activity" Usage="workflowPersistenceService.LoadCompletedContextActivity (scopeId, outerActivity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopeId" Type="System.Guid" />
        <Parameter Name="outerActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="scopeId">
          <see cref="T:System.Guid" /> Ukończone zakresu.</param>
        <param name="outerActivity">
          <see cref="T:System.Workflow.ComponentModel.Activity" /> Reprezentujący działanie, które obejmuje zakres ukończone.</param>
        <summary>Po zaimplementowaniu w klasie pochodnej, ładuje określony zakres ukończone powrotem do pamięci.</summary>
        <returns>
          <see cref="T:System.Workflow.ComponentModel.Activity" /> Reprezentujący wypełniony zakres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzysta z aparatu wykonawczego przepływów pracy <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadCompletedContextActivity%2A> do zaimplementowania wynagrodzenia. Należy przywrócić identyczną kopię wypełniony zakres. Aby to zrobić, należy przywrócić prawidłową <xref:System.IO.Stream> z reprezentacji, ukończone zakresu danych magazynu. Następnie musisz przekazać ten <xref:System.IO.Stream> do jednej z przeciążonych metod <xref:System.Workflow.ComponentModel.Activity.Load%2A> do wykonania deserializacji zakresu.  
  
 Jeśli usługi trwałości, nie można załadować wypełniony zakres, z magazynu danych, należy zgłosić <xref:System.Workflow.Runtime.Hosting.PersistenceException> z odpowiedni komunikat.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano implementację `LoadCompletedContextActivity` metody. W tym przykładzie pochodzi z przykładu usługi trwałości niestandardowych z pliku FilePersistenceService.cs. Aby uzyskać więcej informacji, zobacz [przykładową usługę trwałości niestandardowe](http://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#269](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#269)]
 [!code-vb[WF_Samples#269](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#269)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadWorkflowInstanceState">
      <MemberSignature Language="C#" Value="protected internal abstract System.Workflow.ComponentModel.Activity LoadWorkflowInstanceState (Guid instanceId);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Workflow.ComponentModel.Activity LoadWorkflowInstanceState(valuetype System.Guid instanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadWorkflowInstanceState(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Function LoadWorkflowInstanceState (instanceId As Guid) As Activity" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract System::Workflow::ComponentModel::Activity ^ LoadWorkflowInstanceState(Guid instanceId);" />
      <MemberSignature Language="F#" Value="abstract member LoadWorkflowInstanceState : Guid -&gt; System.Workflow.ComponentModel.Activity" Usage="workflowPersistenceService.LoadWorkflowInstanceState instanceId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="instanceId">
          <see cref="T:System.Guid" /> Głównego działania wystąpienia przepływu pracy.</param>
        <summary>Po zaimplementowaniu w klasie pochodnej, ładuje określonego stanu wystąpienia przepływu pracy do pamięci.</summary>
        <returns>
          <see cref="T:System.Workflow.ComponentModel.Activity" /> Reprezentujący działania głównego wystąpienia przepływu pracy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przywrócić identyczną kopię działania. Aby to zrobić, należy przywrócić prawidłową <xref:System.IO.Stream> z reprezentacji, wystąpienia przepływu pracy w magazynie danych; następnie musisz przekazać ten <xref:System.IO.Stream> do jednej z przeciążonych <xref:System.Workflow.ComponentModel.Activity.Load%2A> metody deserializacji przepływu pracy wystąpienie stanu. Jeśli usługi trwałości, nie można załadować stanu wystąpienia przepływu pracy z magazynu danych, należy zgłosić <xref:System.Workflow.Runtime.Hosting.PersistenceException> z odpowiedni komunikat.  
  
 Aparatu wykonawczego przepływów pracy implementuje semantyką blokowania, aby ograniczyć dostęp do stanu wystąpienia przepływu pracy, który został zapisany w magazynie danych. To jest możliwy przez usługi trwałości, które są uruchamiane w wielu procesach. Blokowanie semantyki są przeznaczone do zapobiegania usługi trwałości, działających w dwóch różnych procesów z ładowania tego samego wystąpienia przepływu pracy do pamięci w tym samym czasie. W zależności od typu środowiska zaprojektowano usługę trwałości do pomocy technicznej, możesz wybrać opcję obsługi tej funkcji. Jeśli zdecydujesz się obsługiwać semantykę blokowania środowiska uruchomieniowego, lub jeśli ten przepływ pracy wystąpienie stan został wcześniej zablokowany przez inny proces, a następnie powinno zgłosić <xref:System.Workflow.Runtime.WorkflowOwnershipException>. W przeciwnym razie należy zablokować dostęp do stanu wystąpienia przepływu pracy w magazynie danych. Stan wystąpienia przepływu pracy może zostać odblokowany przez wywołanie <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnlockWorkflowInstanceState%2A> lub wywołanie <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A> z parametrem unlock równa `true`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano implementację `LoadWorkflowInstanceState` metody. W tym przykładzie pochodzi z przykładu usługi trwałości niestandardowych z pliku FilePersistenceService.cs. Aby uzyskać więcej informacji, zobacz [przykładową usługę trwałości niestandardowe](http://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#266](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#266)]
 [!code-vb[WF_Samples#266](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#266)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreFromDefaultSerializedForm">
      <MemberSignature Language="C#" Value="protected static System.Workflow.ComponentModel.Activity RestoreFromDefaultSerializedForm (byte[] activityBytes, System.Workflow.ComponentModel.Activity outerActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Workflow.ComponentModel.Activity RestoreFromDefaultSerializedForm(unsigned int8[] activityBytes, class System.Workflow.ComponentModel.Activity outerActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.RestoreFromDefaultSerializedForm(System.Byte[],System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function RestoreFromDefaultSerializedForm (activityBytes As Byte(), outerActivity As Activity) As Activity" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Workflow::ComponentModel::Activity ^ RestoreFromDefaultSerializedForm(cli::array &lt;System::Byte&gt; ^ activityBytes, System::Workflow::ComponentModel::Activity ^ outerActivity);" />
      <MemberSignature Language="F#" Value="static member RestoreFromDefaultSerializedForm : byte[] * System.Workflow.ComponentModel.Activity -&gt; System.Workflow.ComponentModel.Activity" Usage="System.Workflow.Runtime.Hosting.WorkflowPersistenceService.RestoreFromDefaultSerializedForm (activityBytes, outerActivity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activityBytes" Type="System.Byte[]" />
        <Parameter Name="outerActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="activityBytes">Serializowane postaci <see cref="T:System.Workflow.ComponentModel.Activity" />.</param>
        <param name="outerActivity">Zewnętrzny <see cref="T:System.Workflow.ComponentModel.Activity" />, zawierającego <see cref="T:System.Workflow.ComponentModel.Activity" /> do przywrócenia.</param>
        <summary>Przywraca <see cref="T:System.Workflow.ComponentModel.Activity" /> z jego serializowanej formie.</summary>
        <returns>Przywróconej <see cref="T:System.Workflow.ComponentModel.Activity" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano implementację `RestoreFromDefaultSerializedForm` metody. W tym przykładzie pochodzi z przykładu usługi trwałości niestandardowych z pliku FilePersistenceService.cs. Aby uzyskać więcej informacji, zobacz [przykładową usługę trwałości niestandardowe](http://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#269](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#269)]
 [!code-vb[WF_Samples#269](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#269)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveCompletedContextActivity">
      <MemberSignature Language="C#" Value="protected internal abstract void SaveCompletedContextActivity (System.Workflow.ComponentModel.Activity activity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SaveCompletedContextActivity(class System.Workflow.ComponentModel.Activity activity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveCompletedContextActivity(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void SaveCompletedContextActivity(System::Workflow::ComponentModel::Activity ^ activity);" />
      <MemberSignature Language="F#" Value="abstract member SaveCompletedContextActivity : System.Workflow.ComponentModel.Activity -&gt; unit" Usage="workflowPersistenceService.SaveCompletedContextActivity activity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="activity">
          <see cref="T:System.Workflow.ComponentModel.Activity" /> Reprezentujący wypełniony zakres.</param>
        <summary>Po zaimplementowaniu w klasie pochodnej, zapisuje określonego zakresu ukończone w magazynie danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aparatu wykonawczego przepływów pracy zapisuje stan ukończonych zakres działań w celu wdrożenia wynagrodzenia. Należy wywołać przeciążonej <xref:System.Workflow.ComponentModel.Activity.Save%2A> metod do wykonywania serializacji `activity` do <xref:System.IO.Stream>; następnie możesz dodatkowo przetwarzania <xref:System.IO.Stream> przed napisaniem go ze swoim magazynem danych. Jednakże, gdy aparatu wykonawczego przepływów pracy wywołuje <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadCompletedContextActivity%2A>, należy przywrócić identyczną kopię działania.  
  
 Użytkownik musi mieć możliwość skojarzyć ukończone zakres z otaczającego wystąpienia przepływu pracy, tak aby oznaczyć zakresu jako niepotrzebne w magazynie danych, gdy wystąpienie przepływu pracy zakończy się lub zostanie przerwane. W związku z tym, należy także zapisać <xref:System.Guid> wystąpienia przepływu pracy, który jest skojarzony z zakresem ukończone; to można uzyskać z <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> właściwość <xref:System.Workflow.Runtime.WorkflowInstance> skojarzone z `activity`.  
  
 <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadCompletedContextActivity%2A> Trwa <xref:System.Guid> ukończone zakresu jako parametr. W związku z tym, należy również zapisać <xref:System.Workflow.ComponentModel.ActivityExecutionContext.ContextGuid%2A> właściwości skojarzonej z `activity`. Ta właściwość może być przywoływany przez <xref:System.Workflow.ComponentModel.Activity.ActivityContextGuidProperty> pole `activity`.  
  
 W przypadku wdrażania usługi trwałości, korzystającą z magazynu trwałego, aby zachować spójność z wewnętrzny stan aparatu wykonawczego przepływów pracy, powinny uczestniczyć w transakcji przepływu pracy mają być odroczone rzeczywiste zapisu do trwałego magazynu do dzielenia na partie przepływ pracy zatwierdzania punktu. Aby uczestniczyć w przetwarzaniu wsadowym, Dodaj element roboczy do <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A> właściwość, która reprezentuje oczekujące zmiany w bazie danych i zaimplementować <xref:System.Workflow.Runtime.IPendingWork> interfejsu w usłudze trwałości.  
  
 Jeśli nie można zapisać wypełniony zakres ze swoim magazynem danych, należy zgłosić <xref:System.Workflow.Runtime.Hosting.PersistenceException> przy użyciu odpowiedniego komunikatu o błędzie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano implementację `SaveCompletedContextActivity` metody. W tym przykładzie pochodzi z przykładu usługi trwałości niestandardowych z pliku FilePersistenceService.cs. Aby uzyskać więcej informacji, zobacz [przykładową usługę trwałości niestandardowe](http://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#268](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#268)]
 [!code-vb[WF_Samples#268](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#268)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveWorkflowInstanceState">
      <MemberSignature Language="C#" Value="protected internal abstract void SaveWorkflowInstanceState (System.Workflow.ComponentModel.Activity rootActivity, bool unlock);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SaveWorkflowInstanceState(class System.Workflow.ComponentModel.Activity rootActivity, bool unlock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState(System.Workflow.ComponentModel.Activity,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Sub SaveWorkflowInstanceState (rootActivity As Activity, unlock As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void SaveWorkflowInstanceState(System::Workflow::ComponentModel::Activity ^ rootActivity, bool unlock);" />
      <MemberSignature Language="F#" Value="abstract member SaveWorkflowInstanceState : System.Workflow.ComponentModel.Activity * bool -&gt; unit" Usage="workflowPersistenceService.SaveWorkflowInstanceState (rootActivity, unlock)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
        <Parameter Name="unlock" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rootActivity">Działania głównego wystąpienia przepływu pracy.</param>
        <param name="unlock">
          <see langword="true" /> Jeśli wystąpienie przepływu pracy nie ma być zablokowane; <see langword="false" /> Jeśli wystąpienie przepływu pracy ma być zablokowane.</param>
        <summary>Po zaimplementowaniu w klasie pochodnej, zapisuje stan wystąpienia przepływu pracy w magazynie danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy wywołać przeciążonej <xref:System.Workflow.ComponentModel.Activity.Save%2A> metod do wykonywania serializacji `rootActivity` do <xref:System.IO.Stream>. Następnie użytkownik może także przetwarzać <xref:System.IO.Stream> przed napisaniem go ze swoim magazynem danych. Jednakże, gdy aparatu wykonawczego przepływów pracy wywołuje <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadWorkflowInstanceState%2A>, należy przywrócić identyczną kopię działania głównego. Jeśli nie można zapisać stanu wystąpienia przepływu pracy ze swoim magazynem danych, należy zgłosić <xref:System.Workflow.Runtime.Hosting.PersistenceException> przy użyciu odpowiedniego komunikatu o błędzie.  
  
 Aparatu wykonawczego przepływów pracy zapewnia semantykę blokowania, aby ograniczyć dostęp do stanu wystąpienia przepływu pracy, który został zapisany w magazynie danych. To jest możliwy przez usługi trwałości, działające w wielu hostach i wskazanie na tym samym magazynie danych. Blokowanie semantyki są przeznaczone do zapobiegania usługi trwałości, działających w dwóch różnych przepływu pracy środowiska uruchomieniowe z ładowania tego samego wystąpienia przepływu pracy do pamięci w tym samym czasie. W zależności od typu środowiska, które usługi trwałości jest przeznaczona do obsługi możesz wybrać, czy obsługują tę funkcję. Jeśli zdecydujesz się obsługiwać semantykę blokowania środowiska uruchomieniowego, a następnie, jeśli usługa trwałości próbuje zapisać stanu wystąpienia przepływu pracy, który wcześniej został zablokowany przez inną usługę trwałości, powinien zgłaszać <xref:System.Workflow.Runtime.WorkflowOwnershipException>. Jeśli `unlock` jest `true`, należy odblokować dostęp do stanu wystąpienia przepływu pracy, po jego zapisaniu.  
  
 <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadWorkflowInstanceState%2A> Trwa <xref:System.Guid> wystąpienia przepływu pracy jako parametr. W związku z tym, należy zapisać ten <xref:System.Guid>. Możesz również użyć tej funkcji <xref:System.Guid> skojarzyć wystąpienie przepływu pracy z zapisanymi stanami z jego zakresów ukończone. Należy to zrobić, ponieważ musi umożliwiać oznaczyć te zakresy ukończone, jako niepotrzebne po ukończeniu wystąpienie przepływu pracy.  
  
 Środowisko uruchomieniowe wywołuje aparat przepływu pracy <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A> końcowego godzinę ukończone lub zakończone wystąpienia przepływu pracy. W związku z tym jeśli <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetWorkflowStatus%2A> jest równa <xref:System.Workflow.Runtime.WorkflowStatus.Completed> lub <xref:System.Workflow.Runtime.WorkflowStatus.Terminated>, można bezpiecznie usunąć wystąpienie przepływu pracy i jego skojarzone zakresy ukończone z magazynu danych. Alternatywnie, możesz zasubskrybować <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowCompleted> lub <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowTerminated> zdarzenia w celu określenia, kiedy jest bezpiecznie usunąć rekordy skojarzone z wystąpieniem przepływu pracy. Czy rzeczywiście usuwania rekordów z magazynu danych, zależy od implementacji.  
  
 Jeśli implementacji usługi trwałości, która korzysta z magazynu trwałego, a następnie, aby zachować spójność z wewnętrzny stan aparatu wykonawczego przepływów pracy, należy wziąć udział w transakcji przepływu pracy, przetwarzanie wsadowe mają być odroczone rzeczywiste zapisu do trwałego magazynu do przepływ pracy zatwierdzania punktu. Aby uczestniczyć w przetwarzaniu wsadowym, Dodaj element roboczy, który reprezentuje oczekujące zmiany do magazynu trwałego na <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A> właściwości i implementowanie <xref:System.Workflow.Runtime.IPendingWork> interfejsu w usłudze trwałości.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano implementację `SaveWorkflowInstanceState` metody. W tym przykładzie pochodzi z przykładu usługi trwałości niestandardowych z pliku FilePersistenceService.cs. Aby uzyskać więcej informacji, zobacz [przykładową usługę trwałości niestandardowe](http://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#264](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#264)]
 [!code-vb[WF_Samples#264](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#264)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadOnIdle">
      <MemberSignature Language="C#" Value="protected internal abstract bool UnloadOnIdle (System.Workflow.ComponentModel.Activity activity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool UnloadOnIdle(class System.Workflow.ComponentModel.Activity activity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnloadOnIdle(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract bool UnloadOnIdle(System::Workflow::ComponentModel::Activity ^ activity);" />
      <MemberSignature Language="F#" Value="abstract member UnloadOnIdle : System.Workflow.ComponentModel.Activity -&gt; bool" Usage="workflowPersistenceService.UnloadOnIdle activity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="activity">
          <see cref="T:System.Workflow.ComponentModel.Activity" /> Reprezentujący wypełniony zakres.</param>
        <summary>Określa, czy przepływ pracy powinna być zwolniona podczas bezczynności.</summary>
        <returns>Jeśli <see langword="true" />, aparatu wykonawczego przepływów pracy zwalnia określonego przepływu pracy, gdy staje się nieaktywna.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano implementację `UnloadOnIdle` metody. W tym przykładzie pochodzi z przykładu usługi trwałości niestandardowych z pliku FilePersistenceService.cs. Aby uzyskać więcej informacji, zobacz [przykładową usługę trwałości niestandardowe](http://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#270](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#270)]
 [!code-vb[WF_Samples#270](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#270)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnlockWorkflowInstanceState">
      <MemberSignature Language="C#" Value="protected internal abstract void UnlockWorkflowInstanceState (System.Workflow.ComponentModel.Activity rootActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void UnlockWorkflowInstanceState(class System.Workflow.ComponentModel.Activity rootActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnlockWorkflowInstanceState(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Sub UnlockWorkflowInstanceState (rootActivity As Activity)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void UnlockWorkflowInstanceState(System::Workflow::ComponentModel::Activity ^ rootActivity);" />
      <MemberSignature Language="F#" Value="abstract member UnlockWorkflowInstanceState : System.Workflow.ComponentModel.Activity -&gt; unit" Usage="workflowPersistenceService.UnlockWorkflowInstanceState rootActivity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="rootActivity">Działania głównego wystąpienia przepływu pracy.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, odblokowuje stanu wystąpienia przepływu pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest abstrakcyjna, więc nie zawiera implementacji domyślnej, na blokowanie i odblokowywanie.  
  
 Podczas wdrażania usługi do niestandardowego, jeśli chcesz zaimplementować blokowania schematu musisz przesłonić tę metodę i mechanizm blokowania odblokowywania w <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A> metody na podstawie wartości parametru odblokowania.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano implementację `UnlockWorkflowInstanceState` metody. W tym przykładzie pochodzi z przykładu usługi trwałości niestandardowych z pliku FilePersistenceService.cs. Aby uzyskać więcej informacji, zobacz [przykładową usługę trwałości niestandardowe](http://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#267](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#267)]
 [!code-vb[WF_Samples#267](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#267)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
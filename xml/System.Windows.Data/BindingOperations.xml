<Type Name="BindingOperations" FullName="System.Windows.Data.BindingOperations">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bd6c8d921090628de948182b18107a0340ae04db" /><Meta Name="ms.sourcegitcommit" Value="f9e71795ba0f9c2dfaa74bec233343ed0f3ffd99" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="03/14/2019" /><Meta Name="ms.locfileid" Value="57935045" /></Metadata><TypeSignature Language="C#" Value="public static class BindingOperations" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit BindingOperations extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Data.BindingOperations" />
  <TypeSignature Language="VB.NET" Value="Public Class BindingOperations" />
  <TypeSignature Language="C++ CLI" Value="public ref class BindingOperations abstract sealed" />
  <TypeSignature Language="F#" Value="type BindingOperations = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zawiera metody statyczne służące do manipulowania powiązań, w tym <see cref="T:System.Windows.Data.Binding" />, <see cref="T:System.Windows.Data.MultiBinding" />, i <see cref="T:System.Windows.Data.PriorityBinding" /> obiektów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa udostępnia zestaw metod statycznych, które służą jako operacje pomocnika dla powiązania danych.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AccessCollection">
      <MemberSignature Language="C#" Value="public static void AccessCollection (System.Collections.IEnumerable collection, Action accessMethod, bool writeAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AccessCollection(class System.Collections.IEnumerable collection, class System.Action accessMethod, bool writeAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.AccessCollection(System.Collections.IEnumerable,System.Action,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AccessCollection (collection As IEnumerable, accessMethod As Action, writeAccess As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AccessCollection(System::Collections::IEnumerable ^ collection, Action ^ accessMethod, bool writeAccess);" />
      <MemberSignature Language="F#" Value="static member AccessCollection : System.Collections.IEnumerable * Action * bool -&gt; unit" Usage="System.Windows.Data.BindingOperations.AccessCollection (collection, accessMethod, writeAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="accessMethod" Type="System.Action" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="writeAccess" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="collection">Kolekcja do uzyskania dostępu.</param>
        <param name="accessMethod">Akcja do wykonania w kolekcji.</param>
        <param name="writeAccess"><see langword="true" /> Jeśli <paramref name="accessMethod" /> będzie zapisywać w kolekcji; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zapewnia dostęp do kolekcji przy użyciu mechanizmu synchronizacji, czy aplikacja określiła, gdy jest ona wywoływana EnableCollectionSynchronization.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearAllBindings">
      <MemberSignature Language="C#" Value="public static void ClearAllBindings (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearAllBindings(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.ClearAllBindings(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearAllBindings (target As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearAllBindings(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member ClearAllBindings : System.Windows.DependencyObject -&gt; unit" Usage="System.Windows.Data.BindingOperations.ClearAllBindings target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt, z którego chcesz usunąć powiązania.</param>
        <summary>Usuwa wszystkie powiązania, łącznie z powiązania typu <see cref="T:System.Windows.Data.Binding" />, <see cref="T:System.Windows.Data.MultiBinding" />, i <see cref="T:System.Windows.Data.PriorityBinding" />, z określonego <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określony obiekt nie jest powiązany z danymi, ta metoda nie ma znaczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Jeśli <paramref name="target" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClearBinding">
      <MemberSignature Language="C#" Value="public static void ClearBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.ClearBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearBinding (target As DependencyObject, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member ClearBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="System.Windows.Data.BindingOperations.ClearBinding (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt, z którego chcesz usunąć powiązanie.</param>
        <param name="dp">Właściwości zależności, z którego chcesz usunąć powiązanie.</param>
        <summary>Usuwa powiązania z właściwością, jeśli taka istnieje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dana właściwość jest powiązane z danymi za pomocą <xref:System.Windows.Data.Binding>, <xref:System.Windows.Data.PriorityBinding>, lub <xref:System.Windows.Data.MultiBinding>, ta metoda usuwa odpowiedniego wyrażenia wiązania i przywraca wartość właściwości sprzed dowolnej wartości lokalnych została ustawiona za pomocą powiązania.  
  
 Jeśli dana właściwość nie jest powiązany z danymi, ta metoda nie ma znaczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> i <paramref name="dp" /> parametry nie mogą być <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CollectionRegistering">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Windows.Data.CollectionRegisteringEventArgs&gt; CollectionRegistering;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.CollectionRegisteringEventArgs&gt; CollectionRegistering" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.BindingOperations.CollectionRegistering" />
      <MemberSignature Language="VB.NET" Value="Public Shared Event CollectionRegistering As EventHandler(Of CollectionRegisteringEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Windows::Data::CollectionRegisteringEventArgs ^&gt; ^ CollectionRegistering;" />
      <MemberSignature Language="F#" Value="member this.CollectionRegistering : EventHandler&lt;System.Windows.Data.CollectionRegisteringEventArgs&gt; " Usage="member this.CollectionRegistering : System.EventHandler&lt;System.Windows.Data.CollectionRegisteringEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.CollectionRegisteringEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy system powiązań danych uwagi dotyczące innych kolekcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionViewRegistering">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Windows.Data.CollectionViewRegisteringEventArgs&gt; CollectionViewRegistering;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.CollectionViewRegisteringEventArgs&gt; CollectionViewRegistering" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.BindingOperations.CollectionViewRegistering" />
      <MemberSignature Language="VB.NET" Value="Public Shared Event CollectionViewRegistering As EventHandler(Of CollectionViewRegisteringEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Windows::Data::CollectionViewRegisteringEventArgs ^&gt; ^ CollectionViewRegistering;" />
      <MemberSignature Language="F#" Value="member this.CollectionViewRegistering : EventHandler&lt;System.Windows.Data.CollectionViewRegisteringEventArgs&gt; " Usage="member this.CollectionViewRegistering : System.EventHandler&lt;System.Windows.Data.CollectionViewRegisteringEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.CollectionViewRegisteringEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy system powiązanie danych zauważa, widok kolekcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableCollectionSynchronization">
      <MemberSignature Language="C#" Value="public static void DisableCollectionSynchronization (System.Collections.IEnumerable collection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DisableCollectionSynchronization(class System.Collections.IEnumerable collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.DisableCollectionSynchronization(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DisableCollectionSynchronization (collection As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DisableCollectionSynchronization(System::Collections::IEnumerable ^ collection);" />
      <MemberSignature Language="F#" Value="static member DisableCollectionSynchronization : System.Collections.IEnumerable -&gt; unit" Usage="System.Windows.Data.BindingOperations.DisableCollectionSynchronization collection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="collection">Kolekcja do usunięcia zsynchronizowany dostęp z.</param>
        <summary>Usuń synchronizacji zarejestrowanych dla określonej kolekcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisconnectedSource">
      <MemberSignature Language="C#" Value="public static object DisconnectedSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property object DisconnectedSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingOperations.DisconnectedSource" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DisconnectedSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Object ^ DisconnectedSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DisconnectedSource : obj" Usage="System.Windows.Data.BindingOperations.DisconnectedSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który zastępuje <see cref="P:System.Windows.FrameworkElement.DataContext" /> po usunięciu kontenera elementu z drzewa wizualnego.</summary>
        <value>Obiekt, który zastępuje <see cref="P:System.Windows.FrameworkElement.DataContext" /> po usunięciu kontenera elementu z drzewa wizualnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej właściwości należy użyć, jeśli potrzebujesz radzenia sobie z <xref:System.Windows.FrameworkElement.DataContext%2A> kontenera elementu.  Kontenera elementu jest elementem interfejsu użytkownika, który wyświetla element <xref:System.Windows.Controls.ItemsControl>.  Gdy <xref:System.Windows.Controls.ItemsControl> dane powiązane z kolekcją, kontenera elementu jest generowany dla każdego elementu.  W niektórych przypadkach kontenerów elementów są usuwane z drzewa wizualnego.  Są dwa typowe przypadki, gdzie kontenera elementu jest usuwany, gdy element zostanie usunięty z kolekcji źródłowej, a gdy włączona jest wirtualizacja <xref:System.Windows.Controls.ItemsControl>.  W takich przypadkach <xref:System.Windows.FrameworkElement.DataContext%2A> właściwości kontenera elementu jest równa <xref:System.Windows.Data.BindingOperations.DisconnectedSource%2A> właściwość, należy sprawdzić, czy <xref:System.Windows.FrameworkElement.DataContext%2A> jest równa <xref:System.Windows.Data.BindingOperations.DisconnectedSource%2A> przed uzyskaniem dostępu do <xref:System.Windows.FrameworkElement.DataContext%2A> w <xref:System.Windows.FrameworkElement.DataContextChanged> zdarzeń dla elementu kontenery. Aby uzyskać więcej informacji na temat kontenerów elementów i wirtualizacji, zobacz uwagi w <xref:System.Windows.Controls.VirtualizingStackPanel> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnableCollectionSynchronization">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Włącza <see cref="T:System.Windows.Data.CollectionView" /> obiekt, aby uczestniczyć w synchronizacji dostępu do kolekcji, która jest używana w wielu wątkach.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Aplikacja WPF można wyświetlić kolekcję danych przy użyciu <xref:System.Windows.Controls.ItemsControl> lub jedna z jej podklasach (<xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.DataGrid>, <xref:System.Windows.Controls.TreeView>, <xref:System.Windows.Controls.ListView>itp.). WPF kanałów jego dostęp do kolekcji za pomocą podklasą <xref:System.Windows.Data.CollectionView>. Zarówno <xref:System.Windows.Controls.ItemsControl> i <xref:System.Windows.Data.CollectionView> miał koligacje do wątku, na którym <xref:System.Windows.Controls.ItemsControl> został utworzony, co oznacza, że ich użycie w innym wątku jest zabroniona i zgłasza wyjątek. W efekcie to ograniczenie obowiązuje również w kolekcji.
 
Można użyć kolekcji w wielu wątkach.   Na przykład chcesz zaktualizować kolekcji (Dodawanie lub usuwanie elementów) w wątku "zbieranie danych", podczas wyświetlania wyników w wątku "interfejs użytkownika", dzięki czemu interfejs użytkownika reaguje podczas gromadzenia danych dzieje się. W takiej sytuacji odpowiedzialność za zapewnienie zsynchronizowane dostępu ("wątkowo") do kolekcji.   Zazwyczaj jest to wykonywane przy użyciu mechanizmu prostą blokadą lub bardziej rozbudowany mechanizm synchronizacji takich jak semaforów, resetowania, zdarzenia itp.   Gdy należy zsynchronizować dostęp aplikacji do kolekcji, musisz również zagwarantować, że dostęp z WPF (w szczególności z <xref:System.Windows.Data.CollectionView>) uczestniczy w ten sam mechanizm synchronizacji.  Można to zrobić, wywołując <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> metody.
 
Aby użyć kolekcji w wielu wątkach, z których jedna jest wątku interfejsu użytkownika, który jest właścicielem <xref:System.Windows.Controls.ItemsControl>, aplikacja ma następujące obowiązki:

1. Wybierz mechanizm synchronizacji.

1. Zsynchronizuj dostęp z aplikacji do kolekcji przy użyciu tego mechanizmu.

1. Wywołaj <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> poinformować WPF mechanizmu.

   - Wywołanie musi nastąpić w wątku interfejsu użytkownika.

   - Wywołanie musi wystąpić przed użyciem kolekcji w innym wątku niż dołączania kolekcji <xref:System.Windows.Controls.ItemsControl>, która kwota jest nowszy.

   - Wywołaj <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)> przeciążenia, jeśli przy użyciu mechanizmu prostą blokadą; wywołania <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)> przeciążenia, jeśli przy użyciu mechanizmu bardziej rozbudowany.

1. Upewnij się, że zmiany do kolekcji i powiadomienia o tej zmianie (za pośrednictwem <xref:System.Collections.Specialized.INotifyCollectionChanged>) są niepodzielne; Brak dostępu z innych wątków może interwencji.  (Jest to zazwyczaj bezpłatne. For instance <xref:System.Collections.ObjectModel.ObservableCollection%601> gwarantuje to, pod warunkiem, że wszystkie zmiany są chronione przy użyciu synchronizacji.)

1. Jeśli wywołasz <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, że wywołanie również musi wystąpić w wątku interfejsu użytkownika.

1. Jeśli chcesz korzystać z tej samej kolekcji na wiele wątków interfejsu użytkownika, należy wywołać <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> (i <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, jeśli to konieczne) oddzielnie w każdym wątku interfejsu użytkownika.

1. Należy unikać zakleszczenia.  To już odpowiedzialność aplikacji po jej zdecydował się użyć synchronizacji, ale należy również wziąć pod uwagę WPF uczestnictwa w synchronizacji, zgodnie z opisem w poniższej akapitu.

W zamian WPF zapewnia następujące zachowanie:

- <xref:System.Windows.Data.CollectionView> Uzyskuje dostęp do kolekcji przy użyciu mechanizmu danego synchronizacji.

- <xref:System.Windows.Data.CollectionView> Przechowuje "kopii w tle" kolekcji do użycia w wątku interfejsu użytkownika.

- <xref:System.Windows.Data.CollectionView.CollectionChanged> zdarzenia są kolejkowane w górę, podczas ich dostarczania (wątek).

- Oczekujące zdarzenia są stosowane do kopii w tle asynchronicznie w wątku interfejsu użytkownika, gdy ma on taką możliwość.

- <xref:System.Windows.Data.CollectionView> Bezpośrednio nie będzie używać inny mechanizm synchronizacji, widoczny dla aplikacji. Jest WPF w sposób uniknięcia zakleszczenie (zobacz poprzednią pozycję 7).   

Efektem sieciowym jest, można zmienić kolekcji na żadnym z wątków, a te zmiany są widoczne po pewnym czasie w <xref:System.Windows.Controls.ItemsControl> kiedy wątek interfejsu użytkownika ma czas "Łap".  Implementacja ma została dostosowana do ograniczania szybkości, że zmiany przepływu w wątku interfejsu użytkownika, aby zachować tła wątki określanie nasycenia wątku interfejsu użytkownika i poszczególne odpowiedzi na dane wejściowe zwykłego użytkownika.

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnableCollectionSynchronization">
      <MemberSignature Language="C#" Value="public static void EnableCollectionSynchronization (System.Collections.IEnumerable collection, object lockObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableCollectionSynchronization(class System.Collections.IEnumerable collection, object lockObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableCollectionSynchronization (collection As IEnumerable, lockObject As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableCollectionSynchronization(System::Collections::IEnumerable ^ collection, System::Object ^ lockObject);" />
      <MemberSignature Language="F#" Value="static member EnableCollectionSynchronization : System.Collections.IEnumerable * obj -&gt; unit" Usage="System.Windows.Data.BindingOperations.EnableCollectionSynchronization (collection, lockObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lockObject" Type="System.Object" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="collection">Kolekcja, która wymaga zsynchronizowany dostęp.</param>
        <param name="lockObject">Obiekt do zablokowania podczas uzyskiwania dostępu do kolekcji.</param>
        <summary>Włącza <see cref="T:System.Windows.Data.CollectionView" /> obiekt, aby uczestniczyć w synchronizacji dostęp do kolekcji, używany w wielu wątkach, za pomocą prostego mechanizm blokowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

Aplikacja WPF można wyświetlić kolekcję danych przy użyciu <xref:System.Windows.Controls.ItemsControl> lub jedna z jej podklasach (<xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.DataGrid>, <xref:System.Windows.Controls.TreeView>, <xref:System.Windows.Controls.ListView>itp.). WPF kanałów jego dostęp do kolekcji za pomocą podklasą <xref:System.Windows.Data.CollectionView>. Zarówno <xref:System.Windows.Controls.ItemsControl> i <xref:System.Windows.Data.CollectionView> miał koligacje do wątku, na którym <xref:System.Windows.Controls.ItemsControl> został utworzony, co oznacza, że ich użycie w innym wątku jest zabroniona i zgłasza wyjątek. W efekcie to ograniczenie obowiązuje również w kolekcji.
 
Można użyć kolekcji w wielu wątkach.   Na przykład chcesz zaktualizować kolekcji (Dodawanie lub usuwanie elementów) w wątku "zbieranie danych", podczas wyświetlania wyników w wątku "interfejs użytkownika", dzięki czemu interfejs użytkownika reaguje podczas gromadzenia danych dzieje się. W takiej sytuacji Ty ponosisz odpowiedzialność za zapewnienie synchronizacji ("wątkowo") dostęp do kolekcji, a także za zapewnienie dostęp z WPF (w szczególności z <xref:System.Windows.Data.CollectionView>) uczestniczy w ten sam mechanizm synchronizacji. Przez wywołanie metody <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)> metody, można to zrobić za pomocą mechanizmu prostą blokadą. 
 
Aby użyć kolekcji w wielu wątkach, z których jedna jest wątku interfejsu użytkownika, który jest właścicielem <xref:System.Windows.Controls.ItemsControl>, należy wykonać następujące czynności:

1. Tworzy obiekt do zablokowania podczas uzyskiwania dostępu do kolekcji.

1. Synchronizuj wszelki dostęp z aplikacji do kolekcji przez blokowanie tego obiektu.

1. Wywołaj <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)> poinformować WPF, że używasz mechanizm prostą blokadą.

   - Wywołanie musi nastąpić w wątku interfejsu użytkownika.

   - Wywołanie musi wystąpić przed użyciem kolekcji w innym wątku niż dołączania kolekcji <xref:System.Windows.Controls.ItemsControl>, która kwota jest nowszy.

1. Upewnij się, że zmiany do kolekcji i powiadomienia o tej zmianie (za pośrednictwem <xref:System.Collections.Specialized.INotifyCollectionChanged>) są niepodzielne; Brak dostępu z innych wątków może interwencji.  (Jest to zazwyczaj bezpłatne. For instance <xref:System.Collections.ObjectModel.ObservableCollection%601> gwarantuje to, pod warunkiem, że wszystkie zmiany są chronione przy użyciu synchronizacji.)

1. Jeśli wywołasz <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, że wywołanie również musi wystąpić w wątku interfejsu użytkownika.

1. Jeśli chcesz korzystać z tej samej kolekcji na wiele wątków interfejsu użytkownika, należy wywołać <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> (i <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, jeśli to konieczne) oddzielnie w każdym wątku interfejsu użytkownika.

1. Należy unikać zakleszczenia.  Ten element jest już odpowiedzialność aplikacji po jej zdecydował się użyć synchronizacji, ale jej należy również wziąć pod uwagę w WPF uczestnictwa w synchronizacji. (Zobacz więcej informacji, poniżej).

W zamian WPF zapewnia następujące zachowanie:

- <xref:System.Windows.Data.CollectionView> Uzyskuje dostęp do kolekcji przy użyciu mechanizm blokowania.

- <xref:System.Windows.Data.CollectionView> Przechowuje "kopii w tle" kolekcji do użycia w wątku interfejsu użytkownika.

- <xref:System.Windows.Data.CollectionView.CollectionChanged> zdarzenia są kolejkowane w górę, podczas ich dostarczania (wątek).

- Oczekujące zdarzenia są stosowane do kopii w tle asynchronicznie w wątku interfejsu użytkownika, gdy ma on taką możliwość.

- <xref:System.Windows.Data.CollectionView> Zostanie bezpośrednio Użyj inny mechanizm synchronizacji, widoczny dla aplikacji. Jest WPF w sposób uniknięcia zakleszczenie (zobacz poprzednią pozycję 7).   

Efektem sieciowym jest, można zmienić kolekcji na żadnym z wątków, a te zmiany są widoczne po pewnym czasie w <xref:System.Windows.Controls.ItemsControl> kiedy wątek interfejsu użytkownika ma czas "Łap".  Implementacja ma została dostosowana do ograniczania szybkości, że zmiany przepływu w wątku interfejsu użytkownika, aby zachować tła wątki określanie nasycenia wątku interfejsu użytkownika i poszczególne odpowiedzi na dane wejściowe zwykłego użytkownika.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableCollectionSynchronization">
      <MemberSignature Language="C#" Value="public static void EnableCollectionSynchronization (System.Collections.IEnumerable collection, object context, System.Windows.Data.CollectionSynchronizationCallback synchronizationCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableCollectionSynchronization(class System.Collections.IEnumerable collection, object context, class System.Windows.Data.CollectionSynchronizationCallback synchronizationCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableCollectionSynchronization (collection As IEnumerable, context As Object, synchronizationCallback As CollectionSynchronizationCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableCollectionSynchronization(System::Collections::IEnumerable ^ collection, System::Object ^ context, System::Windows::Data::CollectionSynchronizationCallback ^ synchronizationCallback);" />
      <MemberSignature Language="F#" Value="static member EnableCollectionSynchronization : System.Collections.IEnumerable * obj * System.Windows.Data.CollectionSynchronizationCallback -&gt; unit" Usage="System.Windows.Data.BindingOperations.EnableCollectionSynchronization (collection, context, synchronizationCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="context" Type="System.Object" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="synchronizationCallback" Type="System.Windows.Data.CollectionSynchronizationCallback" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="collection">Kolekcja, która wymaga zsynchronizowany dostęp.</param>
        <param name="context">Obiekt, który jest przekazywany do wywołania zwrotnego.</param>
        <param name="synchronizationCallback">Wywołanie zwrotne, które jest wywoływane zawsze wtedy, gdy wymagany jest dostęp do kolekcji. Służy on do upewnij się, że kolekcja uzyskuje się dostęp za jeden wątek jednocześnie.</param>
        <summary>Włącza <see cref="T:System.Windows.Data.CollectionView" /> obiekt, aby uczestniczyć w synchronizacji dostęp do kolekcji, używany w wielu wątkach, za pomocą mechanizmu niż prostą blokadą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Aplikacja WPF można wyświetlić kolekcję danych przy użyciu <xref:System.Windows.Controls.ItemsControl> lub jedna z jej podklasach (<xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.DataGrid>, <xref:System.Windows.Controls.TreeView>, <xref:System.Windows.Controls.ListView>itp.). WPF kanałów jego dostęp do kolekcji za pomocą podklasą <xref:System.Windows.Data.CollectionView>. Zarówno <xref:System.Windows.Controls.ItemsControl> i <xref:System.Windows.Data.CollectionView> miał koligacje do wątku, na którym <xref:System.Windows.Controls.ItemsControl> został utworzony, co oznacza, że ich użycie w innym wątku jest zabroniona i zgłasza wyjątek. W efekcie to ograniczenie obowiązuje również w kolekcji.
 
Można użyć kolekcji w wielu wątkach.   Na przykład chcesz zaktualizować kolekcji (Dodawanie lub usuwanie elementów) w wątku "zbieranie danych", podczas wyświetlania wyników w wątku "interfejs użytkownika", dzięki czemu interfejs użytkownika reaguje podczas gromadzenia danych dzieje się. W takiej sytuacji Ty ponosisz odpowiedzialność za zapewnienie synchronizacji ("wątkowo") dostęp do kolekcji, a także za zapewnienie dostęp z WPF (w szczególności z <xref:System.Windows.Data.CollectionView>) uczestniczy w ten sam mechanizm synchronizacji. Przez wywołanie metody <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)> metody, można to zrobić za pomocą mechanizmu synchronizacji, takie jak semaforów, zdarzeniach, resetowanego itp.   Aby użyć kolekcji w wielu wątkach, z których jedna jest wątku interfejsu użytkownika, który jest właścicielem <xref:System.Windows.Controls.ItemsControl>, należy wykonać następujące czynności:

1. Wybierz mechanizm synchronizacji.

1. Zsynchronizuj dostęp z aplikacji do kolekcji przy użyciu tego mechanizmu.

1. Wywołaj <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)> przeciążenia poinformować WPF używają mechanizm niż proste blokowania.

   - Wywołanie musi nastąpić w wątku interfejsu użytkownika.

   - Wywołanie musi wystąpić przed użyciem kolekcji w innym wątku niż dołączania kolekcji <xref:System.Windows.Controls.ItemsControl>, która kwota jest nowszy.

1. Upewnij się, że zmiany do kolekcji i powiadomienia o tej zmianie (za pośrednictwem <xref:System.Collections.Specialized.INotifyCollectionChanged>) są niepodzielne; Brak dostępu z innych wątków może interwencji.  (Jest to zazwyczaj bezpłatne. For instance <xref:System.Collections.ObjectModel.ObservableCollection%601> gwarantuje to, pod warunkiem, że wszystkie zmiany są chronione przy użyciu synchronizacji.)

1. Jeśli wywołasz <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, że wywołanie również musi wystąpić w wątku interfejsu użytkownika.

1. Jeśli chcesz korzystać z tej samej kolekcji na wiele wątków interfejsu użytkownika, należy wywołać <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> (i <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, jeśli to konieczne) oddzielnie w każdym wątku interfejsu użytkownika.

1. Należy unikać zakleszczenia.  Ten element jest już odpowiedzialność aplikacji po jej zdecydował się użyć synchronizacji, ale jej należy również wziąć pod uwagę w WPF uczestnictwa w synchronizacji. (Zobacz więcej informacji, poniżej).

W zamian WPF zapewnia następujące zachowanie:

- <xref:System.Windows.Data.CollectionView> Uzyskuje dostęp do kolekcji, wywołując zarejestrowaną <xref:System.Windows.Data.CollectionSynchronizationCallback> z następującymi argumentami:

   - `collection`: kolekcja zainteresowania.
   - `context`: obiekt kontekstu zarejestrowane.
   - `accessMethod`: delegat, który przeprowadza rzeczywiste dostępu.
   - `writeAccess`: `true` Jeśli delegat zmodyfikuje kolekcji `false` inaczej.

   Twoje <xref:System.Windows.Data.CollectionSynchronizationCallback> ustanowić synchronizacji w kolekcji (przy użyciu `context` obiektu i `writeAccess` wartość zgodnie z potrzebami), wywołanie `accessMethod`, zwolnij synchronizacji.

- <xref:System.Windows.Data.CollectionView> Przechowuje "kopii w tle" kolekcji do użycia w wątku interfejsu użytkownika.

- <xref:System.Windows.Data.CollectionView.CollectionChanged> zdarzenia są kolejkowane w górę, podczas ich dostarczania (wątek).

- Oczekujące zdarzenia są stosowane do kopii w tle asynchronicznie w wątku interfejsu użytkownika, gdy ma on taką możliwość.

- <xref:System.Windows.Data.CollectionView> Zostanie bezpośrednio Użyj inny mechanizm synchronizacji, widoczny dla aplikacji. Jest WPF w sposób uniknięcia zakleszczenie (zobacz poprzednią pozycję 7).   

Efektem sieciowym jest, można zmienić kolekcji na żadnym z wątków, a te zmiany są widoczne po pewnym czasie w <xref:System.Windows.Controls.ItemsControl> kiedy wątek interfejsu użytkownika ma czas "Łap".  Implementacja ma została dostosowana do ograniczania szybkości, że zmiany przepływu w wątku interfejsu użytkownika, aby zachować tła wątki określanie nasycenia wątku interfejsu użytkownika i poszczególne odpowiedzi na dane wejściowe zwykłego użytkownika.

 `context` Parametr jest dowolnego obiektu, który jest przekazywany do `callback`. Służy do określenia mechanizm synchronizacji, używane do kontrolowania dostępu do `collection`. `Context` może być `null`.  
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBinding">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.Binding GetBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.Binding GetBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBinding (target As DependencyObject, dp As DependencyProperty) As Binding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::Binding ^ GetBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.Binding" Usage="System.Windows.Data.BindingOperations.GetBinding (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.Binding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt gdzie <paramref name="dp" /> jest.</param>
        <param name="dp">Właściwość target powiązania z którego mają zostać pobrane powiązania.</param>
        <summary>Pobiera <see cref="T:System.Windows.Data.Binding" /> obiektu, który jest ustawiony dla określonej właściwości.</summary>
        <returns><see cref="T:System.Windows.Data.Binding" /> Nastavit Pro vlastnost danego obiektu lub <see langword="null" /> Jeśli <see cref="T:System.Windows.Data.Binding" /> obiekt został ustawiony.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> i <paramref name="dp" /> parametry nie mogą mieć wartości null.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetMultiBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetPriorityBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetBindingBase">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.BindingBase GetBindingBase (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.BindingBase GetBindingBase(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBindingBase (target As DependencyObject, dp As DependencyProperty) As BindingBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::BindingBase ^ GetBindingBase(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetBindingBase : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingBase" Usage="System.Windows.Data.BindingOperations.GetBindingBase (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt gdzie <paramref name="dp" /> jest.</param>
        <param name="dp">Właściwość target powiązania, z którego mają zostać pobrane <see cref="T:System.Windows.Data.BindingBase" /> obiektu.</param>
        <summary>Pobiera <see cref="T:System.Windows.Data.BindingBase" /> obiektu, który jest ustawiony dla określonej właściwości.</summary>
        <returns><see cref="T:System.Windows.Data.BindingBase" /> Obiektu, który jest ustawiony na danej właściwości lub <see langword="null" /> Jeśli został ustawiony żaden obiekt wiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.BindingBase> Klasa jest wspólna klasa bazowa dla <xref:System.Windows.Data.Binding>, <xref:System.Windows.Data.PriorityBinding>, i <xref:System.Windows.Data.MultiBinding> klasy. Możesz użyć <xref:System.Windows.Data.BindingOperations.GetBinding%2A>, <xref:System.Windows.Data.BindingOperations.GetPriorityBinding%2A>, i <xref:System.Windows.Data.BindingOperations.GetMultiBinding%2A> metody, jeśli wcześniej wiadomo typ powiązania to znaczy, ustaw we właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> i <paramref name="dp" /> parametry nie mogą być <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBindingExpression (target As DependencyObject, dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetBindingExpression : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="System.Windows.Data.BindingOperations.GetBindingExpression (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt docelowy powiązania gdzie <paramref name="dp" /> jest.</param>
        <param name="dp">Właściwość target powiązania, z którego mają zostać pobrane <see cref="T:System.Windows.Data.BindingExpression" /> obiektu.</param>
        <summary>Zwraca <see cref="T:System.Windows.Data.BindingExpression" /> obiekt skojarzony z właściwością target określone powiązanie określonego obiektu.</summary>
        <returns><see cref="T:System.Windows.Data.BindingExpression" /> Obiekt skojarzony z danej właściwości lub <see langword="null" /> Jeśli żaden nie istnieje. Jeśli <see cref="T:System.Windows.Data.PriorityBindingExpression" /> obiekt jest ustawiony na właściwości <see cref="P:System.Windows.Data.PriorityBindingExpression.ActiveBindingExpression" /> jest zwracana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.BindingExpression> Obiekt zachowuje połączenie między źródło wiążące i cel wiążący. Możesz uzyskać <xref:System.Windows.Data.BindingExpression> obiektu przez wywołanie tej metody statyczne lub przez wywołanie metody <xref:System.Windows.FrameworkElement.GetBindingExpression%2A> metody w powiązanych z danymi <xref:System.Windows.FrameworkElement> lub <xref:System.Windows.FrameworkContentElement> obiektu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano implementację <xref:System.Windows.Controls.Primitives.ButtonBase.Click> programu obsługi zdarzeń, który używa <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A> metodę, aby uzyskać <xref:System.Windows.Data.BindingExpression> , a następnie wywołuje <xref:System.Windows.Data.BindingExpression.DataItem%2A> właściwość, aby uzyskać dostęp do obiektu źródłowego powiązania.  
  
 <xref:System.Windows.Controls.TextBlock> `SavingsText` Jest obiektem docelowym powiązania i <xref:System.Windows.Controls.TextBlock.Text%2A> jest właściwość target powiązania.  
  
 [!code-csharp[DirectionalBinding#OnRentRaise](~/samples/snippets/csharp/VS_Snippets_Wpf/DirectionalBinding/CSharp/Page1.xaml.cs#onrentraise)]
 [!code-vb[DirectionalBinding#OnRentRaise](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DirectionalBinding/VisualBasic/DirectionalBinding.vb#onrentraise)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> i <paramref name="dp" /> parametry nie mogą być <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetMultiBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetPriorityBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpressionBase">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.BindingExpressionBase GetBindingExpressionBase (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.BindingExpressionBase GetBindingExpressionBase(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBindingExpressionBase (target As DependencyObject, dp As DependencyProperty) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::BindingExpressionBase ^ GetBindingExpressionBase(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetBindingExpressionBase : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpressionBase" Usage="System.Windows.Data.BindingOperations.GetBindingExpressionBase (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt gdzie <paramref name="dp" /> jest.</param>
        <param name="dp">Właściwość target powiązania, z którego mają zostać pobrane <see cref="T:System.Windows.Data.BindingExpressionBase" /> obiektu.</param>
        <summary>Pobiera <see cref="T:System.Windows.Data.BindingExpressionBase" /> obiektu, który jest ustawiony dla określonej właściwości.</summary>
        <returns><see cref="T:System.Windows.Data.BindingExpressionBase" /> Obiektu, który jest ustawiony na danej właściwości lub <see langword="null" /> Jeśli został ustawiony żaden obiekt wiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.BindingExpressionBase> Klasa jest wspólna klasa bazowa dla <xref:System.Windows.Data.BindingExpression>, <xref:System.Windows.Data.PriorityBindingExpression>, i <xref:System.Windows.Data.MultiBindingExpression> klasy. Możesz użyć <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A>, <xref:System.Windows.Data.BindingOperations.GetPriorityBindingExpression%2A>, i <xref:System.Windows.Data.BindingOperations.GetMultiBindingExpression%2A> metody, jeśli wcześniej wiadomo typ powiązania, który jest ustawiona we właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> i <paramref name="dp" /> parametry nie mogą mieć wartości null.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetMultiBinding">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.MultiBinding GetMultiBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.MultiBinding GetMultiBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetMultiBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMultiBinding (target As DependencyObject, dp As DependencyProperty) As MultiBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::MultiBinding ^ GetMultiBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetMultiBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.MultiBinding" Usage="System.Windows.Data.BindingOperations.GetMultiBinding (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.MultiBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt gdzie <paramref name="dp" /> jest.</param>
        <param name="dp">Właściwość target powiązania z którego mają zostać pobrane powiązania.</param>
        <summary>Pobiera <see cref="T:System.Windows.Data.MultiBinding" /> obiektu, który jest ustawiony dla określonej właściwości.</summary>
        <returns><see cref="T:System.Windows.Data.MultiBinding" /> Nastavit Pro vlastnost danego obiektu lub <see langword="null" /> Jeśli <see cref="T:System.Windows.Data.MultiBinding" /> obiekt został ustawiony.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> i <paramref name="dp" /> parametry nie mogą mieć wartości null.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetMultiBindingExpression">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.MultiBindingExpression GetMultiBindingExpression (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.MultiBindingExpression GetMultiBindingExpression(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetMultiBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMultiBindingExpression (target As DependencyObject, dp As DependencyProperty) As MultiBindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::MultiBindingExpression ^ GetMultiBindingExpression(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetMultiBindingExpression : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.MultiBindingExpression" Usage="System.Windows.Data.BindingOperations.GetMultiBindingExpression (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.MultiBindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt docelowy powiązania gdzie <paramref name="dp" /> jest.</param>
        <param name="dp">Właściwość target powiązania, z którego mają zostać pobrane <see cref="T:System.Windows.Data.MultiBindingExpression" /> obiektu.</param>
        <summary>Zwraca <see cref="T:System.Windows.Data.MultiBindingExpression" /> obiekt skojarzony z właściwością target określone powiązanie określonego obiektu.</summary>
        <returns><see cref="T:System.Windows.Data.MultiBindingExpression" /> Obiekt skojarzony z danej właściwości lub <see langword="null" /> Jeśli żaden nie istnieje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.MultiBindingExpression> Obiekt skojarzony z danej właściwości lub `null` Jeśli żaden nie istnieje.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> i <paramref name="dp" /> parametry nie mogą być <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetMultiBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetPriorityBinding">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.PriorityBinding GetPriorityBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.PriorityBinding GetPriorityBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetPriorityBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPriorityBinding (target As DependencyObject, dp As DependencyProperty) As PriorityBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::PriorityBinding ^ GetPriorityBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetPriorityBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.PriorityBinding" Usage="System.Windows.Data.BindingOperations.GetPriorityBinding (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.PriorityBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt gdzie <paramref name="dp" /> jest.</param>
        <param name="dp">Właściwość target powiązania z którego mają zostać pobrane powiązania.</param>
        <summary>Pobiera <see cref="T:System.Windows.Data.PriorityBinding" /> obiektu, który jest ustawiony dla określonej właściwości.</summary>
        <returns><see cref="T:System.Windows.Data.PriorityBinding" /> Nastavit Pro vlastnost danego obiektu lub <see langword="null" /> Jeśli <see cref="T:System.Windows.Data.PriorityBinding" /> obiekt został ustawiony.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> i <paramref name="dp" /> parametry nie mogą mieć wartości null.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetPriorityBindingExpression">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.PriorityBindingExpression GetPriorityBindingExpression (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.PriorityBindingExpression GetPriorityBindingExpression(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetPriorityBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPriorityBindingExpression (target As DependencyObject, dp As DependencyProperty) As PriorityBindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::PriorityBindingExpression ^ GetPriorityBindingExpression(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetPriorityBindingExpression : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.PriorityBindingExpression" Usage="System.Windows.Data.BindingOperations.GetPriorityBindingExpression (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.PriorityBindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt docelowy powiązania gdzie <paramref name="dp" /> jest.</param>
        <param name="dp">Właściwość target powiązania, z którego mają zostać pobrane <see cref="T:System.Windows.Data.PriorityBindingExpression" /> obiektu.</param>
        <summary>Zwraca <see cref="T:System.Windows.Data.PriorityBindingExpression" /> obiekt skojarzony z właściwością target określone powiązanie określonego obiektu.</summary>
        <returns><see cref="T:System.Windows.Data.PriorityBindingExpression" /> Obiekt skojarzony z danej właściwości lub <see langword="null" /> Jeśli żaden nie istnieje.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> i <paramref name="dp" /> parametry nie mogą być <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetPriorityBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetSourceUpdatingBindingGroups">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingGroup&gt; GetSourceUpdatingBindingGroups (System.Windows.DependencyObject root);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Windows.Data.BindingGroup&gt; GetSourceUpdatingBindingGroups(class System.Windows.DependencyObject root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetSourceUpdatingBindingGroups(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSourceUpdatingBindingGroups (root As DependencyObject) As ReadOnlyCollection(Of BindingGroup)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Data::BindingGroup ^&gt; ^ GetSourceUpdatingBindingGroups(System::Windows::DependencyObject ^ root);" />
      <MemberSignature Language="F#" Value="static member GetSourceUpdatingBindingGroups : System.Windows.DependencyObject -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingGroup&gt;" Usage="System.Windows.Data.BindingOperations.GetSourceUpdatingBindingGroups root" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingGroup&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="root">Katalog główny <see cref="T:System.Windows.UIElement" /> można pobrać grup powiązania.  Ta metoda zwraca <see cref="T:System.Windows.Data.BindingGroup" /> obiektów, które są skojarzone z tym elementem lub jego elementów podrzędnych.</param>
        <summary>Pobiera wszystkie <see cref="T:System.Windows.Data.BindingGroup" /> obiektów, które mają nieprawidłowe wartości lub wartości docelowej nie zostały jeszcze zaktualizowane źródło.</summary>
        <returns>Kolekcja <see cref="T:System.Windows.Data.BindingGroup" /> obiektów, które są skojarzone z określonym elementem i mają nieprawidłowe wartości lub wartości docelowej nie zostały jeszcze zaktualizowane źródło.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `root` jest `null`, <xref:System.Windows.Data.BindingOperations.GetSourceUpdatingBindingGroups%2A> zwraca wszystkie <xref:System.Windows.Data.BindingGroup> obiektów, które są nieprawidłowe lub nie zostały zaktualizowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSourceUpdatingBindings">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingExpressionBase&gt; GetSourceUpdatingBindings (System.Windows.DependencyObject root);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Windows.Data.BindingExpressionBase&gt; GetSourceUpdatingBindings(class System.Windows.DependencyObject root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetSourceUpdatingBindings(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSourceUpdatingBindings (root As DependencyObject) As ReadOnlyCollection(Of BindingExpressionBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Data::BindingExpressionBase ^&gt; ^ GetSourceUpdatingBindings(System::Windows::DependencyObject ^ root);" />
      <MemberSignature Language="F#" Value="static member GetSourceUpdatingBindings : System.Windows.DependencyObject -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingExpressionBase&gt;" Usage="System.Windows.Data.BindingOperations.GetSourceUpdatingBindings root" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingExpressionBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="root">Katalog główny <see cref="T:System.Windows.UIElement" /> można pobrać grup powiązania.  Ta metoda zwraca <see cref="T:System.Windows.Data.BindingExpressionBase" /> obiektów, które są skojarzone z tym elementem lub jego elementów podrzędnych.</param>
        <summary>Pobiera wszystkie <see cref="T:System.Windows.Data.BindingExpressionBase" /> obiektów, które mają nieprawidłowe wartości lub wartości docelowej nie zostały jeszcze zaktualizowane źródło.</summary>
        <returns>Kolekcja <see cref="T:System.Windows.Data.BindingExpressionBase" /> obiektów, które są skojarzone z określonym elementem i mają nieprawidłowe wartości lub wartości docelowej nie zostały jeszcze zaktualizowane źródło.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `root` jest `null`, <xref:System.Windows.Data.BindingOperations.GetSourceUpdatingBindings%2A> zwraca wszystkie <xref:System.Windows.Data.BindingExpressionBase> obiektów, które są nieprawidłowe lub nie zostały zaktualizowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDataBound">
      <MemberSignature Language="C#" Value="public static bool IsDataBound (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDataBound(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.IsDataBound(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDataBound (target As DependencyObject, dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDataBound(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member IsDataBound : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; bool" Usage="System.Windows.Data.BindingOperations.IsDataBound (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt gdzie <paramref name="dp" /> jest.</param>
        <param name="dp">Właściwość zależności do sprawdzenia.</param>
        <summary>Zwraca wartość wskazującą, czy określona właściwość jest obecnie powiązany z danymi.</summary>
        <returns><see langword="true" /> Jeśli określona właściwość jest powiązane z danymi; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Jeśli <paramref name="target" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.SetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetBinding (target As DependencyObject, dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="static member SetBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="System.Windows.Data.BindingOperations.SetBinding (target, dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="target">Wiązanie docelowe powiązania.</param>
        <param name="dp">Właściwość target wiązania.</param>
        <param name="binding"><see cref="T:System.Windows.Data.BindingBase" /> Obiektu, który opisuje powiązanie.</param>
        <summary>Tworzy i kojarzy nowe wystąpienie klasy <see cref="T:System.Windows.Data.BindingExpressionBase" /> z właściwością target określonego powiązania.</summary>
        <returns>Wystąpienie <see cref="T:System.Windows.Data.BindingExpressionBase" /> utworzone dla i skojarzone z określoną właściwością. <see cref="T:System.Windows.Data.BindingExpressionBase" /> Klasa jest klasą bazową dla <see cref="T:System.Windows.Data.BindingExpression" />, <see cref="T:System.Windows.Data.MultiBindingExpression" />, i <see cref="T:System.Windows.Data.PriorityBindingExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy nowe wystąpienie klasy <xref:System.Windows.Data.BindingExpressionBase> i kojarzy wystąpienie z danej właściwości zależności danego obiektu. Jest to sposób, aby dołączyć powiązanie do dowolnego <xref:System.Windows.DependencyObject> może ujawnia swoje własne metody SetBinding.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak ustawić powiązania przy użyciu tej metody. W tym przykładzie `myNewBindDef` jest <xref:System.Windows.Data.Binding> obiektu, który opisuje powiązanie. Wiązanie docelowe jest `myDateText`, wystąpienie <xref:System.Windows.Controls.TextBlock> klasy.  
  
 [!code-csharp[BindConversion#BOSetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/BindConversion/CSharp/Window1.xaml.cs#bosetbinding)]
 [!code-vb[BindConversion#BOSetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindConversion/visualbasic/window1.xaml.vb#bosetbinding)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="binding" /> Parametr nie może być <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
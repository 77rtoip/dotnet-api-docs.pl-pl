<Type Name="BindingOperations" FullName="System.Windows.Data.BindingOperations">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="92b113f334992708d2a2faaedc39e7bed7220632" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36564653" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class BindingOperations" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit BindingOperations extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Data.BindingOperations" />
  <TypeSignature Language="VB.NET" Value="Public Class BindingOperations" />
  <TypeSignature Language="C++ CLI" Value="public ref class BindingOperations abstract sealed" />
  <TypeSignature Language="F#" Value="type BindingOperations = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia metody statyczne do manipulowania powiązań, w tym <see cref="T:System.Windows.Data.Binding" />, <see cref="T:System.Windows.Data.MultiBinding" />, i <see cref="T:System.Windows.Data.PriorityBinding" /> obiektów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa udostępnia zestaw metod statycznych służące jako operacji pomocnika dla powiązania danych.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AccessCollection">
      <MemberSignature Language="C#" Value="public static void AccessCollection (System.Collections.IEnumerable collection, Action accessMethod, bool writeAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AccessCollection(class System.Collections.IEnumerable collection, class System.Action accessMethod, bool writeAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.AccessCollection(System.Collections.IEnumerable,System.Action,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AccessCollection (collection As IEnumerable, accessMethod As Action, writeAccess As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AccessCollection(System::Collections::IEnumerable ^ collection, Action ^ accessMethod, bool writeAccess);" />
      <MemberSignature Language="F#" Value="static member AccessCollection : System.Collections.IEnumerable * Action * bool -&gt; unit" Usage="System.Windows.Data.BindingOperations.AccessCollection (collection, accessMethod, writeAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
        <Parameter Name="accessMethod" Type="System.Action" />
        <Parameter Name="writeAccess" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="collection">Kolekcja, do uzyskania dostępu.</param>
        <param name="accessMethod">Akcja do wykonania w kolekcji.</param>
        <param name="writeAccess">
          <see langword="true" /> Jeśli <c>accessMethod</c> będą zapisywane w kolekcji; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zapewnia dostęp do kolekcji przy użyciu mechanizmu synchronizacji aplikacji określenia po o nazwie EnableCollectionSynchronization.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearAllBindings">
      <MemberSignature Language="C#" Value="public static void ClearAllBindings (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearAllBindings(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.ClearAllBindings(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearAllBindings (target As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearAllBindings(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member ClearAllBindings : System.Windows.DependencyObject -&gt; unit" Usage="System.Windows.Data.BindingOperations.ClearAllBindings target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt, z którego chcesz usunąć powiązania.</param>
        <summary>Usuwa wszystkie powiązania, w tym powiązania typu <see cref="T:System.Windows.Data.Binding" />, <see cref="T:System.Windows.Data.MultiBinding" />, i <see cref="T:System.Windows.Data.PriorityBinding" />, z określonego <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określony obiekt nie jest powiązane z danymi, ta metoda nie ma znaczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Jeśli <paramref name="target" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClearBinding">
      <MemberSignature Language="C#" Value="public static void ClearBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.ClearBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearBinding (target As DependencyObject, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member ClearBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="System.Windows.Data.BindingOperations.ClearBinding (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt, z którego chcesz usunąć powiązania.</param>
        <param name="dp">Właściwości zależności, z którego chcesz usunąć powiązania.</param>
        <summary>Usuwa powiązania z właściwością, jeśli istnieje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dana właściwość jest powiązane z danymi z <xref:System.Windows.Data.Binding>, <xref:System.Windows.Data.PriorityBinding>, lub <xref:System.Windows.Data.MultiBinding>, ta metoda usuwa odpowiedniego wyrażenia powiązania i przywraca ustawiono wartość właściwości, jakie były przed wartością lokalnej za pośrednictwem powiązania.  
  
 Jeśli dana właściwość nie jest powiązane z danymi, ta metoda nie ma znaczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> i <paramref name="dp" /> parametry nie mogą być <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CollectionRegistering">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Windows.Data.CollectionRegisteringEventArgs&gt; CollectionRegistering;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.CollectionRegisteringEventArgs&gt; CollectionRegistering" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.BindingOperations.CollectionRegistering" />
      <MemberSignature Language="VB.NET" Value="Public Shared Event CollectionRegistering As EventHandler(Of CollectionRegisteringEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Windows::Data::CollectionRegisteringEventArgs ^&gt; ^ CollectionRegistering;" />
      <MemberSignature Language="F#" Value="member this.CollectionRegistering : EventHandler&lt;System.Windows.Data.CollectionRegisteringEventArgs&gt; " Usage="member this.CollectionRegistering : System.EventHandler&lt;System.Windows.Data.CollectionRegisteringEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.CollectionRegisteringEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy system wiązania danych powiadomienia kolekcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionViewRegistering">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Windows.Data.CollectionViewRegisteringEventArgs&gt; CollectionViewRegistering;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.CollectionViewRegisteringEventArgs&gt; CollectionViewRegistering" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.BindingOperations.CollectionViewRegistering" />
      <MemberSignature Language="VB.NET" Value="Public Shared Event CollectionViewRegistering As EventHandler(Of CollectionViewRegisteringEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Windows::Data::CollectionViewRegisteringEventArgs ^&gt; ^ CollectionViewRegistering;" />
      <MemberSignature Language="F#" Value="member this.CollectionViewRegistering : EventHandler&lt;System.Windows.Data.CollectionViewRegisteringEventArgs&gt; " Usage="member this.CollectionViewRegistering : System.EventHandler&lt;System.Windows.Data.CollectionViewRegisteringEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.CollectionViewRegisteringEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy system wiązania danych powiadomienia widok kolekcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableCollectionSynchronization">
      <MemberSignature Language="C#" Value="public static void DisableCollectionSynchronization (System.Collections.IEnumerable collection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DisableCollectionSynchronization(class System.Collections.IEnumerable collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.DisableCollectionSynchronization(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DisableCollectionSynchronization (collection As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DisableCollectionSynchronization(System::Collections::IEnumerable ^ collection);" />
      <MemberSignature Language="F#" Value="static member DisableCollectionSynchronization : System.Collections.IEnumerable -&gt; unit" Usage="System.Windows.Data.BindingOperations.DisableCollectionSynchronization collection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="collection">Kolekcja Aby usunąć dostęp zsynchronizowane z.</param>
        <summary>Usuń synchronizacji zarejestrowany dla określonej kolekcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisconnectedSource">
      <MemberSignature Language="C#" Value="public static object DisconnectedSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property object DisconnectedSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingOperations.DisconnectedSource" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DisconnectedSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Object ^ DisconnectedSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DisconnectedSource : obj" Usage="System.Windows.Data.BindingOperations.DisconnectedSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który zastępuje <see cref="P:System.Windows.FrameworkElement.DataContext" /> gdy kontener element zostanie usunięty z drzewa wizualnego.</summary>
        <value>Obiekt, który zastępuje <see cref="P:System.Windows.FrameworkElement.DataContext" /> gdy kontener element zostanie usunięty z drzewa wizualnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej właściwości należy użyć, jeśli potrzebujesz radzenia sobie z <xref:System.Windows.FrameworkElement.DataContext%2A> kontenera elementu.  Kontener elementu jest element interfejsu użytkownika, który zawiera element <xref:System.Windows.Controls.ItemsControl>.  Gdy <xref:System.Windows.Controls.ItemsControl> dane powiązane z kolekcją, kontener elementu jest generowany dla każdego elementu.  W niektórych przypadkach kontenery elementu są usuwane z drzewa wizualnego.  Są typowe przypadków, gdy kontener element zostanie usunięty po usunięciu elementu z kolekcji źródłowej i gdy jest włączona wirtualizacja na <xref:System.Windows.Controls.ItemsControl>.  W takich przypadkach <xref:System.Windows.FrameworkElement.DataContext%2A> obiektu kontenera elementu zostanie ustawiona do <xref:System.Windows.Data.BindingOperations.DisconnectedSource%2A> właściwość, należy sprawdzić, czy <xref:System.Windows.FrameworkElement.DataContext%2A> jest równa <xref:System.Windows.Data.BindingOperations.DisconnectedSource%2A> przed uzyskaniem dostępu do <xref:System.Windows.FrameworkElement.DataContext%2A> w <xref:System.Windows.FrameworkElement.DataContextChanged> zdarzeń dla elementu kontenery. Aby uzyskać więcej informacji na temat kontenery elementu i wirtualizacji, zobacz uwagi w <xref:System.Windows.Controls.VirtualizingStackPanel> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnableCollectionSynchronization">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Włącza <see cref="T:System.Windows.Data.CollectionView" /> obiektu do uczestnictwa w synchronizacji dostępu do kolekcji, która jest używana w wielu wątkach.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Aplikacja WPF można wyświetlić kolekcję danych przy użyciu <xref:System.Windows.Controls.ItemsControl> lub jednej z jego podklas (<xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.DataGrid>, <xref:System.Windows.Controls.TreeView>, <xref:System.Windows.Controls.ListView>itp.). WPF kanały jego dostępu do kolekcji za pomocą podklasą <xref:System.Windows.Data.CollectionView>. Zarówno <xref:System.Windows.Controls.ItemsControl> i <xref:System.Windows.Data.CollectionView> mają koligacji w wątku, w którym <xref:System.Windows.Controls.ItemsControl> został utworzony, co oznacza, że ich użycie w innym wątku jest zabroniony i zgłasza wyjątek. W efekcie to ograniczenie obowiązuje również w kolekcji.
 
Można użyć kolekcji w wielu wątkach.   Na przykład chcesz zaktualizować kolekcji (Dodawanie lub usuwanie elementów) w wątku "zbieranie danych", podczas wyświetlania wyników w wątku "interfejsu użytkownika", tak, aby interfejsu użytkownika reaguje podczas zbierania danych wykonywane. W takiej sytuacji jest odpowiedzialny za zapewnienie zsynchronizowane ("wątkowo") dostęp do kolekcji.   Jest to zazwyczaj wykonywane przy użyciu mechanizmu blokady prostego lub bardziej złożonych mechanizmu synchronizacji takich jak semaforów, resetowania zdarzeń itd. 
 
Chociaż dostęp aplikacji do kolekcji należy przeprowadzić synchronizację, musi również gwarantuje dostępu z WPF (w szczególności z <xref:System.Windows.Data.CollectionView>) uczestniczy w ten sam mechanizm synchronizacji.  Można to zrobić przez wywołanie metody <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> metody.
 
Aby użyć kolekcji na wiele wątków, z których jeden jest wątku interfejsu użytkownika, który jest właścicielem <xref:System.Windows.Controls.ItemsControl>, aplikacja ma następujące obowiązki:

1. Wybierz mechanizm synchronizacji.

1. Synchronizuj dostęp z aplikacji do kolekcji przy użyciu mechanizmu.

1. Wywołanie <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> informują WPF mechanizmu.

   - Wywołanie musi przypadać w wątku interfejsu użytkownika.

   - Wywołanie musi wystąpić przed rozpoczęciem korzystania z kolekcji w innym wątku lub przed podłączeniem go do kolekcji <xref:System.Windows.Controls.ItemsControl>, w zależności od jest nowszy.

   - Wywołanie <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)> przeciążenia, jeśli przy użyciu mechanizmu blokady prostego; wywołania <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)> przeciążenia, jeśli przy użyciu mechanizmu bardziej złożonych.

1. Upewnij się, że zmiany w kolekcji i powiadomienia o tej zmianie (za pośrednictwem <xref:System.Collections.Specialized.INotifyCollectionChanged>) czy atomic; Brak dostępu z innych wątków można interweniować.  (Jest to zazwyczaj wolne. For instance <xref:System.Collections.ObjectModel.ObservableCollection%601> gwarantuje to, pod warunkiem, że wszystkie zmiany są chronione przez synchronizacji.)

1. Jeśli należy wywołać <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, że wywołanie musi także wystąpić w wątku interfejsu użytkownika.

1. Jeśli chcesz użyć tej samej kolekcji na wiele wątków interfejsu użytkownika, należy wywołać <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> (i <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, jeśli to konieczne) pozycje osobno dla każdego wątku interfejsu użytkownika.

1. Unikaj zakleszczenia.  Ten element jest już odpowiedzialność aplikacji po jej zdecydował się użyć synchronizacji, ale należy również wziąć pod uwagę WPF uczestnictwa w synchronizacji, zgodnie z opisem w następujących akapitu.

W zamian WPF zapewnia następujące zachowanie:

- <xref:System.Windows.Data.CollectionView> Uzyskuje dostęp do kolekcji przy użyciu mechanizmu danego synchronizacji.

- <xref:System.Windows.Data.CollectionView> Przechowuje "kopii w tle" kolekcję do użycia w wątku interfejsu użytkownika.

- <xref:System.Windows.Data.CollectionView.CollectionChanged> zdarzenia są umieszczone w kolejce nadejścia (w którymkolwiek wątku).

- Oczekujące zdarzenia są stosowane do kopii w tle asynchronicznie w wątku interfejsu użytkownika po można to zrobić.

- <xref:System.Windows.Data.CollectionView> Bezpośrednio nie będą korzystać z innego mechanizmu synchronizacji, widoczny dla aplikacji. To w WPF sposobem uniknięcia zakleszczenie (zobacz poprzedni element 7).   

Net powoduje, że można zmienić kolekcję w którymkolwiek wątku i po pewnym czasie te zmiany są wyświetlane w <xref:System.Windows.Controls.ItemsControl> po wątku interfejsu użytkownika zawiera czas "odnaleźć".  Implementacja ma została dostosowana do ograniczania szybkości, że w wątku interfejsu użytkownika, aby zachować tła przepływu zmian wątki nasycenia wątku interfejsu użytkownika i starving odpowiedzi na dane wejściowe zwykłego użytkownika.

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnableCollectionSynchronization">
      <MemberSignature Language="C#" Value="public static void EnableCollectionSynchronization (System.Collections.IEnumerable collection, object lockObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableCollectionSynchronization(class System.Collections.IEnumerable collection, object lockObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableCollectionSynchronization (collection As IEnumerable, lockObject As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableCollectionSynchronization(System::Collections::IEnumerable ^ collection, System::Object ^ lockObject);" />
      <MemberSignature Language="F#" Value="static member EnableCollectionSynchronization : System.Collections.IEnumerable * obj -&gt; unit" Usage="System.Windows.Data.BindingOperations.EnableCollectionSynchronization (collection, lockObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
        <Parameter Name="lockObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="collection">Kolekcja, która musi zsynchronizować dostępu.</param>
        <param name="lockObject">Obiekt do blokowania podczas dostępu do kolekcji.</param>
        <summary>Włącza <see cref="T:System.Windows.Data.CollectionView" /> obiektu do uczestnictwa w synchronizacji dostępu do kolekcji, używany w wielu wątkach za pomocą prostego mechanizmu blokowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

Aplikacja WPF można wyświetlić kolekcję danych przy użyciu <xref:System.Windows.Controls.ItemsControl> lub jednej z jego podklas (<xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.DataGrid>, <xref:System.Windows.Controls.TreeView>, <xref:System.Windows.Controls.ListView>itp.). WPF kanały jego dostępu do kolekcji za pomocą podklasą <xref:System.Windows.Data.CollectionView>. Zarówno <xref:System.Windows.Controls.ItemsControl> i <xref:System.Windows.Data.CollectionView> mają koligacji w wątku, w którym <xref:System.Windows.Controls.ItemsControl> został utworzony, co oznacza, że ich użycie w innym wątku jest zabroniony i zgłasza wyjątek. W efekcie to ograniczenie obowiązuje również w kolekcji.
 
Można użyć kolekcji w wielu wątkach.   Na przykład chcesz zaktualizować kolekcji (Dodawanie lub usuwanie elementów) w wątku "zbieranie danych", podczas wyświetlania wyników w wątku "interfejsu użytkownika", tak, aby interfejsu użytkownika reaguje podczas zbierania danych wykonywane. W takiej sytuacji jest odpowiedzialny za zapewnienie synchronizacji ("wątkowo") dostęp do kolekcji, a także za zapewnienie dostępu z WPF (w szczególności z <xref:System.Windows.Data.CollectionView>) uczestniczy w ten sam mechanizm synchronizacji. Wywołując <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)> metody, można to zrobić za pomocą mechanizmu proste blokady. 
 
Aby użyć kolekcji na wiele wątków, z których jeden jest wątku interfejsu użytkownika, który jest właścicielem <xref:System.Windows.Controls.ItemsControl>, należy wykonać następujące czynności:

1. Tworzy wystąpienie obiektu do blokowania podczas dostępu do kolekcji.

1. Synchronizuj dostęp z aplikacji do kolekcji blokując tego obiektu.

1. Wywołanie <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)> informują WPF, czy jest używany mechanizm proste blokady.

   - Wywołanie musi przypadać w wątku interfejsu użytkownika.

   - Wywołanie musi wystąpić przed rozpoczęciem korzystania z kolekcji w innym wątku lub przed podłączeniem go do kolekcji <xref:System.Windows.Controls.ItemsControl>, w zależności od jest nowszy.

1. Upewnij się, że zmiany w kolekcji i powiadomienia o tej zmianie (za pośrednictwem <xref:System.Collections.Specialized.INotifyCollectionChanged>) czy atomic; Brak dostępu z innych wątków można interweniować.  (Jest to zazwyczaj wolne. For instance <xref:System.Collections.ObjectModel.ObservableCollection%601> gwarantuje to, pod warunkiem, że wszystkie zmiany są chronione przez synchronizacji.)

1. Jeśli należy wywołać <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, że wywołanie musi także wystąpić w wątku interfejsu użytkownika.

1. Jeśli chcesz użyć tej samej kolekcji na wiele wątków interfejsu użytkownika, należy wywołać <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> (i <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, jeśli to konieczne) pozycje osobno dla każdego wątku interfejsu użytkownika.

1. Unikaj zakleszczenia.  Ten element jest już odpowiedzialność aplikacji po jej zdecydował się użyć synchronizacji, ale jego należy również wziąć pod uwagę w WPF uczestnictwa w synchronizacji. (Zobacz więcej, poniżej).

W zamian WPF zapewnia następujące zachowanie:

- <xref:System.Windows.Data.CollectionView> Uzyskuje dostęp do kolekcji przy użyciu mechanizmu blokowania.

- <xref:System.Windows.Data.CollectionView> Przechowuje "kopii w tle" kolekcję do użycia w wątku interfejsu użytkownika.

- <xref:System.Windows.Data.CollectionView.CollectionChanged> zdarzenia są umieszczone w kolejce nadejścia (w którymkolwiek wątku).

- Oczekujące zdarzenia są stosowane do kopii w tle asynchronicznie w wątku interfejsu użytkownika po można to zrobić.

- <xref:System.Windows.Data.CollectionView> Zostanie bezpośrednio Użyj inny mechanizm synchronizacji, widoczny dla aplikacji. To w WPF sposobem uniknięcia zakleszczenie (zobacz poprzedni element 7).   

Net powoduje, że można zmienić kolekcję w którymkolwiek wątku i po pewnym czasie te zmiany są wyświetlane w <xref:System.Windows.Controls.ItemsControl> po wątku interfejsu użytkownika zawiera czas "odnaleźć".  Implementacja ma została dostosowana do ograniczania szybkości, że w wątku interfejsu użytkownika, aby zachować tła przepływu zmian wątki nasycenia wątku interfejsu użytkownika i starving odpowiedzi na dane wejściowe zwykłego użytkownika.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableCollectionSynchronization">
      <MemberSignature Language="C#" Value="public static void EnableCollectionSynchronization (System.Collections.IEnumerable collection, object context, System.Windows.Data.CollectionSynchronizationCallback synchronizationCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableCollectionSynchronization(class System.Collections.IEnumerable collection, object context, class System.Windows.Data.CollectionSynchronizationCallback synchronizationCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableCollectionSynchronization (collection As IEnumerable, context As Object, synchronizationCallback As CollectionSynchronizationCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableCollectionSynchronization(System::Collections::IEnumerable ^ collection, System::Object ^ context, System::Windows::Data::CollectionSynchronizationCallback ^ synchronizationCallback);" />
      <MemberSignature Language="F#" Value="static member EnableCollectionSynchronization : System.Collections.IEnumerable * obj * System.Windows.Data.CollectionSynchronizationCallback -&gt; unit" Usage="System.Windows.Data.BindingOperations.EnableCollectionSynchronization (collection, context, synchronizationCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
        <Parameter Name="context" Type="System.Object" />
        <Parameter Name="synchronizationCallback" Type="System.Windows.Data.CollectionSynchronizationCallback" />
      </Parameters>
      <Docs>
        <param name="collection">Kolekcja, która musi zsynchronizować dostępu.</param>
        <param name="context">Obiekt, który jest przekazywany do wywołania zwrotnego.</param>
        <param name="synchronizationCallback">Wywołanie zwrotne, które jest wywoływane zawsze, gdy wymagany jest dostęp do kolekcji. Służy on do kolekcji jest dostęp do jednego wątku w czasie.</param>
        <summary>Włącza <see cref="T:System.Windows.Data.CollectionView" /> obiektu do uczestnictwa w synchronizacji dostępu do kolekcji, używany w wielu wątkach za pomocą mechanizmu innego niż prosty blokady.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Aplikacja WPF można wyświetlić kolekcję danych przy użyciu <xref:System.Windows.Controls.ItemsControl> lub jednej z jego podklas (<xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.DataGrid>, <xref:System.Windows.Controls.TreeView>, <xref:System.Windows.Controls.ListView>itp.). WPF kanały jego dostępu do kolekcji za pomocą podklasą <xref:System.Windows.Data.CollectionView>. Zarówno <xref:System.Windows.Controls.ItemsControl> i <xref:System.Windows.Data.CollectionView> mają koligacji w wątku, w którym <xref:System.Windows.Controls.ItemsControl> został utworzony, co oznacza, że ich użycie w innym wątku jest zabroniony i zgłasza wyjątek. W efekcie to ograniczenie obowiązuje również w kolekcji.
 
Można użyć kolekcji w wielu wątkach.   Na przykład chcesz zaktualizować kolekcji (Dodawanie lub usuwanie elementów) w wątku "zbieranie danych", podczas wyświetlania wyników w wątku "interfejsu użytkownika", tak, aby interfejsu użytkownika reaguje podczas zbierania danych wykonywane. W takiej sytuacji jest odpowiedzialny za zapewnienie synchronizacji ("wątkowo") dostęp do kolekcji, a także za zapewnienie dostępu z WPF (w szczególności z <xref:System.Windows.Data.CollectionView>) uczestniczy w ten sam mechanizm synchronizacji. Wywołując <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)> metody, można to zrobić za pomocą mechanizmu synchronizacji semaforów Resetowanie zdarzenia, np. 
 
Aby użyć kolekcji na wiele wątków, z których jeden jest wątku interfejsu użytkownika, który jest właścicielem <xref:System.Windows.Controls.ItemsControl>, należy wykonać następujące czynności:

1. Wybierz mechanizm synchronizacji.

1. Synchronizuj dostęp z aplikacji do kolekcji przy użyciu mechanizmu.

1. Wywołanie <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)> przeciążenia informują WPF o tym, czy jest używany mechanizm innego niż prosty blokowania.

   - Wywołanie musi przypadać w wątku interfejsu użytkownika.

   - Wywołanie musi wystąpić przed rozpoczęciem korzystania z kolekcji w innym wątku lub przed podłączeniem go do kolekcji <xref:System.Windows.Controls.ItemsControl>, w zależności od jest nowszy.

1. Upewnij się, że zmiany w kolekcji i powiadomienia o tej zmianie (za pośrednictwem <xref:System.Collections.Specialized.INotifyCollectionChanged>) czy atomic; Brak dostępu z innych wątków można interweniować.  (Jest to zazwyczaj wolne. For instance <xref:System.Collections.ObjectModel.ObservableCollection%601> gwarantuje to, pod warunkiem, że wszystkie zmiany są chronione przez synchronizacji.)

1. Jeśli należy wywołać <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, że wywołanie musi także wystąpić w wątku interfejsu użytkownika.

1. Jeśli chcesz użyć tej samej kolekcji na wiele wątków interfejsu użytkownika, należy wywołać <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> (i <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, jeśli to konieczne) pozycje osobno dla każdego wątku interfejsu użytkownika.

1. Unikaj zakleszczenia.  Ten element jest już odpowiedzialność aplikacji po jej zdecydował się użyć synchronizacji, ale jego należy również wziąć pod uwagę w WPF uczestnictwa w synchronizacji. (Zobacz więcej, poniżej).

W zamian WPF zapewnia następujące zachowanie:

- <xref:System.Windows.Data.CollectionView> Uzyskuje dostęp do kolekcji, wywołując zarejestrowaną <xref:System.Windows.Data.CollectionSynchronizationCallback> z następującymi argumentami:

   - `collection`: zbiór zainteresowań.
   - `context`: obiekt zarejestrowanego kontekstu.
   - `accessMethod`: delegata, który wykonuje rzeczywiste dostępu.
   - `writeAccess`: `true` Jeśli delegat zmodyfikuje kolekcji; `false` inaczej.

   Twoje <xref:System.Windows.Data.CollectionSynchronizationCallback> należy określić synchronizacji kolekcji (przy użyciu `context` obiektu i `writeAccess` wartości, zależnie od potrzeb), wywołania `accessMethod`, zwolnij synchronizacji.

- <xref:System.Windows.Data.CollectionView> Przechowuje "kopii w tle" kolekcję do użycia w wątku interfejsu użytkownika.

- <xref:System.Windows.Data.CollectionView.CollectionChanged> zdarzenia są umieszczone w kolejce nadejścia (w którymkolwiek wątku).

- Oczekujące zdarzenia są stosowane do kopii w tle asynchronicznie w wątku interfejsu użytkownika po można to zrobić.

- <xref:System.Windows.Data.CollectionView> Zostanie bezpośrednio Użyj inny mechanizm synchronizacji, widoczny dla aplikacji. To w WPF sposobem uniknięcia zakleszczenie (zobacz poprzedni element 7).   

Net powoduje, że można zmienić kolekcję w którymkolwiek wątku i po pewnym czasie te zmiany są wyświetlane w <xref:System.Windows.Controls.ItemsControl> po wątku interfejsu użytkownika zawiera czas "odnaleźć".  Implementacja ma została dostosowana do ograniczania szybkości, że w wątku interfejsu użytkownika, aby zachować tła przepływu zmian wątki nasycenia wątku interfejsu użytkownika i starving odpowiedzi na dane wejściowe zwykłego użytkownika.

 `context` Parametr jest przekazywany do dowolnego obiektu `callback`. Służy do określenia mechanizm synchronizacji, służący do kontroli dostępu do `collection`. `Context` może być `null`.  
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBinding">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.Binding GetBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.Binding GetBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBinding (target As DependencyObject, dp As DependencyProperty) As Binding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::Binding ^ GetBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.Binding" Usage="System.Windows.Data.BindingOperations.GetBinding (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.Binding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt gdzie <c>dp</c> jest.</param>
        <param name="dp">Właściwość target powiązania z którego można pobrać powiązania.</param>
        <summary>Pobiera <see cref="T:System.Windows.Data.Binding" /> obiekt, który jest ustawiony dla określonej właściwości.</summary>
        <returns>
          <see cref="T:System.Windows.Data.Binding" /> Ustawić dla danej właściwości obiektu lub <see langword="null" /> Jeśli żadne <see cref="T:System.Windows.Data.Binding" /> obiektu została ustawiona.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> i <paramref name="dp" /> parametrów nie może mieć wartości null.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetMultiBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetPriorityBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetBindingBase">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.BindingBase GetBindingBase (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.BindingBase GetBindingBase(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBindingBase (target As DependencyObject, dp As DependencyProperty) As BindingBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::BindingBase ^ GetBindingBase(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetBindingBase : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingBase" Usage="System.Windows.Data.BindingOperations.GetBindingBase (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt gdzie <c>dp</c> jest.</param>
        <param name="dp">Właściwość target powiązanie, z którego można pobrać <see cref="T:System.Windows.Data.BindingBase" /> obiektu.</param>
        <summary>Pobiera <see cref="T:System.Windows.Data.BindingBase" /> obiekt, który jest ustawiony dla określonej właściwości.</summary>
        <returns>
          <see cref="T:System.Windows.Data.BindingBase" /> Obiekt, który jest ustawiony dla danej właściwości lub <see langword="null" /> Jeżeli nie ustawiono żadnego obiektu powiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.BindingBase> Klasy jest wspólna klasa podstawowa dla <xref:System.Windows.Data.Binding>, <xref:System.Windows.Data.PriorityBinding>, i <xref:System.Windows.Data.MultiBinding> klasy. Można użyć <xref:System.Windows.Data.BindingOperations.GetBinding%2A>, <xref:System.Windows.Data.BindingOperations.GetPriorityBinding%2A>, i <xref:System.Windows.Data.BindingOperations.GetMultiBinding%2A> metody, jeśli wcześniej znasz typ powiązania, który jest ustawiona we właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> i <paramref name="dp" /> parametry nie mogą być <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBindingExpression (target As DependencyObject, dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetBindingExpression : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="System.Windows.Data.BindingOperations.GetBindingExpression (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt docelowy powiązanie gdzie <c>dp</c> jest.</param>
        <param name="dp">Właściwość target powiązanie, z którego można pobrać <see cref="T:System.Windows.Data.BindingExpression" /> obiektu.</param>
        <summary>Zwraca <see cref="T:System.Windows.Data.BindingExpression" /> obiekt skojarzony z właściwością target określone powiązanie w określonym obiekcie.</summary>
        <returns>
          <see cref="T:System.Windows.Data.BindingExpression" /> Obiekt skojarzony z danej właściwości lub <see langword="null" /> Jeśli żaden nie istnieje. Jeśli <see cref="T:System.Windows.Data.PriorityBindingExpression" /> obiektu jest ustawiona we właściwości <see cref="P:System.Windows.Data.PriorityBindingExpression.ActiveBindingExpression" /> jest zwracany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.BindingExpression> Obiekt zachowuje połączenie między powiązanie źródło i cel wiązania. Możesz uzyskać <xref:System.Windows.Data.BindingExpression> obiektu przez wywołanie tej metody statycznej, przez wywołanie <xref:System.Windows.FrameworkElement.GetBindingExpression%2A> metoda z danymi <xref:System.Windows.FrameworkElement> lub <xref:System.Windows.FrameworkContentElement> obiektu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia implementację <xref:System.Windows.Controls.Primitives.ButtonBase.Click> obsługi zdarzeń, który używa <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A> metodę, aby uzyskać <xref:System.Windows.Data.BindingExpression> , a następnie wywołuje <xref:System.Windows.Data.BindingExpression.DataItem%2A> dostępu do obiektu źródłowego powiązania dla właściwości.  
  
 <xref:System.Windows.Controls.TextBlock> `SavingsText` Jest obiektem docelowym powiązania i <xref:System.Windows.Controls.TextBlock.Text%2A> jest właściwość target powiązania.  
  
 [!code-csharp[DirectionalBinding#OnRentRaise](~/samples/snippets/csharp/VS_Snippets_Wpf/DirectionalBinding/CSharp/Page1.xaml.cs#onrentraise)]
 [!code-vb[DirectionalBinding#OnRentRaise](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DirectionalBinding/VisualBasic/DirectionalBinding.vb#onrentraise)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> i <paramref name="dp" /> parametry nie mogą być <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetMultiBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetPriorityBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpressionBase">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.BindingExpressionBase GetBindingExpressionBase (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.BindingExpressionBase GetBindingExpressionBase(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBindingExpressionBase (target As DependencyObject, dp As DependencyProperty) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::BindingExpressionBase ^ GetBindingExpressionBase(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetBindingExpressionBase : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpressionBase" Usage="System.Windows.Data.BindingOperations.GetBindingExpressionBase (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt gdzie <c>dp</c> jest.</param>
        <param name="dp">Właściwość target powiązanie, z którego można pobrać <see cref="T:System.Windows.Data.BindingExpressionBase" /> obiektu.</param>
        <summary>Pobiera <see cref="T:System.Windows.Data.BindingExpressionBase" /> obiekt, który jest ustawiony dla określonej właściwości.</summary>
        <returns>
          <see cref="T:System.Windows.Data.BindingExpressionBase" /> Obiekt, który jest ustawiony dla danej właściwości lub <see langword="null" /> Jeżeli nie ustawiono żadnego obiektu powiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.BindingExpressionBase> Klasy jest wspólna klasa podstawowa dla <xref:System.Windows.Data.BindingExpression>, <xref:System.Windows.Data.PriorityBindingExpression>, i <xref:System.Windows.Data.MultiBindingExpression> klasy. Można użyć <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A>, <xref:System.Windows.Data.BindingOperations.GetPriorityBindingExpression%2A>, i <xref:System.Windows.Data.BindingOperations.GetMultiBindingExpression%2A> metody, jeśli znasz z wyprzedzeniem typ powiązania, który jest ustawiona we właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> i <paramref name="dp" /> parametrów nie może mieć wartości null.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetMultiBinding">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.MultiBinding GetMultiBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.MultiBinding GetMultiBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetMultiBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMultiBinding (target As DependencyObject, dp As DependencyProperty) As MultiBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::MultiBinding ^ GetMultiBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetMultiBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.MultiBinding" Usage="System.Windows.Data.BindingOperations.GetMultiBinding (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.MultiBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt gdzie <c>dp</c> jest.</param>
        <param name="dp">Właściwość target powiązania z którego można pobrać powiązania.</param>
        <summary>Pobiera <see cref="T:System.Windows.Data.MultiBinding" /> obiekt, który jest ustawiony dla określonej właściwości.</summary>
        <returns>
          <see cref="T:System.Windows.Data.MultiBinding" /> Ustawić dla danej właściwości obiektu lub <see langword="null" /> Jeśli żadne <see cref="T:System.Windows.Data.MultiBinding" /> obiektu została ustawiona.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> i <paramref name="dp" /> parametrów nie może mieć wartości null.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetMultiBindingExpression">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.MultiBindingExpression GetMultiBindingExpression (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.MultiBindingExpression GetMultiBindingExpression(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetMultiBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMultiBindingExpression (target As DependencyObject, dp As DependencyProperty) As MultiBindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::MultiBindingExpression ^ GetMultiBindingExpression(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetMultiBindingExpression : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.MultiBindingExpression" Usage="System.Windows.Data.BindingOperations.GetMultiBindingExpression (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.MultiBindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt docelowy powiązanie gdzie <c>dp</c> jest.</param>
        <param name="dp">Właściwość target powiązanie, z którego można pobrać <see cref="T:System.Windows.Data.MultiBindingExpression" /> obiektu.</param>
        <summary>Zwraca <see cref="T:System.Windows.Data.MultiBindingExpression" /> obiekt skojarzony z właściwością target określone powiązanie w określonym obiekcie.</summary>
        <returns>
          <see cref="T:System.Windows.Data.MultiBindingExpression" /> Obiekt skojarzony z danej właściwości lub <see langword="null" /> Jeśli żaden nie istnieje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.MultiBindingExpression> Obiekt skojarzony z danej właściwości lub `null` Jeśli żaden nie istnieje.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> i <paramref name="dp" /> parametry nie mogą być <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetMultiBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetPriorityBinding">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.PriorityBinding GetPriorityBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.PriorityBinding GetPriorityBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetPriorityBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPriorityBinding (target As DependencyObject, dp As DependencyProperty) As PriorityBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::PriorityBinding ^ GetPriorityBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetPriorityBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.PriorityBinding" Usage="System.Windows.Data.BindingOperations.GetPriorityBinding (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.PriorityBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt gdzie <c>dp</c> jest.</param>
        <param name="dp">Właściwość target powiązania z którego można pobrać powiązania.</param>
        <summary>Pobiera <see cref="T:System.Windows.Data.PriorityBinding" /> obiekt, który jest ustawiony dla określonej właściwości.</summary>
        <returns>
          <see cref="T:System.Windows.Data.PriorityBinding" /> Ustawić dla danej właściwości obiektu lub <see langword="null" /> Jeśli żadne <see cref="T:System.Windows.Data.PriorityBinding" /> obiektu została ustawiona.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> i <paramref name="dp" /> parametrów nie może mieć wartości null.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetPriorityBindingExpression">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.PriorityBindingExpression GetPriorityBindingExpression (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.PriorityBindingExpression GetPriorityBindingExpression(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetPriorityBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPriorityBindingExpression (target As DependencyObject, dp As DependencyProperty) As PriorityBindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::PriorityBindingExpression ^ GetPriorityBindingExpression(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetPriorityBindingExpression : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.PriorityBindingExpression" Usage="System.Windows.Data.BindingOperations.GetPriorityBindingExpression (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.PriorityBindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt docelowy powiązanie gdzie <c>dp</c> jest.</param>
        <param name="dp">Właściwość target powiązanie, z którego można pobrać <see cref="T:System.Windows.Data.PriorityBindingExpression" /> obiektu.</param>
        <summary>Zwraca <see cref="T:System.Windows.Data.PriorityBindingExpression" /> obiekt skojarzony z właściwością target określone powiązanie w określonym obiekcie.</summary>
        <returns>
          <see cref="T:System.Windows.Data.PriorityBindingExpression" /> Obiekt skojarzony z danej właściwości lub <see langword="null" /> Jeśli żaden nie istnieje.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> i <paramref name="dp" /> parametry nie mogą być <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetPriorityBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetSourceUpdatingBindingGroups">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingGroup&gt; GetSourceUpdatingBindingGroups (System.Windows.DependencyObject root);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Windows.Data.BindingGroup&gt; GetSourceUpdatingBindingGroups(class System.Windows.DependencyObject root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetSourceUpdatingBindingGroups(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSourceUpdatingBindingGroups (root As DependencyObject) As ReadOnlyCollection(Of BindingGroup)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Data::BindingGroup ^&gt; ^ GetSourceUpdatingBindingGroups(System::Windows::DependencyObject ^ root);" />
      <MemberSignature Language="F#" Value="static member GetSourceUpdatingBindingGroups : System.Windows.DependencyObject -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingGroup&gt;" Usage="System.Windows.Data.BindingOperations.GetSourceUpdatingBindingGroups root" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingGroup&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="root">Katalog główny <see cref="T:System.Windows.UIElement" /> można pobrać grupy powiązania.  Ta metoda zwraca <see cref="T:System.Windows.Data.BindingGroup" /> obiektów, które są skojarzone z tym elementem lub jego elementów podrzędnych.</param>
        <summary>Pobiera wszystkie <see cref="T:System.Windows.Data.BindingGroup" /> obiektów, które mają nieprawidłowe wartości lub wartości docelowych nie zostały zaktualizowane w źródle.</summary>
        <returns>Kolekcja <see cref="T:System.Windows.Data.BindingGroup" /> obiekty, które są skojarzone z określonym elementem i mieć nieprawidłowe wartości lub wartości docelowych nie zostały zaktualizowane w źródle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `root` jest `null`, <xref:System.Windows.Data.BindingOperations.GetSourceUpdatingBindingGroups%2A> zwraca wszystkie <xref:System.Windows.Data.BindingGroup> obiektów, które są nieprawidłowe lub nie zostały zaktualizowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSourceUpdatingBindings">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingExpressionBase&gt; GetSourceUpdatingBindings (System.Windows.DependencyObject root);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Windows.Data.BindingExpressionBase&gt; GetSourceUpdatingBindings(class System.Windows.DependencyObject root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetSourceUpdatingBindings(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSourceUpdatingBindings (root As DependencyObject) As ReadOnlyCollection(Of BindingExpressionBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Data::BindingExpressionBase ^&gt; ^ GetSourceUpdatingBindings(System::Windows::DependencyObject ^ root);" />
      <MemberSignature Language="F#" Value="static member GetSourceUpdatingBindings : System.Windows.DependencyObject -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingExpressionBase&gt;" Usage="System.Windows.Data.BindingOperations.GetSourceUpdatingBindings root" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingExpressionBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="root">Katalog główny <see cref="T:System.Windows.UIElement" /> można pobrać grupy powiązania.  Ta metoda zwraca <see cref="T:System.Windows.Data.BindingExpressionBase" /> obiektów, które są skojarzone z tym elementem lub jego elementów podrzędnych.</param>
        <summary>Pobiera wszystkie <see cref="T:System.Windows.Data.BindingExpressionBase" /> obiektów, które mają nieprawidłowe wartości lub wartości docelowych nie zostały zaktualizowane w źródle.</summary>
        <returns>Kolekcja <see cref="T:System.Windows.Data.BindingExpressionBase" /> obiekty, które są skojarzone z określonym elementem i mieć nieprawidłowe wartości lub wartości docelowych nie zostały zaktualizowane w źródle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `root` jest `null`, <xref:System.Windows.Data.BindingOperations.GetSourceUpdatingBindings%2A> zwraca wszystkie <xref:System.Windows.Data.BindingExpressionBase> obiektów, które są nieprawidłowe lub nie zostały zaktualizowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDataBound">
      <MemberSignature Language="C#" Value="public static bool IsDataBound (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDataBound(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.IsDataBound(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDataBound (target As DependencyObject, dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDataBound(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member IsDataBound : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; bool" Usage="System.Windows.Data.BindingOperations.IsDataBound (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt gdzie <c>dp</c> jest.</param>
        <param name="dp">Właściwość zależności do sprawdzenia.</param>
        <summary>Zwraca wartość wskazującą, czy określona właściwość jest obecnie powiązany z danymi.</summary>
        <returns>
          <see langword="true" /> Jeśli określona właściwość jest powiązany z danymi; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Jeśli <paramref name="target" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.SetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetBinding (target As DependencyObject, dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="static member SetBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="System.Windows.Data.BindingOperations.SetBinding (target, dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="target">Cel wiązania powiązania.</param>
        <param name="dp">Właściwość target powiązania.</param>
        <param name="binding">
          <see cref="T:System.Windows.Data.BindingBase" /> Obiekt opisujący wiązanie.</param>
        <summary>Tworzy i kojarzy nowe wystąpienie klasy <see cref="T:System.Windows.Data.BindingExpressionBase" /> z właściwość target określonego powiązania.</summary>
        <returns>Wystąpienie <see cref="T:System.Windows.Data.BindingExpressionBase" /> tworzone dla i skojarzone z określonej właściwości. <see cref="T:System.Windows.Data.BindingExpressionBase" /> Klasa jest klasą bazową dla <see cref="T:System.Windows.Data.BindingExpression" />, <see cref="T:System.Windows.Data.MultiBindingExpression" />, i <see cref="T:System.Windows.Data.PriorityBindingExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy nowe wystąpienie klasy <xref:System.Windows.Data.BindingExpressionBase> i kojarzy wystąpienie z danej właściwości zależności danego obiektu. Jest to sposób, aby dołączyć powiązanie do dowolnego <xref:System.Windows.DependencyObject> może ujawnia własnej metody SetBinding.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak przy użyciu tej metody można ustawić powiązania. W tym przykładzie `myNewBindDef` jest <xref:System.Windows.Data.Binding> Obiekt opisujący wiązanie. Cel wiązania jest `myDateText`, wystąpienie <xref:System.Windows.Controls.TextBlock> klasy.  
  
 [!code-csharp[BindConversion#BOSetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/BindConversion/CSharp/Window1.xaml.cs#bosetbinding)]
 [!code-vb[BindConversion#BOSetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindConversion/visualbasic/window1.xaml.vb#bosetbinding)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="binding" /> Parametr nie może być <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
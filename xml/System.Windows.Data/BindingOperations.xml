<Type Name="BindingOperations" FullName="System.Windows.Data.BindingOperations">
  <Metadata><Meta Name="ms.openlocfilehash" Value="03659029ec57d98d9016e938004b9020468d5614" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69211297" /></Metadata><TypeSignature Language="C#" Value="public static class BindingOperations" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit BindingOperations extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Data.BindingOperations" />
  <TypeSignature Language="VB.NET" Value="Public Class BindingOperations" />
  <TypeSignature Language="C++ CLI" Value="public ref class BindingOperations abstract sealed" />
  <TypeSignature Language="F#" Value="type BindingOperations = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Oferuje statyczne metody do manipulowania powiązaniami <see cref="T:System.Windows.Data.Binding" />, <see cref="T:System.Windows.Data.MultiBinding" />w tym <see cref="T:System.Windows.Data.PriorityBinding" /> obiektami, i.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa uwidacznia zestaw metod statycznych służących jako operacje pomocnika dla powiązań danych.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AccessCollection">
      <MemberSignature Language="C#" Value="public static void AccessCollection (System.Collections.IEnumerable collection, Action accessMethod, bool writeAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AccessCollection(class System.Collections.IEnumerable collection, class System.Action accessMethod, bool writeAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.AccessCollection(System.Collections.IEnumerable,System.Action,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AccessCollection (collection As IEnumerable, accessMethod As Action, writeAccess As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AccessCollection(System::Collections::IEnumerable ^ collection, Action ^ accessMethod, bool writeAccess);" />
      <MemberSignature Language="F#" Value="static member AccessCollection : System.Collections.IEnumerable * Action * bool -&gt; unit" Usage="System.Windows.Data.BindingOperations.AccessCollection (collection, accessMethod, writeAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="accessMethod" Type="System.Action" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="writeAccess" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="collection">Kolekcja, do której można uzyskać dostęp.</param>
        <param name="accessMethod">Akcja do wykonania na kolekcji.</param>
        <param name="writeAccess"><see langword="true" />Jeśli <paramref name="accessMethod" /> nastąpi zapis do kolekcji; <see langword="false" />w przeciwnym razie.</param>
        <summary>Zapewnia dostęp do kolekcji przy użyciu mechanizmu synchronizacji, który aplikacja określona podczas wywoływania EnableCollectionSynchronization.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearAllBindings">
      <MemberSignature Language="C#" Value="public static void ClearAllBindings (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearAllBindings(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.ClearAllBindings(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearAllBindings (target As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearAllBindings(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member ClearAllBindings : System.Windows.DependencyObject -&gt; unit" Usage="System.Windows.Data.BindingOperations.ClearAllBindings target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt, z którego mają zostać usunięte powiązania.</param>
        <summary>Usuwa wszystkie powiązania, w tym powiązania typu <see cref="T:System.Windows.Data.Binding" />, <see cref="T:System.Windows.Data.MultiBinding" />, i <see cref="T:System.Windows.Data.PriorityBinding" />, z określonego <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określony obiekt nie jest powiązany z danymi, ta metoda nie ma żadnego wpływu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Jeśli <paramref name="target" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClearBinding">
      <MemberSignature Language="C#" Value="public static void ClearBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.ClearBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearBinding (target As DependencyObject, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member ClearBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="System.Windows.Data.BindingOperations.ClearBinding (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt, z którego ma zostać usunięte powiązanie.</param>
        <param name="dp">Właściwość zależności, z której ma zostać usunięte powiązanie.</param>
        <summary>Usuwa powiązanie z właściwości, jeśli istnieje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dana właściwość jest powiązana z danymi z <xref:System.Windows.Data.Binding>,, lub <xref:System.Windows.Data.MultiBinding>, ta metoda usuwa odpowiednie wyrażenie powiązania i przywraca wartość właściwości do wartości, <xref:System.Windows.Data.PriorityBinding>która była wcześniejsza niż każda wartość lokalna została ustawiona za pomocą powiązania.  
  
 Jeśli dana właściwość nie jest powiązana z danymi, ta metoda nie ma żadnego wpływu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametry <paramref name="target" /> <see langword="null" />i <paramref name="dp" /> nie mogą być.</exception>
      </Docs>
    </Member>
    <Member MemberName="CollectionRegistering">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Windows.Data.CollectionRegisteringEventArgs&gt; CollectionRegistering;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.CollectionRegisteringEventArgs&gt; CollectionRegistering" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.BindingOperations.CollectionRegistering" />
      <MemberSignature Language="VB.NET" Value="Public Shared Event CollectionRegistering As EventHandler(Of CollectionRegisteringEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Windows::Data::CollectionRegisteringEventArgs ^&gt; ^ CollectionRegistering;" />
      <MemberSignature Language="F#" Value="member this.CollectionRegistering : EventHandler&lt;System.Windows.Data.CollectionRegisteringEventArgs&gt; " Usage="member this.CollectionRegistering : System.EventHandler&lt;System.Windows.Data.CollectionRegisteringEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.CollectionRegisteringEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy system powiązania danych wykryje kolekcję.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionViewRegistering">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Windows.Data.CollectionViewRegisteringEventArgs&gt; CollectionViewRegistering;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.CollectionViewRegisteringEventArgs&gt; CollectionViewRegistering" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.BindingOperations.CollectionViewRegistering" />
      <MemberSignature Language="VB.NET" Value="Public Shared Event CollectionViewRegistering As EventHandler(Of CollectionViewRegisteringEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Windows::Data::CollectionViewRegisteringEventArgs ^&gt; ^ CollectionViewRegistering;" />
      <MemberSignature Language="F#" Value="member this.CollectionViewRegistering : EventHandler&lt;System.Windows.Data.CollectionViewRegisteringEventArgs&gt; " Usage="member this.CollectionViewRegistering : System.EventHandler&lt;System.Windows.Data.CollectionViewRegisteringEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.CollectionViewRegisteringEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy system powiązania danych wykryje widok kolekcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableCollectionSynchronization">
      <MemberSignature Language="C#" Value="public static void DisableCollectionSynchronization (System.Collections.IEnumerable collection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DisableCollectionSynchronization(class System.Collections.IEnumerable collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.DisableCollectionSynchronization(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DisableCollectionSynchronization (collection As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DisableCollectionSynchronization(System::Collections::IEnumerable ^ collection);" />
      <MemberSignature Language="F#" Value="static member DisableCollectionSynchronization : System.Collections.IEnumerable -&gt; unit" Usage="System.Windows.Data.BindingOperations.DisableCollectionSynchronization collection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="collection">Kolekcja, z której ma zostać usunięty zsynchronizowany dostęp.</param>
        <summary>Usuń synchronizację zarejestrowaną dla określonej kolekcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisconnectedSource">
      <MemberSignature Language="C#" Value="public static object DisconnectedSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property object DisconnectedSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingOperations.DisconnectedSource" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DisconnectedSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Object ^ DisconnectedSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DisconnectedSource : obj" Usage="System.Windows.Data.BindingOperations.DisconnectedSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który zamienia <see cref="P:System.Windows.FrameworkElement.DataContext" /> kontener elementu, gdy element jest usuwany z drzewa wizualnego.</summary>
        <value>Obiekt, który zastępuje <see cref="P:System.Windows.FrameworkElement.DataContext" /> element po usunięciu kontenera elementu z drzewa wizualnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej właściwości, jeśli chcesz poradzić sobie z <xref:System.Windows.FrameworkElement.DataContext%2A> kontenerem elementu.  Kontener elementu jest elementem interfejsu użytkownika, który wyświetla element w <xref:System.Windows.Controls.ItemsControl>.  Gdy dane <xref:System.Windows.Controls.ItemsControl> są powiązane z kolekcją, kontener elementu jest generowany dla każdego elementu.  W niektórych przypadkach kontenery elementów są usuwane z drzewa wizualnego.  Dwa typowe przypadki, w których kontener elementu jest usuwany, jest usuwany z kolekcji źródłowej, a po włączeniu wirtualizacji na <xref:System.Windows.Controls.ItemsControl>.  W <xref:System.Windows.FrameworkElement.DataContext%2A> takich przypadkach Właściwość kontenera elementów zostanie ustawiona <xref:System.Windows.Data.BindingOperations.DisconnectedSource%2A> na właściwość, dlatego należy sprawdzić, czy <xref:System.Windows.FrameworkElement.DataContext%2A> jest <xref:System.Windows.FrameworkElement.DataContextChanged> równa <xref:System.Windows.Data.BindingOperations.DisconnectedSource%2A> przed uzyskaniem dostępu do <xref:System.Windows.FrameworkElement.DataContext%2A> elementu w zdarzeniu opakowania. Aby uzyskać więcej informacji na temat kontenerów elementów i wirtualizacji, zobacz uwagi <xref:System.Windows.Controls.VirtualizingStackPanel> w klasie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnableCollectionSynchronization">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Windows.Data.CollectionView" /> Umożliwia obiektowi uczestnictwo w synchronizowanym dostępie do kolekcji, która jest używana w wielu wątkach.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Aplikacja WPF może wyświetlić kolekcję danych <xref:System.Windows.Controls.ItemsControl> przy użyciu lub jednej z jej podklas (<xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.DataGrid>, <xref:System.Windows.Controls.TreeView> <xref:System.Windows.Controls.ListView>, itp.). Funkcja WPF tworzy kanał wszystkich dostępu do kolekcji za pomocą podklasy <xref:System.Windows.Data.CollectionView>. Zarówno, <xref:System.Windows.Controls.ItemsControl> <xref:System.Windows.Controls.ItemsControl> jak i <xref:System.Windows.Data.CollectionView> ma koligację do wątku, w którym został utworzony, co oznacza, że używanie ich w innym wątku jest zabronione i zgłasza wyjątek. W efekcie to ograniczenie dotyczy również kolekcji.
 
Możesz chcieć użyć kolekcji na wielu wątkach.   Na przykład, chcesz zaktualizować kolekcję (Dodaj lub Usuń elementy) do wątku "zbieranie danych", wyświetlając wyniki w wątku "interfejs użytkownika", dzięki czemu interfejs użytkownika nadal odpowiada podczas zbierania danych. W takiej sytuacji użytkownik jest odpowiedzialny za zapewnienie synchronizacji ("bezpieczny wątkowo") dostępu do kolekcji.   Zwykle odbywa się to przy użyciu prostego mechanizmu blokowania lub bardziej rozbudowanego mechanizmu synchronizacji, takiego jak semafory, resetowania zdarzeń itp.  Podczas gdy należy zsynchronizować dostęp aplikacji do kolekcji, należy również zazagwarantować, że dostęp z WPF (w odróżnieniu <xref:System.Windows.Data.CollectionView>od) uczestniczy w tym samym mechanizmie synchronizacji.  W tym celu należy wywołać <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> metodę.
 
Aby użyć kolekcji w wielu wątkach, z których jeden jest wątkiem interfejsu użytkownika <xref:System.Windows.Controls.ItemsControl>, który jest właścicielem, aplikacja ma następujące obowiązki:

1. Wybierz mechanizm synchronizacji.

1. Zsynchronizuj cały dostęp z aplikacji do kolekcji przy użyciu tego mechanizmu.

1. Wywołaj <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> , aby poinformować WPF o mechanizmie.

   - Wywołanie musi nastąpić w wątku interfejsu użytkownika.

   - Wywołanie musi wystąpić przed użyciem kolekcji w innym wątku lub przed dołączeniem kolekcji do <xref:System.Windows.Controls.ItemsControl>elementu, w zależności od tego, co jest późniejsze.

   - Wywołaj <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)> Przeciążenie, jeśli używasz prostego mechanizmu blokowania; Wywołaj <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)> Przeciążenie, jeśli jest używany mechanizm bardziej rozbudowany.

1. Upewnij się, że zmiana kolekcji i powiadomienia o tej zmianie (za pośrednictwem <xref:System.Collections.Specialized.INotifyCollectionChanged>) są niepodzielne; brak dostępu z innych wątków może interweniować.  (Jest to zwykle bezpłatne. Na przykład <xref:System.Collections.ObjectModel.ObservableCollection%601> gwarantuje to, że wszystkie zmiany są chronione przez synchronizację.

1. W przypadku wywołania <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>tego wywołania musi również wystąpić w wątku interfejsu użytkownika.

1. Jeśli chcesz używać tej samej kolekcji w wielu wątkach interfejsu użytkownika, musisz wywołać <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> (i <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, jeśli to konieczne) oddzielnie w każdym wątku interfejsu użytkownika.

1. Unikaj zakleszczenia.  Jest to już odpowiedzialność aplikacji, gdy zdecyduje się ona na korzystanie z synchronizacji, ale musi także wziąć pod uwagę uczestnictwo WPF w synchronizacji, zgodnie z opisem w następnym akapicie.

W programie WPF zapewnia następujące zachowanie:

- <xref:System.Windows.Data.CollectionView> Uzyskuje dostęp do kolekcji przy użyciu danego mechanizmu synchronizacji.

- <xref:System.Windows.Data.CollectionView> Zachowuje "kopię w tle" kolekcji do użycia w wątku interfejsu użytkownika.

- <xref:System.Windows.Data.CollectionView.CollectionChanged>zdarzenia są umieszczane w kolejce w miarę ich nadejścia (w dowolnym wątku).

- Oczekujące zdarzenia są stosowane do kopii w tle asynchronicznie w wątku interfejsu użytkownika, gdy ma ona możliwość wykonania tej czynności.

- <xref:System.Windows.Data.CollectionView> Nie można bezpośrednio użyć żadnego innego mechanizmu synchronizacji widocznego dla aplikacji. Jest to sposób, aby pomóc w uniknięciu zakleszczenia (zobacz poprzedni element 7).   

Efektem netto jest to, że można zmienić kolekcję w dowolnym wątku, a te zmiany ostatecznie pojawiają się <xref:System.Windows.Controls.ItemsControl> w chwili, gdy wątek interfejsu użytkownika ma czas "Catch".  Wdrożenie zostało dostrojone w celu ograniczenia szybkości, która zmienia przepływ na wątek interfejsu użytkownika, aby utrzymać nasycenie wątków w tle, a następnie blokują odpowiedź na normalne dane wejściowe użytkownika.

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnableCollectionSynchronization">
      <MemberSignature Language="C#" Value="public static void EnableCollectionSynchronization (System.Collections.IEnumerable collection, object lockObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableCollectionSynchronization(class System.Collections.IEnumerable collection, object lockObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableCollectionSynchronization (collection As IEnumerable, lockObject As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableCollectionSynchronization(System::Collections::IEnumerable ^ collection, System::Object ^ lockObject);" />
      <MemberSignature Language="F#" Value="static member EnableCollectionSynchronization : System.Collections.IEnumerable * obj -&gt; unit" Usage="System.Windows.Data.BindingOperations.EnableCollectionSynchronization (collection, lockObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lockObject" Type="System.Object" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="collection">Kolekcja, która wymaga synchronizacji dostępu.</param>
        <param name="lockObject">Obiekt do zablokowania podczas uzyskiwania dostępu do kolekcji.</param>
        <summary><see cref="T:System.Windows.Data.CollectionView" /> Umożliwia obiektowi uczestnictwo w synchronizowanym dostępie do kolekcji używanej w wielu wątkach przy użyciu prostego mechanizmu blokowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

Aplikacja WPF może wyświetlić kolekcję danych <xref:System.Windows.Controls.ItemsControl> przy użyciu lub jednej z jej podklas (<xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.DataGrid>, <xref:System.Windows.Controls.TreeView> <xref:System.Windows.Controls.ListView>, itp.). Funkcja WPF tworzy kanał wszystkich dostępu do kolekcji za pomocą podklasy <xref:System.Windows.Data.CollectionView>. Zarówno, <xref:System.Windows.Controls.ItemsControl> <xref:System.Windows.Controls.ItemsControl> jak i <xref:System.Windows.Data.CollectionView> ma koligację do wątku, w którym został utworzony, co oznacza, że używanie ich w innym wątku jest zabronione i zgłasza wyjątek. W efekcie to ograniczenie dotyczy również kolekcji.
 
Możesz chcieć użyć kolekcji na wielu wątkach.   Na przykład, chcesz zaktualizować kolekcję (Dodaj lub Usuń elementy) do wątku "zbieranie danych", wyświetlając wyniki w wątku "interfejs użytkownika", dzięki czemu interfejs użytkownika nadal odpowiada podczas zbierania danych. W takiej sytuacji użytkownik jest odpowiedzialny za zapewnienie synchronizacji ("bezpieczny wątkowo") dostępu do kolekcji oraz zagwarantowanie, że dostęp z WPF ( <xref:System.Windows.Data.CollectionView>w odniesieniu do programu) jest częścią tego samego mechanizmu synchronizacji. Wywołując <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)> metodę, można to zrobić za pomocą prostego mechanizmu blokowania. 
 
Aby użyć kolekcji w wielu wątkach, jeden z nich jest wątkiem interfejsu użytkownika <xref:System.Windows.Controls.ItemsControl>, który jest właścicielem, należy wykonać następujące czynności:

1. Utworzenie wystąpienia obiektu do zablokowania podczas uzyskiwania dostępu do kolekcji.

1. Zsynchronizuj cały dostęp z aplikacji do kolekcji, blokując ten obiekt.

1. Wywołaj <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)> , aby poinformować WPF, że korzystasz z prostego mechanizmu blokowania.

   - Wywołanie musi nastąpić w wątku interfejsu użytkownika.

   - Wywołanie musi wystąpić przed użyciem kolekcji w innym wątku lub przed dołączeniem kolekcji do <xref:System.Windows.Controls.ItemsControl>elementu, w zależności od tego, co jest późniejsze.

1. Upewnij się, że zmiana kolekcji i powiadomienia o tej zmianie (za pośrednictwem <xref:System.Collections.Specialized.INotifyCollectionChanged>) są niepodzielne; brak dostępu z innych wątków może interweniować.  (Jest to zwykle bezpłatne. Na przykład <xref:System.Collections.ObjectModel.ObservableCollection%601> gwarantuje to, że wszystkie zmiany są chronione przez synchronizację.

1. W przypadku wywołania <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>tego wywołania musi również wystąpić w wątku interfejsu użytkownika.

1. Jeśli chcesz używać tej samej kolekcji w wielu wątkach interfejsu użytkownika, musisz wywołać <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> (i <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, jeśli to konieczne) oddzielnie w każdym wątku interfejsu użytkownika.

1. Unikaj zakleszczenia.  Jest to już odpowiedzialność aplikacji, gdy zdecyduje się ona na korzystanie z synchronizacji, ale musi także wziąć pod uwagę uczestnictwo WPF w synchronizacji. (Zobacz więcej, poniżej).

W programie WPF zapewnia następujące zachowanie:

- <xref:System.Windows.Data.CollectionView> Uzyskuje dostęp do kolekcji przy użyciu mechanizmu blokowania.

- <xref:System.Windows.Data.CollectionView> Zachowuje "kopię w tle" kolekcji do użycia w wątku interfejsu użytkownika.

- <xref:System.Windows.Data.CollectionView.CollectionChanged>zdarzenia są umieszczane w kolejce w miarę ich nadejścia (w dowolnym wątku).

- Oczekujące zdarzenia są stosowane do kopii w tle asynchronicznie w wątku interfejsu użytkownika, gdy ma ona możliwość wykonania tej czynności.

- <xref:System.Windows.Data.CollectionView> Program nie będzie bezpośrednio korzystać z żadnego innego mechanizmu synchronizacji widocznego dla aplikacji. Jest to sposób, aby pomóc w uniknięciu zakleszczenia (zobacz poprzedni element 7).   

Efektem netto jest to, że można zmienić kolekcję w dowolnym wątku, a te zmiany ostatecznie pojawiają się <xref:System.Windows.Controls.ItemsControl> w chwili, gdy wątek interfejsu użytkownika ma czas "Catch".  Wdrożenie zostało dostrojone w celu ograniczenia szybkości, która zmienia przepływ na wątek interfejsu użytkownika, aby utrzymać nasycenie wątków w tle, a następnie blokują odpowiedź na normalne dane wejściowe użytkownika.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableCollectionSynchronization">
      <MemberSignature Language="C#" Value="public static void EnableCollectionSynchronization (System.Collections.IEnumerable collection, object context, System.Windows.Data.CollectionSynchronizationCallback synchronizationCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableCollectionSynchronization(class System.Collections.IEnumerable collection, object context, class System.Windows.Data.CollectionSynchronizationCallback synchronizationCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableCollectionSynchronization (collection As IEnumerable, context As Object, synchronizationCallback As CollectionSynchronizationCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableCollectionSynchronization(System::Collections::IEnumerable ^ collection, System::Object ^ context, System::Windows::Data::CollectionSynchronizationCallback ^ synchronizationCallback);" />
      <MemberSignature Language="F#" Value="static member EnableCollectionSynchronization : System.Collections.IEnumerable * obj * System.Windows.Data.CollectionSynchronizationCallback -&gt; unit" Usage="System.Windows.Data.BindingOperations.EnableCollectionSynchronization (collection, context, synchronizationCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="context" Type="System.Object" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="synchronizationCallback" Type="System.Windows.Data.CollectionSynchronizationCallback" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="collection">Kolekcja, która wymaga synchronizacji dostępu.</param>
        <param name="context">Obiekt, który jest przesyłany do wywołania zwrotnego.</param>
        <param name="synchronizationCallback">Wywołanie zwrotne, które jest wywoływane za każdym razem, gdy wymagany jest dostęp do kolekcji. Można go użyć, aby upewnić się, że do kolekcji jest dostęp z jednego wątku w danym momencie.</param>
        <summary><see cref="T:System.Windows.Data.CollectionView" /> Umożliwia obiektowi uczestnictwo w synchronizowanym dostępie do kolekcji używanej w wielu wątkach przy użyciu mechanizmu innego niż prosta blokada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Aplikacja WPF może wyświetlić kolekcję danych <xref:System.Windows.Controls.ItemsControl> przy użyciu lub jednej z jej podklas (<xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.DataGrid>, <xref:System.Windows.Controls.TreeView> <xref:System.Windows.Controls.ListView>, itp.). Funkcja WPF tworzy kanał wszystkich dostępu do kolekcji za pomocą podklasy <xref:System.Windows.Data.CollectionView>. Zarówno, <xref:System.Windows.Controls.ItemsControl> <xref:System.Windows.Controls.ItemsControl> jak i <xref:System.Windows.Data.CollectionView> ma koligację do wątku, w którym został utworzony, co oznacza, że używanie ich w innym wątku jest zabronione i zgłasza wyjątek. W efekcie to ograniczenie dotyczy również kolekcji.
 
Możesz chcieć użyć kolekcji na wielu wątkach.   Na przykład, chcesz zaktualizować kolekcję (Dodaj lub Usuń elementy) do wątku "zbieranie danych", wyświetlając wyniki w wątku "interfejs użytkownika", dzięki czemu interfejs użytkownika nadal odpowiada podczas zbierania danych. W takiej sytuacji użytkownik jest odpowiedzialny za zapewnienie synchronizacji ("bezpieczny wątkowo") dostępu do kolekcji oraz zagwarantowanie, że dostęp z WPF ( <xref:System.Windows.Data.CollectionView>w odniesieniu do programu) jest częścią tego samego mechanizmu synchronizacji. Wywołując <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)> metodę, można to zrobić za pomocą mechanizmu synchronizacji, takiego jak semafory, zdarzenie resetowania itd.  Aby użyć kolekcji w wielu wątkach, jeden z nich jest wątkiem interfejsu użytkownika <xref:System.Windows.Controls.ItemsControl>, który jest właścicielem, należy wykonać następujące czynności:

1. Wybierz mechanizm synchronizacji.

1. Zsynchronizuj cały dostęp z aplikacji do kolekcji przy użyciu tego mechanizmu.

1. Wywołaj <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)> Przeciążenie, aby poinformować WPF, że korzystasz z mechanizmu innego niż proste blokowanie.

   - Wywołanie musi nastąpić w wątku interfejsu użytkownika.

   - Wywołanie musi wystąpić przed użyciem kolekcji w innym wątku lub przed dołączeniem kolekcji do <xref:System.Windows.Controls.ItemsControl>elementu, w zależności od tego, co jest późniejsze.

1. Upewnij się, że zmiana kolekcji i powiadomienia o tej zmianie (za pośrednictwem <xref:System.Collections.Specialized.INotifyCollectionChanged>) są niepodzielne; brak dostępu z innych wątków może interweniować.  (Jest to zwykle bezpłatne. Na przykład <xref:System.Collections.ObjectModel.ObservableCollection%601> gwarantuje to, że wszystkie zmiany są chronione przez synchronizację.

1. W przypadku wywołania <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>tego wywołania musi również wystąpić w wątku interfejsu użytkownika.

1. Jeśli chcesz używać tej samej kolekcji w wielu wątkach interfejsu użytkownika, musisz wywołać <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> (i <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, jeśli to konieczne) oddzielnie w każdym wątku interfejsu użytkownika.

1. Unikaj zakleszczenia.  Jest to już odpowiedzialność aplikacji, gdy zdecyduje się ona na korzystanie z synchronizacji, ale musi także wziąć pod uwagę uczestnictwo WPF w synchronizacji. (Zobacz więcej, poniżej).

W programie WPF zapewnia następujące zachowanie:

- Uzyskuje dostęp do kolekcji, wywołując zarejestrowane <xref:System.Windows.Data.CollectionSynchronizationCallback> z następującymi argumentami: <xref:System.Windows.Data.CollectionView>

   - `collection`: Kolekcja zainteresowania.
   - `context`: zarejestrowany obiekt kontekstu.
   - `accessMethod`: delegat, który wykonuje rzeczywisty dostęp.
   - `writeAccess`: `true` Jeśli delegat zmodyfikuje kolekcję; `false` w przeciwnym razie.

   Należy ustanowić synchronizację w kolekcji ( `context` przy użyciu obiektu i `writeAccess` `accessMethod`wartości, w razie potrzeby), wywołać, a następnie wycofać synchronizację. <xref:System.Windows.Data.CollectionSynchronizationCallback>

- <xref:System.Windows.Data.CollectionView> Zachowuje "kopię w tle" kolekcji do użycia w wątku interfejsu użytkownika.

- <xref:System.Windows.Data.CollectionView.CollectionChanged>zdarzenia są umieszczane w kolejce w miarę ich nadejścia (w dowolnym wątku).

- Oczekujące zdarzenia są stosowane do kopii w tle asynchronicznie w wątku interfejsu użytkownika, gdy ma ona możliwość wykonania tej czynności.

- <xref:System.Windows.Data.CollectionView> Program nie będzie bezpośrednio korzystać z żadnego innego mechanizmu synchronizacji widocznego dla aplikacji. Jest to sposób, aby pomóc w uniknięciu zakleszczenia (zobacz poprzedni element 7).   

Efektem netto jest to, że można zmienić kolekcję w dowolnym wątku, a te zmiany ostatecznie pojawiają się <xref:System.Windows.Controls.ItemsControl> w chwili, gdy wątek interfejsu użytkownika ma czas "Catch".  Wdrożenie zostało dostrojone w celu ograniczenia szybkości, która zmienia przepływ na wątek interfejsu użytkownika, aby utrzymać nasycenie wątków w tle, a następnie blokują odpowiedź na normalne dane wejściowe użytkownika.

 Parametr jest dowolnym obiektem, który jest przesyłany `callback`do. `context` Można jej użyć do określenia mechanizmu synchronizacji używanego do kontrolowania dostępu do `collection`programu. `Context`może być `null`.  
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBinding">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.Binding GetBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.Binding GetBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBinding (target As DependencyObject, dp As DependencyProperty) As Binding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::Binding ^ GetBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.Binding" Usage="System.Windows.Data.BindingOperations.GetBinding (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.Binding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt, gdzie <paramref name="dp" /> is.</param>
        <param name="dp">Właściwość Target powiązania, z której ma zostać pobrane powiązanie.</param>
        <summary><see cref="T:System.Windows.Data.Binding" /> Pobiera obiekt, który jest ustawiony dla określonej właściwości.</summary>
        <returns>Obiekt ustawiony dla danej właściwości lub <see langword="null" /> Jeśli żaden obiekt nie <see cref="T:System.Windows.Data.Binding" /> został ustawiony. <see cref="T:System.Windows.Data.Binding" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Parametry <paramref name="target" /> i<paramref name="dp" /> nie mogą mieć wartości null.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetMultiBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetPriorityBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetBindingBase">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.BindingBase GetBindingBase (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.BindingBase GetBindingBase(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBindingBase (target As DependencyObject, dp As DependencyProperty) As BindingBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::BindingBase ^ GetBindingBase(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetBindingBase : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingBase" Usage="System.Windows.Data.BindingOperations.GetBindingBase (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt, gdzie <paramref name="dp" /> is.</param>
        <param name="dp">Właściwość Target powiązania, z której ma zostać pobrany <see cref="T:System.Windows.Data.BindingBase" /> obiekt.</param>
        <summary><see cref="T:System.Windows.Data.BindingBase" /> Pobiera obiekt, który jest ustawiony dla określonej właściwości.</summary>
        <returns>Obiekt, który jest ustawiony dla danej właściwości lub <see langword="null" /> nie został ustawiony obiekt powiązania. <see cref="T:System.Windows.Data.BindingBase" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa jest wspólną klasą bazową <xref:System.Windows.Data.Binding>dla klas, <xref:System.Windows.Data.PriorityBinding>i <xref:System.Windows.Data.MultiBinding>. <xref:System.Windows.Data.BindingBase> Możesz użyć <xref:System.Windows.Data.BindingOperations.GetBinding%2A>metod,, <xref:System.Windows.Data.BindingOperations.GetPriorityBinding%2A>i <xref:System.Windows.Data.BindingOperations.GetMultiBinding%2A> , Jeśli wiesz, jaki typ powiązania jest ustawiony we właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametry <paramref name="target" /> <see langword="null" />i <paramref name="dp" /> nie mogą być.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBindingExpression (target As DependencyObject, dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetBindingExpression : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="System.Windows.Data.BindingOperations.GetBindingExpression (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt docelowy powiązania, gdzie <paramref name="dp" /> is.</param>
        <param name="dp">Właściwość Target powiązania, z której ma zostać pobrany <see cref="T:System.Windows.Data.BindingExpression" /> obiekt.</param>
        <summary><see cref="T:System.Windows.Data.BindingExpression" /> Zwraca obiekt skojarzony z określoną właściwością Target powiązania dla określonego obiektu.</summary>
        <returns>Obiekt skojarzony z daną właściwością lub <see langword="null" /> Jeśli nie istnieje. <see cref="T:System.Windows.Data.BindingExpression" /> Jeśli obiekt jest ustawiony we właściwości <see cref="P:System.Windows.Data.PriorityBindingExpression.ActiveBindingExpression" /> , jest zwracany. <see cref="T:System.Windows.Data.PriorityBindingExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.BindingExpression> Obiekt utrzymuje połączenie między źródłem powiązania a celem powiązania. Możesz uzyskać <xref:System.Windows.Data.BindingExpression> obiekt, wywołując tę metodę statyczną lub <xref:System.Windows.FrameworkElement.GetBindingExpression%2A> wywołując metodę dla obiektu lub <xref:System.Windows.FrameworkContentElement> powiązanego <xref:System.Windows.FrameworkElement> z danymi.  
  
   
  
## Examples  
 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Poniższy przykład pokazuje implementację procedury obsługi zdarzeń, która <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A> używa metody do uzyskania <xref:System.Windows.Data.BindingExpression> , a następnie wywołuje <xref:System.Windows.Data.BindingExpression.DataItem%2A> właściwość w celu uzyskania dostępu do obiektu źródłowego powiązania.  
  
 Jest obiektem docelowym powiązania i <xref:System.Windows.Controls.TextBlock.Text%2A> jest właściwością Target powiązania. <xref:System.Windows.Controls.TextBlock> `SavingsText`  
  
 [!code-csharp[DirectionalBinding#OnRentRaise](~/samples/snippets/csharp/VS_Snippets_Wpf/DirectionalBinding/CSharp/Page1.xaml.cs#onrentraise)]
 [!code-vb[DirectionalBinding#OnRentRaise](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DirectionalBinding/VisualBasic/DirectionalBinding.vb#onrentraise)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametry <paramref name="target" /> <see langword="null" />i <paramref name="dp" /> nie mogą być.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetMultiBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetPriorityBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpressionBase">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.BindingExpressionBase GetBindingExpressionBase (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.BindingExpressionBase GetBindingExpressionBase(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBindingExpressionBase (target As DependencyObject, dp As DependencyProperty) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::BindingExpressionBase ^ GetBindingExpressionBase(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetBindingExpressionBase : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpressionBase" Usage="System.Windows.Data.BindingOperations.GetBindingExpressionBase (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt, gdzie <paramref name="dp" /> is.</param>
        <param name="dp">Właściwość Target powiązania, z której ma zostać pobrany <see cref="T:System.Windows.Data.BindingExpressionBase" /> obiekt.</param>
        <summary><see cref="T:System.Windows.Data.BindingExpressionBase" /> Pobiera obiekt, który jest ustawiony dla określonej właściwości.</summary>
        <returns>Obiekt, który jest ustawiony dla danej właściwości lub <see langword="null" /> nie został ustawiony obiekt powiązania. <see cref="T:System.Windows.Data.BindingExpressionBase" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa jest wspólną klasą bazową <xref:System.Windows.Data.BindingExpression>dla klas, <xref:System.Windows.Data.PriorityBindingExpression>i <xref:System.Windows.Data.MultiBindingExpression>. <xref:System.Windows.Data.BindingExpressionBase> Możesz użyć <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A>metod,, <xref:System.Windows.Data.BindingOperations.GetPriorityBindingExpression%2A>i <xref:System.Windows.Data.BindingOperations.GetMultiBindingExpression%2A> , jeśli znasz typ powiązania, który jest ustawiony we właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametry <paramref name="target" /> i<paramref name="dp" /> nie mogą mieć wartości null.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetMultiBinding">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.MultiBinding GetMultiBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.MultiBinding GetMultiBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetMultiBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMultiBinding (target As DependencyObject, dp As DependencyProperty) As MultiBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::MultiBinding ^ GetMultiBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetMultiBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.MultiBinding" Usage="System.Windows.Data.BindingOperations.GetMultiBinding (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.MultiBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt, gdzie <paramref name="dp" /> is.</param>
        <param name="dp">Właściwość Target powiązania, z której ma zostać pobrane powiązanie.</param>
        <summary><see cref="T:System.Windows.Data.MultiBinding" /> Pobiera obiekt, który jest ustawiony dla określonej właściwości.</summary>
        <returns>Obiekt ustawiony dla danej właściwości lub <see langword="null" /> Jeśli żaden obiekt nie <see cref="T:System.Windows.Data.MultiBinding" /> został ustawiony. <see cref="T:System.Windows.Data.MultiBinding" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Parametry <paramref name="target" /> i<paramref name="dp" /> nie mogą mieć wartości null.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetMultiBindingExpression">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.MultiBindingExpression GetMultiBindingExpression (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.MultiBindingExpression GetMultiBindingExpression(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetMultiBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMultiBindingExpression (target As DependencyObject, dp As DependencyProperty) As MultiBindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::MultiBindingExpression ^ GetMultiBindingExpression(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetMultiBindingExpression : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.MultiBindingExpression" Usage="System.Windows.Data.BindingOperations.GetMultiBindingExpression (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.MultiBindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt docelowy powiązania, gdzie <paramref name="dp" /> is.</param>
        <param name="dp">Właściwość Target powiązania, z której ma zostać pobrany <see cref="T:System.Windows.Data.MultiBindingExpression" /> obiekt.</param>
        <summary><see cref="T:System.Windows.Data.MultiBindingExpression" /> Zwraca obiekt skojarzony z określoną właściwością Target powiązania dla określonego obiektu.</summary>
        <returns>Obiekt skojarzony z daną właściwością lub <see langword="null" /> Jeśli nie istnieje. <see cref="T:System.Windows.Data.MultiBindingExpression" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt skojarzony z daną właściwością lub `null` Jeśli nie istnieje. <xref:System.Windows.Data.MultiBindingExpression>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametry <paramref name="target" /> <see langword="null" />i <paramref name="dp" /> nie mogą być.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetMultiBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetPriorityBinding">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.PriorityBinding GetPriorityBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.PriorityBinding GetPriorityBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetPriorityBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPriorityBinding (target As DependencyObject, dp As DependencyProperty) As PriorityBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::PriorityBinding ^ GetPriorityBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetPriorityBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.PriorityBinding" Usage="System.Windows.Data.BindingOperations.GetPriorityBinding (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.PriorityBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt, gdzie <paramref name="dp" /> is.</param>
        <param name="dp">Właściwość Target powiązania, z której ma zostać pobrane powiązanie.</param>
        <summary><see cref="T:System.Windows.Data.PriorityBinding" /> Pobiera obiekt, który jest ustawiony dla określonej właściwości.</summary>
        <returns>Obiekt ustawiony dla danej właściwości lub <see langword="null" /> Jeśli żaden obiekt nie <see cref="T:System.Windows.Data.PriorityBinding" /> został ustawiony. <see cref="T:System.Windows.Data.PriorityBinding" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Parametry <paramref name="target" /> i<paramref name="dp" /> nie mogą mieć wartości null.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetPriorityBindingExpression">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.PriorityBindingExpression GetPriorityBindingExpression (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.PriorityBindingExpression GetPriorityBindingExpression(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetPriorityBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPriorityBindingExpression (target As DependencyObject, dp As DependencyProperty) As PriorityBindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::PriorityBindingExpression ^ GetPriorityBindingExpression(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetPriorityBindingExpression : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.PriorityBindingExpression" Usage="System.Windows.Data.BindingOperations.GetPriorityBindingExpression (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.PriorityBindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt docelowy powiązania, gdzie <paramref name="dp" /> is.</param>
        <param name="dp">Właściwość Target powiązania, z której ma zostać pobrany <see cref="T:System.Windows.Data.PriorityBindingExpression" /> obiekt.</param>
        <summary><see cref="T:System.Windows.Data.PriorityBindingExpression" /> Zwraca obiekt skojarzony z określoną właściwością Target powiązania dla określonego obiektu.</summary>
        <returns>Obiekt skojarzony z daną właściwością lub <see langword="null" /> Jeśli nie istnieje. <see cref="T:System.Windows.Data.PriorityBindingExpression" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Parametry <paramref name="target" /> <see langword="null" />i <paramref name="dp" /> nie mogą być.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetPriorityBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetSourceUpdatingBindingGroups">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingGroup&gt; GetSourceUpdatingBindingGroups (System.Windows.DependencyObject root);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Windows.Data.BindingGroup&gt; GetSourceUpdatingBindingGroups(class System.Windows.DependencyObject root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetSourceUpdatingBindingGroups(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSourceUpdatingBindingGroups (root As DependencyObject) As ReadOnlyCollection(Of BindingGroup)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Data::BindingGroup ^&gt; ^ GetSourceUpdatingBindingGroups(System::Windows::DependencyObject ^ root);" />
      <MemberSignature Language="F#" Value="static member GetSourceUpdatingBindingGroups : System.Windows.DependencyObject -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingGroup&gt;" Usage="System.Windows.Data.BindingOperations.GetSourceUpdatingBindingGroups root" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingGroup&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="root">Katalog główny <see cref="T:System.Windows.UIElement" /> , dla którego mają zostać pobrane grupy powiązań.  Ta metoda zwraca <see cref="T:System.Windows.Data.BindingGroup" /> obiekty, które są skojarzone z tym elementem lub jego elementami podrzędnymi.</param>
        <summary>Pobiera wszystkie <see cref="T:System.Windows.Data.BindingGroup" /> obiekty z nieprawidłowymi wartościami lub wartościami docelowymi, które nie zostały zaktualizowane.</summary>
        <returns>Kolekcja <see cref="T:System.Windows.Data.BindingGroup" /> obiektów, które są skojarzone z określonym elementem i mają nieprawidłowe wartości lub wartości docelowe, nie została zaktualizowana jako źródło.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `root` jest `null`, zwraca<xref:System.Windows.Data.BindingOperations.GetSourceUpdatingBindingGroups%2A> wszystkie<xref:System.Windows.Data.BindingGroup> obiekty, które są nieprawidłowe lub nie zostały zaktualizowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSourceUpdatingBindings">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingExpressionBase&gt; GetSourceUpdatingBindings (System.Windows.DependencyObject root);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Windows.Data.BindingExpressionBase&gt; GetSourceUpdatingBindings(class System.Windows.DependencyObject root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetSourceUpdatingBindings(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSourceUpdatingBindings (root As DependencyObject) As ReadOnlyCollection(Of BindingExpressionBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Data::BindingExpressionBase ^&gt; ^ GetSourceUpdatingBindings(System::Windows::DependencyObject ^ root);" />
      <MemberSignature Language="F#" Value="static member GetSourceUpdatingBindings : System.Windows.DependencyObject -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingExpressionBase&gt;" Usage="System.Windows.Data.BindingOperations.GetSourceUpdatingBindings root" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingExpressionBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="root">Katalog główny <see cref="T:System.Windows.UIElement" /> , dla którego mają zostać pobrane grupy powiązań.  Ta metoda zwraca <see cref="T:System.Windows.Data.BindingExpressionBase" /> obiekty, które są skojarzone z tym elementem lub jego elementami podrzędnymi.</param>
        <summary>Pobiera wszystkie <see cref="T:System.Windows.Data.BindingExpressionBase" /> obiekty z nieprawidłowymi wartościami lub wartościami docelowymi, które nie zostały zaktualizowane.</summary>
        <returns>Kolekcja <see cref="T:System.Windows.Data.BindingExpressionBase" /> obiektów, które są skojarzone z określonym elementem i mają nieprawidłowe wartości lub wartości docelowe, nie została zaktualizowana jako źródło.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `root` jest `null`, zwraca<xref:System.Windows.Data.BindingOperations.GetSourceUpdatingBindings%2A> wszystkie<xref:System.Windows.Data.BindingExpressionBase> obiekty, które są nieprawidłowe lub nie zostały zaktualizowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDataBound">
      <MemberSignature Language="C#" Value="public static bool IsDataBound (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDataBound(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.IsDataBound(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDataBound (target As DependencyObject, dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDataBound(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member IsDataBound : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; bool" Usage="System.Windows.Data.BindingOperations.IsDataBound (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt, gdzie <paramref name="dp" /> is.</param>
        <param name="dp">Właściwość zależności do sprawdzenia.</param>
        <summary>Zwraca wartość wskazującą, czy określona właściwość jest obecnie powiązana z danymi.</summary>
        <returns><see langword="true" />Jeśli określona właściwość jest powiązana z danymi; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Jeśli <paramref name="target" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.SetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetBinding (target As DependencyObject, dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="static member SetBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="System.Windows.Data.BindingOperations.SetBinding (target, dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt docelowy powiązania powiązania.</param>
        <param name="dp">Właściwość Target powiązania.</param>
        <param name="binding"><see cref="T:System.Windows.Data.BindingBase" /> Obiekt, który opisuje powiązanie.</param>
        <summary>Tworzy i kojarzy nowe wystąpienie <see cref="T:System.Windows.Data.BindingExpressionBase" /> z określoną właściwością Target powiązania.</summary>
        <returns>Wystąpienie <see cref="T:System.Windows.Data.BindingExpressionBase" /> utworzone dla i skojarzone z określoną właściwością. Klasa jest <see cref="T:System.Windows.Data.MultiBindingExpression" /> <see cref="T:System.Windows.Data.PriorityBindingExpression" />klasą bazową ,,i.<see cref="T:System.Windows.Data.BindingExpression" /> <see cref="T:System.Windows.Data.BindingExpressionBase" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy nowe wystąpienie <xref:System.Windows.Data.BindingExpressionBase> a i kojarzy wystąpienie z określoną właściwością zależności danego obiektu. Ta metoda umożliwia dołączenie powiązania do dowolnego <xref:System.Windows.DependencyObject> elementu, który może nie ujawniać własnej metody SetBinding.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać tej metody do ustawiania powiązania. W tym przykładzie `myNewBindDef` <xref:System.Windows.Data.Binding> jest obiektem opisującym powiązanie. Obiekt docelowy powiązania to `myDateText`wystąpienie <xref:System.Windows.Controls.TextBlock> klasy.  
  
 [!code-csharp[BindConversion#BOSetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/BindConversion/CSharp/Window1.xaml.cs#bosetbinding)]
 [!code-vb[BindConversion#BOSetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindConversion/visualbasic/window1.xaml.vb#bosetbinding)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr nie może być <see langword="null" />. <paramref name="binding" /></exception>
      </Docs>
    </Member>
  </Members>
</Type>

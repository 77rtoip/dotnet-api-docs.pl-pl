<Type Name="BindingGroup" FullName="System.Windows.Data.BindingGroup">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d3a647603ff7b049f413279f879107b667ee1b02" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69211149" /></Metadata><TypeSignature Language="C#" Value="public class BindingGroup : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BindingGroup extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Data.BindingGroup" />
  <TypeSignature Language="VB.NET" Value="Public Class BindingGroup&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class BindingGroup : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type BindingGroup = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zawiera kolekcję powiązań i <see cref="T:System.Windows.Controls.ValidationRule" /> obiektów, które są używane do walidacji obiektu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.BindingGroup> Tworzy relację między wieloma powiązaniami, które można sprawdzić i zaktualizować jednocześnie. Załóżmy na przykład, że aplikacja poprosi użytkownika o wprowadzenie adresu. Następnie `Address`aplikacja wypełnia obiekt typu, który ma właściwości, `Street`, `City` `ZipCode`, i `Country`, z wartościami dostarczonymi przez użytkownika. Aplikacja ma panel, który zawiera cztery <xref:System.Windows.Controls.TextBox> kontrolki, z których każdy jest powiązany z jednym z właściwości obiektu. Aby sprawdzić poprawność <xref:System.Windows.Controls.ValidationRule> `Address` obiektu <xref:System.Windows.Data.BindingGroup> , można użyć elementu in a. Jeśli powiązania uczestniczą w tym samym <xref:System.Windows.Data.BindingGroup>, można upewnić się, że kod pocztowy jest prawidłowy dla kraju/regionu adresu.  
  
 <xref:System.Windows.FrameworkElement.BindingGroup%2A> Właściwość jest ustawiana na <xref:System.Windows.FrameworkElement> lub <xref:System.Windows.FrameworkContentElement>. Elementy podrzędne dziedziczą <xref:System.Windows.Data.BindingGroup> elementy z elementów nadrzędnych, podobnie jak w przypadku każdej innej dziedziczonej właściwości. Powiązanie w elemencie potomnym jest dodawane do a, <xref:System.Windows.Data.BindingGroup> Jeśli wystąpi jedna z następujących sytuacji:  
  
-   Źródło powiązania i <xref:System.Windows.FrameworkElement.DataContext%2A> element, który <xref:System.Windows.Data.BindingGroup> ma taki sam obiekt, i <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> właściwość nie została ustawiona.  
  
-   Właściwość powiązania jest równa <xref:System.Windows.Data.BindingGroup.Name%2A> <xref:System.Windows.FrameworkContentElement.BindingGroup%2A> wartości i nie jest jawnie ustawiona na `null`. <xref:System.Windows.Data.BindingBase.BindingGroupName%2A>  
  
 W przykładzie adresu Załóżmy, że <xref:System.Windows.FrameworkElement.DataContext%2A> dla <xref:System.Windows.Controls.Panel> elementu jest ustawiony obiekt typu `Address`. Powiązanie dla każdej <xref:System.Windows.Data.BindingGroup> z <xref:System.Windows.Controls.TextBox> nich jest dodawane do panelu.  
  
 Dodaj <xref:System.Windows.Controls.ValidationRule> obiekty<xref:System.Windows.Data.BindingGroup>do. Jest przenoszona jako pierwszy parametr <xref:System.Windows.Controls.ValidationRule.Validate%2A> metody podczas <xref:System.Windows.Controls.ValidationRule> uruchamiania. <xref:System.Windows.Data.BindingGroup> Możesz użyć <xref:System.Windows.Data.BindingGroup.TryGetValue%2A> <xref:System.Windows.Data.BindingGroup.Items%2A> metody <xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29> lub, aby uzyskać proponowane wartości obiektu i właściwość, aby uzyskać źródła powiązań. <xref:System.Windows.Data.BindingGroup>  
  
 A <xref:System.Windows.Data.BindingGroup> jednocześnie aktualizuje źródła powiązania, zamiast każdego powiązania, które jest aktualizowane osobno. Po wywołaniu jednej z metod sprawdzania poprawności danych<xref:System.Windows.Data.BindingGroup.ValidateWithoutUpdate%2A>(, <xref:System.Windows.Data.BindingGroup.UpdateSources%2A>lub <xref:System.Windows.Data.BindingGroup.CommitEdit%2A>), powiązanie dla każdego z nich <xref:System.Windows.Controls.TextBox> w przykładzie jest zweryfikowane i potencjalnie zaktualizowane. Gdy powiązanie jest <xref:System.Windows.Data.BindingGroup>częścią, Źródło powiązania nie jest aktualizowane do momentu wywołania <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> lub <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A> w <xref:System.Windows.Data.BindingGroup>, chyba że jawnie ustawisz właściwość.  
  
   
  
## Examples  
 W poniższych przykładach utworzysz aplikację, która będzie monitował użytkownika o wprowadzenie opisu i ceny elementu oraz daty wygaśnięcia oferty. Aplikacja wyświetli bieżące informacje dla elementu poniżej formularza. Użytkownik może przesłać lub anulować zmiany.  
  
 Aby osiągnąć to zachowanie, aplikacja wykonuje następujące czynności.  
  
-   Tworzy i dodaje go do elementu głównego <xref:System.Windows.Controls.StackPanel> podczas tworzenia [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] aplikacji. <xref:System.Windows.Data.BindingGroup>  
  
-   Wywołuje <xref:System.Windows.Data.BindingGroup.BeginEdit%2A>, <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> i<xref:System.Windows.Data.BindingGroup.CancelEdit%2A> w logice aplikacji, aby włączyć wycofywanie zmian.  
  
-   Wywołuje <xref:System.Windows.Data.BindingGroup.TryGetValue%2A> metodę<xref:System.Windows.Controls.ValidationRule.Validate%2A> w celu uzyskania danych wejściowych użytkownika, a następnie sprawdza, czy element ponad 100 dolarów jest dostępny przez co najmniej siedem dni.  
  
 Poniższy przykład tworzy [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] aplikację. Katalog główny <xref:System.Windows.Controls.StackPanel> <xref:System.Windows.Data.BindingGroup> zawiera<xref:System.Windows.Controls.ValidationRule> element, który jest weryfikowany przez program, zgodnie z wcześniejszym opisem. Obiekty powiązań we `Price` właściwości `OfferExpires` i <xref:System.Windows.Data.BindingGroup> właściwość stają się częścią i każde powiązanie ma wartość <xref:System.Windows.Controls.ValidationRule> , aby upewnić się, że odpowiednio cena i Data są prawidłowe. Reguły walidacji dla poszczególnych właściwości są uruchamiane przed <xref:System.Windows.Controls.ValidationRule> <xref:System.Windows.Data.BindingGroup>na.  
  
 [!code-xaml[BindingGroupSnippets#WindowLayout](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml#windowlayout)]  
  
 Poniższy przykład pokazuje programy obsługi zdarzeń dla aplikacji. Gdy użytkownik kliknie przycisk Prześlij, aplikacja wywoła <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> do uruchomienia każdy <xref:System.Windows.Controls.ValidationRule> , <xref:System.Windows.Data.BindingGroup>który jest skojarzony z. Jeśli każde <xref:System.Windows.Controls.ValidationRule> z nich powiedzie się, program <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> zapisze wartości do obiektu i zakończy edytowanie transakcji. Jeśli <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> się powiedzie, aplikacja rozpocznie kolejną edycję transakcji. <xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType> <xref:System.Windows.Data.BindingGroup.NotifyOnValidationError%2A> `true` Gdy wystąpi <xref:System.Windows.Controls.ValidationRule> błąd, zdarzenie występuje, ponieważ<xref:System.Windows.Data.BindingGroup> aplikacja ma ustawioną wartość na (w poprzednim przykładzie). `ItemError`<xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType> obsługuje zdarzenie i wyświetla informacje o błędzie walidacji użytkownika. W przykładzie jest również obsługiwane <xref:System.Windows.FrameworkElement.Loaded> zdarzenie <xref:System.Windows.Controls.StackPanel> dla i <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzenia dla przycisku **Anuluj** .  
  
 [!code-csharp[BindingGroupSnippets#WindowLogic](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#windowlogic)]
 [!code-vb[BindingGroupSnippets#WindowLogic](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#windowlogic)]  
  
 Poniższy przykład pokazuje niestandardowy <xref:System.Windows.Controls.ValidationRule> `ValidateDateAndPrice`, <xref:System.Windows.Data.BindingGroup> który został dodany do pierwszego przykładu. <xref:System.Windows.Controls.ValidationRule> Używametody<xref:System.Windows.Controls.ValidationRule.Validate%2A> w metodzie, aby uzyskać wartości wprowadzone przez użytkownika w formularzu i sprawdza, czy jeśli element jest ponad 100 dolarów, będzie dostępny przez co najmniej siedem dni. <xref:System.Windows.Data.BindingGroup>  
  
 [!code-csharp[BindingGroupSnippets#ValidateObject](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Data.cs#validateobject)]
 [!code-vb[BindingGroupSnippets#ValidateObject](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/data.vb#validateobject)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingGroup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingGroup();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Data.BindingGroup" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginEdit">
      <MemberSignature Language="C#" Value="public void BeginEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.BeginEdit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginEdit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginEdit();" />
      <MemberSignature Language="F#" Value="member this.BeginEdit : unit -&gt; unit" Usage="bindingGroup.BeginEdit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna edytowanie transakcji w źródłach <see cref="T:System.Windows.Data.BindingGroup" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli źródła w <xref:System.Windows.Data.BindingGroup> pomocy technicznej odrzucają oczekujące zmiany, można wywołać <xref:System.Windows.Data.BindingGroup.BeginEdit%2A> , aby rozpocząć edycję transakcji, wywołać <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> , aby zapisać oczekujące zmiany, <xref:System.Windows.Data.BindingGroup.CancelEdit%2A> Wywołaj, aby odrzucić oczekujące zmiany.  
  
 Dla każdego obiektu w <xref:System.Windows.Data.BindingGroup.Items%2A> , który <xref:System.ComponentModel.IEditableObject>implementuje <xref:System.Windows.Data.BindingGroup.BeginEdit%2A> , wywołuje<xref:System.ComponentModel.IEditableObject.BeginEdit%2A?displayProperty=nameWithType>  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Windows.Data.BindingGroup.BeginEdit%2A> czas ładowania okna, aby rozpocząć edytowanie transakcji.  
  
 [!code-csharp[BindingGroupSnippets#BeginEdit](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#beginedit)]
 [!code-vb[BindingGroupSnippets#BeginEdit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#beginedit)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingExpressions">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.Windows.Data.BindingExpressionBase&gt; BindingExpressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.Windows.Data.BindingExpressionBase&gt; BindingExpressions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.BindingExpressions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BindingExpressions As Collection(Of BindingExpressionBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::Windows::Data::BindingExpressionBase ^&gt; ^ BindingExpressions { System::Collections::ObjectModel::Collection&lt;System::Windows::Data::BindingExpressionBase ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BindingExpressions : System.Collections.ObjectModel.Collection&lt;System.Windows.Data.BindingExpressionBase&gt;" Usage="System.Windows.Data.BindingGroup.BindingExpressions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.Windows.Data.BindingExpressionBase&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję <see cref="T:System.Windows.Data.BindingExpression" /> obiektów, które zawierają informacje dla każdego powiązania <see cref="T:System.Windows.Data.BindingGroup" />w.</summary>
        <value>Kolekcja <see cref="T:System.Windows.Data.BindingExpression" /> obiektów, która zawiera informacje dla każdego powiązania <see cref="T:System.Windows.Data.BindingGroup" />w.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Data.BindingExpression> należy do a <xref:System.Windows.Data.BindingGroup> w przypadku wystąpienia jednego z następujących przypadków:  
  
-   Źródło powiązania i <xref:System.Windows.FrameworkElement.DataContext%2A> element, który <xref:System.Windows.Data.BindingGroup> ma taki sam obiekt, i <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> nie jest ustawiony.  
  
-   Właściwość powiązania <xref:System.Windows.Data.BindingGroup> i <xref:System.Windows.Data.BindingGroup.Name%2A> elementu ma ustawioną tę samą wartość różną od null i należy do elementu nadrzędnego elementu docelowego powiązania. <xref:System.Windows.Data.BindingGroup> <xref:System.Windows.Data.BindingBase.BindingGroupName%2A>  
  
-   Dodasz <xref:System.Windows.Data.BindingExpression> do <xref:System.Windows.Data.BindingGroup.BindingExpressions%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelEdit">
      <MemberSignature Language="C#" Value="public void CancelEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.CancelEdit" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelEdit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelEdit();" />
      <MemberSignature Language="F#" Value="member this.CancelEdit : unit -&gt; unit" Usage="bindingGroup.CancelEdit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka edytowanie transakcji i odrzuca oczekujące zmiany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powoduje, że źródła odrzucają oczekujące zmiany, jeśli obiekt źródłowy jest w stanie wykonać tę operację i zakończy edytowanie transakcji. Następnie metoda aktualizuje właściwości docelowe przy użyciu zapisanych wartości źródłowych.  
  
 Dla każdego obiektu w <xref:System.Windows.Data.BindingGroup.Items%2A> , który <xref:System.ComponentModel.IEditableObject>implementuje <xref:System.Windows.Data.BindingGroup.CancelEdit%2A> , wywołuje<xref:System.ComponentModel.IEditableObject.CancelEdit%2A?displayProperty=nameWithType>  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Windows.Data.BindingGroup.CancelEdit%2A> odrzucanie oczekujących zmian, a następnie <xref:System.Windows.Data.BindingGroup.BeginEdit%2A> wywołuje w celu przygotowania źródła do ponownego edytowania.  
  
 [!code-csharp[BindingGroupSnippets#CancelEdit](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#canceledit)]
 [!code-vb[BindingGroupSnippets#CancelEdit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#canceledit)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRestoreValues">
      <MemberSignature Language="C#" Value="public bool CanRestoreValues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRestoreValues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.CanRestoreValues" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRestoreValues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRestoreValues { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRestoreValues : bool" Usage="System.Windows.Data.BindingGroup.CanRestoreValues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy każde źródło w powiązaniu może odrzucać oczekujące zmiany i przywracać pierwotne wartości.</summary>
        <value><see langword="true" />Jeśli każde źródło w powiązaniu może odrzucić oczekujące zmiany i przywrócić oryginalne wartości; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Źródło może odrzucać oczekujące zmiany, <xref:System.ComponentModel.IEditableObject>jeśli implementuje.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommitEdit">
      <MemberSignature Language="C#" Value="public bool CommitEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CommitEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.CommitEdit" />
      <MemberSignature Language="VB.NET" Value="Public Function CommitEdit () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CommitEdit();" />
      <MemberSignature Language="F#" Value="member this.CommitEdit : unit -&gt; bool" Usage="bindingGroup.CommitEdit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia wszystkie <see cref="T:System.Windows.Controls.ValidationRule" /> obiekty i aktualizuje źródła powiązań, jeśli wszystkie reguły poprawności zostały wykonane pomyślnie.</summary>
        <returns><see langword="true" />Jeśli każde <see cref="T:System.Windows.Controls.ValidationRule" /> się powiedzie, a wartości są zatwierdzone dla źródeł; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli każde <xref:System.Windows.Controls.ValidationRule> z nich powiedzie się, ta metoda powoduje, że źródła zatwierdzią oczekujące zmiany i zakończą edycję transakcji, jeśli obiekt źródłowy jest w stanie wykonać tę operację.  
  
 Dla każdego obiektu w <xref:System.Windows.Data.BindingGroup.Items%2A> , który <xref:System.ComponentModel.IEditableObject>implementuje <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> , wywołuje<xref:System.ComponentModel.IEditableObject.EndEdit%2A?displayProperty=nameWithType>  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> , aby zapisać oczekujące zmiany, a następnie <xref:System.Windows.Data.BindingGroup.BeginEdit%2A> wywołuje polecenie przygotowania źródła do ponownego edytowania.  
  
 [!code-csharp[BindingGroupSnippets#BeginEdit](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#beginedit)]
 [!code-vb[BindingGroupSnippets#BeginEdit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#beginedit)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (object item, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(object item, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.GetValue(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (item As Object, propertyName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Object ^ item, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="override this.GetValue : obj * string -&gt; obj" Usage="bindingGroup.GetValue (item, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt, który zawiera określoną właściwość.</param>
        <param name="propertyName">Właściwość, której proponowana wartość ma zostać uzyskana.</param>
        <summary>Zwraca proponowaną wartość dla określonej właściwości i elementu.</summary>
        <returns>Proponowana wartość właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody w <xref:System.Windows.Controls.ValidationRule.Validate%2A?displayProperty=nameWithType> metodzie, aby uzyskać wartość do zatwierdzenia dla źródła. Typ wartości zwracanej zależy od etapu, w którym <xref:System.Windows.Controls.ValidationRule> występuje. Na <xref:System.Windows.Controls.TextBox> przykład jeśli dane są powiązane z właściwością typu Integer <xref:System.Windows.Controls.ValidationStep.RawProposedValue> <xref:System.Windows.Controls.ValidationRule> i że wywołania <xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29> mają <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> ustawioną wartość, metoda zwraca ciąg. <xref:System.Windows.Controls.ValidationRule> Jeśli ma<xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> ustawiony na<xref:System.Windows.Controls.ValidationStep.ConvertedProposedValue>, metoda zwraca dowolny typ, który jest zwracany przez konwerter powiązania. W tym przykładzie <xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29> zwykle zwraca liczbę całkowitą.  
  
   
  
## Examples  
 Poniższy przykład jest częścią aplikacji, która poprosi użytkownika o wprowadzenie wielu klientów i przypisanie przedstawicielowi sprzedaży do każdego klienta. Aplikacja sprawdza, czy przedstawiciel handlowy i klient należą do tego samego regionu. W przykładzie przedstawiono <xref:System.Windows.Controls.ValidationRule.Validate%2A> metodę, która <xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29> używa metody do pobierania wartości wprowadzonych przez klienta.  
  
 [!code-csharp[BindingGroupSnippets#ItemBindGroupValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window2.xaml.cs#itembindgroupvalidationrule)]
 [!code-vb[BindingGroupSnippets#ItemBindGroupValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window2.xaml.vb#itembindgroupvalidationrule)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie istnieje powiązanie dla określonego elementu i właściwości.</exception>
        <exception cref="T:System.Windows.Data.ValueUnavailableException">Wartość określonej właściwości jest niedostępna z powodu błędu konwersji lub ponieważ wcześniejsza reguła walidacji zakończyła się niepowodzeniem.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasValidationError">
      <MemberSignature Language="C#" Value="public bool HasValidationError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValidationError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.HasValidationError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValidationError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValidationError { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValidationError : bool" Usage="System.Windows.Data.BindingGroup.HasValidationError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Windows.Data.BindingGroup" /> występuje niepowodzenie reguły walidacji.</summary>
        <value><see langword="true" />Jeśli reguła <see langword="false" />ma regułę walidacji zakończyła się niepowodzeniem; w przeciwnym razie. <see cref="T:System.Windows.Data.BindingGroup" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirty">
      <MemberSignature Language="C#" Value="public bool IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.IsDirty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDirty : bool" Usage="System.Windows.Data.BindingGroup.IsDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Windows.Data.BindingGroup" /> zawiera proponowaną wartość, która nie została zapisywana w źródle.</summary>
        <value><see langword="true" />Jeśli zawiera proponowaną wartość, która nie została zapisywana w źródle; <see langword="false" />w przeciwnym razie. <see cref="T:System.Windows.Data.BindingGroup" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IList Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IList Items" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IList ^ Items { System::Collections::IList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.IList" Usage="System.Windows.Data.BindingGroup.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera źródła, które są używane przez obiekty powiązań w <see cref="T:System.Windows.Data.BindingGroup" />.</summary>
        <value>Źródła, które są używane przez obiekty powiązań w <see cref="T:System.Windows.Data.BindingGroup" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy obiekt, który jest używany jako źródło, jest dodawany do <xref:System.Windows.Data.BindingGroup.Items%2A> właściwości jeden raz, nawet jeśli obiekt jest używany jako źródło dla wielu powiązań. Często istnieje tylko jeden element w <xref:System.Windows.Data.BindingGroup.Items%2A>, który jest obiektem, który <xref:System.Windows.FrameworkElement.DataContext%2A> jest elementem elementu, który używa <xref:System.Windows.Data.BindingGroup>. Istnieje jednak możliwość <xref:System.Windows.Data.BindingGroup> , aby można było mieć wiele źródeł. Na przykład, jeśli powiązania obiektów współużytkują <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> te same, ale używają różnych obiektów źródłowych, każdy obiekt, który jest używany jako <xref:System.Windows.Data.BindingGroup.Items%2A>źródło, znajduje się w.  
  
 Może być również wiele obiektów w <xref:System.Windows.Data.BindingGroup.Items%2A> , jeśli ścieżka powiązania jest rozpoznawana jako właściwość zagnieżdżona źródła. Na przykład załóżmy, że <xref:System.Windows.Controls.TextBox> powiązanie kontrolki jest częścią <xref:System.Windows.Data.BindingGroup> a i <xref:System.Windows.FrameworkElement.DataContext%2A> jest `Customer` obiektem, który ma właściwość typu `Address`. <xref:System.Windows.Data.Binding.Path%2A> Jeśli właściwość jest,<xref:System.Windows.Data.BindingGroup.Items%2A> jest dodawana do właściwości. `Address` <xref:System.Windows.Data.Binding> `Address.ZipCode`  
  
   
  
## Examples  
 Poniższe przykłady są częścią aplikacji, która sprawdza, czy użytkownik ustawił właściwości dwóch obiektów na równe wartości. Pierwszy przykład tworzy dwie <xref:System.Windows.Controls.TextBox> kontrolki, z których każdy jest powiązany z innym źródłem danych. Powiązanie pierwszego <xref:System.Windows.Controls.TextBox> pobiera jego źródło, `object1`z <xref:System.Windows.FrameworkElement.DataContext%2A> <xref:System.Windows.Controls.TextBox> elementu nadrzędnego formantu ( <xref:System.Windows.Controls.StackPanel>). W drugim <xref:System.Windows.Controls.TextBox>źródle powiązania jest `object2`ustawiana na. Przykład tworzy <xref:System.Windows.Controls.Label> również, który wyświetla błędy walidacji.  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupName](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupname)]  
[!code-xaml[BindingGroupSnippets#ValidationAdornerSite](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#validationadornersite)]  
  
 Poniższy przykład pokazuje <xref:System.Windows.Controls.ValidationRule> , że poprzedni przykład używa. W metodzie, przykład pobiera każdy obiekt źródłowy <xref:System.Windows.Data.BindingGroup> z i sprawdza, czy właściwości obiektów są równe. <xref:System.Windows.Controls.ValidationRule.Validate%2A>  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.Data.BindingGroup.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę identyfikującą <see cref="T:System.Windows.Data.BindingGroup" />, która może być używana do dołączania i wykluczania obiektów powiązań <see cref="T:System.Windows.Data.BindingGroup" />w obiekcie.</summary>
        <value>Nazwa, która identyfikuje <see cref="T:System.Windows.Data.BindingGroup" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Data.BindingGroup.Name%2A> <xref:System.Windows.FrameworkElement.DataContext%2A> jest `null`, powiązania ze źródłem, które jest tym samym obiektem co element, który ma <xref:System.Windows.Data.BindingGroup> udział w <xref:System.Windows.Data.BindingGroup>.  
  
 Można uwzględnić powiązania, które mają źródło, które różni się od <xref:System.Windows.FrameworkElement.DataContext%2A> elementu nadrzędnego, który <xref:System.Windows.Data.BindingGroup> ma <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> ustawienie <xref:System.Windows.Data.BindingGroup.Name%2A> <xref:System.Windows.Data.BindingGroup> i właściwość powiązania z tą samą wartością. Można wykluczyć powiązania, które mają takie samo źródło jak <xref:System.Windows.FrameworkElement.DataContext%2A> element nadrzędny, który <xref:System.Windows.Data.BindingGroup> ma <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> ustawienie <xref:System.Windows.Data.BindingGroup.Name%2A> <xref:System.Windows.Data.BindingGroup> przez i właściwość powiązania z różnymi wartościami.  
  
   
  
## Examples  
 Poniższe przykłady są częścią aplikacji, która sprawdza, czy użytkownik ustawił właściwości dwóch obiektów na równe wartości. Pierwszy przykład tworzy dwie <xref:System.Windows.Controls.TextBox> kontrolki, z których każdy jest powiązany z innym źródłem danych. Powiązanie pierwszej <xref:System.Windows.Controls.TextBox> jest częścią obiektu, <xref:System.Windows.Data.BindingGroup> ponieważ <xref:System.Windows.Controls.TextBox> dziedziczy <xref:System.Windows.FrameworkElement.DataContext%2A> a i <xref:System.Windows.Data.BindingGroup> od jego elementu nadrzędnego <xref:System.Windows.Controls.StackPanel>.  
  
 Powiązanie w <xref:System.Windows.Controls.TextBox> drugim jest częścią, <xref:System.Windows.Data.BindingGroup> ponieważ <xref:System.Windows.Data.BindingGroup.Name%2A> <xref:System.Windows.Data.BindingGroup> z i <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> <xref:System.Windows.Data.Binding> są ustawione na `bindingGroup`.  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupName](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupname)]  
[!code-xaml[BindingGroupSnippets#ValidationAdornerSite](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#validationadornersite)]  
  
 Poniższy przykład pokazuje <xref:System.Windows.Controls.ValidationRule> , że poprzedni przykład używa. W metodzie, przykład pobiera każdy obiekt źródłowy <xref:System.Windows.Data.BindingGroup> z i sprawdza, czy właściwości obiektów są równe. <xref:System.Windows.Controls.ValidationRule.Validate%2A>  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnValidationError">
      <MemberSignature Language="C#" Value="public bool NotifyOnValidationError { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NotifyOnValidationError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.NotifyOnValidationError" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyOnValidationError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NotifyOnValidationError { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyOnValidationError : bool with get, set" Usage="System.Windows.Data.BindingGroup.NotifyOnValidationError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see cref="E:System.Windows.Controls.Validation.Error" /> określającą, czy zdarzenie występuje po <see cref="T:System.Windows.Controls.ValidationRule" /> zmianie stanu.</summary>
        <value><see langword="true" />Jeśli zdarzenie występuje w przypadku <see cref="T:System.Windows.Controls.ValidationRule" /> zmiany stanu; w przeciwnym razie <see langword="false" />. <see cref="E:System.Windows.Controls.Validation.Error" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dołączone zdarzenie występuje w elemencie, który <xref:System.Windows.Data.BindingGroup>ma. <xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType>  
  
   
  
## Examples  
 Poniższy przykład <xref:System.Windows.Data.BindingGroup> tworzy i ustawia `true` <xref:System.Windows.Data.BindingGroup.NotifyOnValidationError%2A> w taki sposób, aby aplikacja mogła obsłużyć zdarzenie w <xref:System.Windows.Controls.ValidationRule> <xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType> przypadku niepowodzenia.  
  
 [!code-xaml[BindingGroupSnippets#BindingGroup](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml#bindinggroup)]  
  
 Poniższy przykład obsługuje <xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType> zdarzenie.  
  
 [!code-csharp[BindingGroupSnippets#ErrorHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#errorhandler)]
 [!code-vb[BindingGroupSnippets#ErrorHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#errorhandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Owner { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.Owner" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Owner As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Owner { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Owner : System.Windows.DependencyObject" Usage="System.Windows.Data.BindingGroup.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, do którego <see cref="T:System.Windows.Data.BindingGroup" /> jest przypisany.</summary>
        <value>Obiekt, do którego <see cref="T:System.Windows.Data.BindingGroup" /> jest przypisany.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SharesProposedValues">
      <MemberSignature Language="C#" Value="public bool SharesProposedValues { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SharesProposedValues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.SharesProposedValues" />
      <MemberSignature Language="VB.NET" Value="Public Property SharesProposedValues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SharesProposedValues { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SharesProposedValues : bool with get, set" Usage="System.Windows.Data.BindingGroup.SharesProposedValues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Windows.Data.BindingGroup" /> ponownie używa wartości docelowej, które nie zostały przekazane do źródła.</summary>
        <value><see langword="true" />Jeśli ponownie używa wartości docelowych, które nie zostały przekazane do źródła; <see langword="false" />w przeciwnym razie. <see cref="T:System.Windows.Data.BindingGroup" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Proponowana wartość jest wartością, która została zmieniona w elemencie docelowym powiązania, ale nie została zatwierdzona do źródła. Załóżmy na przykład, że istnieje dwukierunkowe powiązanie w <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A> i właściwość jest ustawiona na <xref:System.Windows.Data.UpdateSourceTrigger.Explicit>. Jeśli użytkownik zmieni wartość <xref:System.Windows.Controls.TextBox>, proponowana wartość jest wartością znajdującą się <xref:System.Windows.Controls.TextBox> w przed zatwierdzeniem do źródła.  
  
 Gdy <xref:System.Windows.Data.BindingGroup.SharesProposedValues%2A> <xref:System.Windows.Data.BindingGroup> ma `true`wartość, używa proponowanej wartości, gdy jedno powiązanie opuszcza, a inne powiązanie z tym samym źródłem sprzężeń.  Załóżmy na przykład, że aplikacja umożliwia użytkownikowi edytowanie wielu pól i aktualizowanie obiektu źródłowego przez kliknięcie przycisku. Gdy pole nie jest edytowane, aplikacja wyświetli go w <xref:System.Windows.Controls.TextBlock>. Gdy użytkownik zacznie edytować pole, aplikacja zastępuje <xref:System.Windows.Controls.TextBlock>. <xref:System.Windows.Controls.TextBox> Gdy użytkownik zakończy edytowanie tego pola, aplikacja zastępuje <xref:System.Windows.Controls.TextBox>. <xref:System.Windows.Controls.TextBlock> Ponieważ źródło nie jest aktualizowane do momentu kliknięcia przycisku przez użytkownika, w <xref:System.Windows.Controls.TextBlock> celu wyświetlenia proponowanej wartości musi istnieć sposób. Po ustawieniu <xref:System.Windows.Data.BindingGroup.SharesProposedValues%2A> na `true`, aplikacja będzie wyświetlać zmiany w polu użytkownika, nawet jeśli źródło nie zostało zaktualizowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (object item, string propertyName, out object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(object item, string propertyName, [out] object&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.TryGetValue(System.Object,System.String,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (item As Object, propertyName As String, ByRef value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(System::Object ^ item, System::String ^ propertyName, [Runtime::InteropServices::Out] System::Object ^ % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : obj * string *  -&gt; bool" Usage="bindingGroup.TryGetValue (item, propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt, który zawiera określoną właściwość.</param>
        <param name="propertyName">Właściwość, której proponowana wartość ma zostać uzyskana.</param>
        <param name="value">Gdy ta metoda zwraca, zawiera obiekt, który reprezentuje proponowaną wartość właściwości. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Próbuje uzyskać proponowaną wartość dla określonej właściwości i elementu.</summary>
        <returns><see langword="true" />Jeśli wartość jest proponowaną wartością dla określonej właściwości; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.BindingGroup.TryGetValue%2A>zwraca `false` czy nie istnieje powiązanie dla określonego elementu i właściwości lub jeśli wartość określonej właściwości jest niedostępna z powodu błędu konwersji lub ponieważ wcześniejsza reguła walidacji zakończyła się niepowodzeniem.  
  
 Użyj tej metody w <xref:System.Windows.Controls.ValidationRule.Validate%2A?displayProperty=nameWithType> metodzie, aby uzyskać wartość do zatwierdzenia dla źródła. Typ `value` zależy od etapu, w <xref:System.Windows.Controls.ValidationRule> którym występuje. <xref:System.Windows.Controls.TextBox> Na przykład jeśli dane są powiązane z właściwością typu Integer, jest ciągiem, `value` Jeśli <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> te <xref:System.Windows.Controls.ValidationRule> wywołania <xref:System.Windows.Data.BindingGroup.TryGetValue%2A> mają ustawioną wartość <xref:System.Windows.Controls.ValidationStep.RawProposedValue>. <xref:System.Windows.Controls.ValidationRule> Jeśli ma<xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> ustawiony<xref:System.Windows.Controls.ValidationStep.ConvertedProposedValue>na, typ jestdowolnegotypu,któryjestzwracanyprzezkonwerterpowiązania.`value` W tym przykładzie `value` jest to zwykle liczba całkowita.  
  
   
  
## Examples  
 W poniższym przykładzie jest tworzona nazwa <xref:System.Windows.Controls.ValidationRule> `ValidateDateAndPrice`niestandardowa. W metodzie, przykład <xref:System.Windows.Data.BindingGroup.TryGetValue%2A> używa metody i <xref:System.Windows.Data.BindingGroup.Items%2A> właściwości, aby pobrać wartości wprowadzone przez użytkownika w formularzu. <xref:System.Windows.Controls.ValidationRule.Validate%2A> Następnie przykład sprawdza, czy jeśli element jest ponad 100 dolarów, będzie dostępny przez co najmniej siedem dni. Ten przykład jest częścią większego przykładu <xref:System.Windows.Data.BindingGroup> klasy  
  
 [!code-csharp[BindingGroupSnippets#ValidateObject](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Data.cs#validateobject)]
 [!code-vb[BindingGroupSnippets#ValidateObject](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/data.vb#validateobject)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateSources">
      <MemberSignature Language="C#" Value="public bool UpdateSources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool UpdateSources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.UpdateSources" />
      <MemberSignature Language="VB.NET" Value="Public Function UpdateSources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool UpdateSources();" />
      <MemberSignature Language="F#" Value="member this.UpdateSources : unit -&gt; bool" Usage="bindingGroup.UpdateSources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia konwerter na <see cref="T:System.Windows.Controls.ValidationRule" /> oprawie i obiekty, które <see cref="P:System.Windows.Controls.ValidationRule.ValidationStep" /> mają właściwość ustawioną na <see cref="F:System.Windows.Controls.ValidationStep.RawProposedValue" />, <see cref="F:System.Windows.Controls.ValidationStep.ConvertedProposedValue" />lub <see cref="F:System.Windows.Controls.ValidationStep.UpdatedValue" /> i zapisuje wartości obiektów docelowych w obiektach źródłowych, jeśli wszystkie reguły walidacji zostały wykonane pomyślnie.</summary>
        <returns><see langword="true" />Jeśli wszystkie reguły walidacji zakończyły się powodzeniem; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda aktualizuje źródło, jeśli każde <xref:System.Windows.Controls.ValidationRule> z nich powiedzie się, ale nie powoduje, że źródła zatwierdzią oczekujące zmiany i zakończą edytowanie transakcji. Oznacza to, że jeśli obiekt źródłowy implementuje <xref:System.ComponentModel.IEditableObject>. Wywołanie tej metody nie powoduje <xref:System.ComponentModel.IEditableObject.EndEdit%2A> wywołania. <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> Użyj metody, aby źródła zatwierdzać oczekujące zmiany.  
  
   
  
## Examples  
 Poniższy przykład jest częścią aplikacji, która poprosi użytkownika o wprowadzenie wielu klientów i przypisanie przedstawicielowi sprzedaży do każdego klienta. Aplikacja sprawdza, czy przedstawiciel handlowy i klient należą do tego samego regionu. Przykład wywołuje <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> do walidacji powiązań i zapisuje wartości w źródle, jeśli wszystkie reguły poprawności zostały wykonane pomyślnie.  
  
 [!code-csharp[BindingGroupSnippets#UpdateSources](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window2.xaml.cs#updatesources)]
 [!code-vb[BindingGroupSnippets#UpdateSources](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window2.xaml.vb#updatesources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidatesOnNotifyDataError">
      <MemberSignature Language="C#" Value="public bool ValidatesOnNotifyDataError { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidatesOnNotifyDataError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.ValidatesOnNotifyDataError" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidatesOnNotifyDataError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidatesOnNotifyDataError { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidatesOnNotifyDataError : bool with get, set" Usage="System.Windows.Data.BindingGroup.ValidatesOnNotifyDataError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy ma zostać uwzględniony <see cref="T:System.Windows.Controls.NotifyDataErrorValidationRule" />.</summary>
        <value><see langword="true" />Aby uwzględnić <see cref="T:System.Windows.Controls.NotifyDataErrorValidationRule" />; w przeciwnym razie <see langword="false" />,. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.Data.BindingGroup.ValidatesOnNotifyDataError%2A> tak `true`jest, powiązanie sprawdza i raportuje błędy, które są zgłaszane przez źródło danych implementujące <xref:System.ComponentModel.INotifyDataErrorInfo>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateWithoutUpdate">
      <MemberSignature Language="C#" Value="public bool ValidateWithoutUpdate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ValidateWithoutUpdate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.ValidateWithoutUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Function ValidateWithoutUpdate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ValidateWithoutUpdate();" />
      <MemberSignature Language="F#" Value="member this.ValidateWithoutUpdate : unit -&gt; bool" Usage="bindingGroup.ValidateWithoutUpdate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia <see cref="T:System.Windows.Controls.ValidationRule" /> konwerter dla powiązania i obiektów, które <see cref="P:System.Windows.Controls.ValidationRule.ValidationStep" /> mają właściwość ustawioną na <see cref="F:System.Windows.Controls.ValidationStep.RawProposedValue" /> lub <see cref="F:System.Windows.Controls.ValidationStep.ConvertedProposedValue" />.</summary>
        <returns><see langword="true" />Jeśli reguły walidacji zakończyły się powodzeniem; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Źródła nie są aktualizowane w przypadku wywołania tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidationErrors">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Controls.ValidationError&gt; ValidationErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Windows.Controls.ValidationError&gt; ValidationErrors" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.ValidationErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidationErrors As ReadOnlyCollection(Of ValidationError)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Controls::ValidationError ^&gt; ^ ValidationErrors { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Controls::ValidationError ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidationErrors : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Controls.ValidationError&gt;" Usage="System.Windows.Data.BindingGroup.ValidationErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Controls.ValidationError&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję <see cref="T:System.Windows.Controls.ValidationError" /> obiektów, które <see cref="T:System.Windows.Data.BindingGroup" /> spowodowały, że jest ona nieprawidłowa.</summary>
        <value>Kolekcja <see cref="T:System.Windows.Controls.ValidationError" /> obiektów<see cref="T:System.Windows.Data.BindingGroup" /> , które były nieprawidłowe.  Wartość jest <see langword="null" /> w przypadku braku błędów.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidationRules">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt; ValidationRules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.Windows.Controls.ValidationRule&gt; ValidationRules" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.ValidationRules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidationRules As Collection(Of ValidationRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::Windows::Controls::ValidationRule ^&gt; ^ ValidationRules { System::Collections::ObjectModel::Collection&lt;System::Windows::Controls::ValidationRule ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidationRules : System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt;" Usage="System.Windows.Data.BindingGroup.ValidationRules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję <see cref="T:System.Windows.Controls.ValidationRule" /> obiektów, które weryfikują obiekty źródłowe <see cref="T:System.Windows.Data.BindingGroup" />w.</summary>
        <value>Kolekcja <see cref="T:System.Windows.Controls.ValidationRule" /> obiektów, które weryfikują obiekty źródłowe <see cref="T:System.Windows.Data.BindingGroup" />w.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy jest dodawany <xref:System.Windows.Data.BindingGroup>do, <xref:System.Windows.Data.BindingGroup> jest <xref:System.Windows.Controls.ValidationRule.Validate%2A> przenoszona jako pierwszy parametr metody. <xref:System.Windows.Controls.ValidationRule> Proponowane wartości obiektu można uzyskać za pomocą <xref:System.Windows.Data.BindingGroup.TryGetValue%2A> metody lub. <xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29> Można uzyskać obiekty, które są źródłami powiązań z <xref:System.Windows.Data.BindingGroup.Items%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład dodaje niestandardowe <xref:System.Windows.Controls.ValidationRule>, `ValidateDateAndPrice`do <xref:System.Windows.Data.BindingGroup>.  
  
 [!code-xaml[BindingGroupSnippets#BindingGroup](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml#bindinggroup)]  
  
 W poniższym przykładzie pokazano `ValidateDateAndPrice` klasę. <xref:System.Windows.Controls.ValidationRule.Validate%2A> Metoda<xref:System.Windows.Data.BindingGroup> używa do uzyskania wartości wprowadzonych przez użytkownika w formularzu i sprawdza, czy jeśli element jest ponad 100 dolarów, będzie dostępny przez co najmniej siedem dni.  
  
 [!code-csharp[BindingGroupSnippets#ValidateObject](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Data.cs#validateobject)]
 [!code-vb[BindingGroupSnippets#ValidateObject](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/data.vb#validateobject)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="BindingGroup" FullName="System.Windows.Data.BindingGroup">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f72467816af2fa6f2c9300920c84418d9f5bb23a" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39876853" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class BindingGroup : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BindingGroup extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Data.BindingGroup" />
  <TypeSignature Language="VB.NET" Value="Public Class BindingGroup&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class BindingGroup : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type BindingGroup = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zawiera kolekcję powiązań i <see cref="T:System.Windows.Controls.ValidationRule" /> obiekty, które są używane do weryfikacji obiektu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Data.BindingGroup> tworzy relację między wiele powiązań, które mogą być weryfikowane i aktualizowane łącznie. Na przykład załóżmy, że aplikacja monituje użytkownika o podanie adresu. Następnie aplikacja wypełnia obiekt typu `Address`, który ma właściwości, `Street`, `City`, `ZipCode`, i `Country`, wartościami, które użytkownik podał. Aplikacja ma panel, który zawiera cztery <xref:System.Windows.Controls.TextBox> formantów, z których każdy jest powiązane z jedną z właściwości obiektu danych. Możesz użyć <xref:System.Windows.Controls.ValidationRule> w <xref:System.Windows.Data.BindingGroup> do sprawdzania poprawności `Address` obiektu. Jeśli powiązania należeć do tej samej <xref:System.Windows.Data.BindingGroup>, można upewnić się, że kod pocztowy jest prawidłowy dla kraju adresu.  
  
 Możesz ustawić <xref:System.Windows.FrameworkElement.BindingGroup%2A> właściwość <xref:System.Windows.FrameworkElement> lub <xref:System.Windows.FrameworkContentElement>. Elementy podrzędne dziedziczą <xref:System.Windows.Data.BindingGroup> z ich elementów nadrzędnych, tak jak w przypadku wszystkich innych właściwości dziedziczonych. Powiązanie na element podrzędny zostanie dodany do <xref:System.Windows.Data.BindingGroup> Jeśli wystąpi jedno z następujących sytuacji:  
  
-   Źródło powiązania i <xref:System.Windows.FrameworkElement.DataContext%2A> elementu, który ma <xref:System.Windows.Data.BindingGroup> są tego samego obiektu i <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> nie ustawiono właściwości.  
  
-   <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> Właściwość powiązania jest równa <xref:System.Windows.Data.BindingGroup.Name%2A> z <xref:System.Windows.FrameworkContentElement.BindingGroup%2A> i nie są jawnie ustawione `null`.  
  
 W przykładzie adres Załóżmy, że <xref:System.Windows.FrameworkElement.DataContext%2A> z <xref:System.Windows.Controls.Panel> jest ustawiona na obiekt typu `Address`. Powiązania dla każdej <xref:System.Windows.Controls.TextBox> jest dodawany do <xref:System.Windows.Data.BindingGroup> panelu.  
  
 Możesz dodać <xref:System.Windows.Controls.ValidationRule> obiekty do <xref:System.Windows.Data.BindingGroup>. <xref:System.Windows.Data.BindingGroup> Jest przekazywany jako pierwszy parametr <xref:System.Windows.Controls.ValidationRule.Validate%2A> metody podczas <xref:System.Windows.Controls.ValidationRule> działa. Można użyć <xref:System.Windows.Data.BindingGroup.TryGetValue%2A> lub <xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29> metody na tym <xref:System.Windows.Data.BindingGroup> uzyskać proponowane wartości obiektu, a <xref:System.Windows.Data.BindingGroup.Items%2A> właściwości źródła powiązania.  
  
 A <xref:System.Windows.Data.BindingGroup> aktualizuje źródeł powiązania, w tym samym czasie, a nie każdego powiązania są aktualizowane oddzielnie. Wywołanie jednej z metod sprawdzania poprawności danych (<xref:System.Windows.Data.BindingGroup.ValidateWithoutUpdate%2A>, <xref:System.Windows.Data.BindingGroup.UpdateSources%2A>, lub <xref:System.Windows.Data.BindingGroup.CommitEdit%2A>), wiązanie dla każdego <xref:System.Windows.Controls.TextBox> w przykładzie zostanie zatwierdzona i potencjalnie aktualizacji. Jeśli powiązanie jest częścią <xref:System.Windows.Data.BindingGroup>, źródło wiązania nie jest aktualizowana, dopóki nie zostanie wywołana <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> lub <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> na <xref:System.Windows.Data.BindingGroup>, chyba że jawnie ustawić <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A> właściwości.  
  
   
  
## Examples  
 Poniższe przykłady tworzą aplikację, który monituje użytkownika o podanie opisu i ceny elementu i datę wygaśnięcia oferty. Aplikacja wyświetla bieżących informacji dotyczących elementu poniżej formularza. Użytkownik może przesłać lub Anuluj zmiany.  
  
 Aplikacja wykonuje następujące czynności, aby uzyskać takie zachowanie.  
  
-   Tworzy <xref:System.Windows.Data.BindingGroup> i dodaje go w katalogu głównym <xref:System.Windows.Controls.StackPanel> gdy tworzy [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] aplikacji.  
  
-   Wywołania <xref:System.Windows.Data.BindingGroup.BeginEdit%2A>, <xref:System.Windows.Data.BindingGroup.CommitEdit%2A>, i <xref:System.Windows.Data.BindingGroup.CancelEdit%2A> w logice aplikacji, aby umożliwić wycofywanie zmian.  
  
-   Wywołania <xref:System.Windows.Data.BindingGroup.TryGetValue%2A> w <xref:System.Windows.Controls.ValidationRule.Validate%2A> metodę, aby uzyskać dane wejściowe użytkownika, a następnie sprawdź, czy element za pośrednictwem 100 zł jest dostępna przez co najmniej 7 dni.  
  
 Poniższy przykład tworzy [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] aplikacji. Katalog główny <xref:System.Windows.Controls.StackPanel> ma <xref:System.Windows.Data.BindingGroup> zawierający <xref:System.Windows.Controls.ValidationRule> elementu, który sprawdza zgodnie z wcześniejszym opisem. Powiązanie obiektów na `Price` właściwości i `OfferExpires` właściwości stają się częścią <xref:System.Windows.Data.BindingGroup> i każdego powiązania ma <xref:System.Windows.Controls.ValidationRule> się upewnić, że ceny i daty, odpowiednio, są prawidłowe wartości. Reguły sprawdzania poprawności dla poszczególnych właściwości są uruchamiane przed <xref:System.Windows.Controls.ValidationRule> na <xref:System.Windows.Data.BindingGroup>.  
  
 [!code-xaml[BindingGroupSnippets#WindowLayout](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml#windowlayout)]  
  
 Poniższy przykład pokazuje obsługę zdarzeń dla aplikacji. Gdy użytkownik kliknie przycisk przesyłania, aplikacja wywołuje <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> do uruchamiania każdego <xref:System.Windows.Controls.ValidationRule> skojarzony z <xref:System.Windows.Data.BindingGroup>. Jeśli każda <xref:System.Windows.Controls.ValidationRule> zakończy się powodzeniem, <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> zapisuje wartości do obiektu, a kończy transakcji edycji. Jeśli <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> to się powiedzie, aplikacja rozpoczyna się transakcja edycji. Gdy <xref:System.Windows.Controls.ValidationRule> zakończy się niepowodzeniem, <xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType> zdarzenie występuje, ponieważ aplikacja ustawiona <xref:System.Windows.Data.BindingGroup.NotifyOnValidationError%2A> do `true` na <xref:System.Windows.Data.BindingGroup> (w poprzednim przykładzie). `ItemError` uchwyty <xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType> zdarzeń i wyświetla informacje o błędzie weryfikacji dla użytkownika. Przykład obsługuje także <xref:System.Windows.FrameworkElement.Loaded> zdarzenie <xref:System.Windows.Controls.StackPanel> i <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzenia dla **anulować** przycisku.  
  
 [!code-csharp[BindingGroupSnippets#WindowLogic](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#windowlogic)]
 [!code-vb[BindingGroupSnippets#WindowLogic](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#windowlogic)]  
  
 Poniższy przykład pokazuje niestandardowy <xref:System.Windows.Controls.ValidationRule> `ValidateDateAndPrice`, który został dodany do <xref:System.Windows.Data.BindingGroup> w pierwszym przykładzie. <xref:System.Windows.Controls.ValidationRule> Używa <xref:System.Windows.Data.BindingGroup> w jego <xref:System.Windows.Controls.ValidationRule.Validate%2A> metodę, aby uzyskać wartości które użytkownik wprowadził do postaci i sprawdza, czy element w przypadku ponad 100 zł, będzie on dostępny dla co najmniej 7 dni.  
  
 [!code-csharp[BindingGroupSnippets#ValidateObject](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Data.cs#validateobject)]
 [!code-vb[BindingGroupSnippets#ValidateObject](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/data.vb#validateobject)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingGroup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingGroup();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Data.BindingGroup" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginEdit">
      <MemberSignature Language="C#" Value="public void BeginEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.BeginEdit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginEdit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginEdit();" />
      <MemberSignature Language="F#" Value="member this.BeginEdit : unit -&gt; unit" Usage="bindingGroup.BeginEdit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna się transakcja edycji źródeł w <see cref="T:System.Windows.Data.BindingGroup" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli źródła w <xref:System.Windows.Data.BindingGroup> obsługuje odrzucenie oczekujących zmian, możesz wywołać <xref:System.Windows.Data.BindingGroup.BeginEdit%2A> można rozpocząć transakcji edycji, należy wywołać <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> zapisany oczekujących zmian, należy wywołać <xref:System.Windows.Data.BindingGroup.CancelEdit%2A> aby odrzucić zmiany oczekujące.  
  
 Dla każdego obiektu w <xref:System.Windows.Data.BindingGroup.Items%2A> implementującej <xref:System.ComponentModel.IEditableObject>, <xref:System.Windows.Data.BindingGroup.BeginEdit%2A> wywołania <xref:System.ComponentModel.IEditableObject.BeginEdit%2A?displayProperty=nameWithType>  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Windows.Data.BindingGroup.BeginEdit%2A> załadowanie okna można rozpocząć transakcji edycji.  
  
 [!code-csharp[BindingGroupSnippets#BeginEdit](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#beginedit)]
 [!code-vb[BindingGroupSnippets#BeginEdit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#beginedit)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingExpressions">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.Windows.Data.BindingExpressionBase&gt; BindingExpressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.Windows.Data.BindingExpressionBase&gt; BindingExpressions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.BindingExpressions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BindingExpressions As Collection(Of BindingExpressionBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::Windows::Data::BindingExpressionBase ^&gt; ^ BindingExpressions { System::Collections::ObjectModel::Collection&lt;System::Windows::Data::BindingExpressionBase ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BindingExpressions : System.Collections.ObjectModel.Collection&lt;System.Windows.Data.BindingExpressionBase&gt;" Usage="System.Windows.Data.BindingGroup.BindingExpressions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.Windows.Data.BindingExpressionBase&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję <see cref="T:System.Windows.Data.BindingExpression" /> obiektów, które zawiera informacje dla każdego powiązania w <see cref="T:System.Windows.Data.BindingGroup" />.</summary>
        <value>Kolekcja <see cref="T:System.Windows.Data.BindingExpression" /> obiektów, które zawiera informacje dla każdego powiązania w <see cref="T:System.Windows.Data.BindingGroup" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Data.BindingExpression> należy do <xref:System.Windows.Data.BindingGroup> Jeśli wystąpi jedno z następujących przypadkach:  
  
-   Źródło powiązania i <xref:System.Windows.FrameworkElement.DataContext%2A> elementu, który ma <xref:System.Windows.Data.BindingGroup> są tego samego obiektu i <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> nie jest ustawiona.  
  
-   <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> Właściwości powiązania i <xref:System.Windows.Data.BindingGroup.Name%2A> z <xref:System.Windows.Data.BindingGroup> są ustawiane na tę samą wartość inną niż null i <xref:System.Windows.Data.BindingGroup> należy do elementu nadrzędnego elementu docelowego powiązania.  
  
-   Możesz dodać <xref:System.Windows.Data.BindingExpression> do <xref:System.Windows.Data.BindingGroup.BindingExpressions%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelEdit">
      <MemberSignature Language="C#" Value="public void CancelEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.CancelEdit" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelEdit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelEdit();" />
      <MemberSignature Language="F#" Value="member this.CancelEdit : unit -&gt; unit" Usage="bindingGroup.CancelEdit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy transakcji edycji i odrzuca wszystkie zmiany oczekujące.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powoduje, że źródeł, aby odrzucić zmiany oczekujące, jeśli obiekt źródłowy jest w stanie to i zakończenia transakcji edycji. Następnie metoda aktualizuje właściwości obiektu docelowego o wartości zapisane źródła.  
  
 Dla każdego obiektu w <xref:System.Windows.Data.BindingGroup.Items%2A> implementującej <xref:System.ComponentModel.IEditableObject>, <xref:System.Windows.Data.BindingGroup.CancelEdit%2A> wywołania <xref:System.ComponentModel.IEditableObject.CancelEdit%2A?displayProperty=nameWithType>  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Windows.Data.BindingGroup.CancelEdit%2A> można odrzucić oczekujące zmiany, a następnie wywołania <xref:System.Windows.Data.BindingGroup.BeginEdit%2A> przygotować źródła do można ponownie edytowany.  
  
 [!code-csharp[BindingGroupSnippets#CancelEdit](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#canceledit)]
 [!code-vb[BindingGroupSnippets#CancelEdit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#canceledit)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRestoreValues">
      <MemberSignature Language="C#" Value="public bool CanRestoreValues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRestoreValues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.CanRestoreValues" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRestoreValues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRestoreValues { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRestoreValues : bool" Usage="System.Windows.Data.BindingGroup.CanRestoreValues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje, czy każde źródło w powiązaniu można odrzucić oczekujące zmiany i przywrócić oryginalnych wartości.</summary>
        <value>
          <see langword="true" /> Jeśli każde źródło w powiązaniu można odrzucić oczekujące zmiany i przywrócić oryginalnych wartości; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Źródłem może odrzucić zmiany oczekujące, jeśli implementuje <xref:System.ComponentModel.IEditableObject>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommitEdit">
      <MemberSignature Language="C#" Value="public bool CommitEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CommitEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.CommitEdit" />
      <MemberSignature Language="VB.NET" Value="Public Function CommitEdit () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CommitEdit();" />
      <MemberSignature Language="F#" Value="member this.CommitEdit : unit -&gt; bool" Usage="bindingGroup.CommitEdit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamianie wszystkich <see cref="T:System.Windows.Controls.ValidationRule" /> obiektów i aktualizuje powiązanie źródeł, jeśli wszystkie reguły sprawdzania poprawności.</summary>
        <returns>
          <see langword="true" /> Jeśli każdy <see cref="T:System.Windows.Controls.ValidationRule" /> zakończy się powodzeniem, a wartości są zobowiązane do źródła; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli każdy <xref:System.Windows.Controls.ValidationRule> zakończy się powodzeniem, ta metoda powoduje źródeł, aby zatwierdzić oczekujące zmiany i zakończyć transakcji edycji, jeśli obiekt źródłowy jest w stanie działania.  
  
 Dla każdego obiektu w <xref:System.Windows.Data.BindingGroup.Items%2A> implementującej <xref:System.ComponentModel.IEditableObject>, <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> wywołania <xref:System.ComponentModel.IEditableObject.EndEdit%2A?displayProperty=nameWithType>  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> można zapisać oczekujące zmiany, a następnie wywołania <xref:System.Windows.Data.BindingGroup.BeginEdit%2A> przygotować źródła do można ponownie edytowany.  
  
 [!code-csharp[BindingGroupSnippets#BeginEdit](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#beginedit)]
 [!code-vb[BindingGroupSnippets#BeginEdit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#beginedit)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (object item, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(object item, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.GetValue(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (item As Object, propertyName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Object ^ item, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="member this.GetValue : obj * string -&gt; obj" Usage="bindingGroup.GetValue (item, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt zawierający określoną właściwość.</param>
        <param name="propertyName">Właściwość którego proponowana wartość, aby uzyskać.</param>
        <summary>Zwraca proponowana wartość określonej właściwości i elementów.</summary>
        <returns>Wartość właściwości proponowany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody w <xref:System.Windows.Controls.ValidationRule.Validate%2A?displayProperty=nameWithType> metodę, aby uzyskać wartość do można zatwierdzić do źródła. Typ wartości zwracanej jest zależna od etapu, na którym <xref:System.Windows.Controls.ValidationRule> występuje. Na przykład jeśli <xref:System.Windows.Controls.TextBox> jest powiązany z danymi z właściwością typu integer i <xref:System.Windows.Controls.ValidationRule> wywołująca <xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29> ma jego <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> równa <xref:System.Windows.Controls.ValidationStep.RawProposedValue>, metoda zwraca wartość typu ciąg. Jeśli <xref:System.Windows.Controls.ValidationRule> ma jego <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> równa <xref:System.Windows.Controls.ValidationStep.ConvertedProposedValue>, metoda zwraca typ zwracany przez konwerter powiązania. W tym przykładzie <xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29> zwykle zwraca liczbę całkowitą.  
  
   
  
## Examples  
 Poniższy przykład jest częścią aplikacji, który monituje użytkownika o wprowadzenie wielu klientów i przypisać przedstawiciel handlowy do każdego klienta. Aplikacja sprawdza, czy klient i przedstawicielem handlowym firmy należą do tego samego regionu. W przykładzie pokazano <xref:System.Windows.Controls.ValidationRule.Validate%2A> metodę, która używa <xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29> metodę, aby uzyskać wartości, które wprowadzać klienta.  
  
 [!code-csharp[BindingGroupSnippets#ItemBindGroupValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window2.xaml.cs#itembindgroupvalidationrule)]
 [!code-vb[BindingGroupSnippets#ItemBindGroupValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window2.xaml.vb#itembindgroupvalidationrule)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powiązanie dla określonego elementu a właściwość nie istnieje.</exception>
        <exception cref="T:System.Windows.Data.ValueUnavailableException">Wartość określonej właściwości nie jest dostępne, ze względu na błąd konwersji lub z powodu wcześniejszych reguły sprawdzania poprawności nie powiodło się.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasValidationError">
      <MemberSignature Language="C#" Value="public bool HasValidationError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValidationError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.HasValidationError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValidationError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValidationError { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValidationError : bool" Usage="System.Windows.Data.BindingGroup.HasValidationError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Windows.Data.BindingGroup" /> ma regułę sprawdzania poprawności nie powiodło się.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Windows.Data.BindingGroup" /> ma regułę sprawdzania poprawności nie powiodło się; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirty">
      <MemberSignature Language="C#" Value="public bool IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.IsDirty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDirty : bool" Usage="System.Windows.Data.BindingGroup.IsDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Windows.Data.BindingGroup" /> zawiera proponowana wartość, która nie została zapisana w źródle.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Windows.Data.BindingGroup" /> zawiera proponowana wartość, która nie zostało zapisane na źródle; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IList Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IList Items" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IList ^ Items { System::Collections::IList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.IList" Usage="System.Windows.Data.BindingGroup.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera źródła, które są używane przez powiązanie obiektów w <see cref="T:System.Windows.Data.BindingGroup" />.</summary>
        <value>Źródła, które są używane przez powiązanie obiektów w <see cref="T:System.Windows.Data.BindingGroup" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy obiekt, który jest używany jako źródło zostanie dodany do <xref:System.Windows.Data.BindingGroup.Items%2A> właściwość raz, nawet jeśli obiekt jest używany jako źródło dla wiele powiązań. Często istnieje tylko jeden element w <xref:System.Windows.Data.BindingGroup.Items%2A>, który jest obiekt, który jest <xref:System.Windows.FrameworkElement.DataContext%2A> elementu, który używa <xref:System.Windows.Data.BindingGroup>. Możliwe jest <xref:System.Windows.Data.BindingGroup> jednak mieć wielu źródeł. Na przykład, jeśli powiązanie obiektów współużytkować ten sam <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> , ale użyć innego źródła obiektów, każdy obiekt, który jest używany jako źródło znajduje się w <xref:System.Windows.Data.BindingGroup.Items%2A>.  
  
 Można również istnieć wiele obiektów w <xref:System.Windows.Data.BindingGroup.Items%2A> Jeśli ścieżka powiązania jest rozpoznawany jako zagnieżdżonych właściwości źródła. Na przykład, załóżmy, że <xref:System.Windows.Controls.TextBox> powiązania kontrolki jest częścią <xref:System.Windows.Data.BindingGroup> i jego <xref:System.Windows.FrameworkElement.DataContext%2A> jest `Customer` obiektu, który ma właściwość typu `Address`. Jeśli <xref:System.Windows.Data.Binding.Path%2A> z <xref:System.Windows.Data.Binding> jest `Address.ZipCode` właściwości `Address` jest dodawany do <xref:System.Windows.Data.BindingGroup.Items%2A> właściwości.  
  
   
  
## Examples  
 Poniższe przykłady są częścią aplikacji, która sprawdza, czy użytkownik ma ustawioną właściwości dwóch obiektów na równą wartości. Pierwszy przykład umożliwia utworzenie dwóch <xref:System.Windows.Controls.TextBox> formantów, z których każdy jest powiązany z innym źródłem danych. Powiązanie pierwszy <xref:System.Windows.Controls.TextBox> pobiera jego źródło `object1`, z <xref:System.Windows.FrameworkElement.DataContext%2A> z <xref:System.Windows.Controls.TextBox> elementu nadrzędnego formantu ( <xref:System.Windows.Controls.StackPanel>). W drugiej <xref:System.Windows.Controls.TextBox>, źródło powiązania jest ustawiona na `object2`. W przykładzie jest tworzony również <xref:System.Windows.Controls.Label> wyświetlającą błędy sprawdzania poprawności.  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupName](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupname)]  
[!code-xaml[BindingGroupSnippets#ValidationAdornerSite](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#validationadornersite)]  
  
 W poniższym przykładzie przedstawiono <xref:System.Windows.Controls.ValidationRule> używającej w poprzednim przykładzie. W <xref:System.Windows.Controls.ValidationRule.Validate%2A> metody przykład pobiera każdy obiekt źródłowy z <xref:System.Windows.Data.BindingGroup> i sprawdza, czy właściwości obiektów są takie same.  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.Data.BindingGroup.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę, która identyfikuje <see cref="T:System.Windows.Data.BindingGroup" />, której można dołączać i wykluczać obiektów powiązań w <see cref="T:System.Windows.Data.BindingGroup" />.</summary>
        <value>Nazwa, która identyfikuje <see cref="T:System.Windows.Data.BindingGroup" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Data.BindingGroup.Name%2A> jest `null`, powiązań, które mają źródła, które jest ten sam obiekt jako <xref:System.Windows.FrameworkElement.DataContext%2A> elementu, który ma <xref:System.Windows.Data.BindingGroup> uczestniczyć w <xref:System.Windows.Data.BindingGroup>.  
  
 Może zawierać powiązań, które mają źródła, która różni się od <xref:System.Windows.FrameworkElement.DataContext%2A> elementu nadrzędnego, który ma <xref:System.Windows.Data.BindingGroup> , ustawiając <xref:System.Windows.Data.BindingGroup.Name%2A> z <xref:System.Windows.Data.BindingGroup> i <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> właściwość powiązanie z taką samą wartość. Można wykluczyć powiązań, które mają tego samego źródła jako <xref:System.Windows.FrameworkElement.DataContext%2A> elementu nadrzędnego, który ma <xref:System.Windows.Data.BindingGroup> , ustawiając <xref:System.Windows.Data.BindingGroup.Name%2A> z <xref:System.Windows.Data.BindingGroup> i <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> właściwości powiązania różne wartości.  
  
   
  
## Examples  
 Poniższe przykłady są częścią aplikacji, która sprawdza, czy użytkownik ma ustawioną właściwości dwóch obiektów na równą wartości. Pierwszy przykład umożliwia utworzenie dwóch <xref:System.Windows.Controls.TextBox> formantów, z których każdy jest powiązany z innym źródłem danych. Powiązanie pierwszy <xref:System.Windows.Controls.TextBox> jest częścią <xref:System.Windows.Data.BindingGroup> ponieważ <xref:System.Windows.Controls.TextBox> dziedziczy <xref:System.Windows.FrameworkElement.DataContext%2A> i <xref:System.Windows.Data.BindingGroup> od jego elementu nadrzędnego <xref:System.Windows.Controls.StackPanel>.  
  
 Powiązanie w drugiej <xref:System.Windows.Controls.TextBox> jest częścią <xref:System.Windows.Data.BindingGroup> ponieważ <xref:System.Windows.Data.BindingGroup.Name%2A> z <xref:System.Windows.Data.BindingGroup> i <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> z <xref:System.Windows.Data.Binding> są ustawione na `bindingGroup`.  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupName](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupname)]  
[!code-xaml[BindingGroupSnippets#ValidationAdornerSite](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#validationadornersite)]  
  
 W poniższym przykładzie przedstawiono <xref:System.Windows.Controls.ValidationRule> używającej w poprzednim przykładzie. W <xref:System.Windows.Controls.ValidationRule.Validate%2A> metody przykład pobiera każdy obiekt źródłowy z <xref:System.Windows.Data.BindingGroup> i sprawdza, czy właściwości obiektów są takie same.  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnValidationError">
      <MemberSignature Language="C#" Value="public bool NotifyOnValidationError { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NotifyOnValidationError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.NotifyOnValidationError" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyOnValidationError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NotifyOnValidationError { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyOnValidationError : bool with get, set" Usage="System.Windows.Data.BindingGroup.NotifyOnValidationError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia czy <see cref="E:System.Windows.Controls.Validation.Error" /> zdarzenie występuje, gdy stan <see cref="T:System.Windows.Controls.ValidationRule" /> zmiany.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="E:System.Windows.Controls.Validation.Error" /> zdarzenie występuje gdy stan <see cref="T:System.Windows.Controls.ValidationRule" /> zmienia; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType> Dołączone zdarzenie występuje na element, który ma <xref:System.Windows.Data.BindingGroup>.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Windows.Data.BindingGroup> i ustawia <xref:System.Windows.Data.BindingGroup.NotifyOnValidationError%2A> do `true` tak, aby aplikacja może obsługiwać <xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType> zdarzenia podczas <xref:System.Windows.Controls.ValidationRule> zakończy się niepowodzeniem.  
  
 [!code-xaml[BindingGroupSnippets#BindingGroup](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml#bindinggroup)]  
  
 Następujące uchwyty przykład <xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType> zdarzeń.  
  
 [!code-csharp[BindingGroupSnippets#ErrorHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#errorhandler)]
 [!code-vb[BindingGroupSnippets#ErrorHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#errorhandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Owner { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.Owner" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Owner As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Owner { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Owner : System.Windows.DependencyObject" Usage="System.Windows.Data.BindingGroup.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt to <see cref="T:System.Windows.Data.BindingGroup" /> przypisano do.</summary>
        <value>Obiekt że <see cref="T:System.Windows.Data.BindingGroup" /> przypisano do.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SharesProposedValues">
      <MemberSignature Language="C#" Value="public bool SharesProposedValues { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SharesProposedValues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.SharesProposedValues" />
      <MemberSignature Language="VB.NET" Value="Public Property SharesProposedValues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SharesProposedValues { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SharesProposedValues : bool with get, set" Usage="System.Windows.Data.BindingGroup.SharesProposedValues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Windows.Data.BindingGroup" /> powtórnych dotyczą wartości, które nie zostały jeszcze zatwierdzone do źródła.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Windows.Data.BindingGroup" /> powtórnych dotyczą wartości, które nie zostały jeszcze zatwierdzone do źródła; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Proponowana wartość jest wartością, który został zmieniony w elemencie docelowym powiązania, ale nie został zatwierdzony w źródle. Na przykład załóżmy, że jest powiązanie dwustronne na <xref:System.Windows.Controls.TextBox> i <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A> właściwość jest ustawiona na <xref:System.Windows.Data.UpdateSourceTrigger.Explicit>. Jeśli użytkownik zmieni wartość <xref:System.Windows.Controls.TextBox>, proponowana wartość jest wartość, która znajduje się w <xref:System.Windows.Controls.TextBox> przed zobowiązuje się do źródła.  
  
 Gdy <xref:System.Windows.Data.BindingGroup.SharesProposedValues%2A> jest `true`, <xref:System.Windows.Data.BindingGroup> używa proponowana wartość, gdy jedno powiązanie pozostawia BindingGroup i innym wiązaniu przy użyciu tego samego źródła dołączania BindingGroup.  Na przykład załóżmy, że aplikacja umożliwia użytkownikowi edytować wiele pól i zaktualizuj obiekt źródłowy, klikając przycisk. Gdy pole nie jest edytowany, aplikacja wyświetli go w <xref:System.Windows.Controls.TextBlock>. Gdy użytkownik rozpoczyna edytowanie pola, aplikacja zastępuje <xref:System.Windows.Controls.TextBlock> z <xref:System.Windows.Controls.TextBox>. Gdy użytkownik zakończy edytowania tego pola, aplikacja zastępuje <xref:System.Windows.Controls.TextBox> z <xref:System.Windows.Controls.TextBlock>. Ponieważ źródło nie zostanie zaktualizowane, dopóki użytkownik kliknie przycisk, musi istnieć sposób <xref:System.Windows.Controls.TextBlock> do wyświetlenia proponowanych wartości. Ustawiając <xref:System.Windows.Data.BindingGroup.SharesProposedValues%2A> do `true`, aplikacja wyświetli zmiany wprowadzone przez użytkownika do pola, nawet wtedy, gdy źródło nie został zaktualizowany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (object item, string propertyName, out object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(object item, string propertyName, [out] object&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.TryGetValue(System.Object,System.String,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (item As Object, propertyName As String, ByRef value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(System::Object ^ item, System::String ^ propertyName, [Runtime::InteropServices::Out] System::Object ^ % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : obj * string *  -&gt; bool" Usage="bindingGroup.TryGetValue (item, propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt zawierający określoną właściwość.</param>
        <param name="propertyName">Właściwość którego proponowana wartość, aby uzyskać.</param>
        <param name="value">Po powrocie z tej metody zawiera obiekt reprezentujący wartość właściwości proponowane. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Próbuje pobrać proponowana wartość określonej właściwości lub elementu.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość jest proponowana wartość określonej właściwości; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.BindingGroup.TryGetValue%2A> Zwraca `false` Jeśli nie ma powiązań dla określonego elementu a właściwość lub wartość określonej właściwości nie jest dostępne, ze względu na błąd konwersji lub ponieważ wcześniejsze reguły sprawdzania poprawności nie powiodło się.  
  
 Użyj tej metody w <xref:System.Windows.Controls.ValidationRule.Validate%2A?displayProperty=nameWithType> metodę, aby uzyskać wartość do można zatwierdzić do źródła. Typ `value` zależy od etapu, na którym <xref:System.Windows.Controls.ValidationRule> występuje. Na przykład jeśli <xref:System.Windows.Controls.TextBox> dane powiązane z właściwością typu integer `value` to ciąg, jeśli <xref:System.Windows.Controls.ValidationRule> wywołująca <xref:System.Windows.Data.BindingGroup.TryGetValue%2A> ma jego <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> równa <xref:System.Windows.Controls.ValidationStep.RawProposedValue>. Jeśli <xref:System.Windows.Controls.ValidationRule> ma jego <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> równa <xref:System.Windows.Controls.ValidationStep.ConvertedProposedValue>, typ `value` jest jakiegokolwiek rodzaju, który jest zwracany przez konwerter powiązania. W tym przykładzie `value` jest zazwyczaj liczbą całkowitą.  
  
   
  
## Examples  
 Poniższy przykład tworzy niestandardowy <xref:System.Windows.Controls.ValidationRule> o nazwie `ValidateDateAndPrice`. W <xref:System.Windows.Controls.ValidationRule.Validate%2A> metody, w przykładzie użyto <xref:System.Windows.Data.BindingGroup.TryGetValue%2A> metody i <xref:System.Windows.Data.BindingGroup.Items%2A> właściwości, aby uzyskać wartości które użytkownik wprowadził do formularza. Następnie przykład sprawdza, czy element w przypadku ponad 100 zł, będzie on dostępny dla co najmniej 7 dni. W tym przykładzie jest częścią większego przykładu na <xref:System.Windows.Data.BindingGroup> klasy  
  
 [!code-csharp[BindingGroupSnippets#ValidateObject](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Data.cs#validateobject)]
 [!code-vb[BindingGroupSnippets#ValidateObject](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/data.vb#validateobject)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateSources">
      <MemberSignature Language="C#" Value="public bool UpdateSources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool UpdateSources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.UpdateSources" />
      <MemberSignature Language="VB.NET" Value="Public Function UpdateSources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool UpdateSources();" />
      <MemberSignature Language="F#" Value="member this.UpdateSources : unit -&gt; bool" Usage="bindingGroup.UpdateSources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Działa konwerter powiązania i <see cref="T:System.Windows.Controls.ValidationRule" /> obiektów, które mają <see cref="P:System.Windows.Controls.ValidationRule.ValidationStep" /> właściwością <see cref="F:System.Windows.Controls.ValidationStep.RawProposedValue" />, <see cref="F:System.Windows.Controls.ValidationStep.ConvertedProposedValue" />, lub <see cref="F:System.Windows.Controls.ValidationStep.UpdatedValue" /> i zapisuje wartości elementów docelowych do obiektów źródła, jeśli wszystkie reguły sprawdzania poprawności.</summary>
        <returns>
          <see langword="true" /> Jeśli wszystkie reguły sprawdzania poprawności powiodła się; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda aktualizuje źródło, jeśli co <xref:System.Windows.Controls.ValidationRule> zakończy się powodzeniem, ale nie spowoduje źródeł, aby zatwierdzić oczekujące zmiany i zakończyć transakcji edycji. Oznacza to jeśli obiekt źródłowy implementuje <xref:System.ComponentModel.IEditableObject>. Wywołanie tej metody nie powoduje, że <xref:System.ComponentModel.IEditableObject.EndEdit%2A> do wywołania. Użyj <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> metoda będzie miała źródeł zatwierdzić oczekujące zmiany.  
  
   
  
## Examples  
 Poniższy przykład jest częścią aplikacji, który monituje użytkownika o wprowadzenie wielu klientów i przypisać przedstawiciel handlowy do każdego klienta. Aplikacja sprawdza, czy klient i przedstawicielem handlowym firmy należą do tego samego regionu. Przykład wywołuje <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> do sprawdzania poprawności powiązania i zapisać wartości w źródle, jeśli wszystkie reguły sprawdzania poprawności.  
  
 [!code-csharp[BindingGroupSnippets#UpdateSources](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window2.xaml.cs#updatesources)]
 [!code-vb[BindingGroupSnippets#UpdateSources](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window2.xaml.vb#updatesources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidatesOnNotifyDataError">
      <MemberSignature Language="C#" Value="public bool ValidatesOnNotifyDataError { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidatesOnNotifyDataError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.ValidatesOnNotifyDataError" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidatesOnNotifyDataError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidatesOnNotifyDataError { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidatesOnNotifyDataError : bool with get, set" Usage="System.Windows.Data.BindingGroup.ValidatesOnNotifyDataError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy dołączać <see cref="T:System.Windows.Controls.NotifyDataErrorValidationRule" />.</summary>
        <value>
          <see langword="true" /> Aby uwzględnić <see cref="T:System.Windows.Controls.NotifyDataErrorValidationRule" />; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.Data.BindingGroup.ValidatesOnNotifyDataError%2A> jest `true`, sprawdza, czy powiązanie i zgłasza błędy, które są wywoływane przez źródło danych, który implementuje <xref:System.ComponentModel.INotifyDataErrorInfo>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateWithoutUpdate">
      <MemberSignature Language="C#" Value="public bool ValidateWithoutUpdate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ValidateWithoutUpdate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.ValidateWithoutUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Function ValidateWithoutUpdate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ValidateWithoutUpdate();" />
      <MemberSignature Language="F#" Value="member this.ValidateWithoutUpdate : unit -&gt; bool" Usage="bindingGroup.ValidateWithoutUpdate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Działa konwerter powiązania i <see cref="T:System.Windows.Controls.ValidationRule" /> obiektów, które mają <see cref="P:System.Windows.Controls.ValidationRule.ValidationStep" /> właściwością <see cref="F:System.Windows.Controls.ValidationStep.RawProposedValue" /> lub <see cref="F:System.Windows.Controls.ValidationStep.ConvertedProposedValue" />.</summary>
        <returns>
          <see langword="true" /> Jeśli powiedzie się reguły sprawdzania poprawności; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Źródła nie są aktualizowane, gdy chcesz wywołać tę metodę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidationErrors">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Controls.ValidationError&gt; ValidationErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Windows.Controls.ValidationError&gt; ValidationErrors" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.ValidationErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidationErrors As ReadOnlyCollection(Of ValidationError)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Controls::ValidationError ^&gt; ^ ValidationErrors { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Controls::ValidationError ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidationErrors : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Controls.ValidationError&gt;" Usage="System.Windows.Data.BindingGroup.ValidationErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Controls.ValidationError&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję <see cref="T:System.Windows.Controls.ValidationError" /> obiektów, które spowodowały <see cref="T:System.Windows.Data.BindingGroup" /> jest nieprawidłowy.</summary>
        <value>Kolekcja <see cref="T:System.Windows.Controls.ValidationError" /> obiektów, które spowodowały <see cref="T:System.Windows.Data.BindingGroup" /> jest nieprawidłowy.  Wartość jest <see langword="null" /> , jeśli nie ma żadnych błędów.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidationRules">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt; ValidationRules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.Windows.Controls.ValidationRule&gt; ValidationRules" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.ValidationRules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidationRules As Collection(Of ValidationRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::Windows::Controls::ValidationRule ^&gt; ^ ValidationRules { System::Collections::ObjectModel::Collection&lt;System::Windows::Controls::ValidationRule ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidationRules : System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt;" Usage="System.Windows.Data.BindingGroup.ValidationRules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję <see cref="T:System.Windows.Controls.ValidationRule" /> obiekty, które sprawdzają poprawność obiekty źródła <see cref="T:System.Windows.Data.BindingGroup" />.</summary>
        <value>Kolekcja <see cref="T:System.Windows.Controls.ValidationRule" /> obiekty, które sprawdzają poprawność obiekty źródła <see cref="T:System.Windows.Data.BindingGroup" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.Controls.ValidationRule> jest dodawany do <xref:System.Windows.Data.BindingGroup>, <xref:System.Windows.Data.BindingGroup> jest przekazywany jako pierwszy parametr <xref:System.Windows.Controls.ValidationRule.Validate%2A> metody. Proponowana wartości obiektu można uzyskać za pomocą <xref:System.Windows.Data.BindingGroup.TryGetValue%2A> lub <xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29> metody. Zawiera obiekty, które są źródeł powiązania z <xref:System.Windows.Data.BindingGroup.Items%2A> właściwości.  
  
   
  
## Examples  
 W poniższym przykładzie dodano niestandardowy <xref:System.Windows.Controls.ValidationRule>, `ValidateDateAndPrice`, <xref:System.Windows.Data.BindingGroup>.  
  
 [!code-xaml[BindingGroupSnippets#BindingGroup](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml#bindinggroup)]  
  
 W poniższym przykładzie przedstawiono `ValidateDateAndPrice` klasy. <xref:System.Windows.Controls.ValidationRule.Validate%2A> Metoda używa <xref:System.Windows.Data.BindingGroup> można pobrać wartości które użytkownik wprowadził do postaci i sprawdza, czy element w przypadku ponad 100 zł, będzie on dostępny dla co najmniej 7 dni.  
  
 [!code-csharp[BindingGroupSnippets#ValidateObject](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Data.cs#validateobject)]
 [!code-vb[BindingGroupSnippets#ValidateObject](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/data.vb#validateobject)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="CollectionView" FullName="System.Windows.Data.CollectionView">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8d3b9900ff3ea9a80c58df84188864118f024334" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30700817" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class CollectionView : System.Windows.Threading.DispatcherObject, System.Collections.IEnumerable, System.Collections.Specialized.INotifyCollectionChanged, System.ComponentModel.ICollectionView, System.ComponentModel.INotifyPropertyChanged" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit CollectionView extends System.Windows.Threading.DispatcherObject implements class System.Collections.IEnumerable, class System.Collections.Specialized.INotifyCollectionChanged, class System.ComponentModel.ICollectionView, class System.ComponentModel.INotifyPropertyChanged" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Data.CollectionView" />
  <TypeSignature Language="VB.NET" Value="Public Class CollectionView&#xA;Inherits DispatcherObject&#xA;Implements ICollectionView, IEnumerable, INotifyCollectionChanged, INotifyPropertyChanged" />
  <TypeSignature Language="C++ CLI" Value="public ref class CollectionView : System::Windows::Threading::DispatcherObject, System::Collections::IEnumerable, System::Collections::Specialized::INotifyCollectionChanged, System::ComponentModel::ICollectionView, System::ComponentModel::INotifyPropertyChanged" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Specialized.INotifyCollectionChanged</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ICollectionView</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.INotifyPropertyChanged</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje widoku dla grupowania, sortowanie, filtrowanie i nawigacja zbierania danych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie należy tworzyć obiektów tej klasy w kodzie. Aby utworzyć widok kolekcji dla kolekcji, który implementuje tylko <xref:System.Collections.IEnumerable>, Utwórz <xref:System.Windows.Data.CollectionViewSource> obiektów, Dodaj do kolekcji <xref:System.Windows.Data.CollectionViewSource.Source%2A> właściwości i pobierania kolekcję wyświetlić z <xref:System.Windows.Data.CollectionViewSource.View%2A> właściwości.  
  
 Widok kolekcji można traktować jako warstwą kolekcja źródło powiązania, która umożliwia nawigacji i wyświetlania kolekcji na podstawie sortowania, filtrów i grupy zapytań, bez konieczności modyfikowania podstawowej sama kolekcja źródła. Jeśli implementuje kolekcji źródłowej <xref:System.Collections.Specialized.INotifyCollectionChanged> interfejsu zmiany, które uruchamiają <xref:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged> zdarzenia są propagowane do widoków.  
  
 Ponieważ widok nie zmienia się kolekcja podstawowa źródła, Kolekcja źródłowa może mieć wiele widoków skojarzonych z nim. Przy użyciu widoków, można wyświetlić te same dane w różny sposób. Na przykład można użyć dwóch widoków na kolekcji `Task` obiektów, aby wyświetlić zadania posortowane według priorytetu w jednej części strony i pogrupowane według obszaru w innej części strony.  
  
 W [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] aplikacji, wszystkie kolekcje mają kolekcji skojarzoną domyślną wyświetlić. Zamiast pracy z tą kolekcją, aparat wiązania zawsze uzyskuje dostęp do kolekcji przy użyciu skojarzonego widoku. Aby uzyskać widok domyślny, należy użyć <xref:System.Windows.Data.CollectionViewSource.GetDefaultView%2A?displayProperty=nameWithType> metody. Wewnętrzna klasa na podstawie <xref:System.Windows.Data.CollectionView> jest domyślnym widokiem dla kolekcji, które implementują tylko <xref:System.Collections.IEnumerable>. <xref:System.Windows.Data.ListCollectionView> jest to domyślny widok dla kolekcji, które implementują <xref:System.Collections.IList>. <xref:System.Windows.Data.BindingListCollectionView> jest to domyślny widok dla kolekcji, które implementują <xref:System.ComponentModel.IBindingListView> lub <xref:System.ComponentModel.IBindingList>.  
  
 Alternatywnie można utworzyć widok kolekcji w [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] przy użyciu <xref:System.Windows.Data.CollectionViewSource> klasy, a następnie powiązać formantu tego widoku. <xref:System.Windows.Data.CollectionViewSource> Jest klasa [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] reprezentację <xref:System.Windows.Data.CollectionView> klasy. Na przykład zobacz [porady: sortowanie i grupy danych przy użyciu widoku w języku XAML](~/docs/framework/wpf/data/how-to-sort-and-group-data-using-a-view-in-xaml.md).  
  
 Aby uzyskać więcej informacji, zobacz "Powiązanie do kolekcji" w [omówienie powiązania danych](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 Aby ustawić widoku w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], użyj <xref:System.Windows.Data.CollectionViewSource> klasy. <xref:System.Windows.Data.CollectionViewSource> jest [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] reprezentację <xref:System.Windows.Data.CollectionView> klasy która przedstawia najczęściej używane członkami <xref:System.Windows.Data.CollectionView> klasy.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CollectionView (System.Collections.IEnumerable collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IEnumerable collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.#ctor(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CollectionView(System::Collections::IEnumerable ^ collection);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="collection">Kolekcja źródłowa.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Data.CollectionView" /> klasa, która reprezentuje widok określonej kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie <xref:System.Windows.Data.CollectionView> jest powiązany z [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] Wątek dyspozytora wywołujący tego konstruktora.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowsCrossThreadChanges">
      <MemberSignature Language="C#" Value="protected bool AllowsCrossThreadChanges { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsCrossThreadChanges" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.AllowsCrossThreadChanges" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property AllowsCrossThreadChanges As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool AllowsCrossThreadChanges { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wątku innego niż utworzony <see cref="T:System.Windows.Data.CollectionView" /> można zmienić <see cref="P:System.Windows.Data.CollectionView.SourceCollection" />.</summary>
        <value>
          <see langword="true" /> Jeśli z wątku innego niż konto, którego utworzono <see cref="T:System.Windows.Data.CollectionView" /> można zmienić <see cref="P:System.Windows.Data.CollectionView.SourceCollection" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFilter">
      <MemberSignature Language="C#" Value="public virtual bool CanFilter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFilter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.CanFilter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanFilter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanFilter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy widok obsługuje filtrowania.</summary>
        <value>
          <see langword="true" /> Jeśli widok obsługuje filtrowanie; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość zwraca `false`, ustawienie <xref:System.Windows.Data.CollectionView.Filter%2A> właściwości zgłasza wyjątek.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanGroup">
      <MemberSignature Language="C#" Value="public virtual bool CanGroup { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.CanGroup" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanGroup As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanGroup { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy widok obsługuje grupowania.</summary>
        <value>
          <see langword="false" /> we wszystkich przypadkach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość służy do sprawdzenia, czy widok obsługuje sortowanie przed dodaniem <xref:System.Windows.Data.CollectionView.GroupDescriptions%2A>. Klasy pochodne zastąpić tę właściwość, aby wskazać, czy obsługują one grupowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSort">
      <MemberSignature Language="C#" Value="public virtual bool CanSort { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSort" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.CanSort" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanSort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSort { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy widok obsługuje sortowanie.</summary>
        <value>
          <see langword="false" /> we wszystkich przypadkach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość służy do sprawdzenia, czy widok obsługuje sortowanie przed dodaniem <xref:System.Windows.Data.CollectionView.SortDescriptions%2A>. Klasy pochodne zastąpić tę właściwość, aby wskazać, czy obsługują one sortowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearChangeLog">
      <MemberSignature Language="C#" Value="protected void ClearChangeLog ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChangeLog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.ClearChangeLog" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChangeLog ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChangeLog();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Replaced by ClearPendingChanges")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści oczekujących zmian z dziennika zmian.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Data.CollectionView.OnBeginChangeLogging(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ClearPendingChanges">
      <MemberSignature Language="C#" Value="protected void ClearPendingChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearPendingChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.ClearPendingChanges" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearPendingChanges ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearPendingChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści nieprzetworzone zmienione do kolekcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionChanged">
      <MemberSignature Language="C#" Value="protected virtual event System.Collections.Specialized.NotifyCollectionChangedEventHandler CollectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Collections.Specialized.NotifyCollectionChangedEventHandler CollectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.CollectionView.CollectionChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Event CollectionChanged As NotifyCollectionChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual event System::Collections::Specialized::NotifyCollectionChangedEventHandler ^ CollectionChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NotifyCollectionChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie widoku.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged" />
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IComparer Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IComparer Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Comparer As IComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IComparer ^ Comparer { System::Collections::IComparer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca obiekt, który służy do porównywania elementów w widoku.</summary>
        <value>
          <see cref="T:System.Collections.IComparer" /> Obiektów, której można porównać elementów w widoku.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do sprawdzenia.</param>
        <summary>Zwraca wartość wskazującą, czy określony element należy do widoku.</summary>
        <returns>
          <see langword="true" /> Jeśli element należy do widoku. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie powoduje żadnych założenia dotyczące tego, czy element należy do kolekcji źródłowej. Jeśli element wywołujący wie, że element należy do kolekcji źródłowej, jest bardziej wydajne, aby wywołać <xref:System.Windows.Data.CollectionView.PassesFilter%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę rekordów w widoku.</summary>
        <value>Liczba rekordów w widoku lub -1 Jeśli liczba rekordów jest nieznany.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli filtr jest ustawiona, wartość tej właściwości zawiera tylko elementy, które przejdą filtru. Jeśli kolekcja źródłowa jest typu <xref:System.Collections.IEnumerable>, jest to operacja O(N). Ta wartość jest buforowany do momentu zmiany kolekcji.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Podczas tworzenia klasy pochodnej z <see cref="T:System.Windows.Data.CollectionView" />, Zastąp tę właściwość, aby bardziej wydajne implementacji.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public virtual System.Globalization.CultureInfo Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Culture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.Culture" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Culture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Globalization::CultureInfo ^ Culture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.CultureInfoIetfLanguageTagConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje o ustawieniach kulturowych do użycia podczas sortowania.</summary>
        <value>Informacje o ustawieniach kulturowych do użycia podczas sortowania.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentChanged">
      <MemberSignature Language="C#" Value="public virtual event EventHandler CurrentChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CurrentChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.CollectionView.CurrentChanged" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Event CurrentChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ CurrentChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> została zmieniona.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Zgłoś to zdarzenie po zmianie <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</para>
        </block>
        <altmember cref="E:System.ComponentModel.ICollectionView.CurrentChanged" />
      </Docs>
    </Member>
    <Member MemberName="CurrentChanging">
      <MemberSignature Language="C#" Value="public virtual event System.ComponentModel.CurrentChangingEventHandler CurrentChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CurrentChangingEventHandler CurrentChanging" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.CollectionView.CurrentChanging" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Event CurrentChanging As CurrentChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::ComponentModel::CurrentChangingEventHandler ^ CurrentChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CurrentChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> jest zmieniany.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Zgłoś to zdarzenie przed zmianą <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</para>
        </block>
        <altmember cref="E:System.ComponentModel.ICollectionView.CurrentChanging" />
      </Docs>
    </Member>
    <Member MemberName="CurrentItem">
      <MemberSignature Language="C#" Value="public virtual object CurrentItem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object CurrentItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.CurrentItem" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrentItem As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ CurrentItem { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący element w widoku.</summary>
        <value>Element bieżącego widoku. Domyślnie jako bieżący element rozpoczyna się pierwszego elementu w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolekcja widoków obsługuje pojęcie wskaźnik do bieżącego rekordu. Podczas przeglądania obiektów w widoku kolekcji przenosisz wskaźnik rekordu, który pozwala na pobieranie obiektu, który istnieje w tej lokalizacji określonej w kolekcji.  
  
 Należy zauważyć, że przenoszenie bieżącego rekordu wskaźnika ma niektóre interakcje ze wszystkimi sortowanie lub filtrowanie jest stosowany do kolekcji. Sortowanie zachowuje bieżący wskaźnik rekordu na ostatni rekord wybrane, ale restrukturyzacji wokół niego widok kolekcji. (Być może został wybranego rekordu na początku listy przed, ale wybranego rekordu może być teraz gdzieś w środku). Filtrowanie zachowuje wybranego rekordu, jeżeli Wybieranie pozostaje w widoku po filtrowania. W przeciwnym razie bieżący wskaźnik rekordu jest ustawiona na pierwszy rekord widok filtrowany kolekcji.  
  
 Bieżący element w kolekcji jest powiązany z automatycznie, jeśli element docelowy powiązanie jest pojedyncza wartość. Jeśli obiektem docelowym jest <xref:System.Windows.Controls.ItemsControl>, bieżący element jest zsynchronizowany z wybranego elementu. Na przykład, jeśli pole listy jest powiązana z kolekcją <xref:System.Windows.Data.CollectionView.CurrentItem%2A> jest zsynchronizowany z aktualnie wybranego elementu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Tylko klasy, które przekazać waluty obsługi wywołania do innego wewnętrznego <see cref="T:System.Windows.Data.CollectionView" /> obiektu powinny zastępować właściwość ta; należy użyć wszystkich innych klas pochodnych <see cref="M:System.Windows.Data.CollectionView.SetCurrent(System.Object,System.Int32)" /> metodę aktualizowania czy obecne wartości przechowywane w klasie podstawowej.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CurrentPosition">
      <MemberSignature Language="C#" Value="public virtual int CurrentPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.CurrentPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrentPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CurrentPosition { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pozycji porządkowej <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> w widoku (opcjonalnie posortowane i przefiltrowane).</summary>
        <value>{Numer porządkowy pozycja <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> w widoku (opcjonalnie posortowane i przefiltrowane).</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Tylko klasy, które przekazać waluty obsługi wywołania do innego wewnętrznego <see cref="T:System.Windows.Data.CollectionView" /> obiektu powinny zastępować właściwość ta; należy użyć wszystkich innych klas pochodnych <see cref="M:System.Windows.Data.CollectionView.SetCurrent(System.Object,System.Int32)" /> metodę aktualizowania czy obecne wartości przechowywane w klasie podstawowej.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DeferRefresh">
      <MemberSignature Language="C#" Value="public virtual IDisposable DeferRefresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IDisposable DeferRefresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.DeferRefresh" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeferRefresh () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IDisposable ^ DeferRefresh();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wprowadza cykl Ustąp, który służy do scalania zmian wprowadzonych na automatyczne odświeżanie widoku i opóźnienie.</summary>
        <returns>
          <see cref="T:System.IDisposable" /> Obiekt, który służy do usuwania obiektu wywołującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typowy sposób polega na utworzeniu `using` zakres przy użyciu tej metody, a następnie umieść wielu wywołań zmiana widoku w zakresie. Opóźnia automatycznego odświeżania, dopóki nie zostanie zakończone cyklu Ustąp.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetachFromSourceCollection">
      <MemberSignature Language="C#" Value="public virtual void DetachFromSourceCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DetachFromSourceCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.DetachFromSourceCollection" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DetachFromSourceCollection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DetachFromSourceCollection();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa odwołanie do podstawowej kolekcji z <see cref="T:System.Windows.Data.CollectionView" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia anulowanie subskrypcji zdarzeń dla kolekcji źródłowej i umożliwić <xref:System.Windows.Data.CollectionView> być bezużytecznych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public virtual Predicate&lt;object&gt; Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Predicate`1&lt;object&gt; Filter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Filter As Predicate(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Predicate&lt;System::Object ^&gt; ^ Filter { Predicate&lt;System::Object ^&gt; ^ get(); void set(Predicate&lt;System::Object ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Predicate&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia metodę używaną do ustalenia, czy element jest odpowiednie do widoku.</summary>
        <value>Delegat, który reprezentuje metodę używaną do ustalenia, czy element jest odpowiednie do widoku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prostsze implementacji nie obsługuje filtrowania i zgłosić <xref:System.NotSupportedException>. Użyj <xref:System.Windows.Data.CollectionView.CanFilter%2A> właściwości, aby sprawdzić, czy filtrowanie jest obsługiwany przed przypisaniem tej właściwości wartość inną niż null.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Bieżąca implementacja nie obsługuje filtrowania.</exception>
        <altmember cref="E:System.Windows.Data.CollectionViewSource.Filter" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca obiekt, który służy do wyliczania elementów w widoku.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> Obiektów można wyliczyć elementów w widoku.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemAt">
      <MemberSignature Language="C#" Value="public virtual object GetItemAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetItemAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.GetItemAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetItemAt (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetItemAt(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu do pobrania.</param>
        <summary>Pobiera element pod określonym indeksem liczony od zera w widoku.</summary>
        <returns>Element pod określonym indeksem liczony od zera w widoku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ocenia indeksu ze wszystkimi <xref:System.Windows.Data.CollectionView.SortDescriptions%2A> lub <xref:System.Windows.Data.CollectionView.Filter%2A> wartości właściwości, które są ustawione w widoku.  
  
 Jeśli kolekcja źródłowa jest typu <xref:System.Collections.IEnumerable>, jest to operacja O(N).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż 0.</exception>
        <block subset="none" type="overrides">
          <para>Podczas tworzenia klasy pochodnej z <see cref="T:System.Windows.Data.CollectionView" />, przesłonić tę metodę do bardziej wydajne implementacji.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GroupDescriptions">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ObjectModel.ObservableCollection&lt;System.ComponentModel.GroupDescription&gt; GroupDescriptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ObservableCollection`1&lt;class System.ComponentModel.GroupDescription&gt; GroupDescriptions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.GroupDescriptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GroupDescriptions As ObservableCollection(Of GroupDescription)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ObjectModel::ObservableCollection&lt;System::ComponentModel::GroupDescription ^&gt; ^ GroupDescriptions { System::Collections::ObjectModel::ObservableCollection&lt;System::ComponentModel::GroupDescription ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ObservableCollection&lt;System.ComponentModel.GroupDescription&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję <see cref="T:System.ComponentModel.GroupDescription" /> obiektów, które opisano w sposób grupowania elementów w kolekcji w widoku.</summary>
        <value>
          <see langword="null" /> we wszystkich przypadkach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej właściwości jest zawsze `null` ponieważ <xref:System.Windows.Data.CollectionView> za pośrednictwem jego kolekcja podstawowa klasa nie obsługuje grupowania. Klasy pochodne <xref:System.Windows.Data.ListCollectionView> i <xref:System.Windows.Data.BindingListCollectionView> obsługuje grupowania.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.ListCollectionView.GroupDescriptions" />
      </Docs>
    </Member>
    <Member MemberName="Groups">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ObjectModel.ReadOnlyObservableCollection&lt;object&gt; Groups { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyObservableCollection`1&lt;object&gt; Groups" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.Groups" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Groups As ReadOnlyObservableCollection(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ObjectModel::ReadOnlyObservableCollection&lt;System::Object ^&gt; ^ Groups { System::Collections::ObjectModel::ReadOnlyObservableCollection&lt;System::Object ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyObservableCollection&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję najwyższego poziomu grupy, które jest tworzony na podstawie <see cref="P:System.Windows.Data.CollectionView.GroupDescriptions" /> właściwości.</summary>
        <value>
          <see langword="null" /> we wszystkich przypadkach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej właściwości jest zawsze `null` ponieważ <xref:System.Windows.Data.CollectionView> za pośrednictwem jego kolekcja podstawowa klasa nie obsługuje grupowania. Klasy pochodne <xref:System.Windows.Data.ListCollectionView> i <xref:System.Windows.Data.BindingListCollectionView> obsługuje grupowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (item As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Object ^ item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Element do zlokalizowania.</param>
        <summary>Zwraca indeks, w której znajduje się określony element.</summary>
        <returns>Indeks, w którym określony element znajduje się, lub -1, jeśli element jest nieznany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta metoda zwraca wartość indeksu niż -1, musi być zawsze wartość true, ten widok [Indeks-1] < elementu < = widoku [Indeks], gdzie porównanie są wykonywane przy użyciu <xref:System.Collections.IComparer.Compare%2A?displayProperty=nameWithType> metody widoku, jeśli taka istnieje.  
  
 To zachowanie określonej metody jest używana przez niektóre <xref:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged> procedury obsługi zdarzeń w celu przyspieszenia reakcji na wstawianie i usuwanie. Jeśli klasa pochodna nie przesłonić tę metodę, odbiornik nie binarne wyszukiwania za pomocą funkcji <xref:System.Collections.IComparer.Compare%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCurrentAfterLast">
      <MemberSignature Language="C#" Value="public virtual bool IsCurrentAfterLast { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCurrentAfterLast" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsCurrentAfterLast" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsCurrentAfterLast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCurrentAfterLast { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> widoku jest poza końcem kolekcji.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> widoku jest poza końcem kolekcji; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolekcja widoków obsługuje pojęcie wskaźnik do bieżącego rekordu. Podczas przeglądania obiektów w widoku kolekcji przenosisz wskaźnik rekordu, który pozwala na pobieranie obiektu, który istnieje w tej lokalizacji określonej w kolekcji.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.IsCurrentAfterLast" />
      </Docs>
    </Member>
    <Member MemberName="IsCurrentBeforeFirst">
      <MemberSignature Language="C#" Value="public virtual bool IsCurrentBeforeFirst { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCurrentBeforeFirst" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsCurrentBeforeFirst" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsCurrentBeforeFirst As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCurrentBeforeFirst { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> widoku jest przed początkiem kolekcji.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> widoku jest przed początkiem kolekcji; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolekcja widoków obsługuje pojęcie wskaźnik do bieżącego rekordu. Podczas przeglądania obiektów w widoku kolekcji przenosisz wskaźnik rekordu, który pozwala na pobieranie obiektu, który istnieje w tej lokalizacji określonej w kolekcji.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.IsCurrentAfterLast" />
      </Docs>
    </Member>
    <Member MemberName="IsCurrentInSync">
      <MemberSignature Language="C#" Value="protected bool IsCurrentInSync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCurrentInSync" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsCurrentInSync" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsCurrentInSync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsCurrentInSync { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> w <see cref="P:System.Windows.Data.CollectionView.CurrentPosition" />.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> w widoku i w <see cref="P:System.Windows.Data.CollectionView.CurrentPosition" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="protected bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsDynamic { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy odpowiednia kolekcja zawiera powiadomienia o zmianie.</summary>
        <value>
          <see langword="true" /> Jeśli odpowiednia kolekcja zawiera powiadomienia o zmianie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public virtual bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEmpty { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wynikowy widoku (filtrowane) jest pusty.</summary>
        <value>
          <see langword="true" /> Jeśli uzyskany widok jest pusta. w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInUse">
      <MemberSignature Language="C#" Value="public virtual bool IsInUse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInUse" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsInUse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsInUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsInUse { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy każdy obiekt jest subskrybowanie zdarzeń to <see cref="T:System.Windows.Data.CollectionView" />.</summary>
        <value>
          <see langword="true" /> Jeśli dowolny obiekt jest subskrybowanie zdarzeń to <see cref="T:System.Windows.Data.CollectionView" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRefreshDeferred">
      <MemberSignature Language="C#" Value="protected bool IsRefreshDeferred { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRefreshDeferred" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsRefreshDeferred" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsRefreshDeferred As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsRefreshDeferred { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy istnieje oczekujące <see cref="M:System.Windows.Data.CollectionView.DeferRefresh" /> w użyciu.</summary>
        <value>
          <see langword="true" /> Jeśli istnieje oczekujące <see cref="M:System.Windows.Data.CollectionView.DeferRefresh" /> używany; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Klasy pochodne należy unikać wywoływania <see cref="M:System.Windows.Data.CollectionView.Refresh" /> Jeśli <see cref="P:System.Windows.Data.CollectionView.IsRefreshDeferred" /> zwraca <see langword="true" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentTo">
      <MemberSignature Language="C#" Value="public virtual bool MoveCurrentTo (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveCurrentTo(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.MoveCurrentTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveCurrentTo (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveCurrentTo(System::Object ^ item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Element, aby ustawić jako <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</param>
        <summary>Ustawia określony element jako <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> w widoku.</summary>
        <returns>
          <see langword="true" /> Jeśli powstałe w ten sposób <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> znajduje się w widoku, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określony element nie zostanie znaleziony, metoda zwraca `false` i <xref:System.Windows.Data.CollectionView.CurrentItem%2A> znajduje się przed rozpoczęciem kolekcji w widoku.  
  
 Kolekcja widoków obsługuje pojęcie wskaźnik do bieżącego rekordu. Podczas przeglądania obiektów w widoku kolekcji przenosisz wskaźnik rekordu, który pozwala na pobieranie obiektu, który istnieje w tej lokalizacji określonej w kolekcji. Aby uzyskać więcej informacji, zobacz "Powiązanie do kolekcji" w [omówienie powiązania danych](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 Aby uzyskać więcej informacji na temat bieżącego elementu widoku, zobacz <xref:System.Windows.Data.CollectionView.CurrentItem%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano korzystać z tej metody.  
  
 [!code-csharp[Colors#NewColor](~/samples/snippets/csharp/VS_Snippets_Wpf/Colors/CSharp/Colors.xaml.cs#newcolor)]
 [!code-vb[Colors#NewColor](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Colors/visualbasic/colors.xaml.vb#newcolor)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.CurrentItem" />
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToFirst">
      <MemberSignature Language="C#" Value="public virtual bool MoveCurrentToFirst ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveCurrentToFirst() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.MoveCurrentToFirst" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveCurrentToFirst () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveCurrentToFirst();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia pierwszego elementu w widoku w postaci <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</summary>
        <returns>
          <see langword="true" /> Jeśli powstałe w ten sposób <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> jest element w widoku, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolekcja widoków obsługuje pojęcie wskaźnik do bieżącego rekordu. Podczas przeglądania obiektów w widoku kolekcji przenosisz wskaźnik rekordu, który pozwala na pobieranie obiektu, który istnieje w tej lokalizacji określonej w kolekcji. Aby uzyskać więcej informacji, zobacz "Powiązanie do kolekcji" w [omówienie powiązania danych](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.IsCurrentBeforeFirst" />
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToLast">
      <MemberSignature Language="C#" Value="public virtual bool MoveCurrentToLast ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveCurrentToLast() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.MoveCurrentToLast" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveCurrentToLast () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveCurrentToLast();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia ostatniego elementu w widoku w postaci <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</summary>
        <returns>
          <see langword="true" /> Jeśli powstałe w ten sposób <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> jest element w widoku, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolekcja widoków obsługuje pojęcie wskaźnik do bieżącego rekordu. Podczas przeglądania obiektów w widoku kolekcji przenosisz wskaźnik rekordu, który pozwala na pobieranie obiektu, który istnieje w tej lokalizacji określonej w kolekcji. Aby uzyskać więcej informacji, zobacz "Powiązanie do kolekcji" w [omówienie powiązania danych](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.IsCurrentAfterLast" />
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToNext">
      <MemberSignature Language="C#" Value="public virtual bool MoveCurrentToNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveCurrentToNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.MoveCurrentToNext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveCurrentToNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveCurrentToNext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia element po <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> w widoku w postaci <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</summary>
        <returns>
          <see langword="true" /> Jeśli powstałe w ten sposób <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> jest element w widoku, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolekcja widoków obsługuje pojęcie wskaźnik do bieżącego rekordu. Podczas przeglądania obiektów w widoku kolekcji przenosisz wskaźnik rekordu, który pozwala na pobieranie obiektu, który istnieje w tej lokalizacji określonej w kolekcji. Aby uzyskać więcej informacji, zobacz "Powiązanie do kolekcji" w [omówienie powiązania danych](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.IsCurrentAfterLast" />
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToPosition">
      <MemberSignature Language="C#" Value="public virtual bool MoveCurrentToPosition (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveCurrentToPosition(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.MoveCurrentToPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveCurrentToPosition (position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveCurrentToPosition(int position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Indeks, aby ustawić <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> do.</param>
        <summary>Ustawia element pod określonym indeksem jako <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> w widoku.</summary>
        <returns>
          <see langword="true" /> Jeśli powstałe w ten sposób <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> jest element w widoku, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolekcja widoków obsługuje pojęcie wskaźnik do bieżącego rekordu. Podczas przeglądania obiektów w widoku kolekcji przenosisz wskaźnik rekordu, który pozwala na pobieranie obiektu, który istnieje w tej lokalizacji określonej w kolekcji. Aby uzyskać więcej informacji, zobacz "Powiązanie do kolekcji" w [omówienie powiązania danych](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToPrevious">
      <MemberSignature Language="C#" Value="public virtual bool MoveCurrentToPrevious ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveCurrentToPrevious() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.MoveCurrentToPrevious" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveCurrentToPrevious () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveCurrentToPrevious();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia element przed <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> w widoku w postaci <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</summary>
        <returns>
          <see langword="true" /> Jeśli powstałe w ten sposób <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> jest element w widoku, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolekcja widoków obsługuje pojęcie wskaźnik do bieżącego rekordu. Podczas przeglądania obiektów w widoku kolekcji przenosisz wskaźnik rekordu, który pozwala na pobieranie obiektu, który istnieje w tej lokalizacji określonej w kolekcji. Aby uzyskać więcej informacji, zobacz "Powiązanie do kolekcji" w [omówienie powiązania danych](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.IsCurrentBeforeFirst" />
      </Docs>
    </Member>
    <Member MemberName="NeedsRefresh">
      <MemberSignature Language="C#" Value="public virtual bool NeedsRefresh { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NeedsRefresh" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.NeedsRefresh" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NeedsRefresh As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool NeedsRefresh { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy konieczne jest odświeżenie widoku.</summary>
        <value>
          <see langword="true" /> Jeśli widok konieczne jest odświeżenie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość wskazuje, czy wewnętrzny stan widoku został zmieniony i wymaga <xref:System.Windows.Data.CollectionView.Refresh%2A> wywołania metody. Typowy scenariusz polega na Jeśli <xref:System.ComponentModel.SortDescription> lub podobne został dodany do widoku podczas cyklu odroczonego odświeżanie widoku (zobacz <xref:System.Windows.Data.CollectionView.DeferRefresh%2A>). W tym scenariuszu nie jawnym wywołaniem <xref:System.Windows.Data.CollectionView.Refresh%2A> jest wymagana; jak cyklu odświeżania odroczonego zakończeń widoku wywołuje odświeżania automatycznie.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Data.CollectionView.Refresh" />
        <altmember cref="M:System.Windows.Data.CollectionView.DeferRefresh" />
      </Docs>
    </Member>
    <Member MemberName="NewItemPlaceholder">
      <MemberSignature Language="C#" Value="public static object NewItemPlaceholder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property object NewItemPlaceholder" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.NewItemPlaceholder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NewItemPlaceholder As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Object ^ NewItemPlaceholder { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który znajduje się w kolekcji do reprezentowania nowego elementu.</summary>
        <value>Obiekt, który znajduje się w kolekcji do reprezentowania nowego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.Data.CollectionView> implementującej <xref:System.ComponentModel.IEditableCollectionView> ma <xref:System.ComponentModel.IEditableCollectionView.NewItemPlaceholderPosition%2A> ustawioną <xref:System.ComponentModel.NewItemPlaceholderPosition.AtBeginning> lub <xref:System.ComponentModel.NewItemPlaceholderPosition.AtEnd>, <xref:System.Windows.Data.CollectionView.NewItemPlaceholder%2A> zostanie dodany do kolekcji.  <xref:System.Windows.Data.CollectionView.NewItemPlaceholder%2A> Zawsze jest wyświetlany w kolekcji; nie uczestniczy w grupowania, sortowania i filtrowania.  
  
 <xref:System.Windows.Data.CollectionView.CurrentItem%2A> Nie może być <xref:System.Windows.Data.CollectionView.NewItemPlaceholder%2A>. Metodach wykonujących względną nawigacji, takich jak <xref:System.Windows.Data.CollectionView.MoveCurrentToNext%2A>, Pomiń <xref:System.Windows.Data.CollectionView.NewItemPlaceholder%2A>.  <xref:System.Windows.Data.CollectionView.MoveCurrentToFirst%2A> i <xref:System.Windows.Data.CollectionView.MoveCurrentToLast%2A> pominąć <xref:System.Windows.Data.CollectionView.NewItemPlaceholder%2A> Jeśli <xref:System.ComponentModel.IEditableCollectionView.NewItemPlaceholderPosition%2A> ustawiono <xref:System.ComponentModel.NewItemPlaceholderPosition.AtBeginning> lub <xref:System.ComponentModel.NewItemPlaceholderPosition.AtEnd>odpowiednio. Metodach wykonujących bezwzględną nawigacji, takich jak <xref:System.Windows.Data.CollectionView.MoveCurrentToPosition%2A>, nic nie rób Jeśli <xref:System.Windows.Data.CollectionView.NewItemPlaceholder%2A> będzie <xref:System.Windows.Data.CollectionView.CurrentItem%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OKToChangeCurrent">
      <MemberSignature Language="C#" Value="protected bool OKToChangeCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool OKToChangeCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OKToChangeCurrent" />
      <MemberSignature Language="VB.NET" Value="Protected Function OKToChangeCurrent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool OKToChangeCurrent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy widok można zmienić elementu <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</summary>
        <returns>
          <see langword="false" /> Jeśli odbiornik Anuluje zmiany; w przeciwnym razie <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAllowsCrossThreadChangesChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAllowsCrossThreadChangesChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAllowsCrossThreadChangesChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnAllowsCrossThreadChangesChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAllowsCrossThreadChangesChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAllowsCrossThreadChangesChanged();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Data.CollectionView.AllowsCrossThreadChanges" /> zmiany właściwości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginChangeLogging">
      <MemberSignature Language="C#" Value="protected virtual void OnBeginChangeLogging (System.Collections.Specialized.NotifyCollectionChangedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBeginChangeLogging(class System.Collections.Specialized.NotifyCollectionChangedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnBeginChangeLogging(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBeginChangeLogging (args As NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBeginChangeLogging(System::Collections::Specialized::NotifyCollectionChangedEventArgs ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Replaced by OnAllowsCrossThreadChangesChanged")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Collections.Specialized.NotifyCollectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">
          <see cref="T:System.Collections.Specialized.NotifyCollectionChangedEventArgs" /> Obiektu, który jest dodawany do dziennika zmian.</param>
        <summary>Metoda wywoływana przez klasę podstawową powiadomiono klasy pochodnej <see cref="E:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged" /> zdarzeń została opublikowana do kolejki wiadomości.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OnCollectionChanged">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zgłasza <see cref="E:System.Windows.Data.CollectionView.CollectionChanged" /> zdarzeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnCollectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCollectionChanged (System.Collections.Specialized.NotifyCollectionChangedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCollectionChanged(class System.Collections.Specialized.NotifyCollectionChangedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCollectionChanged (args As NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCollectionChanged(System::Collections::Specialized::NotifyCollectionChangedEventArgs ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Collections.Specialized.NotifyCollectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">
          <see cref="T:System.Collections.Specialized.NotifyCollectionChangedEventArgs" /> Obiektu do przekazania do programu obsługi zdarzeń.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Data.CollectionView.CollectionChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszelkie sortowanie, filtrowanie lub kryteria grupowania pod uwagę przed wywołaniem tej metody, aby podnieść <xref:System.Windows.Data.CollectionView.CollectionChanged> zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCollectionChanged">
      <MemberSignature Language="C#" Value="protected void OnCollectionChanged (object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCollectionChanged(object sender, class System.Collections.Specialized.NotifyCollectionChangedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnCollectionChanged(System.Object,System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCollectionChanged (sender As Object, args As NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCollectionChanged(System::Object ^ sender, System::Collections::Specialized::NotifyCollectionChangedEventArgs ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.Collections.Specialized.NotifyCollectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">Nadawca zdarzenia.</param>
        <param name="args">
          <see cref="T:System.Collections.Specialized.NotifyCollectionChangedEventArgs" /> Obiektu do przekazania do programu obsługi zdarzeń.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Data.CollectionView.CollectionChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje <xref:System.Windows.Data.CollectionView.ProcessCollectionChanged%2A> przypadku rozpoczął [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] Wątek dyspozytora i nigdy nie został zaktualizowany z innego wątku lub zapisuje zmiany do dyspozytora go przetworzyć na zorganizuj poprawny wątek.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCurrentChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCurrentChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCurrentChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnCurrentChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCurrentChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCurrentChanged();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zgłasza <see cref="E:System.Windows.Data.CollectionView.CurrentChanged" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OnCurrentChanging">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zgłasza <see cref="E:System.Windows.Data.CollectionView.CurrentChanging" /> zdarzeń.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnCurrentChanging">
      <MemberSignature Language="C#" Value="protected void OnCurrentChanging ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCurrentChanging() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnCurrentChanging" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCurrentChanging ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCurrentChanging();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zgłasza <see cref="E:System.Windows.Data.CollectionView.CurrentChanging" /> zdarzeń, który nie jest można anulować.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ustawia <xref:System.Windows.Data.CollectionView.CurrentPosition%2A> na -1. Ta metoda jest wywoływana przez zmiany kolekcji, które mają wpływ na <xref:System.Windows.Data.CollectionView.CurrentItem%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCurrentChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnCurrentChanging (System.ComponentModel.CurrentChangingEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCurrentChanging(class System.ComponentModel.CurrentChangingEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnCurrentChanging(System.ComponentModel.CurrentChangingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCurrentChanging (args As CurrentChangingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCurrentChanging(System::ComponentModel::CurrentChangingEventArgs ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.ComponentModel.CurrentChangingEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">Informacje o zdarzeniu.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Data.CollectionView.CurrentChanging" /> zdarzenia z określonymi argumentami.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.ComponentModel.PropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(class System.ComponentModel.PropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::ComponentModel::PropertyChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Argumenty zdarzeń są zgłaszane.</param>
        <summary>Zgłasza <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" /> zdarzeń przy użyciu określonych argumentów.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PassesFilter">
      <MemberSignature Language="C#" Value="public virtual bool PassesFilter (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PassesFilter(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.PassesFilter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PassesFilter (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PassesFilter(System::Object ^ item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Element do sprawdzenia.</param>
        <summary>Zwraca wartość wskazującą, czy określony element w kolekcji źródłowej należy do widoku.</summary>
        <returns>
          <see langword="true" /> Jeśli określony element należy do tego widoku lub jeśli istnieje filtruje zestaw w widoku kolekcji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od <xref:System.Windows.Data.CollectionView.Contains%2A> metody, ta metoda przyjęto założenie, że określony element należy do kolekcji źródłowej. Ta metoda uwzględnia filtrów. Zazwyczaj umożliwia tej metody podczas zmiany kolekcji powiadomienia Sprawdź, czy dodany lub usunięty element wymaga przetwarzania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessCollectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void ProcessCollectionChanged (System.Collections.Specialized.NotifyCollectionChangedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ProcessCollectionChanged(class System.Collections.Specialized.NotifyCollectionChangedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.ProcessCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ProcessCollectionChanged (args As NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ProcessCollectionChanged(System::Collections::Specialized::NotifyCollectionChangedEventArgs ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Collections.Specialized.NotifyCollectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">
          <see cref="T:System.Collections.Specialized.NotifyCollectionChangedEventArgs" /> Obiekt do procesu.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, przetwarza jednej zmiany w [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] wątku.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Ta metoda musi zostać zastąpiony w klasie pochodnej przetwarzaniu jednej zmiany w [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] wątku.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessPendingChanges">
      <MemberSignature Language="C#" Value="protected void ProcessPendingChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProcessPendingChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.ProcessPendingChanges" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProcessPendingChanges ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProcessPendingChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia, że wszystkie oczekujące zmiany w kolekcji zostały przekazane.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.PropertyChangedEventHandler PropertyChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.CollectionView.PropertyChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Event PropertyChanged As PropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual event System::ComponentModel::PropertyChangedEventHandler ^ PropertyChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zmieniono wartość właściwości.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public virtual void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Refresh();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ponownie tworzy widok.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas ustawiania <xref:System.Windows.Data.CollectionView.Filter%2A>, <xref:System.Windows.Data.CollectionView.SortDescriptions%2A>, lub <xref:System.Windows.Data.CollectionView.GroupDescriptions%2A> właściwości; odświeżenie występuje.  Nie trzeba wywołać <xref:System.Windows.Data.CollectionView.Refresh%2A> metoda natychmiast po ustawić jedną z tych właściwości. Informacje o sposobie opóźnienie automatycznego odświeżania, zobacz <xref:System.Windows.Data.CollectionView.DeferRefresh%2A>.  
  
 Klasy pochodne Użyj chronionej <xref:System.Windows.Data.CollectionView.RefreshOverride%2A> metodę, aby zastąpić zachowanie tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Data.CollectionView.DeferRefresh" />
        <altmember cref="P:System.Windows.Data.CollectionView.NeedsRefresh" />
      </Docs>
    </Member>
    <Member MemberName="RefreshOrDefer">
      <MemberSignature Language="C#" Value="protected void RefreshOrDefer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RefreshOrDefer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.RefreshOrDefer" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RefreshOrDefer ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RefreshOrDefer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa, czy widoku konieczne jest odświeżenie po zakończeniu cyklu Ustąp lub odświeża widok.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RefreshOverride">
      <MemberSignature Language="C#" Value="protected virtual void RefreshOverride ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RefreshOverride() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.RefreshOverride" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RefreshOverride ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RefreshOverride();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ponownie tworzy widok.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Klasy pochodne powinny przesłaniać tę metodę w celu zmiany zachowania <see cref="M:System.Windows.Data.CollectionView.Refresh" /> metody.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCurrent">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia bieżący element <see cref="T:System.Windows.Data.CollectionView" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCurrent">
      <MemberSignature Language="C#" Value="protected void SetCurrent (object newItem, int newPosition);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetCurrent(object newItem, int32 newPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.SetCurrent(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetCurrent (newItem As Object, newPosition As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetCurrent(System::Object ^ newItem, int newPosition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newItem" Type="System.Object" />
        <Parameter Name="newPosition" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="newItem">Element, aby ustawić jako <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</param>
        <param name="newPosition">Wartość do ustawienia jako <see cref="P:System.Windows.Data.CollectionView.CurrentPosition" /> wartości właściwości.</param>
        <summary>Ustawia określony element i indeksu jako wartości <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> i <see cref="P:System.Windows.Data.CollectionView.CurrentPosition" /> właściwości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCurrent">
      <MemberSignature Language="C#" Value="protected void SetCurrent (object newItem, int newPosition, int count);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetCurrent(object newItem, int32 newPosition, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.SetCurrent(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetCurrent (newItem As Object, newPosition As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetCurrent(System::Object ^ newItem, int newPosition, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newItem" Type="System.Object" />
        <Parameter Name="newPosition" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="newItem">Element, aby ustawić jako <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</param>
        <param name="newPosition">Wartość do ustawienia jako <see cref="P:System.Windows.Data.CollectionView.CurrentPosition" /> wartości właściwości.</param>
        <param name="count">Liczba elementów w <see cref="T:System.Windows.Data.CollectionView" />.</param>
        <summary>Ustawia określony element i indeksu jako wartości <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> i <see cref="P:System.Windows.Data.CollectionView.CurrentPosition" /> właściwości. Ta metoda może być wywołana z konstruktora klasy pochodnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołać tego przeciążenia z konstruktora klasy pochodnej.  Nie przekazuj <xref:System.Windows.Data.CollectionView.Count%2A> właściwość, która jest właściwością wirtualnego, jako `count`. Zamiast tego należy przekazać liczbę wewnętrznej <xref:System.Collections.IList> reprezentujący kolekcji.  
  
 <xref:System.Windows.Data.CollectionView.SetCurrent%2A> wprowadzono w programie .NET Framework w wersji 3.5.  Aby uzyskać więcej informacji, zobacz [wersje i zależności](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SortDescriptions">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.SortDescriptionCollection SortDescriptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.SortDescriptionCollection SortDescriptions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.SortDescriptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SortDescriptions As SortDescriptionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::SortDescriptionCollection ^ SortDescriptions { System::ComponentModel::SortDescriptionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.SortDescriptionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję <see cref="T:System.ComponentModel.SortDescription" /> struktur, które opisano w sposób sortowania elementów w kolekcji w widoku.</summary>
        <value>Pusta <see cref="T:System.ComponentModel.SortDescriptionCollection" /> we wszystkich przypadkach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można dodać <xref:System.ComponentModel.SortDescription> do zwrócony (pusta) kolekcja ponieważ klasa podstawowa <xref:System.Windows.Data.CollectionView> nie obsługuje sortowania. Zamiast tego należy użyć klasy pochodne <xref:System.Windows.Data.ListCollectionView> i <xref:System.Windows.Data.BindingListCollectionView> który obsługuje sortowanie. Sprawdź również, <xref:System.Windows.Data.CollectionView.CanSort%2A> właściwość przed dodaniem lub usunięciem <xref:System.ComponentModel.SortDescription> obiektów, aby uniknąć Wystąpił wyjątek.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionViewSource.SortDescriptions" />
      </Docs>
    </Member>
    <Member MemberName="SourceCollection">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerable SourceCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerable SourceCollection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.SourceCollection" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SourceCollection As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IEnumerable ^ SourceCollection { System::Collections::IEnumerable ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca kolekcję niefiltrowane podstawowej.</summary>
        <value>
          <see cref="T:System.Collections.IEnumerable" /> Obiekt, który jest odpowiednia kolekcja.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Collections.IEnumerator" /> obiektów, której można wyliczyć elementów w widoku.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> Obiektów można wyliczyć elementów w widoku.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdatedOutsideDispatcher">
      <MemberSignature Language="C#" Value="protected bool UpdatedOutsideDispatcher { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UpdatedOutsideDispatcher" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.UpdatedOutsideDispatcher" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property UpdatedOutsideDispatcher As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool UpdatedOutsideDispatcher { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy został on niezbędne do aktualizacji dziennik zmian, ponieważ <see cref="E:System.Windows.Data.CollectionView.CollectionChanged" /> Otrzymano powiadomienie w innym wątku po wprowadzeniu [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] Wątek dyspozytora.</summary>
        <value>
          <see langword="true" /> Jeśli było konieczne zaktualizowanie dziennik zmian, ponieważ <see cref="E:System.Windows.Data.CollectionView.CollectionChanged" /> Otrzymano powiadomienie w innym wątku po wprowadzeniu [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] Wątek dyspozytora; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Data.CollectionView.OnBeginChangeLogging(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      </Docs>
    </Member>
  </Members>
</Type>
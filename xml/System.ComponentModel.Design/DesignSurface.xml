<Type Name="DesignSurface" FullName="System.ComponentModel.Design.DesignSurface">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b9043a02e4ef99359f1cf161142f09f0e89e203d" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36707605" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DesignSurface : IDisposable, IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DesignSurface extends System.Object implements class System.IDisposable, class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.Design.DesignSurface" />
  <TypeSignature Language="VB.NET" Value="Public Class DesignSurface&#xA;Implements IDisposable, IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class DesignSurface : IDisposable, IServiceProvider" />
  <TypeSignature Language="F#" Value="type DesignSurface = class&#xA;    interface IDisposable&#xA;    interface IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Design</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Przedstawia informacje dotyczące projektowania składników interfejsu użytkownika.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.DesignSurface> Klasa implementuje użytkownik przewiduje Projektant. <xref:System.ComponentModel.Design.DesignSurface> to interfejs użytkownika manipuluje zmienić funkcje czasu projektowania. <xref:System.ComponentModel.Design.DesignSurface> udostępnia całkowicie niezależna powierzchnię.  
  
 <xref:System.ComponentModel.Design.DesignSurface> Klasy może być używany jako autonomiczny projektanta, lub mogą być połączone z <xref:System.ComponentModel.Design.DesignSurfaceManager> klasy do implementacji wspólne dla aplikacji, która obsługuje wiele <xref:System.ComponentModel.Design.DesignSurface> obiektów.  
  
 <xref:System.ComponentModel.Design.DesignSurface> Klasa może być używana samodzielnie, lub użytkownik może dziedziczyć po nim nową klasę i rozszerzyć zachowanie.  
  
 <xref:System.ComponentModel.Design.DesignSurface> Klasy automatycznie zapewnia kilka usług czasu projektowania. <xref:System.ComponentModel.Design.DesignSurface> Klasa dodaje wszystkie jego usług w jego konstruktora. Większość usług może być zastąpiona przez zastąpienie ich w chronionej <xref:System.ComponentModel.Design.DesignSurface.ServiceContainer%2A> właściwości. Aby zastąpić usługi, zastąpienie konstruktora wywołać podstawową i wprowadzać żadnych zmian do chronionej <xref:System.ComponentModel.Design.DesignSurface.ServiceContainer%2A> właściwości. Wszystkie usługi, które są dodawane do kontenera usług i implementują <xref:System.IDisposable> są usuwane po usunięciu powierzchnię projektu. Domyślny zbiór replaceable usług <xref:System.ComponentModel.Design.DesignSurface> klasa udostępnia przedstawiono w poniższej tabeli.  
  
|Usługa|Opis|  
|-------------|-----------------|  
|<xref:System.ComponentModel.Design.IExtenderProviderService>|Umożliwia obiektów, które nie są częścią kolekcji składników kontenera zapewnienie dostawców rozszerzeń.|  
|<xref:System.ComponentModel.Design.IExtenderListService>|Używane przez <xref:System.ComponentModel.TypeDescriptor> w celu uzyskania listy dostawców rozszerzeń. Z tą usługą rozszerzający dostawców można na żywo poza kontenera.|  
|<xref:System.ComponentModel.Design.ITypeDescriptorFilterService>|Udostępnia punkty zaczepienia projektanta metadanych. Jest to podstawowy interfejs do filtrowania metadanych.|  
|<xref:System.ComponentModel.Design.ISelectionService>|Zapewnia sposób, aby wybrać składniki w projektancie.|  
|<xref:System.ComponentModel.Design.IReferenceService>|Zapewnia sposób uzyskać nazwę dla obiektów, nawet wtedy, gdy te obiekty nie jest ulokowany.|  
|<xref:System.ComponentModel.Design.DesignSurface>|Oferuje powierzchni projektu jako usługa.|  
|<xref:System.ComponentModel.Design.DesignerOptionService>|Udostępnia klasę podstawową dla pobieranie i ustawianie wartości opcji dla projektanta.|  
  
 W poniższej tabeli przedstawiono niewymienne usług świadczonych przez domyślny.  
  
|Usługa|Opis|  
|-------------|-----------------|  
|<xref:System.ComponentModel.Design.IComponentChangeService>|Informuje o zdarzeniach zmiany do składników.|  
|<xref:System.ComponentModel.Design.IDesignerHost>|Służy do sterowania dostępem do typów, usług i transakcji. Główny interfejs dla projektantów.|  
|<xref:System.ComponentModel.IContainer>|Właścicielem zestaw składników, które projektowania. Każdy Konstruktor ma <xref:System.ComponentModel.IContainer> , który jest właścicielem składników.|  
|<xref:System.ComponentModel.Design.IServiceContainer>|Pochodną <xref:System.IServiceProvider> i służy do dodawania i usuwania usług przy użyciu projektanta.|  
  
 Oprócz tych usług <xref:System.ComponentModel.Design.DesignSurface> klasa udostępnia także jeden usługa, która jest dostępna za pośrednictwem witryny składnika. Ta usługa jest unikatowy dla każdego składnika. W poniższej tabeli przedstawiono usługi, których nie można zastąpić.  
  
|Usługa|Opis|  
|-------------|-----------------|  
|<xref:System.ComponentModel.Design.IDictionaryService>|Ogólny słownik pary klucz wartość, które mogą służyć do przechowywania danych dowolnego dotyczących składnika.|  
|<xref:System.ComponentModel.INestedContainer>|Kontener, który włącza składnik, aby dodać kolejne podrzędne składniki do projektanta. Te składniki będzie częścią powierzchnię projektu, ale nie będzie uczestniczyć w serializacji. Jest to przydatne w przypadku projektowania formant, który jest w stanie udostępnianie region siebie samego za pomocą projektanta, ale nie ma obszaru do udziału w serializacji.|  
  
 Oprócz <xref:System.ComponentModel.ISite>, lokacji implementuje również następujące interfejsy.  
  
> [!CAUTION]
>  Sprawdzaj istnienie tych interfejsów, zamiast używać niekontrolowane rzutowanie, ponieważ inne implementacje lokacji nie może ich wdrażania.  
  
|Usługa|Opis|  
|-------------|-----------------|  
|<xref:System.ComponentModel.Design.IServiceContainer>|Umożliwia uzyskanie dostępu do kontenera usług specyficzne dla lokacji. Na przykład <xref:System.ComponentModel.Design.IDictionaryService> jest usługą specyficzne dla lokacji. Z tą usługą możesz dodać dodatkowe usługi specyficzne dla lokacji.|  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.NamedPermissionSet">Aby uzyskać dostęp do zasobów systemowych. Żądanie wartości: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />, <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Skojarzony stan:</permission>
    <altmember cref="T:System.ComponentModel.Design.IDesignerHost" />
    <altmember cref="T:System.IServiceProvider" />
    <altmember cref="T:System.ComponentModel.Design.Serialization.DesignerLoader" />
    <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerLoaderService" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.Design.DesignSurface" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignSurface ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignSurface();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.Design.DesignSurface" /> klasy.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączony do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignSurface (IServiceProvider parentProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IServiceProvider parentProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.#ctor(System.IServiceProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parentProvider As IServiceProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignSurface(IServiceProvider ^ parentProvider);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.Design.DesignSurface : IServiceProvider -&gt; System.ComponentModel.Design.DesignSurface" Usage="new System.ComponentModel.Design.DesignSurface parentProvider" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parentProvider" Type="System.IServiceProvider" />
      </Parameters>
      <Docs>
        <param name="parentProvider">Nadrzędny dostawca usługi lub <see langword="null" /> Jeśli jest używany do rozpoznawania usług elementu nadrzędnego.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.Design.DesignSurface" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy `parentProvide` jest obecny, projektantów zawartych w powierzchni można pobrać usług z aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączony do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignSurface (Type rootComponentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type rootComponentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rootComponentType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignSurface(Type ^ rootComponentType);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.Design.DesignSurface : Type -&gt; System.ComponentModel.Design.DesignSurface" Usage="new System.ComponentModel.Design.DesignSurface rootComponentType" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rootComponentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="rootComponentType">Typ główny składnika do utworzenia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.Design.DesignSurface" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz <xref:System.ComponentModel.Design.DesignSurface.%23ctor%2A> konstruktora, tworzy prosty program ładujący projektanta, który z kolei tworzy składnik danego typu, a następnie kończy proces ładowania. To łatwe tworzenie projektanta, przy założeniu, że wszystkie zapisywania stanu zostanie to zrobione zewnętrznie. Wewnętrznie wywołuje <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> i przekazuje typ składnika głównego.  
  
> [!NOTE]
>  <xref:System.ComponentModel.Design.DesignSurface.%23ctor%2A> Przeciążenia nie ma wpływu na <xref:System.Windows.Forms.Design.DesignerOptions>. <xref:System.Windows.Forms.Design.DesignerOptions> Musi być w kontenerze usługi przed ładuje powierzchnię projektu. Jeśli potrzebujesz dostępu do <xref:System.Windows.Forms.Design.DesignerOptions>, Wywołaj pustego konstruktora, Dodaj <xref:System.Windows.Forms.Design.DesignerOptions> do <xref:System.ComponentModel.Design.DesignSurface.ServiceContainer%2A> i Wywołaj <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> z `rootComponentType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rootComponent" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączony do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignSurface (IServiceProvider parentProvider, Type rootComponentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IServiceProvider parentProvider, class System.Type rootComponentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.#ctor(System.IServiceProvider,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parentProvider As IServiceProvider, rootComponentType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignSurface(IServiceProvider ^ parentProvider, Type ^ rootComponentType);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.Design.DesignSurface : IServiceProvider * Type -&gt; System.ComponentModel.Design.DesignSurface" Usage="new System.ComponentModel.Design.DesignSurface (parentProvider, rootComponentType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parentProvider" Type="System.IServiceProvider" />
        <Parameter Name="rootComponentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="parentProvider">Nadrzędny dostawca usługi lub <see langword="null" /> Jeśli jest używany do rozpoznawania usług elementu nadrzędnego.</param>
        <param name="rootComponentType">Typ główny składnika do utworzenia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.Design.DesignSurface" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przy użyciu <xref:System.ComponentModel.Design.DesignSurface.%23ctor%2A> Konstruktor tworzy prosty ładujący projektanta, który tworzy składnik danego typu, a następnie kończy proces ładowania. To łatwe tworzenie projektanta, przy założeniu, że wszystkie zapisywania stanu zostanie to zrobione zewnętrznie. Wewnętrznie wywołuje <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> i przekazuje typ składnika głównego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rootComponent" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączony do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginLoad">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpocznie się proces ładowania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public void BeginLoad (System.ComponentModel.Design.Serialization.DesignerLoader loader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoad(class System.ComponentModel.Design.Serialization.DesignerLoader loader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.BeginLoad(System.ComponentModel.Design.Serialization.DesignerLoader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoad (loader As DesignerLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoad(System::ComponentModel::Design::Serialization::DesignerLoader ^ loader);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : System.ComponentModel.Design.Serialization.DesignerLoader -&gt; unit" Usage="designSurface.BeginLoad loader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loader" Type="System.ComponentModel.Design.Serialization.DesignerLoader" />
      </Parameters>
      <Docs>
        <param name="loader">Program ładujący projektanta do użycia podczas ładowania projektanta.</param>
        <summary>Rozpocznie się proces ładowania z danym moduł ładowania projektanta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas ładowania projektanta można asynchroniczne, więc obciążenie może w dalszym ciągu postępu po zwrócił to wywołanie. Program obsługi zdarzeń, aby dołączyć <xref:System.ComponentModel.Design.IDesignerHost.LoadComplete> zdarzenie zgłaszane po zakończeniu ładowania powierzchnię projektu.  
  
 Po <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> jest wywoływana, można natychmiast uzyskać widok tego projektanta, ponieważ ładowarki projektanta musisz podać co najmniej składnik główny podczas ładowania asynchronicznie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="loader" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączony do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
        <altmember cref="T:System.ComponentModel.Design.Serialization.DesignerLoader" />
        <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerLoaderService" />
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public void BeginLoad (Type rootComponentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoad(class System.Type rootComponentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.BeginLoad(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoad (rootComponentType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoad(Type ^ rootComponentType);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : Type -&gt; unit" Usage="designSurface.BeginLoad rootComponentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootComponentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="rootComponentType">Typ składnika do utworzenia w trybie projektowania.</param>
        <summary>Rozpocznie się proces ładowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy `rootComponentType` jest określony, domyślne ładujący projektanta, która po prostu tworzy wystąpienie `rootComponentType` będą używane. Podczas ładowania projektanta można asynchroniczne, więc obciążenie może w dalszym ciągu postępu po zwrócił to wywołanie. Program obsługi zdarzeń, aby dołączyć <xref:System.ComponentModel.Design.IDesignerHost.LoadComplete> zdarzenie zgłaszane po zakończeniu ładowania powierzchnię projektu.  
  
 Po <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> jest wywoływana, można natychmiast uzyskać widok tego projektanta, ponieważ ładowarki projektanta musisz podać co najmniej składnik główny podczas ładowania asynchronicznie.  
  
> [!NOTE]
>  <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> Metoda tworzy wystąpienie podanego typu składnika i inicjuje projektanta dla tego wystąpienia. <xref:System.ComponentModel.Design.DesignSurface.Loaded> Zdarzenie jest wywoływane przed ta metoda zwraca wartość.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rootComponentType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączony do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ComponentContainer">
      <MemberSignature Language="C#" Value="public System.ComponentModel.IContainer ComponentContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.IContainer ComponentContainer" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.ComponentContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ComponentContainer As IContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::IContainer ^ ComponentContainer { System::ComponentModel::IContainer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ComponentContainer : System.ComponentModel.IContainer" Usage="System.ComponentModel.Design.DesignSurface.ComponentContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.ComponentModel.IContainer" /> implementacji w powierzchnię projektu.</summary>
        <value>
          <see cref="T:System.ComponentModel.IContainer" /> Implementacji w powierzchnię projektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.DesignSurface.ComponentContainer%2A> Właściwość przechowuje wszystkie obiekty, które są obecnie w trybie projektowania. Gdy składniki są dodawane do <xref:System.ComponentModel.Design.DesignSurface.ComponentContainer%2A>, ich projektanta, jeśli istnieje, jest załadowany. Składnik jest ulokowany z lokacją, która zapewnia pełny dostęp do powierzchni projektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączony do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateComponent">
      <MemberSignature Language="C#" Value="protected internal virtual System.ComponentModel.IComponent CreateComponent (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.ComponentModel.IComponent CreateComponent(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateComponent(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateComponent (componentType As Type) As IComponent" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::ComponentModel::IComponent ^ CreateComponent(Type ^ componentType);" />
      <MemberSignature Language="F#" Value="abstract member CreateComponent : Type -&gt; System.ComponentModel.IComponent&#xA;override this.CreateComponent : Type -&gt; System.ComponentModel.IComponent" Usage="designSurface.CreateComponent componentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("CreateComponent has been replaced by CreateInstance and will be removed after Beta2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IComponent</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">Typ składnika do utworzenia.</param>
        <summary>Tworzy wystąpienie składnika.</summary>
        <returns>Nowo utworzony składnik.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.DesignSurface.CreateComponent%2A> Metoda jest wywoływana przez powierzchnię projektu <xref:System.ComponentModel.Design.IDesignerHost.CreateComponent%2A> metodę w celu utworzenia wystąpienia składnika. Składnika należy utworzyć i dodać do publicznego kontenera na powierzchni projektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="componentType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączony do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateDesigner">
      <MemberSignature Language="C#" Value="protected internal virtual System.ComponentModel.Design.IDesigner CreateDesigner (System.ComponentModel.IComponent component, bool rootDesigner);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.ComponentModel.Design.IDesigner CreateDesigner(class System.ComponentModel.IComponent component, bool rootDesigner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateDesigner(System.ComponentModel.IComponent,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateDesigner (component As IComponent, rootDesigner As Boolean) As IDesigner" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::ComponentModel::Design::IDesigner ^ CreateDesigner(System::ComponentModel::IComponent ^ component, bool rootDesigner);" />
      <MemberSignature Language="F#" Value="abstract member CreateDesigner : System.ComponentModel.IComponent * bool -&gt; System.ComponentModel.Design.IDesigner&#xA;override this.CreateDesigner : System.ComponentModel.IComponent * bool -&gt; System.ComponentModel.Design.IDesigner" Usage="designSurface.CreateDesigner (component, rootDesigner)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.IDesigner</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.ComponentModel.IComponent" />
        <Parameter Name="rootDesigner" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Składnik, dla którego należy utworzyć designer.</param>
        <param name="rootDesigner">
          <see langword="true" /> Aby utworzyć designer głównego; <see langword="false" /> utworzyć designer normalnego.</param>
        <summary>Tworzy projektanta, gdy składnik zostanie dodany do kontenera.</summary>
        <returns>Wystąpienia żądanego projektanta lub <see langword="null" /> Jeśli nie odnaleziono zgodnego projektanta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.DesignSurface.CreateDesigner%2A> Metoda jest wywoływana przez powierzchnię projektu <xref:System.ComponentModel.IContainer> po dodaniu składnika do kontenera. Ta metoda tworzy projektanta, ale nie zainicjowany. Gdy powróci ona projektanta został zainicjowany przez kontener.  
  
 <xref:System.ComponentModel.Design.DesignSurface.CreateDesigner%2A> można utworzyć dwa rodzaje projektantów: główny projektantów i normalnym projektantów. Projektant główny jest projektanta dla składnika głównego na powierzchni projektu, który zgodnie z definicją jest pierwszym składnikiem dodać do kontenera. Projektanci głównego różnią się od normalnego projektantów, ponieważ są właściwe dla interfejsu użytkownika podane dla użytkownika końcowego. Projektanci głównego zwykle koordynować z resztą projektantów na powierzchni projektowej zapewnienie tego interfejsu.  
  
 Domyślna implementacja tej metody deleguje do <xref:System.ComponentModel.TypeDescriptor>, przekazując <xref:System.ComponentModel.Design.IRootDesigner> jako typ projektanta dla projektantów głównego lub <xref:System.ComponentModel.Design.IDesigner> dla projektantów normalnego. Można zastąpić tę metodę w celu żądania dla określonego typu projektanta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączony do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected internal virtual object CreateInstance (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object CreateInstance(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateInstance(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ CreateInstance(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : Type -&gt; obj&#xA;override this.CreateInstance : Type -&gt; obj" Usage="designSurface.CreateInstance type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Typ do utworzenia.</param>
        <summary>Tworzy wystąpienie podanego typu.</summary>
        <returns>Nowo utworzony obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `type` jest <xref:System.ComponentModel.IComponent>, <xref:System.ComponentModel.Design.DesignSurface.CreateInstance%2A> wyszukuje konstruktora typu <xref:System.ComponentModel.IContainer> po pustego konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączony do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNestedContainer">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy kontener przeznaczony do zagnieżdżenia kontrolek i składników.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNestedContainer">
      <MemberSignature Language="C#" Value="public System.ComponentModel.INestedContainer CreateNestedContainer (System.ComponentModel.IComponent owningComponent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.INestedContainer CreateNestedContainer(class System.ComponentModel.IComponent owningComponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateNestedContainer(System.ComponentModel.IComponent)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateNestedContainer (owningComponent As IComponent) As INestedContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::INestedContainer ^ CreateNestedContainer(System::ComponentModel::IComponent ^ owningComponent);" />
      <MemberSignature Language="F#" Value="member this.CreateNestedContainer : System.ComponentModel.IComponent -&gt; System.ComponentModel.INestedContainer" Usage="designSurface.CreateNestedContainer owningComponent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.INestedContainer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owningComponent" Type="System.ComponentModel.IComponent" />
      </Parameters>
      <Docs>
        <param name="owningComponent">Składnik, który zarządza zagnieżdżonych kontenera.</param>
        <summary>Tworzy kontener przeznaczony do zagnieżdżenia kontrolek i składników.</summary>
        <returns>Kontener zagnieżdżonych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dodanie składnika do kontenera zagnieżdżonych tworzy jego projektanta i udostępnia go kwalifikuje się do wszystkich usług z powierzchni projektu. Składniki dodane do zagnieżdżone kontenery nie uczestniczą w serializacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="owningComponent" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączony do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNestedContainer">
      <MemberSignature Language="C#" Value="public System.ComponentModel.INestedContainer CreateNestedContainer (System.ComponentModel.IComponent owningComponent, string containerName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.INestedContainer CreateNestedContainer(class System.ComponentModel.IComponent owningComponent, string containerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateNestedContainer(System.ComponentModel.IComponent,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateNestedContainer (owningComponent As IComponent, containerName As String) As INestedContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::INestedContainer ^ CreateNestedContainer(System::ComponentModel::IComponent ^ owningComponent, System::String ^ containerName);" />
      <MemberSignature Language="F#" Value="member this.CreateNestedContainer : System.ComponentModel.IComponent * string -&gt; System.ComponentModel.INestedContainer" Usage="designSurface.CreateNestedContainer (owningComponent, containerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.INestedContainer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owningComponent" Type="System.ComponentModel.IComponent" />
        <Parameter Name="containerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="owningComponent">Składnik, który zarządza zagnieżdżonych kontenera.</param>
        <param name="containerName">Dodatkowe nazwę kontenera zagnieżdżonych.</param>
        <summary>Tworzy kontener przeznaczony do zagnieżdżenia kontrolek i składników.</summary>
        <returns>Kontener zagnieżdżonych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dodanie składnika do kontenera zagnieżdżonych tworzy jego projektanta i udostępnia go kwalifikuje się do wszystkich usług z powierzchni projektu. Składniki dodane do zagnieżdżone kontenery nie uczestniczą w serializacji.  
  
 Zapewniają dodatkową nazwę <xref:System.ComponentModel.Design.DesignSurface.CreateNestedContainer%2A> metody przez przekazanie wartości do `containerName`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="owningComponent" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączony do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="designSurface.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Publicznego <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> metoda zgodna standardowego <xref:System.IDisposable> wzorca. Wywołanie tej metody niszczy powierzchnię projektu. Chroniona wersja ta metoda jest `virtual` i jest zgodna z normalnym <xref:System.IDisposable> wzorca.  
  
> [!NOTE]
>  Ponieważ <xref:System.ComponentModel.Design.DesignSurface> nie ma żadnych kodu natywnego, aby wyczyścić, nie ma finalizator tego wywołania <xref:System.ComponentModel.Design.DesignSurface.Dispose%28System.Boolean%29>. Jeśli należy wywołać <xref:System.ComponentModel.Design.DesignSurface.Dispose%28System.Boolean%29>, możesz finalizator należy dodać.  
  
 Wywołanie <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> po zakończeniu przy użyciu <xref:System.ComponentModel.Design.DesignSurface>. <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> Pozostawia metody <xref:System.ComponentModel.Design.DesignSurface> w stanie uniemożliwiającym jego używanie. Po wywołaniu <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A>, konieczne jest zwolnienie wszystkich odwołań do <xref:System.ComponentModel.Design.DesignSurface> , moduł zbierający elementy bezużyteczne mógł odzyskać pamięć który <xref:System.ComponentModel.Design.DesignSurface> klasy. Aby uzyskać więcej informacji, zobacz [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [implementacja metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Wywoływanie zawsze <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> przed zwolnieniem ostatniego odwołania do <xref:System.ComponentModel.Design.DesignSurface>. W przeciwnym razie używa zasobów nie zostanie zwolniona do wywołania modułu zbierającego elementy bezużyteczne <xref:System.ComponentModel.Design.DesignSurface> obiektu `Finalize` metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="designSurface.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Publicznego <xref:System.ComponentModel.Design.DesignSurface.Dispose> metoda zgodna standardowego <xref:System.IDisposable> wzorca. Wywołanie tej metody niszczy powierzchnię projektu. Chroniona wersja ta metoda jest `virtual` i jest zgodna z normalnym <xref:System.IDisposable> wzorca.  
  
> [!NOTE]
>  Ponieważ <xref:System.ComponentModel.Design.DesignSurface> nie ma żadnych kodu natywnego, aby wyczyścić, nie ma finalizator tego wywołania <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A>. Jeśli należy wywołać <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A>, możesz finalizator należy dodać.  
  
 Ta metoda jest wywoływana przez metodę publiczną `Dispose()` — metoda i <xref:System.Object.Finalize%2A> metody. `Dispose()` wywołuje chronioną metodę `Dispose(Boolean)` metody z `disposing` ustawiono parametr `true`. <xref:System.Object.Finalize%2A> wywołuje `Dispose` z `disposing` ustawioną `false`.  
  
 Gdy `disposing` parametr ma wartość true, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.ComponentModel.Design.DesignSurface> odwołania. Ta metoda wywołuje `Dispose()` metody każdego odwołuje się do obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> można wywoływać wielokrotnie przez inne obiekty. W przypadku przesłaniania <see langword="Dispose(Boolean)" /> należy uważać, aby nie odwołują się obiekty, które zostały wcześniej zlikwidowane w wywołaniu wcześniejszych <see langword="Dispose" />. Aby uzyskać więcej informacji na temat sposobu wdrażania <see langword="Dispose(Boolean)" />, zobacz [implementacja Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.  Aby uzyskać więcej informacji na temat <see langword="Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [czyszczenia Resources](~/docs/standard/garbage-collection/unmanaged.md) niezarządzane i [zastąpienie metody Finalize] (http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Disposed">
      <MemberSignature Language="C#" Value="public event EventHandler Disposed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Disposed" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Disposed" />
      <MemberSignature Language="VB.NET" Value="Public Event Disposed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Disposed;" />
      <MemberSignature Language="F#" Value="member this.Disposed : EventHandler " Usage="member this.Disposed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po usunięciu powierzchnię projektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar jest tylko usunięte, gdy publicznego <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> metoda <xref:System.ComponentModel.Design.DesignSurface> jest wywoływana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DtelLoading">
      <MemberSignature Language="C#" Value="public bool DtelLoading { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DtelLoading" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.DtelLoading" />
      <MemberSignature Language="VB.NET" Value="Public Property DtelLoading As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DtelLoading { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DtelLoading : bool with get, set" Usage="System.ComponentModel.Design.DesignSurface.DtelLoading" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy ** czasu projektowania błąd listy ** ładowania.</summary>
        <value>
          <see langword="true" /> Jeśli ** czasu projektowania błąd listy ** ładuje; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="designSurface.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Serializuje zmiany na powierzchnię projektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.DesignSurface.Flush%2A> Można wywołać metody, aby wypchnąć zmiany wprowadzone na powierzchnię projektu do serializatora. Dzięki temu zsynchronizowane powierzchni projektowej oraz jego Zserializowany stan. Rzeczywista implementacja tej metody jest przekazywany do modułu ładującego projektanta skojarzone z powierzchni projektu. Program ładujący projektanta zrezygnować odroczenie zmiany do <xref:System.ComponentModel.Design.DesignSurface.Flush%2A> jest wywoływana lub może być aktualne dane serializowane z wszystkie zmiany wprowadzane przez użytkownika. <xref:System.ComponentModel.Design.DesignSurface.Flush%2A> Metoda gwarantuje, że niezależnie od tego modelu Moduł ładowania projektanta zdecydował się użyć, Zserializowany stan jest zsynchronizowany z rzeczywistego powierzchnię.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flushed">
      <MemberSignature Language="C#" Value="public event EventHandler Flushed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Flushed" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Flushed" />
      <MemberSignature Language="VB.NET" Value="Public Event Flushed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Flushed;" />
      <MemberSignature Language="F#" Value="member this.Flushed : EventHandler " Usage="member this.Flushed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy połączenie jest nawiązywane w przypadku <see cref="M:System.ComponentModel.Design.DesignSurface.Flush" /> metody <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Program ładujący projektanta jest opróżniany najpierw, a następnie <xref:System.ComponentModel.Design.DesignSurface.Flushed> zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetService">
      <MemberSignature Language="C#" Value="public object GetService (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetService(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetService (serviceType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetService(Type ^ serviceType);" />
      <MemberSignature Language="F#" Value="abstract member GetService : Type -&gt; obj&#xA;override this.GetService : Type -&gt; obj" Usage="designSurface.GetService serviceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType">Typ usługi do pobrania.</param>
        <summary>Pobiera usługę z kontenera usług.</summary>
        <returns>Obiekt, który implementuje lub jest w klasie pochodnej, <paramref name="serviceType" />, lub <see langword="null" /> Jeśli usługa nie istnieje w kontenerze usług.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.DesignSurface.GetService%2A> Metoda pobiera usługę kontenera usług powierzchnię projektu. Ponadto to przesyła do dowolnego dostawcy usług, który podano na powierzchnię projektu podczas konstruowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.ComponentModel.Design.DesignSurface.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy powierzchnię projektu jest aktualnie załadowany.</summary>
        <value>
          <see langword="true" /> Jeśli powierzchnię projektu jest aktualnie załadowany; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.Design.LoadedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.Design.LoadedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Event Loaded As LoadedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::Design::LoadedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.ComponentModel.Design.LoadedEventHandler " Usage="member this.Loaded : System.ComponentModel.Design.LoadedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.LoadedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zakończeniu ładowania projektanta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.DesignSurface.Loaded> Zdarzenie jest wywoływane dla obciążeń powiodło się, jak również nieudanymi. Jeśli kod w tej obsłudze zdarzeń zgłasza wyjątek, Projektant nie jest załadowany.  
  
 <xref:System.ComponentModel.Design.LoadedEventArgs> Obiekt może służyć do określenia, czy ładowanie zakończyło się pomyślnie, a można też podać listę błędów, które wystąpiły podczas ładowania.  
  
> [!NOTE]
>  W przypadku obciążeń powiodło się również, mogą wystąpić błędy, pod warunkiem, że system serializacji może tolerować błędy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadErrors">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection LoadErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection LoadErrors" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.LoadErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LoadErrors As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ LoadErrors { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LoadErrors : System.Collections.ICollection" Usage="System.ComponentModel.Design.DesignSurface.LoadErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca kolekcję ładowania błędy lub void kolekcji.</summary>
        <value>A <see cref="T:System.Collections.ICollection" /> błędy ładowania.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loading">
      <MemberSignature Language="C#" Value="public event EventHandler Loading;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Loading" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Loading" />
      <MemberSignature Language="VB.NET" Value="Public Event Loading As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Loading;" />
      <MemberSignature Language="F#" Value="member this.Loading : EventHandler " Usage="member this.Loading : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy projektant ma być załadowany.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLoaded">
      <MemberSignature Language="C#" Value="protected virtual void OnLoaded (System.ComponentModel.Design.LoadedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoaded(class System.ComponentModel.Design.LoadedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnLoaded(System.ComponentModel.Design.LoadedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoaded (e As LoadedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoaded(System::ComponentModel::Design::LoadedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoaded : System.ComponentModel.Design.LoadedEventArgs -&gt; unit&#xA;override this.OnLoaded : System.ComponentModel.Design.LoadedEventArgs -&gt; unit" Usage="designSurface.OnLoaded e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.Design.LoadedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.ComponentModel.Design.LoadedEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.ComponentModel.Design.DesignSurface.Loaded" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLoading">
      <MemberSignature Language="C#" Value="protected virtual void OnLoading (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoading(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnLoading(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoading (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoading(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoading : EventArgs -&gt; unit&#xA;override this.OnLoading : EventArgs -&gt; unit" Usage="designSurface.OnLoading e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.ComponentModel.Design.DesignSurface.Loading" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUnloaded">
      <MemberSignature Language="C#" Value="protected virtual void OnUnloaded (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnUnloaded(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnUnloaded(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnUnloaded (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnUnloaded(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnloaded : EventArgs -&gt; unit&#xA;override this.OnUnloaded : EventArgs -&gt; unit" Usage="designSurface.OnUnloaded e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.ComponentModel.Design.DesignSurface.Unloaded" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUnloading">
      <MemberSignature Language="C#" Value="protected virtual void OnUnloading (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnUnloading(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnUnloading(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnUnloading (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnUnloading(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnloading : EventArgs -&gt; unit&#xA;override this.OnUnloading : EventArgs -&gt; unit" Usage="designSurface.OnUnloading e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.ComponentModel.Design.DesignSurface.Unloading" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnViewActivate">
      <MemberSignature Language="C#" Value="protected virtual void OnViewActivate (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnViewActivate(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnViewActivate(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnViewActivate (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnViewActivate(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnViewActivate : EventArgs -&gt; unit&#xA;override this.OnViewActivate : EventArgs -&gt; unit" Usage="designSurface.OnViewActivate e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.ComponentModel.Design.DesignSurface.ViewActivated" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceContainer">
      <MemberSignature Language="C#" Value="protected System.ComponentModel.Design.ServiceContainer ServiceContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.Design.ServiceContainer ServiceContainer" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.ServiceContainer" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceContainer As ServiceContainer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::ComponentModel::Design::ServiceContainer ^ ServiceContainer { System::ComponentModel::Design::ServiceContainer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServiceContainer : System.ComponentModel.Design.ServiceContainer" Usage="System.ComponentModel.Design.DesignSurface.ServiceContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.ServiceContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kontener usług.</summary>
        <value>Kontener usługi, który zawiera wszystkie usługi konstruktorom zawartych w powierzchnię projektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas konstruowania <xref:System.ComponentModel.Design.DesignSurface> dodaje usług domyślnych w tym kontenerze usług. Usługi domyślne można pozostawić w jego obecnym stanie lub można je usunąć i je zastąpić własnymi. Usługi domyślne są wszystkie żądanie utworzone, więc nie ma żadnego spadku wydajności dodanie ich w chwili tworzenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączony do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event EventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Event Unloaded As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : EventHandler " Usage="member this.Unloaded : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy projektant zakończył zwalnianie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unloading">
      <MemberSignature Language="C#" Value="public event EventHandler Unloading;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Unloading" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Unloading" />
      <MemberSignature Language="VB.NET" Value="Public Event Unloading As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Unloading;" />
      <MemberSignature Language="F#" Value="member this.Unloading : EventHandler " Usage="member this.Unloading : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy ma zwolnić projektanta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy zwalnia projektanta, zostanie zniszczony całego stanu dla tego projektanta, w tym widoku projektanta. Widok powinien być bez elementów nadrzędnych w tym momencie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="View">
      <MemberSignature Language="C#" Value="public object View { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object View" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.View" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property View As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ View { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.View : obj" Usage="System.ComponentModel.Design.DesignSurface.View" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera Widok projektanta głównego.</summary>
        <value>Widok projektanta głównego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> Metoda musi zostać wywołana uprzednio, aby rozpocząć proces ładowania. Istnieje możliwość zwrócić widok przed zakończeniem moduł ładowania projektanta podczas ładowania projektanta głównego, który dostarcza widoku, ponieważ pierwszy obiekt utworzony przez program ładujący projektanta. Jeśli widok jest niedostępny, <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> zgłasza wyjątek.  
  
 Podstawowe pojęcie w zakresie technologii widoku jest przestarzała. Jednak pozostaje w interfejsach dla projektantów głównego dla zgodności z poprzednimi wersjami. Ich użycie jest niewidoczna dla wszystkich osób korzystających z <xref:System.ComponentModel.Design.DesignSurface> obiektów. <xref:System.ComponentModel.Design.DesignSurface.View%2A> Właściwość ukrywa technologii widoku przez przekazanie obsługiwanych technologiach do projektanta głównego.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład sposobu <xref:System.ComponentModel.Design.DesignSurface.View%2A> ukrywa wyświetlić technologii.  
  
 ```csharp 
 IRootDesigner d;  
  
 ViewTechnology[] supported = d.SupportedTechnologies;  
  
 return d.GetView(supported[0]);
 ``` 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powierzchni projektu nie jest ładowany, program ładujący projektanta nie utworzył jeszcze projektanta głównego lub obciążenia, ale nie zostało zakończone powierzchnię projektu. Więcej informacji może być dostępna w <see cref="P:System.Exception.InnerException" />.</exception>
        <exception cref="T:System.NotSupportedException">Załadowano projektanta, ale nie ma w nim widoku zgodnego z tą warstwą projektowania.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączony do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ViewActivated">
      <MemberSignature Language="C#" Value="public event EventHandler ViewActivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ViewActivated" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.ViewActivated" />
      <MemberSignature Language="VB.NET" Value="Public Event ViewActivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ViewActivated;" />
      <MemberSignature Language="F#" Value="member this.ViewActivated : EventHandler " Usage="member this.ViewActivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="M:System.ComponentModel.Design.IDesignerHost.Activate" /> wywołano metodę <see cref="T:System.ComponentModel.Design.IDesignerHost" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli chcesz obsługiwać <xref:System.ComponentModel.Design.IDesignerHost.Activate%2A> metody obsługi zdarzenia należy aktywować okna dla tej warstwy projektowania.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.Design.IDesignerHost" />
      </Docs>
    </Member>
  </Members>
</Type>
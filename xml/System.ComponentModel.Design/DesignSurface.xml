<Type Name="DesignSurface" FullName="System.ComponentModel.Design.DesignSurface">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d9ca903bb93ff2aee30155faf382ddc7247980c2" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55423033" /></Metadata><TypeSignature Language="C#" Value="public class DesignSurface : IDisposable, IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DesignSurface extends System.Object implements class System.IDisposable, class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.Design.DesignSurface" />
  <TypeSignature Language="VB.NET" Value="Public Class DesignSurface&#xA;Implements IDisposable, IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class DesignSurface : IDisposable, IServiceProvider" />
  <TypeSignature Language="F#" Value="type DesignSurface = class&#xA;    interface IDisposable&#xA;    interface IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Design</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Przedstawia informacje o projektowanie składników interfejsu użytkownika.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.DesignSurface> Klasa implementuje, co użytkownik uświadamia sobie, Projektant. <xref:System.ComponentModel.Design.DesignSurface> czy interfejs użytkownika, użytkownik manipuluje można zmienić funkcje czasu projektowania. <xref:System.ComponentModel.Design.DesignSurface> udostępnia powierzchni projektowej całkowicie niezależna.  
  
 <xref:System.ComponentModel.Design.DesignSurface> Klasy może być używany jako autonomiczny projektanta lub mogą być połączone z <xref:System.ComponentModel.Design.DesignSurfaceManager> Aby klasa zapewniała typową implementację dla aplikacji, która obsługuje wiele <xref:System.ComponentModel.Design.DesignSurface> obiektów.  
  
 <xref:System.ComponentModel.Design.DesignSurface> Klasa może być używana samodzielnie, lub użytkownik może dziedziczyć po nim nową klasę i rozszerzać to zachowanie.  
  
 <xref:System.ComponentModel.Design.DesignSurface> Klasa automatycznie udostępnia kilka usług pomocy technicznej czasu projektowania. <xref:System.ComponentModel.Design.DesignSurface> Klasa dodaje wszystkie swoje usługi w jego konstruktorze. Większość z tych usług może być zastąpiona przez zastąpienie ich w chronionym <xref:System.ComponentModel.Design.DesignSurface.ServiceContainer%2A> właściwości. Aby zastąpić to usługa, Zastąp konstruktora wywołać podstawowej i wprowadzać żadnych zmian, za pośrednictwem chronionego <xref:System.ComponentModel.Design.DesignSurface.ServiceContainer%2A> właściwości. Wszystkie usługi, które są dodawane do kontenera usługi i implementują <xref:System.IDisposable> są usuwane po usunięciu powierzchni projektowej. Domyślny zestaw wymienne usługi, których <xref:System.ComponentModel.Design.DesignSurface> udostępnia zostały przedstawione w poniższej tabeli.  
  
|Usługa|Opis|  
|-------------|-----------------|  
|<xref:System.ComponentModel.Design.IExtenderProviderService>|Umożliwia obiekty, które nie są częścią kolekcji składników kontenera, aby zapewnić ich własnego dostawcy rozszerzeń.|  
|<xref:System.ComponentModel.Design.IExtenderListService>|Używane przez <xref:System.ComponentModel.TypeDescriptor> można pobrać listy dostawcy rozszerzeń. Ta usługa dostawcy rozszerzeń mogą się znajdować poza kontenerem.|  
|<xref:System.ComponentModel.Design.ITypeDescriptorFilterService>|Udostępnia metadane projektanta punkty zaczepienia. Jest to podstawowy interfejs dla filtrowanie metadanych.|  
|<xref:System.ComponentModel.Design.ISelectionService>|Umożliwia wybór składników w projektancie.|  
|<xref:System.ComponentModel.Design.IReferenceService>|Zapewnia sposób Pobierz nazwy obiektów, nawet wtedy, gdy te obiekty nie są zlokalizowane.|  
|<xref:System.ComponentModel.Design.DesignSurface>|Oferuje powierzchni projektowej jako usługa.|  
|<xref:System.ComponentModel.Design.DesignerOptionService>|Udostępnia klasę bazową dla pobierania i ustawiania wartości opcji dla projektanta.|  
  
 W poniższej tabeli przedstawiono niewymienne usługi świadczone przez domyślny.  
  
|Usługa|Opis|  
|-------------|-----------------|  
|<xref:System.ComponentModel.Design.IComponentChangeService>|Wywołuje zdarzenia, zmiany do składników.|  
|<xref:System.ComponentModel.Design.IDesignerHost>|Służy do sterowania dostępem do typów, usług i transakcji. Główny interfejs dla projektantów.|  
|<xref:System.ComponentModel.IContainer>|Jest właścicielem zestaw składników, które zostały również tak zaprojektowane. Każdy projektancie <xref:System.ComponentModel.IContainer> , który jest właścicielem składników.|  
|<xref:System.ComponentModel.Design.IServiceContainer>|Pochodzi od klasy <xref:System.IServiceProvider> i służy do dodawania i usuwania usług przy użyciu projektanta.|  
  
 Oprócz tych usług <xref:System.ComponentModel.Design.DesignSurface> klasa udostępnia także jednej usługi, który jest dostępny za pośrednictwem witryny składnika. Ta usługa jest unikatowy dla każdego składnika. W poniższej tabeli przedstawiono usługi, które nie mogą zostać zastąpione.  
  
|Usługa|Opis|  
|-------------|-----------------|  
|<xref:System.ComponentModel.Design.IDictionaryService>|Generyczny słownik par klucz wartość, które mogą służyć do przechowywania dowolnego danych dotyczących składnika.|  
|<xref:System.ComponentModel.INestedContainer>|Kontener, który umożliwia składnikowi dodać składniki dodatkowe podrzędne do projektanta. Te składniki będzie częścią powierzchni projektowania, ale nie będzie uczestniczyć w serializacji. Jest to przydatne, gdy użytkownik chce zaprojektować formant, który jest w stanie ujawnienia region samego siebie w projektancie, ale nie chcesz, region, aby uczestniczyć w serializacji.|  
  
 Oprócz <xref:System.ComponentModel.ISite>, witryna implementuje również następujące interfejsy.  
  
> [!CAUTION]
>  Do sprawdzania istnienia te interfejsy, zamiast używać nieograniczonego rzutowania, ponieważ inne implementacje witryny nie może implementować ich.  
  
|Usługa|Opis|  
|-------------|-----------------|  
|<xref:System.ComponentModel.Design.IServiceContainer>|Zapewnia sposób uzyskać dostęp do kontenera usługi specyficzne dla lokacji. Na przykład <xref:System.ComponentModel.Design.IDictionaryService> jest usługą specyficzne dla lokacji. Z tą usługą możesz dodać dodatkowe usługi specyficzne dla lokacji.|  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.NamedPermissionSet">Aby uzyskać pełny dostęp do zasobów systemowych. Zapotrzebowanie wartości: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />, <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Skojarzony stan:</permission>
    <altmember cref="T:System.ComponentModel.Design.IDesignerHost" />
    <altmember cref="T:System.IServiceProvider" />
    <altmember cref="T:System.ComponentModel.Design.Serialization.DesignerLoader" />
    <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerLoaderService" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.Design.DesignSurface" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignSurface ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignSurface();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.Design.DesignSurface" /> klasy.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączone do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignSurface (IServiceProvider parentProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IServiceProvider parentProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.#ctor(System.IServiceProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parentProvider As IServiceProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignSurface(IServiceProvider ^ parentProvider);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.Design.DesignSurface : IServiceProvider -&gt; System.ComponentModel.Design.DesignSurface" Usage="new System.ComponentModel.Design.DesignSurface parentProvider" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parentProvider" Type="System.IServiceProvider" />
      </Parameters>
      <Docs>
        <param name="parentProvider">Nadrzędny dostawca usługi lub <see langword="null" /> czy brak elementu nadrzędnego, używany do rozpoznawania usług.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.Design.DesignSurface" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy `parentProvide` jest obecny, projektantów zawartych w powierzchni można pobrać usług z aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączone do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignSurface (Type rootComponentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type rootComponentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rootComponentType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignSurface(Type ^ rootComponentType);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.Design.DesignSurface : Type -&gt; System.ComponentModel.Design.DesignSurface" Usage="new System.ComponentModel.Design.DesignSurface rootComponentType" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="rootComponentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="rootComponentType">Typ główny składnika do utworzenia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.Design.DesignSurface" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kiedy używasz <xref:System.ComponentModel.Design.DesignSurface.%23ctor%2A> konstruktora tworzy prostą ładujący projektanta, który z kolei tworzy składnik danego typu, a następnie kończy proces ładowania. Jest to prosty sposób utworzyć projektanta, przy założeniu, że wszystkie Zapisywanie stanu będzie odbywać się na zewnątrz. Wewnętrznie, powoduje to wywołanie <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> i przekazuje typ składnika głównego.  
  
> [!NOTE]
>  <xref:System.ComponentModel.Design.DesignSurface.%23ctor%2A> Przeciążenia nie mają wpływu <xref:System.Windows.Forms.Design.DesignerOptions>. <xref:System.Windows.Forms.Design.DesignerOptions> Musi być w kontenerze usługi przed ładuje powierzchni projektowej. Jeśli potrzebujesz dostępu do <xref:System.Windows.Forms.Design.DesignerOptions>, Wywołaj pustego konstruktora, dodawanie <xref:System.Windows.Forms.Design.DesignerOptions> do <xref:System.ComponentModel.Design.DesignSurface.ServiceContainer%2A> i wywołać <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> z `rootComponentType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rootComponent" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączone do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignSurface (IServiceProvider parentProvider, Type rootComponentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IServiceProvider parentProvider, class System.Type rootComponentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.#ctor(System.IServiceProvider,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parentProvider As IServiceProvider, rootComponentType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignSurface(IServiceProvider ^ parentProvider, Type ^ rootComponentType);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.Design.DesignSurface : IServiceProvider * Type -&gt; System.ComponentModel.Design.DesignSurface" Usage="new System.ComponentModel.Design.DesignSurface (parentProvider, rootComponentType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parentProvider" Type="System.IServiceProvider" />
        <Parameter Name="rootComponentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="parentProvider">Nadrzędny dostawca usługi lub <see langword="null" /> czy brak elementu nadrzędnego, używany do rozpoznawania usług.</param>
        <param name="rootComponentType">Typ główny składnika do utworzenia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.Design.DesignSurface" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą <xref:System.ComponentModel.Design.DesignSurface.%23ctor%2A> Konstruktor tworzy prostą ładujący projektanta, który tworzy składnik danego typu, a następnie kończy proces ładowania. Jest to prosty sposób utworzyć projektanta, przy założeniu, że wszystkie Zapisywanie stanu będzie odbywać się na zewnątrz. Wewnętrznie, powoduje to wywołanie <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> i przekazuje typ składnika głównego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rootComponent" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączone do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginLoad">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpocznie się proces ładowania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public void BeginLoad (System.ComponentModel.Design.Serialization.DesignerLoader loader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoad(class System.ComponentModel.Design.Serialization.DesignerLoader loader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.BeginLoad(System.ComponentModel.Design.Serialization.DesignerLoader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoad (loader As DesignerLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoad(System::ComponentModel::Design::Serialization::DesignerLoader ^ loader);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : System.ComponentModel.Design.Serialization.DesignerLoader -&gt; unit" Usage="designSurface.BeginLoad loader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loader" Type="System.ComponentModel.Design.Serialization.DesignerLoader" />
      </Parameters>
      <Docs>
        <param name="loader">Program ładujący projektanta na potrzeby ładowania projektanta.</param>
        <summary>Rozpocznie się proces ładowania przy użyciu danego program ładujący projektanta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Trwa ładowanie Projektanta mogą być asynchroniczny, obciążenie może w dalszym ciągu postępu po zwrócił tego wywołania. Program obsługi zdarzeń, aby dołączyć <xref:System.ComponentModel.Design.IDesignerHost.LoadComplete> zdarzeń, aby otrzymywać powiadomienia po zakończeniu ładowania powierzchni projektowej.  
  
 Po <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> jest wywoływana, można natychmiast uzyskać widok projektanta, ponieważ projektanta modułów ładujących należy podać co najmniej składnik główny podczas ładowania asynchronicznie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="loader" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączone do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
        <altmember cref="T:System.ComponentModel.Design.Serialization.DesignerLoader" />
        <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerLoaderService" />
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public void BeginLoad (Type rootComponentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoad(class System.Type rootComponentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.BeginLoad(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoad (rootComponentType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoad(Type ^ rootComponentType);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : Type -&gt; unit" Usage="designSurface.BeginLoad rootComponentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootComponentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="rootComponentType">Typ składnika do utworzenia w trybie projektowania.</param>
        <summary>Rozpocznie się proces ładowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas `rootComponentType` jest określony, domyślna ładujący projektanta, który po prostu tworzy wystąpienie `rootComponentType` będą używane. Trwa ładowanie Projektanta mogą być asynchroniczny, obciążenie może w dalszym ciągu postępu po zwrócił tego wywołania. Program obsługi zdarzeń, aby dołączyć <xref:System.ComponentModel.Design.IDesignerHost.LoadComplete> zdarzeń, aby otrzymywać powiadomienia po zakończeniu ładowania powierzchni projektowej.  
  
 Po <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> jest wywoływana, można natychmiast uzyskać widok projektanta, ponieważ projektanta modułów ładujących należy podać co najmniej składnik główny podczas ładowania asynchronicznie.  
  
> [!NOTE]
>  <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> Metoda tworzy wystąpienie typu składnika i inicjuje projektanta dla tego wystąpienia. <xref:System.ComponentModel.Design.DesignSurface.Loaded> Zdarzenie jest zgłaszane, zanim ta metoda zwraca wartość.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rootComponentType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączone do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ComponentContainer">
      <MemberSignature Language="C#" Value="public System.ComponentModel.IContainer ComponentContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.IContainer ComponentContainer" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.ComponentContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ComponentContainer As IContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::IContainer ^ ComponentContainer { System::ComponentModel::IContainer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ComponentContainer : System.ComponentModel.IContainer" Usage="System.ComponentModel.Design.DesignSurface.ComponentContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.ComponentModel.IContainer" /> implementacji w ramach powierzchni projektowej.</summary>
        <value><see cref="T:System.ComponentModel.IContainer" /> Implementacji w ramach powierzchni projektowej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.DesignSurface.ComponentContainer%2A> Właściwość przechowuje wszystkie obiekty, które są obecnie dostępne w trybie projektowania. Gdy składniki są dodawane do <xref:System.ComponentModel.Design.DesignSurface.ComponentContainer%2A>, ich projektanta, jest ładowany. Składnik jest ulokowany z lokacją, która zapewnia pełny dostęp do powierzchni projektowej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączone do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateComponent">
      <MemberSignature Language="C#" Value="protected internal virtual System.ComponentModel.IComponent CreateComponent (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.ComponentModel.IComponent CreateComponent(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateComponent(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateComponent (componentType As Type) As IComponent" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::ComponentModel::IComponent ^ CreateComponent(Type ^ componentType);" />
      <MemberSignature Language="F#" Value="abstract member CreateComponent : Type -&gt; System.ComponentModel.IComponent&#xA;override this.CreateComponent : Type -&gt; System.ComponentModel.IComponent" Usage="designSurface.CreateComponent componentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("CreateComponent has been replaced by CreateInstance and will be removed after Beta2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IComponent</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">Typ składnika do utworzenia.</param>
        <summary>Tworzy wystąpienie składnika.</summary>
        <returns>Nowo utworzony składnik.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.DesignSurface.CreateComponent%2A> Metoda jest wywoływana przez powierzchnię projektu <xref:System.ComponentModel.Design.IDesignerHost.CreateComponent%2A> metodę w celu utworzenia wystąpienia składnika. Składnik powinien być utworzony i dodany do publicznego kontenera na powierzchni projektowej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="componentType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączone do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateDesigner">
      <MemberSignature Language="C#" Value="protected internal virtual System.ComponentModel.Design.IDesigner CreateDesigner (System.ComponentModel.IComponent component, bool rootDesigner);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.ComponentModel.Design.IDesigner CreateDesigner(class System.ComponentModel.IComponent component, bool rootDesigner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateDesigner(System.ComponentModel.IComponent,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateDesigner (component As IComponent, rootDesigner As Boolean) As IDesigner" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::ComponentModel::Design::IDesigner ^ CreateDesigner(System::ComponentModel::IComponent ^ component, bool rootDesigner);" />
      <MemberSignature Language="F#" Value="abstract member CreateDesigner : System.ComponentModel.IComponent * bool -&gt; System.ComponentModel.Design.IDesigner&#xA;override this.CreateDesigner : System.ComponentModel.IComponent * bool -&gt; System.ComponentModel.Design.IDesigner" Usage="designSurface.CreateDesigner (component, rootDesigner)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.IDesigner</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.ComponentModel.IComponent" />
        <Parameter Name="rootDesigner" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Składnik, dla którego należy utworzyć projektanta.</param>
        <param name="rootDesigner"><see langword="true" /> Aby utworzyć projektanta głównego; <see langword="false" /> utworzyć normalny projektanta.</param>
        <summary>Tworzy projektanta, gdy składnik zostanie dodany do kontenera.</summary>
        <returns>Wystąpienie żądanego projektanta lub <see langword="null" /> Jeśli można odnaleźć pasującego projektanta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.DesignSurface.CreateDesigner%2A> Metoda jest wywoływana przez powierzchnię projektu <xref:System.ComponentModel.IContainer> gdy składnik zostanie dodany do kontenera. Ta metoda tworzy projektanta, ale nie zainicjowany. Gdy zwraca ono projektanta jest inicjowany przez kontener.  
  
 <xref:System.ComponentModel.Design.DesignSurface.CreateDesigner%2A> można utworzyć dwa różne typy projektantów: główny projektantów i projektanci normalny. Projektant główny jest Projektant składnik główny powierzchni projektowej, w którym zgodnie z definicją to pierwszy komponent, dodać do kontenera. Projektanci głównego różnią się od normalnej projektantów, ponieważ są one odpowiedzialne za interfejs użytkownika, użytkownik końcowy. Projektanci głównego zwykle należy uzgodnić z pozostałej części projektantom na powierzchni projektowej udostępniają ten interfejs.  
  
 Domyślna implementacja tej metody deleguje do <xref:System.ComponentModel.TypeDescriptor>, przekazując <xref:System.ComponentModel.Design.IRootDesigner> jako typ projektanta dla projektantów głównego lub <xref:System.ComponentModel.Design.IDesigner> dla projektantów normalny. Można zastąpić tę metodę, aby zażądać określonego typu projektanta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="component" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączone do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected internal virtual object CreateInstance (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object CreateInstance(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateInstance(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ CreateInstance(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : Type -&gt; obj&#xA;override this.CreateInstance : Type -&gt; obj" Usage="designSurface.CreateInstance type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Typ do utworzenia.</param>
        <summary>Tworzy wystąpienie podanego typu.</summary>
        <returns>Nowo utworzony obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `type` jest <xref:System.ComponentModel.IComponent>, <xref:System.ComponentModel.Design.DesignSurface.CreateInstance%2A> wyszukuje konstruktora typu <xref:System.ComponentModel.IContainer> najpierw następuje pustego konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączone do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNestedContainer">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy kontener jest przeznaczony do zagnieżdżenia kontrolek i składników.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNestedContainer">
      <MemberSignature Language="C#" Value="public System.ComponentModel.INestedContainer CreateNestedContainer (System.ComponentModel.IComponent owningComponent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.INestedContainer CreateNestedContainer(class System.ComponentModel.IComponent owningComponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateNestedContainer(System.ComponentModel.IComponent)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateNestedContainer (owningComponent As IComponent) As INestedContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::INestedContainer ^ CreateNestedContainer(System::ComponentModel::IComponent ^ owningComponent);" />
      <MemberSignature Language="F#" Value="member this.CreateNestedContainer : System.ComponentModel.IComponent -&gt; System.ComponentModel.INestedContainer" Usage="designSurface.CreateNestedContainer owningComponent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.INestedContainer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owningComponent" Type="System.ComponentModel.IComponent" />
      </Parameters>
      <Docs>
        <param name="owningComponent">Składnik, który zarządza zagnieżdżonych kontenerów.</param>
        <summary>Tworzy kontener jest przeznaczony do zagnieżdżenia kontrolek i składników.</summary>
        <returns>Kontener zagnieżdżonych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dodawanie składnika do kontenera zagnieżdżonych tworzy swojego projektanta i udostępnia je kwalifikuje się do wszystkich usług z powierzchni projektowej. Składniki dodane do zagnieżdżone kontenery nie uczestniczą w serializacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="owningComponent" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączone do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNestedContainer">
      <MemberSignature Language="C#" Value="public System.ComponentModel.INestedContainer CreateNestedContainer (System.ComponentModel.IComponent owningComponent, string containerName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.INestedContainer CreateNestedContainer(class System.ComponentModel.IComponent owningComponent, string containerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateNestedContainer(System.ComponentModel.IComponent,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateNestedContainer (owningComponent As IComponent, containerName As String) As INestedContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::INestedContainer ^ CreateNestedContainer(System::ComponentModel::IComponent ^ owningComponent, System::String ^ containerName);" />
      <MemberSignature Language="F#" Value="member this.CreateNestedContainer : System.ComponentModel.IComponent * string -&gt; System.ComponentModel.INestedContainer" Usage="designSurface.CreateNestedContainer (owningComponent, containerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.INestedContainer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owningComponent" Type="System.ComponentModel.IComponent" />
        <Parameter Name="containerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="owningComponent">Składnik, który zarządza zagnieżdżonych kontenerów.</param>
        <param name="containerName">Dodatkowe nazwę kontenera zagnieżdżonych.</param>
        <summary>Tworzy kontener jest przeznaczony do zagnieżdżenia kontrolek i składników.</summary>
        <returns>Kontener zagnieżdżonych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dodawanie składnika do kontenera zagnieżdżonych tworzy swojego projektanta i udostępnia je kwalifikuje się do wszystkich usług z powierzchni projektowej. Składniki dodane do zagnieżdżone kontenery nie uczestniczą w serializacji.  
  
 Można zapewnić dodatkową nazwę <xref:System.ComponentModel.Design.DesignSurface.CreateNestedContainer%2A> metody przez przekazanie wartości do `containerName`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="owningComponent" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączone do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="designSurface.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Publicznie <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> metoda postępuje zgodnie ze standardowym <xref:System.IDisposable> wzorca. Wywołanie tej metody niszczy powierzchni projektowej. Chroniona wersja ta metoda jest `virtual` i następuje normalną <xref:System.IDisposable> wzorca.  
  
> [!NOTE]
>  Ponieważ <xref:System.ComponentModel.Design.DesignSurface> nie ma żadnych kodu natywnego, aby wyczyścić, nie ma finalizatora, który wywołuje metodę <xref:System.ComponentModel.Design.DesignSurface.Dispose%28System.Boolean%29>. Jeśli chcesz wywołać <xref:System.ComponentModel.Design.DesignSurface.Dispose%28System.Boolean%29>, możesz finalizator należy dodać.  
  
 Wywołaj <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> po zakończeniu przy użyciu <xref:System.ComponentModel.Design.DesignSurface>. <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> Pozostawia metoda <xref:System.ComponentModel.Design.DesignSurface> w stanie uniemożliwiającym jego używanie. Po wywołaniu <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A>, trzeba zwolnić wszystkie odwołania do <xref:System.ComponentModel.Design.DesignSurface> , moduł zbierający elementy bezużyteczne mógł odzyskać pamięć, <xref:System.ComponentModel.Design.DesignSurface> zajmowaną przez wystąpienie. Aby uzyskać więcej informacji, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) i [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> przed publikacją swoje ostatnie odwołanie do <xref:System.ComponentModel.Design.DesignSurface>. W przeciwnym razie zasobów jest przy użyciu nie zostanie zwolniona, dopóki moduł odśmiecania pamięci wywołuje <xref:System.ComponentModel.Design.DesignSurface> obiektu `Finalize` metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="designSurface.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Publicznie <xref:System.ComponentModel.Design.DesignSurface.Dispose> metoda postępuje zgodnie ze standardowym <xref:System.IDisposable> wzorca. Wywołanie tej metody niszczy powierzchni projektowej. Chroniona wersja ta metoda jest `virtual` i następuje normalną <xref:System.IDisposable> wzorca.  
  
> [!NOTE]
>  Ponieważ <xref:System.ComponentModel.Design.DesignSurface> nie ma żadnych kodu natywnego, aby wyczyścić, nie ma finalizatora, który wywołuje metodę <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A>. Jeśli chcesz wywołać <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A>, możesz finalizator należy dodać.  
  
 Ta metoda jest wywoływana przez publiczną `Dispose()` metody i <xref:System.Object.Finalize%2A> metody. `Dispose()` wywołuje chronioną metodę `Dispose(Boolean)` metody z `disposing` parametr `true`. <xref:System.Object.Finalize%2A> wywołuje `Dispose` z `disposing` równa `false`.  
  
 Gdy `disposing` parametr ma wartość true, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane że <xref:System.ComponentModel.Design.DesignSurface> odwołania. Ta metoda wywołuje `Dispose()` metoda każdego obiektu, do którego istnieje odwołanie.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> może być wywoływana wiele razy przez inne obiekty. Podczas zastępowania <see langword="Dispose(Boolean)" /> Uważaj, aby nie odwołują się do obiektów, które zostały wcześniej zlikwidowane wcześniejszym wywołaniem do <see langword="Dispose" />. Aby uzyskać więcej informacji o sposobie wdrażania <see langword="Dispose(Boolean)" />, zobacz [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Aby uzyskać więcej informacji na temat <see langword="Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) i [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Disposed">
      <MemberSignature Language="C#" Value="public event EventHandler Disposed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Disposed" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Disposed" />
      <MemberSignature Language="VB.NET" Value="Public Event Disposed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Disposed;" />
      <MemberSignature Language="F#" Value="member this.Disposed : EventHandler " Usage="member this.Disposed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po usunięciu powierzchni projektowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powierzchni jest tylko wtedy, gdy usunięte publicznie <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> metody <xref:System.ComponentModel.Design.DesignSurface> jest wywoływana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DtelLoading">
      <MemberSignature Language="C#" Value="public bool DtelLoading { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DtelLoading" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.DtelLoading" />
      <MemberSignature Language="VB.NET" Value="Public Property DtelLoading As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DtelLoading { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DtelLoading : bool with get, set" Usage="System.ComponentModel.Design.DesignSurface.DtelLoading" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy **lista błędów w czasie projektowania** ładowania.</summary>
        <value><see langword="true" /> Jeśli **lista błędów w czasie projektowania** jest ładowanie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ad408380-825a-46d8-9a4a-531b130b88ce">Błędy czasu projektowania w narzędziu Projektant dla formularzy systemu Windows</related>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="designSurface.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Serializuje zmiany do powierzchni projektowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.DesignSurface.Flush%2A> Można wywołać metody wypychania zmian do powierzchni projektowej w dół do serializatora. Dzięki temu zsynchronizowane na powierzchnię projektową i jego Zserializowany stan. Rzeczywista implementacja tej metody jest przekazywany do modułu ładującego projektanta skojarzone z powierzchni projektowej. Program ładujący projektanta zrezygnować z ustawienia mają być odroczone zmiany do momentu <xref:System.ComponentModel.Design.DesignSurface.Flush%2A> jest wywoływana, lub mają możliwość serializowane dane na bieżąco z wszystkie zmiany wprowadzane przez użytkownika. <xref:System.ComponentModel.Design.DesignSurface.Flush%2A> Metoda gwarantuje, że niezależnie od tego, program ładujący projektanta zdecydował się użyć modelu Zserializowany stan jest zsynchronizowany z powierzchni projektowej rzeczywistych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flushed">
      <MemberSignature Language="C#" Value="public event EventHandler Flushed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Flushed" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Flushed" />
      <MemberSignature Language="VB.NET" Value="Public Event Flushed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Flushed;" />
      <MemberSignature Language="F#" Value="member this.Flushed : EventHandler " Usage="member this.Flushed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy połączenie jest nawiązywane w przypadku <see cref="M:System.ComponentModel.Design.DesignSurface.Flush" /> metody <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Program ładujący projektanta jest opróżniany najpierw, a następnie <xref:System.ComponentModel.Design.DesignSurface.Flushed> zdarzenie jest wywoływane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetService">
      <MemberSignature Language="C#" Value="public object GetService (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetService(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetService (serviceType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetService(Type ^ serviceType);" />
      <MemberSignature Language="F#" Value="abstract member GetService : Type -&gt; obj&#xA;override this.GetService : Type -&gt; obj" Usage="designSurface.GetService serviceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IServiceProvider.GetService(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType">Typ usługi do pobrania.</param>
        <summary>Pobiera usługę z kontenera usług.</summary>
        <returns>Obiekt, który implementuje lub jest w klasie pochodnej, <paramref name="serviceType" />, lub <see langword="null" /> Jeśli usługa nie istnieje w kontenerze usługi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.DesignSurface.GetService%2A> Metoda pobiera usługi w kontenerze usługi powierzchni projektowej. Ponadto to będzie przesyłać wszystkich dostawców usług, czy podano na powierzchnię projektową podczas konstruowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.ComponentModel.Design.DesignSurface.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy na powierzchnię projektową jest aktualnie załadowana.</summary>
        <value><see langword="true" /> Jeśli na powierzchnię projektową jest aktualnie załadowana; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.Design.LoadedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.Design.LoadedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Event Loaded As LoadedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::Design::LoadedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.ComponentModel.Design.LoadedEventHandler " Usage="member this.Loaded : System.ComponentModel.Design.LoadedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.LoadedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zakończeniu ładowania projektanta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.DesignSurface.Loaded> Zdarzenie jest wywoływane dla obciążeń pomyślnie, a także nieudanymi. Jeśli kod w tej obsługi zdarzeń zgłasza wyjątek, Projektant jest zwalniana.  
  
 <xref:System.ComponentModel.Design.LoadedEventArgs> Obiekt może służyć do określenia, czy podczas ładowania zakończyło się pomyślnie i oferuje również listę błędów, które wystąpiły podczas ładowania.  
  
> [!NOTE]
>  W przypadku pomyślnego obciążeń, mogą wystąpić błędy, pod warunkiem, że system serializacji może tolerować błędy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadErrors">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection LoadErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection LoadErrors" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.LoadErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LoadErrors As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ LoadErrors { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LoadErrors : System.Collections.ICollection" Usage="System.ComponentModel.Design.DesignSurface.LoadErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca kolekcję ładowania błędów lub void kolekcji.</summary>
        <value>A <see cref="T:System.Collections.ICollection" /> ładowania błędów.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loading">
      <MemberSignature Language="C#" Value="public event EventHandler Loading;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Loading" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Loading" />
      <MemberSignature Language="VB.NET" Value="Public Event Loading As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Loading;" />
      <MemberSignature Language="F#" Value="member this.Loading : EventHandler " Usage="member this.Loading : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy projektant ma być załadowany.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLoaded">
      <MemberSignature Language="C#" Value="protected virtual void OnLoaded (System.ComponentModel.Design.LoadedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoaded(class System.ComponentModel.Design.LoadedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnLoaded(System.ComponentModel.Design.LoadedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoaded (e As LoadedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoaded(System::ComponentModel::Design::LoadedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoaded : System.ComponentModel.Design.LoadedEventArgs -&gt; unit&#xA;override this.OnLoaded : System.ComponentModel.Design.LoadedEventArgs -&gt; unit" Usage="designSurface.OnLoaded e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.Design.LoadedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.ComponentModel.Design.LoadedEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.ComponentModel.Design.DesignSurface.Loaded" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLoading">
      <MemberSignature Language="C#" Value="protected virtual void OnLoading (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoading(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnLoading(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoading (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoading(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoading : EventArgs -&gt; unit&#xA;override this.OnLoading : EventArgs -&gt; unit" Usage="designSurface.OnLoading e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.ComponentModel.Design.DesignSurface.Loading" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUnloaded">
      <MemberSignature Language="C#" Value="protected virtual void OnUnloaded (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnUnloaded(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnUnloaded(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnUnloaded (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnUnloaded(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnloaded : EventArgs -&gt; unit&#xA;override this.OnUnloaded : EventArgs -&gt; unit" Usage="designSurface.OnUnloaded e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.ComponentModel.Design.DesignSurface.Unloaded" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUnloading">
      <MemberSignature Language="C#" Value="protected virtual void OnUnloading (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnUnloading(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnUnloading(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnUnloading (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnUnloading(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnloading : EventArgs -&gt; unit&#xA;override this.OnUnloading : EventArgs -&gt; unit" Usage="designSurface.OnUnloading e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.ComponentModel.Design.DesignSurface.Unloading" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnViewActivate">
      <MemberSignature Language="C#" Value="protected virtual void OnViewActivate (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnViewActivate(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnViewActivate(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnViewActivate (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnViewActivate(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnViewActivate : EventArgs -&gt; unit&#xA;override this.OnViewActivate : EventArgs -&gt; unit" Usage="designSurface.OnViewActivate e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.ComponentModel.Design.DesignSurface.ViewActivated" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceContainer">
      <MemberSignature Language="C#" Value="protected System.ComponentModel.Design.ServiceContainer ServiceContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.Design.ServiceContainer ServiceContainer" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.ServiceContainer" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceContainer As ServiceContainer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::ComponentModel::Design::ServiceContainer ^ ServiceContainer { System::ComponentModel::Design::ServiceContainer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServiceContainer : System.ComponentModel.Design.ServiceContainer" Usage="System.ComponentModel.Design.DesignSurface.ServiceContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.ServiceContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kontener usług.</summary>
        <value>Kontener usługi, który zawiera wszystkie usługi projektantów zawartych w powierzchni projektowej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W czasie tworzenia <xref:System.ComponentModel.Design.DesignSurface> ten kontener usługi umożliwia dodanie usług domyślnych. Możesz pozostawić usług domyślnych w jego obecnym stanie lub można je usunąć i zastąpić je własnymi. Usługi domyślne są wszystkie żądanie utworzonej przez więc istnieje bez utraty wydajności dodawane podczas konstruowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączone do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event EventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Event Unloaded As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : EventHandler " Usage="member this.Unloaded : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy projektant zakończył zwolnienie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unloading">
      <MemberSignature Language="C#" Value="public event EventHandler Unloading;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Unloading" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Unloading" />
      <MemberSignature Language="VB.NET" Value="Public Event Unloading As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Unloading;" />
      <MemberSignature Language="F#" Value="member this.Unloading : EventHandler " Usage="member this.Unloading : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy ma zwolnienie projektanta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy zwalnia projektanta, cały stan dla tego projektanta jest niszczony, w tym widoku projektanta. W tym momencie powinna być bez elementów nadrzędnych tego widoku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="View">
      <MemberSignature Language="C#" Value="public object View { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object View" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.View" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property View As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ View { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.View : obj" Usage="System.ComponentModel.Design.DesignSurface.View" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera Widok projektanta głównego.</summary>
        <value>Widok projektanta głównego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> Metoda musi zostać wywołana wyprzedzeniem, aby rozpocząć proces ładowania. Istnieje możliwość zwrócenia widoku, zanim program ładujący projektanta zakończy ładowanie projektanta głównego, który dostarcza widoku, ponieważ pierwszy obiekt utworzony przez program ładujący projektanta. Jeśli widok jest niedostępny, <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> zgłasza wyjątek.  
  
 Pojęcie to technologia widok jest przestarzały. Jednak pozostanie w interfejsach dla projektantów głównego zgodności z poprzednimi wersjami. Jego użycie jest ukryty dla wszystkich osób korzystających z <xref:System.ComponentModel.Design.DesignSurface> obiektów. <xref:System.ComponentModel.Design.DesignSurface.View%2A> Właściwość ukrywa technologii widoku, przekazując obsługiwane technologie do projektanta głównego.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład sposobu <xref:System.ComponentModel.Design.DesignSurface.View%2A> ukrywa wyświetlić technologii.  
  
 ```csharp 
 IRootDesigner d;  
  
 ViewTechnology[] supported = d.SupportedTechnologies;  
  
 return d.GetView(supported[0]);
 ``` 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Powierzchni projektowej nie jest ładowany, program ładujący projektanta nie utworzył jeszcze projektanta głównego lub powierzchni projektowej Zakończono obciążenia, ale nie powiodło się. Więcej informacji może być dostępna w <see cref="P:System.Exception.InnerException" />.</exception>
        <exception cref="T:System.NotSupportedException">Załadowano projektanta, ale nie oferuje widok zgodny z tym powierzchni projektowej.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.ComponentModel.Design.IDesignerHost" /> Dołączone do <see cref="T:System.ComponentModel.Design.DesignSurface" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ViewActivated">
      <MemberSignature Language="C#" Value="public event EventHandler ViewActivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ViewActivated" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.ViewActivated" />
      <MemberSignature Language="VB.NET" Value="Public Event ViewActivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ViewActivated;" />
      <MemberSignature Language="F#" Value="member this.ViewActivated : EventHandler " Usage="member this.ViewActivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="M:System.ComponentModel.Design.IDesignerHost.Activate" /> metoda została wywołana dla <see cref="T:System.ComponentModel.Design.IDesignerHost" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli chcesz obsługiwać <xref:System.ComponentModel.Design.IDesignerHost.Activate%2A> metodę obsługi zdarzenia powinna być aktywowana w oknie tę powierzchnię projektu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.Design.IDesignerHost" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="MenuCommandService" FullName="System.ComponentModel.Design.MenuCommandService">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d63f3a6a1f4d7bf1c700b9a4a6153561337e17a6" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69329470" /></Metadata><TypeSignature Language="C#" Value="public class MenuCommandService : IDisposable, System.ComponentModel.Design.IMenuCommandService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MenuCommandService extends System.Object implements class System.ComponentModel.Design.IMenuCommandService, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.Design.MenuCommandService" />
  <TypeSignature Language="VB.NET" Value="Public Class MenuCommandService&#xA;Implements IDisposable, IMenuCommandService" />
  <TypeSignature Language="C++ CLI" Value="public ref class MenuCommandService : IDisposable, System::ComponentModel::Design::IMenuCommandService" />
  <TypeSignature Language="F#" Value="type MenuCommandService = class&#xA;    interface IMenuCommandService&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Design</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.Design.IMenuCommandService</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><see cref="T:System.ComponentModel.Design.IMenuCommandService" /> Implementuje interfejs.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.MenuCommandService> Klasa<xref:System.ComponentModel.Design.IMenuCommandService> implementuje interfejs, który jest zarządzanym interfejsem używanym do dodawania obsługi poleceń menu i definiowania czasowników.  
  
 Klasa jest automatycznie oferowana przez klasę pakietu, aby oferować polecenia globalne dla całego pakietu i jest również oferowana `Microsoft.VisualStudio.Shell.WindowPane` przez klasę w celu oferowania poleceń dla bieżącego okna. <xref:System.ComponentModel.Design.MenuCommandService> Ta oferta jest zawsze wykonywana przez kontener usługi, dzięki czemu każda osoba pochodna z pakietu lub z klas okienka okna może usunąć lub zamienić domyślną implementację <xref:System.ComponentModel.Design.IMenuCommandService> interfejsu.  
  
 <xref:System.ComponentModel.Design.MenuCommandService> Klasa wykorzystuje kilka innych usług. Wszystkie te usługi są opcjonalne, w związku z czym zachowanie <xref:System.ComponentModel.Design.MenuCommandService> klasy ulega obniżeniu, jeśli brakuje co najmniej jednej usługi. W poniższej tabeli przedstawiono, które usługi są używane i w jakim celu.  
  
|Usługa|Cel|  
|-------------|-------------|  
|<xref:System.ComponentModel.Design.ISelectionService>|Służy do wykrywania bieżącego wyboru w celu uzyskania zleceń oferowanych przez aktualnie wybranego projektanta.|  
|<xref:System.ComponentModel.Design.IDesignerHost>|Służy do uzyskania projektanta dla aktualnie wybranego składnika, jeśli istnieje.|  
|`Microsoft.VisualStudio.Shell.Interop.IVsUIShell`|Służy do powiadamiania programu Visual Studio o zmianie stanu polecenia.|  
|`Microsoft.VisualStudio.Shell.Interop.IOleComponentUIManager`|Używane do wyświetlania menu kontekstowych.|  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
    <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
    <altmember cref="T:System.ComponentModel.Design.CommandID" />
    <altmember cref="T:System.IServiceProvider" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuCommandService (IServiceProvider serviceProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IServiceProvider serviceProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.#ctor(System.IServiceProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (serviceProvider As IServiceProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuCommandService(IServiceProvider ^ serviceProvider);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.Design.MenuCommandService : IServiceProvider -&gt; System.ComponentModel.Design.MenuCommandService" Usage="new System.ComponentModel.Design.MenuCommandService serviceProvider" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serviceProvider" Type="System.IServiceProvider" />
      </Parameters>
      <Docs>
        <param name="serviceProvider">Dostawca usług, którego ta usługa używa do uzyskiwania innych usług.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.Design.MenuCommandService" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli usługa jest używana z projektantem, `serviceProvider` parametr powinien być dostawcą usług dla projektanta, tak jak w <xref:System.ComponentModel.Design.DesignSurface>przypadku.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName="AddCommand">
      <MemberSignature Language="C#" Value="public virtual void AddCommand (System.ComponentModel.Design.MenuCommand command);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddCommand(class System.ComponentModel.Design.MenuCommand command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.AddCommand(System.ComponentModel.Design.MenuCommand)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AddCommand (command As MenuCommand)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddCommand(System::ComponentModel::Design::MenuCommand ^ command);" />
      <MemberSignature Language="F#" Value="abstract member AddCommand : System.ComponentModel.Design.MenuCommand -&gt; unit&#xA;override this.AddCommand : System.ComponentModel.Design.MenuCommand -&gt; unit" Usage="menuCommandService.AddCommand command" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.IMenuCommandService.AddCommand(System.ComponentModel.Design.MenuCommand)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.ComponentModel.Design.MenuCommand" />
      </Parameters>
      <Docs>
        <param name="command"><see cref="T:System.ComponentModel.Design.MenuCommand" /> Do dodania.</param>
        <summary>Dodaje procedurę obsługi do usługi poleceń menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.MenuCommandService.AddCommand%2A> Metoda dodaje procedurę obsługi do usługi poleceń menu. Programy obsługi poleceń nie definiują tekstu, skrótu ani rozmieszczenia elementu menu. Zamiast tego definiuje zachowanie elementu menu, jeśli element zostanie kliknięty.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="command" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Procedura obsługi <paramref name="command" /> poleceń już istnieje.</exception>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName="AddVerb">
      <MemberSignature Language="C#" Value="public virtual void AddVerb (System.ComponentModel.Design.DesignerVerb verb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddVerb(class System.ComponentModel.Design.DesignerVerb verb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.AddVerb(System.ComponentModel.Design.DesignerVerb)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AddVerb (verb As DesignerVerb)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddVerb(System::ComponentModel::Design::DesignerVerb ^ verb);" />
      <MemberSignature Language="F#" Value="abstract member AddVerb : System.ComponentModel.Design.DesignerVerb -&gt; unit&#xA;override this.AddVerb : System.ComponentModel.Design.DesignerVerb -&gt; unit" Usage="menuCommandService.AddVerb verb" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.IMenuCommandService.AddVerb(System.ComponentModel.Design.DesignerVerb)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="verb" Type="System.ComponentModel.Design.DesignerVerb" />
      </Parameters>
      <Docs>
        <param name="verb"><see cref="T:System.ComponentModel.Design.DesignerVerb" /> Do dodania.</param>
        <summary>Dodaje czasownik do tabeli <see cref="T:System.ComponentModel.Design.MenuCommandService" />Verb obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zlecenie jest dostępne niezależnie od tego, jaki Projektant jest obecnie wybrany. W przeciwieństwie do poleceń menu czasowniki mogą definiować tekst wyświetlany użytkownikowi, ale nie definiują położenia polecenia w menu rzeczywistym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="verb" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez <see cref="T:System.ComponentModel.Design.MenuCommandService" />program.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="menuCommandService.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez <see cref="T:System.ComponentModel.Design.MenuCommandService" />program.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.ComponentModel.Design.MenuCommandService.Dispose%2A> po zakończeniu korzystania z <xref:System.ComponentModel.Design.MenuCommandService>. <xref:System.ComponentModel.Design.MenuCommandService.Dispose%2A> Metoda<xref:System.ComponentModel.Design.MenuCommandService> pozostawia w stanie niezdatnym do użytku. Po wywołaniu <xref:System.ComponentModel.Design.MenuCommandService.Dispose%2A>należy wydać wszystkie odwołania <xref:System.ComponentModel.Design.MenuCommandService> do, aby moduł wyrzucania elementów bezużytecznych mógł odwoływać pamięć <xref:System.ComponentModel.Design.MenuCommandService> , którą zajmował. Aby uzyskać więcej informacji, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i implementowanie [metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.ComponentModel.Design.MenuCommandService.Dispose%2A> przed wydaniem ostatniego odwołania <xref:System.ComponentModel.Design.MenuCommandService>do. W przeciwnym razie używane zasoby nie zostaną zwolnione do momentu wywołania <xref:System.ComponentModel.Design.MenuCommandService> `Finalize` metody obiektu przez moduł zbierający elementy bezużyteczne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="menuCommandService.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Zwalnia wszystkie zasoby używane przez <see cref="T:System.ComponentModel.Design.MenuCommandService" />program.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną `Dispose()` <xref:System.Object.Finalize%2A> i metodę. `Dispose()`wywołuje metodę chronioną `Dispose(Boolean)` `disposing` z parametrem ustawionym `true`na. <xref:System.Object.Finalize%2A>wywołuje `Dispose` `false`z `disposing` ustawionym na.  
  
 Gdy parametr ma wartość true, ta metoda zwalnia wszystkie zasoby przechowywane przez wszystkie obiekty zarządzane, do <xref:System.ComponentModel.Design.MenuCommandService> których odwołują się te odwołania. `disposing` Ta metoda wywołuje `Dispose()` metodę każdego przywoływanego obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" />może być wywoływana wiele razy przez inne obiekty. W przypadku <see langword="Dispose(Boolean)" /> przesłaniania należy zachować ostrożność, aby nie odwoływać się do obiektów, które zostały <see langword="Dispose" />wcześniej usunięte w ramach wcześniejszego wywołania do. Aby uzyskać więcej informacji na temat sposobu <see langword="Dispose(Boolean)" />implementacji, zobacz [implementowanie metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Aby uzyskać więcej informacji <see langword="Dispose" /> na <see cref="M:System.Object.Finalize" />temat i, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [Zastępowanie metody Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EnsureVerbs">
      <MemberSignature Language="C#" Value="protected void EnsureVerbs ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EnsureVerbs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.EnsureVerbs" />
      <MemberSignature Language="VB.NET" Value="Protected Sub EnsureVerbs ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void EnsureVerbs();" />
      <MemberSignature Language="F#" Value="member this.EnsureVerbs : unit -&gt; unit" Usage="menuCommandService.EnsureVerbs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia, że lista zleceń została utworzona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.MenuCommandService.EnsureVerbs%2A> Metoda tworzy listę zleceń, jeśli nie została jeszcze utworzona.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindCommand">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje <see cref="T:System.ComponentModel.Design.MenuCommand" /> skojarzone z danym identyfikatorem polecenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindCommand">
      <MemberSignature Language="C#" Value="public System.ComponentModel.Design.MenuCommand FindCommand (System.ComponentModel.Design.CommandID commandID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.Design.MenuCommand FindCommand(class System.ComponentModel.Design.CommandID commandID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.FindCommand(System.ComponentModel.Design.CommandID)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::Design::MenuCommand ^ FindCommand(System::ComponentModel::Design::CommandID ^ commandID);" />
      <MemberSignature Language="F#" Value="abstract member FindCommand : System.ComponentModel.Design.CommandID -&gt; System.ComponentModel.Design.MenuCommand&#xA;override this.FindCommand : System.ComponentModel.Design.CommandID -&gt; System.ComponentModel.Design.MenuCommand" Usage="menuCommandService.FindCommand commandID" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.IMenuCommandService.FindCommand(System.ComponentModel.Design.CommandID)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.MenuCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandID" Type="System.ComponentModel.Design.CommandID" />
      </Parameters>
      <Docs>
        <param name="commandID"><see cref="T:System.ComponentModel.Design.CommandID" /> Do znalezienia.</param>
        <summary>Wyszukuje <see cref="T:System.ComponentModel.Design.MenuCommand" /> skojarzone z danym identyfikatorem polecenia.</summary>
        <returns>Skojarzone z danym poleceniem; w przeciwnym razie <see langword="null" /> , jeśli polecenie nie zostanie odnalezione. <see cref="T:System.ComponentModel.Design.MenuCommand" /></returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName="FindCommand">
      <MemberSignature Language="C#" Value="protected System.ComponentModel.Design.MenuCommand FindCommand (Guid guid, int id);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.ComponentModel.Design.MenuCommand FindCommand(valuetype System.Guid guid, int32 id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.FindCommand(System.Guid,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::ComponentModel::Design::MenuCommand ^ FindCommand(Guid guid, int id);" />
      <MemberSignature Language="F#" Value="member this.FindCommand : Guid * int -&gt; System.ComponentModel.Design.MenuCommand" Usage="menuCommandService.FindCommand (guid, id)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.MenuCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.Guid" />
        <Parameter Name="id" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="guid">Identyfikator GUID polecenia.</param>
        <param name="id">Identyfikator polecenia.</param>
        <summary>Wyszukuje <see cref="T:System.ComponentModel.Design.MenuCommand" /> skojarzone z danym poleceniem.</summary>
        <returns>Skojarzone z danym poleceniem; w przeciwnym razie <see langword="null" /> , jeśli polecenie nie zostanie odnalezione. <see cref="T:System.ComponentModel.Design.MenuCommand" /></returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName="GetCommandList">
      <MemberSignature Language="C#" Value="protected System.Collections.ICollection GetCommandList (Guid guid);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Collections.ICollection GetCommandList(valuetype System.Guid guid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.GetCommandList(System.Guid)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Collections::ICollection ^ GetCommandList(Guid guid);" />
      <MemberSignature Language="F#" Value="member this.GetCommandList : Guid -&gt; System.Collections.ICollection" Usage="menuCommandService.GetCommandList guid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="guid">Identyfikator GUID listy poleceń.</param>
        <summary>Pobiera listę poleceń dla danego identyfikatora GUID.</summary>
        <returns><see cref="T:System.Collections.ICollection" /> Poleceń.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName="GetService">
      <MemberSignature Language="C#" Value="protected object GetService (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object GetService(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetService (serviceType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ GetService(Type ^ serviceType);" />
      <MemberSignature Language="F#" Value="member this.GetService : Type -&gt; obj" Usage="menuCommandService.GetService serviceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType"><see cref="T:System.Type" /> Usługa do pobrania.</param>
        <summary>Pobiera odwołanie do żądanej usługi.</summary>
        <returns>Odwołanie do <paramref name="serviceType" />; w przeciwnym razie <see langword="null" /> , jeśli usługa nie zostanie znaleziona.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="serviceType" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GlobalInvoke">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wywołuje polecenie w formularzu lokalnym lub w środowisku globalnym.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GlobalInvoke">
      <MemberSignature Language="C#" Value="public virtual bool GlobalInvoke (System.ComponentModel.Design.CommandID commandID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GlobalInvoke(class System.ComponentModel.Design.CommandID commandID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.GlobalInvoke(System.ComponentModel.Design.CommandID)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GlobalInvoke(System::ComponentModel::Design::CommandID ^ commandID);" />
      <MemberSignature Language="F#" Value="abstract member GlobalInvoke : System.ComponentModel.Design.CommandID -&gt; bool&#xA;override this.GlobalInvoke : System.ComponentModel.Design.CommandID -&gt; bool" Usage="menuCommandService.GlobalInvoke commandID" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.IMenuCommandService.GlobalInvoke(System.ComponentModel.Design.CommandID)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandID" Type="System.ComponentModel.Design.CommandID" />
      </Parameters>
      <Docs>
        <param name="commandID">Polecenie do wywołania.</param>
        <summary>Wywołuje to polecenie w formularzu lokalnym lub w środowisku globalnym.</summary>
        <returns><see langword="true" />, jeśli polecenie zostało znalezione; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Formularz lokalny jest najpierw przeszukiwany dla danego identyfikatora polecenia. Jeśli zostanie znalezione, jest wywoływana. W przeciwnym razie identyfikator polecenia jest przesyłany do procedury obsługi poleceń środowiska globalnego, jeśli jest dostępny.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName="GlobalInvoke">
      <MemberSignature Language="C#" Value="public virtual bool GlobalInvoke (System.ComponentModel.Design.CommandID commandId, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GlobalInvoke(class System.ComponentModel.Design.CommandID commandId, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.GlobalInvoke(System.ComponentModel.Design.CommandID,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GlobalInvoke(System::ComponentModel::Design::CommandID ^ commandId, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="abstract member GlobalInvoke : System.ComponentModel.Design.CommandID * obj -&gt; bool&#xA;override this.GlobalInvoke : System.ComponentModel.Design.CommandID * obj -&gt; bool" Usage="menuCommandService.GlobalInvoke (commandId, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandId" Type="System.ComponentModel.Design.CommandID" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="commandId">Polecenie do wywołania.</param>
        <param name="arg">Parametr wywołania.</param>
        <summary>Wywołuje daną polecenie z podanym parametrem w formularzu lokalnym lub w środowisku globalnym.</summary>
        <returns><see langword="true" />, jeśli polecenie zostało znalezione; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Formularz lokalny jest najpierw przeszukiwany dla danego identyfikatora polecenia. Jeśli zostanie znalezione, jest wywoływana. W przeciwnym razie identyfikator polecenia jest przesyłany do procedury obsługi poleceń środowiska globalnego, jeśli jest dostępny.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName="MenuCommandsChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.Design.MenuCommandsChangedEventHandler MenuCommandsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.Design.MenuCommandsChangedEventHandler MenuCommandsChanged" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.MenuCommandService.MenuCommandsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MenuCommandsChanged As MenuCommandsChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::Design::MenuCommandsChangedEventHandler ^ MenuCommandsChanged;" />
      <MemberSignature Language="F#" Value="member this.MenuCommandsChanged : System.ComponentModel.Design.MenuCommandsChangedEventHandler " Usage="member this.MenuCommandsChanged : System.ComponentModel.Design.MenuCommandsChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.MenuCommandsChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie stanu polecenia menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji o sposobie obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCommandsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCommandsChanged (System.ComponentModel.Design.MenuCommandsChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCommandsChanged(class System.ComponentModel.Design.MenuCommandsChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.OnCommandsChanged(System.ComponentModel.Design.MenuCommandsChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCommandsChanged (e As MenuCommandsChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCommandsChanged(System::ComponentModel::Design::MenuCommandsChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCommandsChanged : System.ComponentModel.Design.MenuCommandsChangedEventArgs -&gt; unit&#xA;override this.OnCommandsChanged : System.ComponentModel.Design.MenuCommandsChangedEventArgs -&gt; unit" Usage="menuCommandService.OnCommandsChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.Design.MenuCommandsChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.ComponentModel.Design.MenuCommandsChangedEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.ComponentModel.Design.MenuCommandService.MenuCommandsChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.MenuCommandService.OnCommandsChanged%2A> Metoda jest wywoływana przez polecenie menu, gdy jego stan zmieni się.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.ComponentModel.Design.MenuCommandService.OnCommandsChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.ComponentModel.Design.MenuCommandService.OnCommandsChanged(System.ComponentModel.Design.MenuCommandsChangedEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.ComponentModel.Design.MenuCommandService.OnCommandsChanged(System.ComponentModel.Design.MenuCommandsChangedEventArgs)" /> metodę klasy bazowej, aby zarejestrowani pełnomocnicy otrzymywali zdarzenie.</para></block>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCommand">
      <MemberSignature Language="C#" Value="public virtual void RemoveCommand (System.ComponentModel.Design.MenuCommand command);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveCommand(class System.ComponentModel.Design.MenuCommand command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.RemoveCommand(System.ComponentModel.Design.MenuCommand)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveCommand (command As MenuCommand)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveCommand(System::ComponentModel::Design::MenuCommand ^ command);" />
      <MemberSignature Language="F#" Value="abstract member RemoveCommand : System.ComponentModel.Design.MenuCommand -&gt; unit&#xA;override this.RemoveCommand : System.ComponentModel.Design.MenuCommand -&gt; unit" Usage="menuCommandService.RemoveCommand command" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.IMenuCommandService.RemoveCommand(System.ComponentModel.Design.MenuCommand)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.ComponentModel.Design.MenuCommand" />
      </Parameters>
      <Docs>
        <param name="command">Polecenie do usunięcia.</param>
        <summary>Usuwa podaną polecenie menu z dokumentu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli w grupie poleceń nie ma więcej poleceń, Grupa zostanie usunięta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="command" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName="RemoveVerb">
      <MemberSignature Language="C#" Value="public virtual void RemoveVerb (System.ComponentModel.Design.DesignerVerb verb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveVerb(class System.ComponentModel.Design.DesignerVerb verb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.RemoveVerb(System.ComponentModel.Design.DesignerVerb)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveVerb (verb As DesignerVerb)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveVerb(System::ComponentModel::Design::DesignerVerb ^ verb);" />
      <MemberSignature Language="F#" Value="abstract member RemoveVerb : System.ComponentModel.Design.DesignerVerb -&gt; unit&#xA;override this.RemoveVerb : System.ComponentModel.Design.DesignerVerb -&gt; unit" Usage="menuCommandService.RemoveVerb verb" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.IMenuCommandService.RemoveVerb(System.ComponentModel.Design.DesignerVerb)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="verb" Type="System.ComponentModel.Design.DesignerVerb" />
      </Parameters>
      <Docs>
        <param name="verb">Zlecenie do usunięcia.</param>
        <summary>Usuwa daną czasownik z dokumentu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="verb" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName="ShowContextMenu">
      <MemberSignature Language="C#" Value="public virtual void ShowContextMenu (System.ComponentModel.Design.CommandID menuID, int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ShowContextMenu(class System.ComponentModel.Design.CommandID menuID, int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.ShowContextMenu(System.ComponentModel.Design.CommandID,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ShowContextMenu (menuID As CommandID, x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ShowContextMenu(System::ComponentModel::Design::CommandID ^ menuID, int x, int y);" />
      <MemberSignature Language="F#" Value="abstract member ShowContextMenu : System.ComponentModel.Design.CommandID * int * int -&gt; unit&#xA;override this.ShowContextMenu : System.ComponentModel.Design.CommandID * int * int -&gt; unit" Usage="menuCommandService.ShowContextMenu (menuID, x, y)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.IMenuCommandService.ShowContextMenu(System.ComponentModel.Design.CommandID,System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="menuID" Type="System.ComponentModel.Design.CommandID" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="menuID">Menu skrótów do wyświetlenia.</param>
        <param name="x">Współrzędna x lokalizacji menu skrótów.</param>
        <param name="y">Współrzędna y lokalizacji menu skrótów.</param>
        <summary>Pokazuje menu skrótów z danym IDENTYFIKATORem polecenia w danej lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja nie robi nic.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName="Verbs">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.Design.DesignerVerbCollection Verbs { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.Design.DesignerVerbCollection Verbs" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.MenuCommandService.Verbs" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Verbs As DesignerVerbCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::Design::DesignerVerbCollection ^ Verbs { System::ComponentModel::Design::DesignerVerbCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Verbs : System.ComponentModel.Design.DesignerVerbCollection" Usage="System.ComponentModel.Design.MenuCommandService.Verbs" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.Design.IMenuCommandService.Verbs</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.DesignerVerbCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję zleceń projektanta, które są obecnie dostępne.</summary>
        <value><see cref="T:System.ComponentModel.Design.DesignerVerbCollection" /> Aktualnie dostępne są zlecenia projektanta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.MenuCommandService.Verbs%2A> Właściwość zawiera kolekcję zleceń. Te czasowniki pochodzą z dwóch miejsc:  
  
-   Czasowniki dodane przez <xref:System.ComponentModel.Design.MenuCommandService.AddVerb%2A> <xref:System.ComponentModel.Design.MenuCommandService.Verbs%2A>metodę.  
  
-   Zlecenia oferowane przez aktualnie wybranego projektanta.  
  
 Czasowniki dodane do tej usługi za <xref:System.ComponentModel.Design.MenuCommandService.AddVerb%2A> pomocą metody są nazywane czasownikami globalnymi, ponieważ są one globalne dla tej usługi, ale ogólnie istnieje jedno wystąpienie tej usługi dla każdego okna narzędzi lub dokumentu. Zlecenia projektanta są uzyskiwane przez przeszukiwanie dostawcy usług dla <xref:System.ComponentModel.Design.IDesignerHost> i <xref:System.ComponentModel.Design.ISelectionService>. Jeśli usługa zaznaczania oferuje podstawową opcję, a Projektant może uzyskać ten wybór z <xref:System.ComponentModel.Design.IDesignerHost>, zlecenia projektanta zostaną dodane do tej listy. Jeśli nazwa czasownika globalnego powoduje konflikt z nazwą zlecenia projektanta, pierwszeństwo ma zlecenie projektanta udostępniane przez projektanta.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="_Type" FullName="System.Runtime.InteropServices._Type">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="31982e866eb2ee3dc6628ccd7d14f09821e16aac" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48647773" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface _Type" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract _Type" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices._Type" />
  <TypeSignature Language="VB.NET" Value="Public Interface _Type" />
  <TypeSignature Language="C++ CLI" Value="public interface class _Type" />
  <TypeSignature Language="F#" Value="type _Type = interface" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.CLSCompliant(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.Guid("BCA8B44D-AAD6-3A86-8AB7-03349F4F2DA2")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.InterfaceType(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.TypeLibImportClass(typeof(System.Type))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia publiczne elementy członkowskie <see cref="T:System.Type" /> klasy do kodu niezarządzanego.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten interfejs jest dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 Ten interfejs zachowuje vtable kolejności <xref:System.Type?displayProperty=nameWithType> elementy członkowskie, które mogą być udostępniane przez niezarządzane obiekty COM klasy.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Runtime.InteropServices._Type.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.Assembly" /> właściwości.</summary>
        <value>
          <see cref="T:System.Reflection.Assembly" /> Wystąpienia, który opisuje zestawu zawierającego bieżącego typu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.Assembly%2A?displayProperty=nameWithType> Pobiera właściwość <xref:System.Reflection.Assembly> w którym zadeklarowano typu. Dla typów ogólnych tej właściwości pobiera <xref:System.Reflection.Assembly> w jest definicja typu ogólnego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Runtime.InteropServices._Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.AssemblyQualifiedName" /> właściwości.</summary>
        <value>Nazwa kwalifikowanego dla zestawu <see cref="T:System.Type" />, łącznie z nazwą zestawu, z którego <see cref="T:System.Type" /> został załadowany.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> Właściwości pobiera nazwę kwalifikowaną dla zestawu <xref:System.Type>, łącznie z nazwą zestawu, z którego <xref:System.Type> został załadowany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Runtime.InteropServices._Type.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.Attributes" /> właściwości.</summary>
        <value>A <see cref="T:System.Reflection.TypeAttributes" /> obiekt reprezentujący zestaw atrybutów <see cref="T:System.Type" />, chyba że <see cref="T:System.Type" /> reprezentuje parametr typu ogólnego, w której wartość jest nieokreślony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.Attributes%2A?displayProperty=nameWithType> Właściwości pobiera atrybuty skojarzone z <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Runtime.InteropServices._Type.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.BaseType" /> właściwości.</summary>
        <value>
          <see cref="T:System.Type" /> z którego bieżący <see cref="T:System.Type" /> dziedziczy bezpośrednio, lub <see langword="null" /> Jeśli bieżące <see langword="Type" /> reprezentuje <see cref="T:System.Object" /> klasy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.BaseType%2A?displayProperty=nameWithType> Właściwości pobiera typ, z którego bieżący <xref:System.Type> dziedziczy bezpośrednio.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Runtime.InteropServices._Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.DeclaringType" /> właściwości.</summary>
        <value>
          <see cref="T:System.Type" /> Obiektu klasy, która deklaruje tego elementu członkowskiego. Jeśli typ jest typem zagnieżdżonym, ta właściwość zwraca typ otaczający.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.DeclaringType%2A?displayProperty=nameWithType> Właściwości pobiera klasę, która deklaruje tego elementu członkowskiego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="Overload:System.Type.Equals" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.Equals%2A?displayProperty=nameWithType> Metoda określa, czy typ podstawowy system bieżącego <xref:System.Type> jest taka sama jak system typem podstawowym określonego <xref:System.Object> lub <xref:System.Type>.  
  
 .  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (object other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Object ^ other);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool" Usage="_Type.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="other">
          <see cref="T:System.Object" /> Którego podstawowym typem systemu jest ma zostać porównane z podstawowym typem systemu bieżącego <see cref="T:System.Type" />.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.Equals(System.Object)" /> metody.</summary>
        <returns>
          <see langword="true" /> Jeśli typ podstawowy system <paramref name="o" /> jest taka sama jak podstawowym typem systemu bieżącego <see cref="T:System.Type" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.Equals%2A?displayProperty=nameWithType> Metoda określa, czy typ podstawowy system bieżącego <xref:System.Type> jest taka sama jak system typem podstawowym określonego <xref:System.Object>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(Type ^ o);" />
      <MemberSignature Language="F#" Value="abstract member Equals : Type -&gt; bool" Usage="_Type.Equals o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">
          <see cref="T:System.Type" /> Którego podstawowym typem systemu jest ma zostać porównane z podstawowym typem systemu bieżącego <see cref="T:System.Type" />.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.Equals(System.Type)" /> metody.</summary>
        <returns>
          <see langword="true" /> Jeśli typ podstawowy system <paramref name="o" /> jest taka sama jak podstawowym typem systemu bieżącego <see cref="T:System.Type" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.Equals%2A?displayProperty=nameWithType> Metoda określa, czy typ podstawowy system bieżącego <xref:System.Type> jest taka sama jak system typem podstawowym określonego <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="_Type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">
          <see cref="T:System.Reflection.TypeFilter" /> Delegata, który porównuje interfejsów względem <c>filterCriteria</c>.</param>
        <param name="filterCriteria">Kryteria wyszukiwania, które określa, czy interfejs powinny być objęte zwróconej tablicy.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" /> metody.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiekty reprezentujące filtrowana lista interfejsy implementowane lub jest dziedziczona przez bieżący <see cref="T:System.Type" />.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" />, jeśli interfejsy nie jest zgodny z filtrem są implementowane lub dziedziczone przez bieżącą <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.FindInterfaces%2A?displayProperty=nameWithType> Metoda zwraca tablicę <xref:System.Type> obiekty reprezentujące filtrowana lista interfejsy implementowane lub jest dziedziczona przez bieżący <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="_Type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">A <see langword="MemberTypes" /> wskazujący typ elementu członkowskiego, aby wyszukać obiekt.</param>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <param name="filter">Delegat, który wykonuje porównania, zwracając <see langword="true" /> elementu członkowskiego aktualnie inspekcji dopasowania <c>filterCriteria</c> i <see langword="false" /> inaczej. Możesz użyć <see langword="FilterAttribute" />, <see langword="FilterName" />, i <see langword="FilterNameIgnoreCase" /> delegatów, dostarczone przez tę klasę. Pierwszy używa pól <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, i <see langword="MethodImplAttributes" /> jako kryteria wyszukiwania, a następnie użyj dwa delegaty <see langword="String" /> obiektów jako kryterium wyszukiwania.</param>
        <param name="filterCriteria">Kryteria wyszukiwania, które określa, czy członek jest zwracany w tablicy <see langword="MemberInfo" /> obiektów.  
  
Pola <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, i <see langword="MethodImplAttributes" /> mogą być używane w połączeniu z <see langword="FilterAttribute" /> delegata dostarczonych przez tę klasę.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" /> metody.</summary>
        <returns>Filtrowane tablicę <see cref="T:System.Reflection.MemberInfo" /> obiektów typu określonego elementu członkowskiego.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.MemberInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma elementów członkowskich typu <paramref name="memberType" /> pasujących do kryteriów filtrowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.FindMembers%2A?displayProperty=nameWithType> Metoda zwraca przefiltrowane tablicę <xref:System.Reflection.MemberInfo> obiektów typu określonego elementu członkowskiego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Runtime.InteropServices._Type.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.FullName" /> właściwości.</summary>
        <value>Ciąg zawierający w pełni kwalifikowanej nazwy <see cref="T:System.Type" />, włącznie z przestrzenią nazw z <see cref="T:System.Type" /> , ale nie zestaw.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.FullName%2A?displayProperty=nameWithType> Właściwości pobiera w pełni kwalifikowana nazwa <xref:System.Type>, włącznie z przestrzenią nazw z <xref:System.Type> , ale nie zestaw.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetArrayRank();" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int" Usage="_Type.GetArrayRank " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetArrayRank" /> metody.</summary>
        <returns>
          <see cref="T:System.Int32" /> Zawierającą liczbę wymiarów w bieżącym <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetArrayRank%2A?displayProperty=nameWithType> Metoda pobiera liczbę wymiarów <xref:System.Array>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="Overload:System.Type.GetConstructor" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetConstructor%2A?displayProperty=nameWithType> Metoda pobiera określone Konstruktor bieżącego <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="_Type.GetConstructor types" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla żądanego konstruktora.  
  
—lub— 
Pusta tablica <see cref="T:System.Type" /> obiektów, można pobrać konstruktora, który nie przyjmuje żadnych parametrów. Pusta tablica jest dostarczany przez <see langword="static" /> pola <see cref="F:System.Type.EmptyTypes" />.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetConstructor(System.Type[])" /> metody.</summary>
        <returns>A <see cref="T:System.Reflection.ConstructorInfo" /> obiekt reprezentujący konstruktora wystąpienia publicznego, w której parametry pasują do typów w tablicy typu parametru, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetConstructor%2A?displayProperty=nameWithType> Metoda wyszukiwanie konstruktora wystąpienia publicznego, w której parametry pasują do typów w określonej tablicy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="_Type.GetConstructor (bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <param name="binder">A <see cref="T:System.Reflection.Binder" /> obiekt, który definiuje zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
 <see langword="null" />, aby użyć <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla konstruktora, aby uzyskać.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie konstruktora, który nie przyjmuje żadnych parametrów.  
  
—lub— 
 <see cref="F:System.Type.EmptyTypes" />.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w tablicy typu parametru. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" /> metody.</summary>
        <returns>A <see cref="T:System.Reflection.ConstructorInfo" /> obiekt reprezentujący Konstruktor, który spełnia określone wymagania, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetConstructor%2A?displayProperty=nameWithType> Metoda wyszukiwanie konstruktora, w której parametry odpowiadają określone typy argumentów i modyfikatorów, za pomocą ograniczeń w określonym powiązaniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="_Type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <param name="binder">A <see cref="T:System.Reflection.Binder" /> obiekt, który definiuje zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
 <see langword="null" />, aby użyć <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">
          <see cref="T:System.Reflection.CallingConventions" /> Obiekt, który określa zestaw reguł do użycia w odniesieniu do zlecenia i układ argumentów, jak wartość zwracana jest przekazywany, jakie rejestrów są używane dla argumentów i stos jest czyszczony.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla konstruktora, aby uzyskać.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie konstruktora, który nie przyjmuje żadnych parametrów.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <c>typy</c> tablicy. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> metody.</summary>
        <returns>A <see cref="T:System.Reflection.ConstructorInfo" /> obiekt reprezentujący Konstruktor, który spełnia określone wymagania, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetConstructor%2A?displayProperty=nameWithType> Metoda wyszukiwanie konstruktora, w której parametry odpowiadają określone typy argumentów i modyfikatorów, za pomocą ograniczeń w określonym powiązaniu i określonej konwencji wywoływania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="Overload:System.Type.GetConstructors" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetConstructors%2A?displayProperty=nameWithType> Metoda pobiera konstruktory bieżącego <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="_Type.GetConstructors " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetConstructors" /> metody.</summary>
        <returns>Tablica <see cref="T:System.Reflection.ConstructorInfo" /> obiekty reprezentujące wszystkie konstruktory publiczne wystąpienia zdefiniowane dla bieżącego <see cref="T:System.Type" />, z wyjątkiem typu inicjatora (Konstruktor statyczny). Jeśli nie konstruktory publiczne wystąpienia są zdefiniowane dla bieżącego <see cref="T:System.Type" />, lub, jeśli bieżący <see cref="T:System.Type" /> reprezentuje parametr typu ogólnego definicji typu lub metody, pusta tablica typu <see cref="T:System.Reflection.ConstructorInfo" /> jest zwracana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetConstructors%2A?displayProperty=nameWithType> Metoda zwraca wszystkie publiczne konstruktory zdefiniowane dla bieżącego <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="_Type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" /> metody.</summary>
        <returns>Tablica <see cref="T:System.Reflection.ConstructorInfo" /> obiekty reprezentujące wszystkie konstruktory zdefiniowane dla bieżącego <see cref="T:System.Type" /> zgodnych ograniczeń w określonym powiązaniu, w tym inicjatora typu, jeśli jest on zdefiniowany. Zwraca pustą tablicę typu <see cref="T:System.Reflection.ConstructorInfo" /> Jeśli konstruktory nie są zdefiniowane dla bieżącego <see cref="T:System.Type" />, czy żaden z konstruktorów zdefiniowanych być zgodne z ograniczeniami powiązania, czy bieżący <see cref="T:System.Type" /> reprezentuje parametr typu ogólnego lub metody Definicja.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetConstructors%2A?displayProperty=nameWithType> Metoda wyszukiwania dla konstruktorów, zdefiniowanych dla bieżącej <xref:System.Type>, przy użyciu określonego <xref:System.Reflection.BindingFlags>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="Overload:System.Reflection.MemberInfo.GetCustomAttributes" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A?displayProperty=nameWithType> Metoda zwraca wszystkie atrybuty stosowane do tego elementu członkowskiego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : bool -&gt; obj[]" Usage="_Type.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">Określa, czy przeszukać łańcuch dziedziczenia tego elementu członkowskiego w celu znalezienia atrybutów.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)" /> metody.</summary>
        <returns>Tablica atrybutów niestandardowych zastosowanych do tego elementu członkowskiego lub tablica nie zawierająca żadnego elementu (0), jeśli atrybuty nie zostały zastosowane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> Metoda zwraca wszystkie atrybuty stosowane do tego elementu członkowskiego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : Type * bool -&gt; obj[]" Usage="_Type.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Typ atrybutu do wyszukiwania. Zwracane są tylko atrybuty, które są przypisane do tego typu.</param>
        <param name="inherit">Określa, czy przeszukać łańcuch dziedziczenia tego elementu członkowskiego w celu znalezienia atrybutów.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /> metody.</summary>
        <returns>Tablica atrybutów niestandardowych zastosowanych do tego elementu członkowskiego lub tablica nie zawierająca żadnego elementu (0), jeśli atrybuty nie zostały zastosowane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A?displayProperty=nameWithType> Metoda zwraca wszystkie atrybuty stosowane do tego elementu członkowskiego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="_Type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetDefaultMembers" /> metody.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące wszystkie domyślne elementy członkowskie bieżącego <see cref="T:System.Type" />.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.MemberInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma domyślne elementy członkowskie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetDefaultMembers%2A?displayProperty=nameWithType> Metoda wyszukuje elementy członkowskie zdefiniowane dla bieżącego <xref:System.Type> którego <xref:System.Reflection.DefaultMemberAttribute> jest ustawiona.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="_Type.GetElementType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetElementType" /> metody.</summary>
        <returns>
          <see cref="T:System.Type" /> Obiektu wchodzących w skład lub określone przez bieżący typ tablicy, wskaźnika lub odwołania.  
  
—lub— 
 <see langword="null" /> Jeśli bieżący <see cref="T:System.Type" /> nie jest tablicą ani wskaźnikiem, nie jest przekazywany przez odwołanie lub reprezentuje typ ogólny lub parametr typu ogólnego definicji typu lub metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetElementType%2A?displayProperty=nameWithType> Metoda zwraca <xref:System.Type> obiektu wchodzących w skład lub określone przez bieżący typ tablicy, wskaźnika lub odwołania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="Overload:System.Type.GetEvent" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetEvent%2A?displayProperty=nameWithType> Metoda pobiera określone zdarzenie zadeklarowane lub dziedziczone przez bieżącą <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo" Usage="_Type.GetEvent name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetEvent(System.String)" /> metody.</summary>
        <returns>Tablica <see cref="T:System.Reflection.EventInfo" /> obiekty reprezentujące wszystkie zdarzenia, które są zadeklarowane lub dziedziczone przez bieżącą <see cref="T:System.Type" /> zgodnych ograniczeń w określonym powiązaniu.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.EventInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma zdarzenia, lub jeśli żadna z tych zdarzeń ograniczenia wiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetEvent%2A?displayProperty=nameWithType> Metoda wyszukiwania dla zdarzenia, które są zadeklarowane lub dziedziczone przez bieżącą <xref:System.Type>, za pomocą ograniczeń w określonym powiązaniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="_Type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierający nazwę zdarzenia, które jest zadeklarowany lub jest dziedziczona przez bieżący <see cref="T:System.Type" />.</param>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /> metody.</summary>
        <returns>
          <see cref="T:System.Reflection.EventInfo" /> Obiekt reprezentujący określonego zdarzenia, które jest zadeklarowany lub jest dziedziczona przez bieżący <see cref="T:System.Type" />, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetEvent%2A?displayProperty=nameWithType> Metoda zwraca <xref:System.Reflection.EventInfo> obiekt reprezentujący określonych zdarzeń, za pomocą ograniczeń w określonym powiązaniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="Overload:System.Type.GetEvents" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetEvents%2A?displayProperty=nameWithType> Metoda pobiera zdarzenia, które są zadeklarowane lub dziedziczone przez bieżącą <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="_Type.GetEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetEvents" /> metody.</summary>
        <returns>Tablica <see cref="T:System.Reflection.EventInfo" /> obiekty reprezentujące wszystkie publicznych zdarzenia, które są zadeklarowane lub dziedziczone przez bieżącą <see cref="T:System.Type" />.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.EventInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma publicznych zdarzeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetEvents%2A?displayProperty=nameWithType> Metoda zwraca wszystkie publicznych zdarzenia, które są zadeklarowane lub dziedziczone przez bieżącą <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="_Type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" /> metody.</summary>
        <returns>Tablica <see cref="T:System.Reflection.EventInfo" /> obiekty reprezentujące wszystkie zdarzenia, które są zadeklarowane lub dziedziczone przez bieżącą <see cref="T:System.Type" /> zgodnych ograniczeń w określonym powiązaniu.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.EventInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma zdarzenia, lub jeśli żadna z tych zdarzeń ograniczenia wiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetEvents%2A?displayProperty=nameWithType> Metoda wyszukiwania dla zdarzenia, które są zadeklarowane lub dziedziczone przez bieżącą <xref:System.Type>, za pomocą ograniczeń w określonym powiązaniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="Overload:System.Type.GetField" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetField%2A?displayProperty=nameWithType> Metoda pobiera określonego pola bieżącego <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo" Usage="_Type.GetField name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierający nazwę pola danych można pobrać.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetField(System.String)" /> metody.</summary>
        <returns>A <see cref="T:System.Reflection.FieldInfo" /> obiekt reprezentujący publiczne pole o określonej nazwie, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetField%2A?displayProperty=nameWithType> Metoda wyszukuje publiczne pole o określonej nazwie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="_Type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierający nazwę pola danych można pobrać.</param>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" /> metody.</summary>
        <returns>A <see cref="T:System.Reflection.FieldInfo" /> obiekt reprezentujący pola, które spełnia określone wymagania, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetField%2A?displayProperty=nameWithType> Metoda wyszukiwania dla określonego pola, za pomocą ograniczeń w określonym powiązaniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="Overload:System.Type.GetFields" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetFields%2A?displayProperty=nameWithType> Metoda pobiera określonego pola bieżącego <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="_Type.GetFields " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetFields" /> metody.</summary>
        <returns>Tablica <see cref="T:System.Reflection.FieldInfo" /> obiektów reprezentujących pola publiczne zdefiniowane dla bieżącego <see cref="T:System.Type" />.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.FieldInfo" />, jeśli nie ma publicznej pól zdefiniowanych dla bieżącego <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetFields%2A?displayProperty=nameWithType> Metoda zwraca wszystkie publiczne pola bieżącego <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="_Type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" /> metody.</summary>
        <returns>Tablica <see cref="T:System.Reflection.FieldInfo" /> obiekty reprezentujące wszystkie pola zdefiniowane dla bieżącego <see cref="T:System.Type" /> zgodnych ograniczeń w określonym powiązaniu.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.FieldInfo" />, jeśli nie ma pól zdefiniowanych dla bieżącego <see cref="T:System.Type" />, lub jeśli żadne z pól zdefiniowanych być zgodne z ograniczeniami powiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetFields%2A?displayProperty=nameWithType> Wyszukiwanie metody pól zdefiniowanych dla bieżącego <xref:System.Type>, za pomocą ograniczeń w określonym powiązaniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int" Usage="_Type.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetHashCode" /> metody.</summary>
        <returns>
          <see cref="T:System.Int32" /> Zawierające kod skrótu dla tego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetHashCode%2A?displayProperty=nameWithType> Metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIDsOfNames">
      <MemberSignature Language="C#" Value="public void GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId);" />
      <MemberSignature Language="F#" Value="abstract member GetIDsOfNames :  * nativeint * uint32 * uint32 * nativeint -&gt; unit" Usage="_Type.GetIDsOfNames (riid, rgszNames, cNames, lcid, rgDispId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="rgszNames">Przekazana tablica nazw ma być mapowana.</param>
        <param name="cNames">Liczba nazw, które mają być mapowane.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</param>
        <param name="rgDispId">Tablica przydzielana przez obiekt wywołujący, który otrzymuje numery identyfikacyjne odpowiadających nazw.</param>
        <summary>Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetIDsOfNames`, zobacz: Biblioteka MSDN.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="Overload:System.Type.GetInterface" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetInterface%2A?displayProperty=nameWithType> Metoda pobiera określonego interfejsu, zaimplementować lub dziedziczone przez bieżącą <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetInterface(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type" Usage="_Type.GetInterface name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierający nazwę interfejsu, który można pobrać. Interfejsy ogólne to zniekształcone nazwy.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetInterface(System.String)" /> metody.</summary>
        <returns>A <see cref="T:System.Type" /> obiekt reprezentujący interfejs o określonej nazwie zaimplementowana lub dziedziczone przez bieżącą <see cref="T:System.Type" />, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetInterface%2A?displayProperty=nameWithType> Metoda wyszukiwania dla interfejsu o określonej nazwie...  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="_Type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierający nazwę interfejsu, który można pobrać. Interfejsy ogólne to zniekształcone nazwy.</param>
        <param name="ignoreCase">
          <see langword="true" /> Aby wykonać wyszukiwanie bez uwzględniania wielkości liter dla <c>nazwa</c>.  
  
—lub— 
 <see langword="false" /> Aby wykonać wyszukiwanie dla <c>nazwa</c>.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" /> metody.</summary>
        <returns>A <see cref="T:System.Type" /> obiekt reprezentujący interfejs o określonej nazwie zaimplementowana lub dziedziczone przez bieżącą <see cref="T:System.Type" />, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetInterface%2A?displayProperty=nameWithType> Metoda wyszukiwania dla określonego interfejsu, określająca, czy w celu wyszukiwania uwzględniana wielkość liter.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="_Type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">
          <see cref="T:System.Type" /> Interfejsu, z którego mają zostać pobrane mapowanie.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetInterfaceMap(System.Type)" /> metody.</summary>
        <returns>
          <see cref="T:System.Reflection.InterfaceMapping" /> Obiekt reprezentujący mapowania interfejsu dla <paramref name="interfaceType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetInterfaceMap%2A?displayProperty=nameWithType> Metoda zwraca mapowania interfejsu dla typu określonego interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="_Type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetInterfaces" /> metody.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiekty reprezentujące wszystkie interfejsy implementowane lub jest dziedziczona przez bieżący <see cref="T:System.Type" />.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" />, jeśli interfejsy nie są implementowane lub dziedziczone przez bieżącą <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetInterfaces%2A?displayProperty=nameWithType> Metoda pobiera wszystkie interfejsy implementowane lub dziedziczone przez bieżącą <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="Overload:System.Type.GetMember" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetMember%2A?displayProperty=nameWithType> Metoda pobiera określoną członków bieżącej <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="_Type.GetMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierający nazwę publiczne elementy członkowskie można pobrać.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetMember(System.String)" /> metody.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące publiczne elementy członkowskie o określonej nazwie, jeśli je znaleziono; w przeciwnym razie, pusta tablica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetMember%2A?displayProperty=nameWithType> Metoda wyszukuje publiczne elementy członkowskie o określonej nazwie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="_Type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierający nazwę elementy członkowskie można pobrać.</param>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić pustą tablicę.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" /> metody.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące publiczne elementy członkowskie o określonej nazwie, jeśli je znaleziono; w przeciwnym razie, pusta tablica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetMember%2A?displayProperty=nameWithType> Metoda wyszukuje członkowie określonej, za pomocą ograniczeń w określonym powiązaniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="_Type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierający nazwę elementy członkowskie można pobrać.</param>
        <param name="type">
          <see cref="T:System.Reflection.MemberTypes" /> Wartość do wyszukania.</param>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić pustą tablicę.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" /> metody.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące publiczne elementy członkowskie o określonej nazwie, jeśli je znaleziono; w przeciwnym razie, pusta tablica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetMember%2A?displayProperty=nameWithType> Metoda wyszukuje określony elementy członkowskie typu określonego elementu członkowskiego, za pomocą ograniczeń w określonym powiązaniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="Overload:System.Type.GetMembers" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetMembers%2A?displayProperty=nameWithType> Metoda pobiera elementy członkowskie (właściwości, metody, pola, zdarzenia i tak dalej) bieżącego <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="_Type.GetMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetMembers" /> metody.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące wszystkie publiczne elementy członkowskie bieżącego <see cref="T:System.Type" />.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.MemberInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma publicznych elementów członkowskich.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetMembers%2A?displayProperty=nameWithType> Metoda zwraca wszystkie publiczne elementy członkowskie bieżącego <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="_Type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetMembers(System.Reflection.BindingFlags)" /> metody.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące wszystkie elementy członkowskie zdefiniowane dla bieżącego <see cref="T:System.Type" /> zgodnych ograniczeń w określonym powiązaniu.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.MemberInfo" />, jeśli żadne składowe są zdefiniowane dla bieżącego <see cref="T:System.Type" />, lub jeśli żadna z określonych elementów członkowskich ograniczenia wiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetMembers%2A?displayProperty=nameWithType> Metoda wyszukuje elementy członkowskie zdefiniowane dla bieżącego <xref:System.Type>, za pomocą ograniczeń w określonym powiązaniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="Overload:System.Type.GetMethod" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> Metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="_Type.GetMethod name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierający nazwę publicznej metody pobierania.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetMethod(System.String)" /> metody.</summary>
        <returns>A <see cref="T:System.Reflection.MethodInfo" /> obiekt reprezentujący publicznej metody o określonej nazwie, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> Metoda wyszukiwania dla publicznej metody przy użyciu określonej nazwy...  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="_Type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierający nazwę metody pobierania.</param>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" /> metody.</summary>
        <returns>A <see cref="T:System.Reflection.MethodInfo" /> obiekt reprezentujący metodę, która spełnia określone wymagania, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> Metoda wyszukiwania dla określonej metody, za pomocą ograniczeń w określonym powiązaniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="_Type.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierający nazwę publicznej metody pobierania.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla metody, aby uzyskać.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie metodę, która nie przyjmuje żadnych parametrów.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetMethod(System.String,System.Type[])" /> metody.</summary>
        <returns>A <see cref="T:System.Reflection.MethodInfo" /> obiekt reprezentujący publicznej metody, której parametry pasują do typów określonego argumentu, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> Metoda wyszukiwania dla określonej metody publiczne, której parametry pasuje określone typy argumentów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="_Type.GetMethod (name, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierający nazwę publicznej metody pobierania.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla metody, aby uzyskać.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie metodę, która nie przyjmuje żadnych parametrów.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <c>typy</c> tablicy. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" /> metody.</summary>
        <returns>A <see cref="T:System.Reflection.MethodInfo" /> obiekt reprezentujący metodę publiczną, która spełnia określone wymagania, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> Metoda wyszukiwania dla określonej metody publiczne, której parametry odpowiadają określone typy argumentów i modyfikatorów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="_Type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierający nazwę metody pobierania.</param>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <param name="binder">A <see cref="T:System.Reflection.Binder" /> obiekt, który definiuje zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
 <see langword="null" />, aby użyć <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla metody, aby uzyskać.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie metodę, która nie przyjmuje żadnych parametrów.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <c>typy</c> tablicy. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" /> metody.</summary>
        <returns>A <see cref="T:System.Reflection.MethodInfo" /> obiekt reprezentujący metodę, która spełnia określone wymagania, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> Metoda wyszukiwania dla określonej metody, której parametry odpowiadają określone typy argumentów i modyfikatorów, za pomocą ograniczeń w określonym powiązaniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="_Type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierający nazwę metody pobierania.</param>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <param name="binder">A <see cref="T:System.Reflection.Binder" /> obiekt, który definiuje zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
 <see langword="null" />, aby użyć <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">
          <see cref="T:System.Reflection.CallingConventions" /> Obiekt, który określa zestaw reguł dotyczących kolejności i układ argumentów, jak wartość zwracana jest przekazywana, jakie rejestrów są używane dla argumentów i jak stos jest czyszczony.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla metody, aby uzyskać.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie metodę, która nie przyjmuje żadnych parametrów.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <c>typy</c> tablicy. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> metody.</summary>
        <returns>A <see cref="T:System.Reflection.MethodInfo" /> obiekt reprezentujący metodę, która spełnia określone wymagania, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> Metoda wyszukiwania dla określonej metody, której parametry odpowiadają określone typy argumentów i modyfikatorów, za pomocą ograniczeń w określonym powiązaniu i określonej konwencji wywoływania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="Overload:System.Type.GetMethods" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetMethods%2A?displayProperty=nameWithType> Metoda pobiera metody bieżącego <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="_Type.GetMethods " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetMethods" /> metody.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MethodInfo" /> obiekty reprezentujące wszystkie metody publiczne zdefiniowane dla bieżącego <see cref="T:System.Type" />.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.MethodInfo" />, jeśli nie metody publiczne są zdefiniowane dla bieżącego <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetMethods%2A?displayProperty=nameWithType> Metoda zwraca wszystkie metody publiczne bieżącego <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="_Type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" /> metody.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MethodInfo" /> obiekty reprezentujące wszystkie metody zdefiniowane dla bieżącego <see cref="T:System.Type" /> zgodnych ograniczeń w określonym powiązaniu.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.MethodInfo" />, jeśli nie metody są zdefiniowane dla bieżącego <see cref="T:System.Type" />, lub jeśli żadna z metody zdefiniowane ograniczenia wiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetMethods%2A?displayProperty=nameWithType> Metoda wyszukuje metody zdefiniowane dla bieżącego <xref:System.Type>, za pomocą ograniczeń w określonym powiązaniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="Overload:System.Type.GetNestedType" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetNestedType%2A?displayProperty=nameWithType> Metoda pobiera określonego typu zagnieżdżone w obrębie bieżącego <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type" Usage="_Type.GetNestedType name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę typu zagnieżdżonego, aby uzyskać.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetNestedType(System.String)" /> metody.</summary>
        <returns>A <see cref="T:System.Type" /> obiekt reprezentujący publicznego typu zagnieżdżonego o określonej nazwie, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetNestedType%2A?displayProperty=nameWithType> Metoda wyszukiwania dla publicznego typu zagnieżdżonego o określonej nazwie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="_Type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę typu zagnieżdżonego, aby uzyskać.</param>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" /> metody.</summary>
        <returns>A <see cref="T:System.Type" /> obiekt reprezentujący typ zagnieżdżony, która spełnia określone wymagania, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetNestedType%2A?displayProperty=nameWithType> Metoda wyszukiwania dla określonego typu zagnieżdżonego, za pomocą ograniczeń w określonym powiązaniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="Overload:System.Type.GetNestedTypes" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetNestedTypes%2A?displayProperty=nameWithType> Metoda pobiera typy zagnieżdżone w obrębie bieżącego <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]" Usage="_Type.GetNestedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetNestedTypes" /> metody.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiekty reprezentujące wszystkie typy zagnieżdżone w obrębie bieżącego <see cref="T:System.Type" />.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" />, jeśli żaden z typów są zagnieżdżone w obrębie bieżącego <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetNestedTypes%2A?displayProperty=nameWithType> Metoda zwraca wszystkie typy zagnieżdżone w obrębie bieżącego <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="_Type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <summary>Udostępnia obiekty COM niezależny od wersji dostęp do <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" /> metoda i wyszukuje typy zagnieżdżone w obrębie bieżącego <see cref="T:System.Type" />, za pomocą ograniczeń w określonym powiązaniu.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiekty reprezentujące wszystkie typy zagnieżdżone w obrębie bieżącego <see cref="T:System.Type" /> zgodnych ograniczeń w określonym powiązaniu.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" />, jeśli żaden z typów są zagnieżdżone w obrębie bieżącego <see cref="T:System.Type" />, lub jeśli żadna z zagnieżdżone typy ograniczenia wiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="Overload:System.Type.GetProperties" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> Metoda pobiera właściwości bieżącego <xref:System.Type>...  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="_Type.GetProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetProperties" /> metody.</summary>
        <returns>Tablica <see cref="T:System.Reflection.PropertyInfo" /> obiekty reprezentujące wszystkie publiczne właściwości bieżącego <see cref="T:System.Type" />.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.PropertyInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma właściwości publiczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> Metoda zwraca wszystkie publiczne właściwości bieżącego <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="_Type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" /> metody.</summary>
        <returns>Tablica <see cref="T:System.Reflection.PropertyInfo" /> obiekty reprezentujące wszystkie właściwości bieżącego <see cref="T:System.Type" /> zgodnych ograniczeń w określonym powiązaniu.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.PropertyInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma właściwości, lub jeśli żadna z właściwości ograniczenia wiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> Metoda wyszukiwania dla właściwości bieżącego <xref:System.Type>, za pomocą ograniczeń w określonym powiązaniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="Overload:System.Type.GetProperty" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> Metoda pobiera określoną właściwość bieżącego <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="_Type.GetProperty name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierający nazwę właściwości publicznej do pobrania.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetProperty(System.String)" /> metody.</summary>
        <returns>A <see cref="T:System.Reflection.PropertyInfo" /> obiekt reprezentujący właściwość publiczną o określonej nazwie, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> Metoda wyszukiwania dla właściwości publicznej przy użyciu określonej nazwy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="_Type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierający nazwę właściwości do pobrania.</param>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" /> metody.</summary>
        <returns>A <see cref="T:System.Reflection.PropertyInfo" /> obiekt reprezentujący właściwość, która spełnia określone wymagania, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> Metoda wyszukiwania dla określonej właściwości, za pomocą ograniczeń w określonym powiązaniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="_Type.GetProperty (name, returnType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierający nazwę właściwości publicznej do pobrania.</param>
        <param name="returnType">Zwracany typ właściwości.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetProperty(System.String,System.Type)" /> metody.</summary>
        <returns>A <see cref="T:System.Reflection.PropertyInfo" /> obiekt reprezentujący właściwość publiczną o określonej nazwie, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> Metoda wyszukuje właściwość publiczną o określonej nazwie i typ zwracany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="_Type.GetProperty (name, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierający nazwę właściwości publicznej do pobrania.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów właściwości indeksowanej, aby uzyskać.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie właściwości, która nie jest indeksowana.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetProperty(System.String,System.Type[])" /> metody.</summary>
        <returns>A <see cref="T:System.Reflection.PropertyInfo" /> obiekt reprezentujący właściwość publiczną, której parametry pasują do typów określonego argumentu, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> Metoda wyszukiwania dla określonej właściwości publiczne, której parametry pasuje określone typy argumentów...  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="_Type.GetProperty (name, returnType, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierający nazwę właściwości publicznej do pobrania.</param>
        <param name="returnType">Zwracany typ właściwości.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów właściwości indeksowanej, aby uzyskać.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie właściwości, która nie jest indeksowana.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" /> metody.</summary>
        <returns>A <see cref="T:System.Reflection.PropertyInfo" /> obiekt reprezentujący właściwość publiczną, której parametry pasują do typów określonego argumentu, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> Metoda wyszukiwania dla określonej właściwości publiczne, której parametry pasuje określone typy argumentów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="_Type.GetProperty (name, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierający nazwę właściwości publicznej do pobrania.</param>
        <param name="returnType">Zwracany typ właściwości.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów właściwości indeksowanej, aby uzyskać.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie właściwości, która nie jest indeksowana.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <c>typy</c> tablicy. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" /> metody.</summary>
        <returns>A <see cref="T:System.Reflection.PropertyInfo" /> obiekt reprezentujący właściwość publiczną, która spełnia określone wymagania, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> Metoda wyszukiwania dla określonej właściwości publiczne, której parametry odpowiadają określone typy argumentów i modyfikatorów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="_Type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierający nazwę właściwości do pobrania.</param>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <param name="binder">A <see cref="T:System.Reflection.Binder" /> obiekt, który definiuje zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
 <see langword="null" />, aby użyć <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="returnType">Zwracany typ właściwości.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów właściwości indeksowanej, aby uzyskać.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie właściwości, która nie jest indeksowana.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <c>typy</c> tablicy. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" /> metody.</summary>
        <returns>A <see cref="T:System.Reflection.PropertyInfo" /> obiekt reprezentujący właściwość, która spełnia określone wymagania, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> Metoda wyszukiwania dla określonej właściwości, której parametry odpowiadają określone typy argumentów i modyfikatorów, za pomocą ograniczeń w określonym powiązaniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="abstract member GetType : unit -&gt; Type" Usage="_Type.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.GetType" /> metody.</summary>
        <returns>Bieżący <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GetType%2A?displayProperty=nameWithType> Metoda pobiera bieżący <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeInfo">
      <MemberSignature Language="C#" Value="public void GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeInfo : uint32 * uint32 * nativeint -&gt; unit" Usage="_Type.GetTypeInfo (iTInfo, lcid, ppTInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informacje o typie, który będzie zwracany.</param>
        <param name="lcid">Identyfikator regionalny dla informacji o typie.</param>
        <param name="ppTInfo">Otrzymuje wskaźnik do obiektu informacji żądanego typu.</param>
        <summary>Pobiera informacje o typie dla obiektu, których następnie można użyć do uzyskania informacji o typie interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfo`, zobacz: Biblioteka MSDN.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeInfoCount">
      <MemberSignature Language="C#" Value="public void GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetTypeInfoCount (ByRef pcTInfo As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeInfoCount :  -&gt; unit" Usage="_Type.GetTypeInfoCount pcTInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Wskazuje lokalizację, która odbiera informację o liczbie typów dostarczanych przez obiekt.</param>
        <summary>Pobiera informację o liczbie typów interfejsów, jakie zawiera obiekt (0 lub 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfoCount`, zobacz: Biblioteka MSDN.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Runtime.InteropServices._Type.GUID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.GUID" /> właściwości.</summary>
        <value>Identyfikator GUID skojarzony z <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.GUID%2A?displayProperty=nameWithType> Właściwości pobiera identyfikator GUID skojarzony z <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Runtime.InteropServices._Type.HasElementType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.HasElementType" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest tablicą, wskaźnik, lub jest przekazywany przez odwołanie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.HasElementType%2A?displayProperty=nameWithType> Właściwości  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="F#" Value="abstract member Invoke : uint32 *  * uint32 * int16 * nativeint * nativeint * nativeint * nativeint -&gt; unit" Usage="_Type.Invoke (dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Określa element członkowski.</param>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</param>
        <param name="wFlags">Flagi opisujące kontekst wywołania.</param>
        <param name="pDispParams">Wskaźnik do struktury zawiera tablicę argumentów, tablicę identyfikatorów DISPID argumentu dla nazwanych argumentów i zlicza liczbę elementów w tablicach.</param>
        <param name="pVarResult">Wskaźnik miejsca, gdzie ma być przechowywany wynik.</param>
        <param name="pExcepInfo">Wskaźnik do struktury, która zawiera informacje o wyjątku.</param>
        <param name="puArgErr">Indeks pierwszego argumentu, który zawiera błąd.</param>
        <summary>Umożliwia dostęp do właściwości i metod udostępnianych przez obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::Invoke`, zobacz: Biblioteka MSDN.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="Overload:System.Type.InvokeMember" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> Metoda wywołuje określonego członka bieżącego <xref:System.Type>.  
  
 .  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="_Type.InvokeMember (name, invokeAttr, binder, target, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierający nazwę konstruktora, metody, właściwości lub pól członka do wywołania.  
  
—lub— 
Ciąg pusty ("") do wywołania domyślny element członkowski.  
  
—lub— 
W przypadku członków IDispatch, ciąg reprezentujący identyfikator DispID, na przykład "[identyfikator DispID = 3]".</param>
        <param name="invokeAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie. Dostęp może być jednym z <see langword="BindingFlags" /> takich jak <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />i tak dalej. Typ wyszukiwania nie muszą być określane. W przypadku pominięcia typ wyszukiwania <see langword="BindingFlags.Public" />  |  <see langword="BindingFlags.Instance" /> zostaną zastosowane.</param>
        <param name="binder">A <see cref="T:System.Reflection.Binder" /> obiekt, który definiuje zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
 <see langword="null" />, aby użyć <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="target">
          <see cref="T:System.Object" /> Do wywołania określonego elementu członkowskiego.</param>
        <param name="args">Tablica zawierająca argumenty do przekazania do składowej na potrzeby wywołania.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" /> metody.</summary>
        <returns>
          <see cref="T:System.Object" /> Reprezentujący wartość zwracaną wywołanego elementu członkowskiego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> Metoda wywołuje określony element członkowski przy użyciu określonego powiązania ograniczeń i dopasowywanie określoną listę argumentów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="_Type.InvokeMember (name, invokeAttr, binder, target, args, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierający nazwę konstruktora, metody, właściwości lub pól członka do wywołania.  
  
—lub— 
Ciąg pusty ("") do wywołania domyślny element członkowski.  
  
—lub— 
W przypadku członków IDispatch, ciąg reprezentujący identyfikator DispID, na przykład "[identyfikator DispID = 3]".</param>
        <param name="invokeAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie. Dostęp może być jednym z <see langword="BindingFlags" /> takich jak <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />i tak dalej. Typ wyszukiwania nie muszą być określane. W przypadku pominięcia typ wyszukiwania <see langword="BindingFlags.Public" />  |  <see langword="BindingFlags.Instance" /> zostaną zastosowane.</param>
        <param name="binder">A <see cref="T:System.Reflection.Binder" /> obiekt, który definiuje zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
 <see langword="null" />, aby użyć <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="target">
          <see cref="T:System.Object" /> Do wywołania określonego elementu członkowskiego.</param>
        <param name="args">Tablica zawierająca argumenty do przekazania do składowej na potrzeby wywołania.</param>
        <param name="culture">
          <see cref="T:System.Globalization.CultureInfo" /> Obiekt reprezentujący globalizacji ustawienia regionalne, które mogą być konieczne w przypadku konwersji specyficzne dla ustawień regionalnych, takich jak konwertowanie ciągów liczbowych na wartość o podwójnej precyzji.  
  
—lub— 
 <see langword="null" /> Aby użyć bieżącego wątku <see cref="T:System.Globalization.CultureInfo" />.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" /> metody.</summary>
        <returns>
          <see cref="T:System.Object" /> Reprezentujący wartość zwracaną wywołanego elementu członkowskiego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> Metoda wywołuje określony element członkowski przy użyciu określonego powiązania ograniczeń i dopasowywanie określoną listę argumentów i kultury.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="_Type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierający nazwę konstruktora, metody, właściwości lub pól członka do wywołania.  
  
—lub— 
Ciąg pusty ("") do wywołania domyślny element członkowski.  
  
—lub— 
W przypadku członków IDispatch, ciąg reprezentujący identyfikator DispID, na przykład "[identyfikator DispID = 3]".</param>
        <param name="invokeAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie. Dostęp może być jednym z <see langword="BindingFlags" /> takich jak <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />i tak dalej. Typ wyszukiwania nie muszą być określane. W przypadku pominięcia typ wyszukiwania <see langword="BindingFlags.Public" />  |  <see langword="BindingFlags.Instance" /> zostaną zastosowane.</param>
        <param name="binder">A <see cref="T:System.Reflection.Binder" /> obiekt, który definiuje zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
 <see langword="null" />, aby użyć <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="target">
          <see cref="T:System.Object" /> Do wywołania określonego elementu członkowskiego.</param>
        <param name="args">Tablica zawierająca argumenty do przekazania do składowej na potrzeby wywołania.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <c>args</c> tablicy. Parametr skojarzonych z nimi atrybutów są przechowywane w podpisie elementu członkowskiego. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <param name="culture">
          <see cref="T:System.Globalization.CultureInfo" /> Obiekt reprezentujący globalizacji ustawienia regionalne, które mogą być konieczne w przypadku konwersji specyficzne dla ustawień regionalnych, takich jak konwertowanie ciągów liczbowych na wartość o podwójnej precyzji.  
  
—lub— 
 <see langword="null" /> Aby użyć bieżącego wątku <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="namedParameters">Tablica zawierająca nazwy parametrów, do której wartości w <c>args</c> tablicy są przekazywane.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> metody.</summary>
        <returns>
          <see cref="T:System.Object" /> Reprezentujący wartość zwracaną wywołanego elementu członkowskiego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> Metoda wywołuje określony element członkowski przy użyciu określonego powiązania ograniczeń i dopasowywanie określoną listę argumentów, Modyfikatory i kultury.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Runtime.InteropServices._Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsAbstract" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest abstrakcyjna; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsAbstract%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy <xref:System.Type> jest abstrakcyjny i musi zostać zastąpiona.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Runtime.InteropServices._Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsAnsiClass" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli ciąg formatu atrybut <see langword="AnsiClass" /> wybrano <see cref="T:System.Type" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsAnsiClass%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy ciąg formatu atrybut `AnsiClass` wybrano <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Runtime.InteropServices._Type.IsArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsArray" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest tablicą, a w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsArray%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy <xref:System.Type> jest tablicą.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool" Usage="_Type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">
          <see cref="T:System.Type" /> Do porównania z bieżącym <see cref="T:System.Type" />.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> metody.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> i bieżący <see cref="T:System.Type" /> reprezentują ten sam typ, lub, jeśli bieżący <see cref="T:System.Type" /> znajduje się w hierarchii dziedziczenia <paramref name="c" />, lub, jeśli bieżący <see cref="T:System.Type" /> jest interfejsem, <paramref name="c" /> implementuje, lub jeśli <paramref name="c" />jest parametr typu ogólnego i bieżący <see cref="T:System.Type" /> reprezentuje jeden ograniczenia <paramref name="c" />. <see langword="false" /> Jeśli żaden z tych warunków nie jest tak lub <paramref name="c" /> jest <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Runtime.InteropServices._Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsAutoClass" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli ciąg formatu atrybut <see langword="AutoClass" /> wybrano <see cref="T:System.Type" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsAutoClass%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy ciąg formatu atrybut `AutoClass` wybrano <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Runtime.InteropServices._Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsAutoLayout" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli atrybut class układ <see langword="AutoLayout" /> wybrano <see cref="T:System.Type" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsAutoLayout%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy atrybut układ klasy `AutoLayout` wybrano <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Runtime.InteropServices._Type.IsByRef" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsByRef" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest przekazywany przez odwołanie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsByRef%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy <xref:System.Type> jest przekazywany przez odwołanie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Runtime.InteropServices._Type.IsClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsClass" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest klasą; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsClass%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy <xref:System.Type> klasy; oznacza to, że nie jest typem wartości lub interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Runtime.InteropServices._Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsCOMObject" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest obiektem COM; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsCOMObject%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy <xref:System.Type> jest obiektem COM.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Runtime.InteropServices._Type.IsContextful" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsContextful" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> może być hostowana w kontekście, w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsContextful%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy <xref:System.Type> może znajdować się w kontekście.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member IsDefined : Type * bool -&gt; bool" Usage="_Type.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <see langword="Type" /> Obiektu, dla których są stosowane atrybuty niestandardowe.</param>
        <param name="inherit">Określa, czy przeszukać łańcuch dziedziczenia tego elementu członkowskiego w celu znalezienia atrybutów.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> metody.</summary>
        <returns>
          <see langword="true" /> Jeśli jeden lub więcej wystąpienie <paramref name="attributeType" /> jest zastosowany do tego elementu członkowskiego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Reflection.MemberInfo.IsDefined%2A?displayProperty=nameWithType> Metoda wskazuje, czy jeden lub więcej wystąpienie `attributeType` jest stosowany do tego elementu członkowskiego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Runtime.InteropServices._Type.IsEnum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsEnum" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący <see cref="T:System.Type" /> reprezentuje wyliczenia; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsEnum%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy bieżący <xref:System.Type> reprezentuje wyliczenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Runtime.InteropServices._Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsExplicitLayout" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli atrybut class układ <see langword="ExplicitLayout" /> wybrano <see cref="T:System.Type" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsExplicitLayout%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy atrybut układ klasy `ExplicitLayout` wybrano <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Runtime.InteropServices._Type.IsImport" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsImport" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> ma <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsImport%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy <xref:System.Type> ma <xref:System.Runtime.InteropServices.ComImportAttribute>, wskazujący, że został zaimportowany z biblioteki typów COM.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool" Usage="_Type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Obiekt do porównania z bieżącym <see cref="T:System.Type" />.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.IsInstanceOfType(System.Object)" /> metody.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący <see cref="T:System.Type" /> znajduje się w hierarchii dziedziczenia obiektu reprezentowanego przez <paramref name="o" />, lub, jeśli bieżący <see cref="T:System.Type" /> jest interfejsem, <paramref name="o" /> obsługuje. <see langword="false" /> Jeśli żadna z tych warunków jest przypadek, lub jeśli <paramref name="o" /> jest <see langword="null" />, lub, jeśli bieżący <see cref="T:System.Type" /> jest to otwarty typ ogólny (oznacza to, <see cref="P:System.Type.ContainsGenericParameters" /> zwraca <see langword="true" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsInstanceOfType%2A?displayProperty=nameWithType> Metoda określa, czy określony obiekt jest wystąpieniem bieżącego <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Runtime.InteropServices._Type.IsInterface" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsInterface" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest interfejsem; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsInterface%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy <xref:System.Type> interfejsu; nie jest klasą lub typu wartości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Runtime.InteropServices._Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsLayoutSequential" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli atrybut class układ <see langword="SequentialLayout" /> wybrano <see cref="T:System.Type" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsLayoutSequential%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy atrybut układ klasy `SequentialLayout` wybrano <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Runtime.InteropServices._Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsMarshalByRef" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest organizowane przez odwołanie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsMarshalByRef%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą, czy typ jest przekazywany przez odwołanie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Runtime.InteropServices._Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsNestedAssembly" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zagnieżdżony i widoczne tylko w ramach ich własnych zestawach; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsNestedAssembly%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy <xref:System.Type> jest zagnieżdżony i są widoczne tylko w ramach ich własnych zestawach.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Runtime.InteropServices._Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsNestedFamANDAssem" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zagnieżdżony i widoczne tylko dla klas, które należą do jego własnej rodzinę i swój własny zestaw; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsNestedFamANDAssem%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy <xref:System.Type> jest zagnieżdżony i są widoczne tylko dla klas, które należą do jego własnej rodzinę i swój własny zestaw.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Runtime.InteropServices._Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsNestedFamily" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zagnieżdżony i widoczne tylko w obrębie własnej rodziny; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsNestedFamily%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy <xref:System.Type> jest zagnieżdżony i są widoczne tylko w obrębie własnej rodziny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Runtime.InteropServices._Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsNestedFamORAssem" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zagnieżdżony i widoczne tylko dla klas, które należą do jego własnej rodziny lub ich własnych zestawach; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsNestedFamORAssem%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy <xref:System.Type> jest zagnieżdżony i są widoczne tylko dla klas, które należą do jednej swój własny rodziny i swój własny zestaw.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Runtime.InteropServices._Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsNestedPrivate" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zagnieżdżony i zadeklarować prywatny; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsNestedPrivate%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy <xref:System.Type> jest zagnieżdżony, a następnie deklarować prywatnych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Runtime.InteropServices._Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsNestedPublic" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli klasa jest publiczny zagnieżdżony i zadeklarowane; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsNestedPublic%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą, czy klasa jest zagnieżdżone i zadeklarowana publicznych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Runtime.InteropServices._Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsNotPublic" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli najwyższego poziomu <see cref="T:System.Type" /> nie jest zadeklarowany jako publiczny; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsNotPublic%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy najwyższego poziomu <xref:System.Type> nie jest zadeklarowany jako publiczny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Runtime.InteropServices._Type.IsPointer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsPointer" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest wskaźnikiem typu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsPointer%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy <xref:System.Type> jest wskaźnikiem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Runtime.InteropServices._Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsPrimitive" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest jednym z typów pierwotnych; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsPrimitive%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy <xref:System.Type> jest jednym z typów pierwotnych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Runtime.InteropServices._Type.IsPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsPublic" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli najwyższego poziomu <see cref="T:System.Type" /> jest zadeklarowany jako publiczny; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsPublic%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy najwyższego poziomu <xref:System.Type> jest zadeklarowany jako publiczny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Runtime.InteropServices._Type.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsSealed" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zadeklarowany jako sealed; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsSealed%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy <xref:System.Type> jest zadeklarowany jako zapieczętowany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Runtime.InteropServices._Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsSerializable" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest możliwy do serializacji; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsSerializable%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy <xref:System.Type> jest możliwy do serializacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Runtime.InteropServices._Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsSpecialName" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> ma nazwę, która wymaga specjalnej obsługi; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsSpecialName%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy <xref:System.Type> ma nazwę, która wymaga specjalnej obsługi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool" Usage="_Type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">
          <see cref="T:System.Type" /> Do porównania z bieżącym <see cref="T:System.Type" />.</param>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.IsSubclassOf(System.Type)" /> metody.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> reprezentowany przez <paramref name="c" /> parametru i bieżący <see cref="T:System.Type" /> reprezentują klasy i klasa przedstawiana przez bieżącą <see cref="T:System.Type" /> pochodzi od klasy reprezentowane przez <paramref name="c" />; w przeciwnym razie <see langword="false" />. Ta metoda zwraca też wartość <see langword="false" /> Jeśli <paramref name="c" /> i bieżący <see cref="T:System.Type" /> reprezentowania tej samej klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsSubclassOf%2A?displayProperty=nameWithType> Metoda określa, czy klasa jest reprezentowany przez bieżącą <xref:System.Type> pochodzi od klasy reprezentowane przez określony <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Runtime.InteropServices._Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsUnicodeClass" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli ciąg formatu atrybut <see langword="UnicodeClass" /> wybrano <see cref="T:System.Type" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsUnicodeClass%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy ciąg formatu atrybut `UnicodeClass` wybrano <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Runtime.InteropServices._Type.IsValueType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.IsValueType" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest typem wartości; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.IsValueType%2A?displayProperty=nameWithType> Właściwości pobiera wartość wskazującą czy <xref:System.Type> jest typem wartości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Runtime.InteropServices._Type.MemberType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.MemberType" /> właściwości.</summary>
        <value>A <see cref="T:System.Reflection.MemberTypes" /> wartość wskazującą, czy ten element członkowski jest typem lub typu zagnieżdżonego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.MemberType%2A?displayProperty=nameWithType> Pobiera właściwość <xref:System.Reflection.MemberTypes> wartość wskazującą, czy ten element członkowski jest typem lub typu zagnieżdżonego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Runtime.InteropServices._Type.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.Module" /> właściwości.</summary>
        <value>Nazwa modułu, w którym bieżącego <see cref="T:System.Type" /> jest zdefiniowana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.Module%2A?displayProperty=nameWithType> Właściwości pobiera modułu (DLL), w którym bieżącego <xref:System.Type> jest zdefiniowana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.InteropServices._Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Reflection.MemberInfo.Name" /> właściwości.</summary>
        <value>Nazwa <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Reflection.MemberInfo.Name%2A?displayProperty=nameWithType> Właściwości pobiera nazwę <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Runtime.InteropServices._Type.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.Namespace" /> właściwości.</summary>
        <value>Przestrzeń nazw <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.Namespace%2A?displayProperty=nameWithType> Właściwości pobiera obszar nazw <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Runtime.InteropServices._Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.ReflectedType" /> właściwości.</summary>
        <value>
          <see cref="T:System.Type" /> Obiektu za pomocą którego należy to <see cref="T:System.Reflection.MemberInfo" /> obiekt został uzyskany.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.ReflectedType%2A?displayProperty=nameWithType> Właściwości powoduje pobranie obiektu klasy, który został użyty do uzyskania tego elementu członkowskiego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices._Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string" Usage="_Type.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="M:System.Type.ToString" /> metody.</summary>
        <returns>A <see cref="T:System.String" /> reprezentujący nazwę bieżącego <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.ToString%2A?displayProperty=nameWithType> Metoda zwraca nazwę bieżącego <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Runtime.InteropServices._Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.TypeHandle" /> właściwości.</summary>
        <value>Dojście do bieżącego <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.TypeHandle%2A?displayProperty=nameWithType> Właściwości pobiera uchwyt dla bieżącego <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Runtime.InteropServices._Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.TypeInitializer" /> właściwości.</summary>
        <value>A <see cref="T:System.Reflection.ConstructorInfo" /> zawierający nazwę Konstruktor klasy <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.TypeInitializer%2A?displayProperty=nameWithType> Właściwości pobiera inicjator dla <xref:System.Type>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices._Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Runtime.InteropServices._Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia niezależny od wersji dostęp do obiektów COM <see cref="P:System.Type.UnderlyingSystemType" /> właściwości.</summary>
        <value>Podstawowy typ systemu <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy dostępu do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.  
  
 <xref:System.Type.UnderlyingSystemType%2A?displayProperty=nameWithType> Właściwość wskazuje typ dostarczane przez środowisko uruchomieniowe języka wspólnego reprezentujący tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="StructLayoutAttribute" FullName="System.Runtime.InteropServices.StructLayoutAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="40521d9554f0cf59a81ca8f000f7fb5aa654a557" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30564538" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class StructLayoutAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit StructLayoutAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.StructLayoutAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StructLayoutAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class StructLayoutAttribute sealed : Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Umożliwia sterowanie fizyczny układ pól danych klasy lub struktury w pamięci.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten atrybut można stosować do klasy lub struktury.  
  
 Środowisko uruchomieniowe języka wspólnego określa fizyczny układ pól danych klasy lub struktury w pamięci zarządzanej. Jednak jeśli chcesz przekazać typ do kodu niezarządzanego, można użyć <xref:System.Runtime.InteropServices.StructLayoutAttribute> atrybut do sterowania układem niezarządzanego typu. Użyj atrybutu z <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> wymusić członkowie mają być określone sekwencyjnie w kolejności ich występowania. <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> Steruje zarówno układu w pamięci zarządzanej i układu w pamięci niezarządzanej. Dla typów niekopiowalne kontroluje układ klasy lub struktury jest przekazywane do kodu niezarządzanego, ale nie kontroluje układ w pamięci zarządzanej. Użyj atrybutu z <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> do kontrolowania dokładności dla każdego elementu członkowskiego danych. Ma to wpływ na układ zarządzane i niezarządzane, dla typów zarówno kopiowalne i niekopiowalne. Przy użyciu <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> wymaga użycia <xref:System.Runtime.InteropServices.FieldOffsetAttribute> atrybutu, aby wskazać położenie każdego pola w ramach typu.  
  
 Kompilatory języka C#, Visual Basic i C++ zastosować <xref:System.Runtime.InteropServices.LayoutKind.Sequential> wartość układu struktur domyślnie. Dla klas, należy najpierw zastosować <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> jawnie wartości. [Tlbimp.exe (Importer biblioteki typów)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) ma również zastosowanie <xref:System.Runtime.InteropServices.StructLayoutAttribute> atrybutu; dotyczy zawsze <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> wartości podczas importowania biblioteki typów.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano zarządzanych deklarację `GetSystemTime` funkcji i definiuje `MySystemTime` klasy z <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> układu. `GetSystemTime` pobiera czas systemowy i drukowanie do konsoli.  
  
 [!code-cpp[StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/StructLayoutAttribute/CPP/structlayoutattribute.cpp#1)]
 [!code-csharp[StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/StructLayoutAttribute/CS/structlayoutattribute.cs#1)]
 [!code-vb[StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StructLayoutAttribute/VB/structlayoutattribute.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initalizes nowe wystąpienie elementu <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StructLayoutAttribute (short layoutKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int16 layoutKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (layoutKind As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StructLayoutAttribute(short layoutKind);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="layoutKind" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="layoutKind">16-bitową liczbę całkowitą, który reprezentuje jeden z <see cref="T:System.Runtime.InteropServices.LayoutKind" /> wartości tego Określa, jak powinny być rozmieszczane klasy lub struktury.</param>
        <summary>Initalizes nowe wystąpienie elementu <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> klasy z określonym <see cref="T:System.Runtime.InteropServices.LayoutKind" /> element członkowski wyliczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor ma podstawowej 16-bitową liczbę całkowitą reprezentującą każdego <xref:System.Runtime.InteropServices.LayoutKind> element członkowski wyliczenia. [Tlbimp.exe (Importer biblioteki typów)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) używa tego konstruktora.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.LayoutKind" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StructLayoutAttribute (System.Runtime.InteropServices.LayoutKind layoutKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Runtime.InteropServices.LayoutKind layoutKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Runtime.InteropServices.LayoutKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StructLayoutAttribute(System::Runtime::InteropServices::LayoutKind layoutKind);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="layoutKind" Type="System.Runtime.InteropServices.LayoutKind" />
      </Parameters>
      <Docs>
        <param name="layoutKind">Jedną z wyliczenia wartości tego Określa, jak powinny być rozmieszczane klasy lub struktury.</param>
        <summary>Initalizes nowe wystąpienie elementu <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> klasy z określonym <see cref="T:System.Runtime.InteropServices.LayoutKind" /> element członkowski wyliczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czytelny kod jest mniej podatne na błędy należy zawsze używać tego konstruktora.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.LayoutKind" />
      </Docs>
    </Member>
    <Member MemberName="CharSet">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CharSet CharSet;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CharSet CharSet" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.StructLayoutAttribute.CharSet" />
      <MemberSignature Language="VB.NET" Value="Public CharSet As CharSet " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CharSet CharSet;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CharSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy ciąg pola danych w ramach klasy powinny zostać zorganizowany jako <see langword="LPWSTR" /> lub <see langword="LPSTR" /> domyślnie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `CharSet` pole jest ustawione na <xref:System.Runtime.InteropServices.CharSet.Unicode?displayProperty=nameWithType>, wszystkie argumenty typu string są konwertowane na znaki Unicode (`LPWSTR`) przed są one przekazywane do niezarządzanego implementacji. Jeśli pole jest ustawione na <xref:System.Runtime.InteropServices.CharSet.Ansi?displayProperty=nameWithType>, ciągi są konwertowane na ciągów ANSI (`LPSTR`). Jeśli `CharSet` pole jest ustawione na <xref:System.Runtime.InteropServices.CharSet.Auto?displayProperty=nameWithType>, konwersja jest zależny od platformy (ANSI Windows 98 i Windows Me i Unicode w nowszych wersjach).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.CharSet" />
      </Docs>
    </Member>
    <Member MemberName="Pack">
      <MemberSignature Language="C#" Value="public int Pack;" />
      <MemberSignature Language="ILAsm" Value=".field public int32 Pack" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack" />
      <MemberSignature Language="VB.NET" Value="Public Pack As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: int Pack;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa wyrównanie pola danych klasy lub struktury w pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> Pole określa wyrównanie pola typu w pamięci.  Ma to wpływ na obu <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> i <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType>. Domyślnie wartość to 0, co oznacza domyślny rozmiar dla bieżącej platformy pakowania. Wartość <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> musi być 0, 1, 2, 4, 8, 16, 32, 64 lub 128:  
  
 Pola wystąpienia typu są wyrównane za pomocą następujących reguł:  
  
-   Wyrównanie typu jest większy niż jego największy element (1, 2, 4, 8, itd., bajtów) lub pakowania określony rozmiar, w zależności od jest mniejszy.  
  
-   Każdego pola muszą być wyrównane z polami własny rozmiar (1, 2, 4, 8, itd., bajtów) lub wyrównaniem tekstu, zależności jest mniejsza.  Ponieważ domyślne wyrównanie typu jest rozmiarem największy element, który jest większa niż lub równa długości wszystkich innych pól, to zwykle oznacza to, że pola są wyrównane według ich rozmiaru. Na przykład, nawet jeśli pole największy w typie jest 64-bitowa liczba całkowita (8-bajtowych) lub z dodatkiem Service Pack pola jest równa 8, <xref:System.Byte> pól Dopasuj przy 1-bajtowych granicach <xref:System.Int16> pól Dopasuj przy 2-bajtowych granicach i <xref:System.Int32> pola Dopasuj przy 4-bajtowych granicach.  
  
-   Dopełnienie dodawany jest odstęp pola, aby spełnić wymagania dotyczące wyrównywania.  
  
 Na przykład, należy wziąć pod uwagę następujące struktury, która składa się z dwóch <xref:System.Byte> pól i jeden <xref:System.Int32> pola, gdy jest używany z różnych wartości <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> pola.  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex0.cs#1)]  
  
> [!IMPORTANT]
>  Aby pomyślnie skompilować przykłady C#, należy określić `/unsafe` przełącznika kompilatora.  
  
 Jeśli określisz domyślny rozmiar pakowania, rozmiar struktury jest 8 bajtów. Dwa bajty zajmują pierwsze dwa bajty pamięci, ponieważ bajtów muszą być wyrównane na granicach jednobajtowe. Ponieważ domyślne wyrównanie typu wynosi 4 bajty, który jest większy niż największy pól, `i3`, istnieją dwa bajty uzupełnienia, a następnie w polu Liczba całkowita.  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex1.cs#2)]  
  
 Jeśli <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> jest ustawiona na 2, rozmiar struktury jest 6 bajtów. Jako przed, dwa bajty zajmują pierwsze dwa bajty pamięci. Pola teraz były wyrównane na granicach 2-bajtowych, nie istnieje żadne uzupełnienie między drugi bajt i liczbę całkowitą.  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex2.cs#3)]  
  
 Jeśli <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> ma wartość 4, rozmiar struktury jest taka sama, jak w przypadku domyślnej, gdzie wyrównanie typ został zdefiniowany przez rozmiar jego największy pola, `i3`, która jest 4.  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex3.cs#4)]  
  
 Jeśli <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> jest ustawiony na 8, rozmiar struktury jest nadal takie same jak domyślne wielkość liter, ponieważ `i3` Wyrównuje pola w granicach 4-bajtowych, która jest mniejsza niż 8-bajtowe granice określony przez pole pakietu.  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex4.cs#5)]  
  
 Aby w kolejnym przykładzie, należy wziąć pod uwagę następujące struktury, która składa się z pola dwubajtowo, jedną 32-bitowej liczby całkowitej ze znakiem pola, co tablica bajtów pojedynczego elementu i wartości dziesiętnej. Przy użyciu domyślnego rozmiar pakowania rozmiar struktury jest 28 bajtów. Dwa bajty zajmują pierwsze dwa bajty pamięci, następuje dwa bajty uzupełnienia, a następnie do liczby całkowitej. Następnie jest tablicy jednobajtowych następują trzy bajty uzupełnienia. Na koniec <xref:System.Decimal> pola, d5, wyrównuje w granicach 4-bajtowych, ponieważ wartość dziesiętną składa się z czterech <xref:System.Int32> pola, więc jego wyrównania jest zależnie od rozmiaru największej swoich pól, a nie na rozmiar <xref:System.Decimal> struktury jako całość.  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex5.cs#6)]  
  
 Jeśli <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> jest ustawiona na 2, rozmiar struktury jest 24 bajty. Porównaniu domyślne wyrównanie dwa bajty uzupełnienie między dwa bajty i całkowitej zostały usunięte, ponieważ typ wyrównania jest teraz 4 niż 2. Oraz trzy bajtów uzupełnienia po `a4` zostały zastąpione przez jednego bajtu uzupełnienia, ponieważ `d5` teraz wyrównuje 2-bajtowe granice zamiast granicy 4-bajtowych.  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex6.cs#7)]  
  
 Jeśli <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> jest ustawiony na 8, rozmiar struktury jest takie same jak w przypadku domyślnej, ponieważ wszystkie wymagania wyrównania struktury są mniej niż 8.  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex7.cs#8)]  
  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> Pole jest często używane podczas operacji zapisu w sieci i struktury są eksportowane podczas dysku. To pole jest również często używane podczas platformy wywołania i działania interop.  
  
 Czasami pole umożliwia Zmniejsz wymagania dotyczące pamięci, przedstawiając większego rozmiaru pakowania. Jednak to użycie wymaga zaplanowania dokładne ograniczeń sprzętem i faktycznie może obniżyć wydajność.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public int Size;" />
      <MemberSignature Language="ILAsm" Value=".field public int32 Size" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.StructLayoutAttribute.Size" />
      <MemberSignature Language="VB.NET" Value="Public Size As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: int Size;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje rozmiar bezwzględny klasy lub struktury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To pole musi być większa lub równa całkowity rozmiar w bajtach elementów członkowskich klasy lub struktury. To pole jest przeznaczone głównie dla autorów kompilatora, którzy chcą rozszerzyć pamięci zajmowane przez strukturę dostępu bezpośredniego, niezarządzany. Na przykład można użyć tego pola, podczas pracy z Unii, które nie znajdują się w metadanych bezpośrednio.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.LayoutKind Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.InteropServices.LayoutKind Value" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.StructLayoutAttribute.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As LayoutKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::InteropServices::LayoutKind Value { System::Runtime::InteropServices::LayoutKind get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.LayoutKind</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Runtime.InteropServices.LayoutKind" /> wartość, która określa sposób rozmieszczenia klasy lub struktury.</summary>
        <value>Jedna z wartości wyliczenia, które określa sposób rozmieszczenia klasy lub struktury.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
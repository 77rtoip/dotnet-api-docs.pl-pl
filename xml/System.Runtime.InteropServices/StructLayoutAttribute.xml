<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="StructLayoutAttribute.xml" source-language="en-US" target-language="pl-PL">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac540521d9554f0cf59a81ca8f000f7fb5aa654a557.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">40521d9554f0cf59a81ca8f000f7fb5aa654a557</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>Lets you control the physical layout of the data fields of a class or structure in memory.</source>
          <target state="translated">Umożliwia sterowanie fizyczny układ pól danych klasy lub struktury w pamięci.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>You can apply this attribute to classes or structures.</source>
          <target state="translated">Ten atrybut można stosować do klasy lub struktury.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>The common language runtime controls the physical layout of the data fields of a class or structure in managed memory.</source>
          <target state="translated">Środowisko uruchomieniowe języka wspólnego określa fizyczny układ pól danych klasy lub struktury w pamięci zarządzanej.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>However, if you want to pass the type to unmanaged code, you can use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute to control the unmanaged layout of the type.</source>
          <target state="translated">Jednak jeśli chcesz przekazać typ do kodu niezarządzanego, można użyć <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> atrybut do sterowania układem niezarządzanego typu.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>Use the attribute with <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> to force the members to be laid out sequentially in the order they appear.</source>
          <target state="translated">Użyj atrybutu z <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> wymusić członkowie mają być określone sekwencyjnie w kolejności ich występowania.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>For , <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> controls both the layout in managed memory and the layout in unmanaged memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> Steruje zarówno układu w pamięci zarządzanej i układu w pamięci niezarządzanej.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>For non-blittable types, it controls the layout when the class or structure is marshaled to unmanaged code, but does not control the layout in managed memory.</source>
          <target state="translated">Dla typów niekopiowalne kontroluje układ klasy lub struktury jest przekazywane do kodu niezarządzanego, ale nie kontroluje układ w pamięci zarządzanej.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>Use the attribute with <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> to control the precise position of each data member.</source>
          <target state="translated">Użyj atrybutu z <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> do kontrolowania dokładności dla każdego elementu członkowskiego danych.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>This affects both managed and unmanaged layout, for both blittable and non-blittable types.</source>
          <target state="translated">Ma to wpływ na układ zarządzane i niezarządzane, dla typów zarówno kopiowalne i niekopiowalne.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>Using <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> requires that you use the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.FieldOffsetAttribute&gt;</ph> attribute to indicate the position of each field within the type.</source>
          <target state="translated">Przy użyciu <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> wymaga użycia <ph id="ph2">&lt;xref:System.Runtime.InteropServices.FieldOffsetAttribute&gt;</ph> atrybutu, aby wskazać położenie każdego pola w ramach typu.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>C#, Visual Basic, and C++ compilers apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential&gt;</ph> layout value to structures by default.</source>
          <target state="translated">Kompilatory języka C#, Visual Basic i C++ zastosować <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential&gt;</ph> wartość układu struktur domyślnie.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>For classes, you must apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> value explicitly.</source>
          <target state="translated">Dla klas, należy najpierw zastosować <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> jawnie wartości.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>The <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> also applies the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute; it always applies the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> value when it imports a type library.</source>
          <target state="translated"><bpt id="p1">[</bpt>Tlbimp.exe (Importer biblioteki typów)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> ma również zastosowanie <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> atrybutu; dotyczy zawsze <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> wartości podczas importowania biblioteki typów.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>The following example demonstrates a managed declaration of the <ph id="ph1">`GetSystemTime`</ph> function and defines <ph id="ph2">`MySystemTime`</ph> class with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> layout.</source>
          <target state="translated">W poniższym przykładzie pokazano zarządzanych deklarację <ph id="ph1">`GetSystemTime`</ph> funkcji i definiuje <ph id="ph2">`MySystemTime`</ph> klasy z <ph id="ph3">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> układu.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source><ph id="ph1">`GetSystemTime`</ph> gets the system time and prints to the console.</source>
          <target state="translated"><ph id="ph1">`GetSystemTime`</ph> pobiera czas systemowy i drukowanie do konsoli.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>Initalizes a new instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> class.</source>
          <target state="translated">Initalizes nowe wystąpienie elementu <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Int16)">
          <source>A 16-bit integer that represents one of the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> values that specifes how the class or structure should be arranged.</source>
          <target state="translated">16-bitową liczbę całkowitą, który reprezentuje jeden z <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> wartości tego Określa, jak powinny być rozmieszczane klasy lub struktury.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Int16)">
          <source>Initalizes a new instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> class with the specified <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> enumeration member.</source>
          <target state="translated">Initalizes nowe wystąpienie elementu <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> klasy z określonym <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> element członkowski wyliczenia.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Int16)">
          <source>This constructor takes an underlying 16-bit integer that represents each <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind&gt;</ph> enumeration member.</source>
          <target state="translated">Ten konstruktor ma podstawowej 16-bitową liczbę całkowitą reprezentującą każdego <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind&gt;</ph> element członkowski wyliczenia.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Int16)">
          <source>The <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> uses this constructor.</source>
          <target state="translated"><bpt id="p1">[</bpt>Tlbimp.exe (Importer biblioteki typów)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> używa tego konstruktora.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Runtime.InteropServices.LayoutKind)">
          <source>One of the enumeration values that specifes how the class or structure should be arranged.</source>
          <target state="translated">Jedną z wyliczenia wartości tego Określa, jak powinny być rozmieszczane klasy lub struktury.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Runtime.InteropServices.LayoutKind)">
          <source>Initalizes a new instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> class with the specified <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> enumeration member.</source>
          <target state="translated">Initalizes nowe wystąpienie elementu <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> klasy z określonym <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> element członkowski wyliczenia.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Runtime.InteropServices.LayoutKind)">
          <source>For readable code that is less prone to error, always use this constructor.</source>
          <target state="translated">Czytelny kod jest mniej podatne na błędy należy zawsze używać tego konstruktora.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.CharSet">
          <source>Indicates whether string data fields within the class should be marshaled as <ph id="ph1">&lt;see langword="LPWSTR" /&gt;</ph> or <ph id="ph2">&lt;see langword="LPSTR" /&gt;</ph> by default.</source>
          <target state="translated">Wskazuje, czy ciąg pola danych w ramach klasy powinny zostać zorganizowany jako <ph id="ph1">&lt;see langword="LPWSTR" /&gt;</ph> lub <ph id="ph2">&lt;see langword="LPSTR" /&gt;</ph> domyślnie.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.CharSet">
          <source>If the <ph id="ph1">`CharSet`</ph> field is set to <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CharSet.Unicode?displayProperty=nameWithType&gt;</ph>, all string arguments are converted to Unicode characters (<ph id="ph3">`LPWSTR`</ph>) before they are passed to the unmanaged implementation.</source>
          <target state="translated">Jeśli <ph id="ph1">`CharSet`</ph> pole jest ustawione na <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CharSet.Unicode?displayProperty=nameWithType&gt;</ph>, wszystkie argumenty typu string są konwertowane na znaki Unicode (<ph id="ph3">`LPWSTR`</ph>) przed są one przekazywane do niezarządzanego implementacji.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.CharSet">
          <source>If the field is set to <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet.Ansi?displayProperty=nameWithType&gt;</ph>, the strings are converted to ANSI strings (<ph id="ph2">`LPSTR`</ph>).</source>
          <target state="translated">Jeśli pole jest ustawione na <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet.Ansi?displayProperty=nameWithType&gt;</ph>, ciągi są konwertowane na ciągów ANSI (<ph id="ph2">`LPSTR`</ph>).</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.CharSet">
          <source>If the <ph id="ph1">`CharSet`</ph> field is set to <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CharSet.Auto?displayProperty=nameWithType&gt;</ph>, the conversion is platform-dependent (ANSI on Windows 98 and Windows Me, and Unicode on later versions).</source>
          <target state="translated">Jeśli <ph id="ph1">`CharSet`</ph> pole jest ustawione na <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CharSet.Auto?displayProperty=nameWithType&gt;</ph>, konwersja jest zależny od platformy (ANSI Windows 98 i Windows Me i Unicode w nowszych wersjach).</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Controls the alignment of data fields of a class or structure in memory.</source>
          <target state="translated">Określa wyrównanie pola danych klasy lub struktury w pamięci.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> field controls the alignment of a type's fields in memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> Pole określa wyrównanie pola typu w pamięci.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>It affects both <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ma to wpływ na obu <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> i <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>By default, the value is 0, indicating the default packing size for the current platform.</source>
          <target state="translated">Domyślnie wartość to 0, co oznacza domyślny rozmiar dla bieżącej platformy pakowania.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The value of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> must be 0, 1, 2, 4, 8, 16, 32, 64, or 128:</source>
          <target state="translated">Wartość <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> musi być 0, 1, 2, 4, 8, 16, 32, 64 lub 128:</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The fields of a type instance are aligned by using the following rules:</source>
          <target state="translated">Pola wystąpienia typu są wyrównane za pomocą następujących reguł:</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The alignment of the type is the size of its largest element (1, 2, 4, 8, etc., bytes) or the specified packing size, whichever is smaller.</source>
          <target state="translated">Wyrównanie typu jest większy niż jego największy element (1, 2, 4, 8, itd., bajtów) lub pakowania określony rozmiar, w zależności od jest mniejszy.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Each field must align with fields of its own size (1, 2, 4, 8, etc., bytes) or the alignment of the type, whichever is smaller.</source>
          <target state="translated">Każdego pola muszą być wyrównane z polami własny rozmiar (1, 2, 4, 8, itd., bajtów) lub wyrównaniem tekstu, zależności jest mniejsza.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Because the default alignment of the type is the size of its largest element, which is greater than or equal to all other field lengths, this usually means that fields are aligned by their size.</source>
          <target state="translated">Ponieważ domyślne wyrównanie typu jest rozmiarem największy element, który jest większa niż lub równa długości wszystkich innych pól, to zwykle oznacza to, że pola są wyrównane według ich rozmiaru.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>For example, even if the largest field in a type is a 64-bit (8-byte) integer or the Pack field is set to 8, <ph id="ph1">&lt;xref:System.Byte&gt;</ph> fields align on 1-byte boundaries, <ph id="ph2">&lt;xref:System.Int16&gt;</ph> fields align on 2-byte boundaries, and <ph id="ph3">&lt;xref:System.Int32&gt;</ph> fields align on 4-byte boundaries.</source>
          <target state="translated">Na przykład, nawet jeśli pole największy w typie jest 64-bitowa liczba całkowita (8-bajtowych) lub z dodatkiem Service Pack pola jest równa 8, <ph id="ph1">&lt;xref:System.Byte&gt;</ph> pól Dopasuj przy 1-bajtowych granicach <ph id="ph2">&lt;xref:System.Int16&gt;</ph> pól Dopasuj przy 2-bajtowych granicach i <ph id="ph3">&lt;xref:System.Int32&gt;</ph> pola Dopasuj przy 4-bajtowych granicach.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Padding is added between fields to satisfy the alignment requirements.</source>
          <target state="translated">Dopełnienie dodawany jest odstęp pola, aby spełnić wymagania dotyczące wyrównywania.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>For example, consider the following structure, which consists of two <ph id="ph1">&lt;xref:System.Byte&gt;</ph> fields and one <ph id="ph2">&lt;xref:System.Int32&gt;</ph> field, when it is used with various values for the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> field.</source>
          <target state="translated">Na przykład, należy wziąć pod uwagę następujące struktury, która składa się z dwóch <ph id="ph1">&lt;xref:System.Byte&gt;</ph> pól i jeden <ph id="ph2">&lt;xref:System.Int32&gt;</ph> pola, gdy jest używany z różnych wartości <ph id="ph3">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> pola.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>To successfully compile the C# examples, you must specify the <ph id="ph1">`/unsafe`</ph> compiler switch.</source>
          <target state="translated">Aby pomyślnie skompilować przykłady C#, należy określić <ph id="ph1">`/unsafe`</ph> przełącznika kompilatora.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>If you specify the default packing size, the size of the structure is 8 bytes.</source>
          <target state="translated">Jeśli określisz domyślny rozmiar pakowania, rozmiar struktury jest 8 bajtów.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The two bytes occupy the first two bytes of memory, because bytes must align on one-byte boundaries.</source>
          <target state="translated">Dwa bajty zajmują pierwsze dwa bajty pamięci, ponieważ bajtów muszą być wyrównane na granicach jednobajtowe.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Because the default alignment of the type is 4 bytes, which is the size of its largest fields, <ph id="ph1">`i3`</ph>, there are two bytes of padding followed by the integer field.</source>
          <target state="translated">Ponieważ domyślne wyrównanie typu wynosi 4 bajty, który jest większy niż największy pól, <ph id="ph1">`i3`</ph>, istnieją dwa bajty uzupełnienia, a następnie w polu Liczba całkowita.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>If <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 2, the size of the structure is 6 bytes.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> jest ustawiona na 2, rozmiar struktury jest 6 bajtów.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>As before, the two bytes occupy the first two bytes of memory.</source>
          <target state="translated">Jako przed, dwa bajty zajmują pierwsze dwa bajty pamięci.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Because fields now align on 2-byte boundaries, there is no padding between the second byte and the integer.</source>
          <target state="translated">Pola teraz były wyrównane na granicach 2-bajtowych, nie istnieje żadne uzupełnienie między drugi bajt i liczbę całkowitą.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>If <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 4, the size of the structure is the same as in the default case, where the type's alignment was defined by the size of its largest field, <ph id="ph2">`i3`</ph>, which is 4.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> ma wartość 4, rozmiar struktury jest taka sama, jak w przypadku domyślnej, gdzie wyrównanie typ został zdefiniowany przez rozmiar jego największy pola, <ph id="ph2">`i3`</ph>, która jest 4.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>If <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 8, the size of the structure is the still same as in the default case, because the <ph id="ph2">`i3`</ph> field aligns on a 4-byte boundary, which is smaller than the 8-byte boundary specified by the Pack field.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> jest ustawiony na 8, rozmiar struktury jest nadal takie same jak domyślne wielkość liter, ponieważ <ph id="ph2">`i3`</ph> Wyrównuje pola w granicach 4-bajtowych, która jest mniejsza niż 8-bajtowe granice określony przez pole pakietu.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>To take another example, consider the following structure, which consists of two byte fields, one 32-bit signed integer field, one single-element byte array, and a decimal value.</source>
          <target state="translated">Aby w kolejnym przykładzie, należy wziąć pod uwagę następujące struktury, która składa się z pola dwubajtowo, jedną 32-bitowej liczby całkowitej ze znakiem pola, co tablica bajtów pojedynczego elementu i wartości dziesiętnej.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>With the default packing size, the size of the structure is 28 bytes.</source>
          <target state="translated">Przy użyciu domyślnego rozmiar pakowania rozmiar struktury jest 28 bajtów.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The two bytes occupy the first two bytes of memory, followed by two bytes of padding, followed by the integer.</source>
          <target state="translated">Dwa bajty zajmują pierwsze dwa bajty pamięci, następuje dwa bajty uzupełnienia, a następnie do liczby całkowitej.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Next is the one-byte array, followed by three bytes of padding.</source>
          <target state="translated">Następnie jest tablicy jednobajtowych następują trzy bajty uzupełnienia.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> field, d5, aligns on a 4-byte boundary because a decimal value consists of four <ph id="ph2">&lt;xref:System.Int32&gt;</ph> fields, so its alignment is based on the size of the largest of its fields rather than on the size of the <ph id="ph3">&lt;xref:System.Decimal&gt;</ph> structure as a whole.</source>
          <target state="translated">Na koniec <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> pola, d5, wyrównuje w granicach 4-bajtowych, ponieważ wartość dziesiętną składa się z czterech <ph id="ph2">&lt;xref:System.Int32&gt;</ph> pola, więc jego wyrównania jest zależnie od rozmiaru największej swoich pól, a nie na rozmiar <ph id="ph3">&lt;xref:System.Decimal&gt;</ph> struktury jako całość.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>If <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 2, the size of the structure is 24 bytes.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> jest ustawiona na 2, rozmiar struktury jest 24 bajty.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>In comparison with the default alignment, the two bytes of padding between the two bytes and the integer have been removed because the type's alignment is now 4 rather than 2.</source>
          <target state="translated">Porównaniu domyślne wyrównanie dwa bajty uzupełnienie między dwa bajty i całkowitej zostały usunięte, ponieważ typ wyrównania jest teraz 4 niż 2.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>And the three bytes of padding after <ph id="ph1">`a4`</ph> have been replaced by one byte of padding, since <ph id="ph2">`d5`</ph> now aligns on a 2-byte boundary rather than a 4-byte boundary.</source>
          <target state="translated">Oraz trzy bajtów uzupełnienia po <ph id="ph1">`a4`</ph> zostały zastąpione przez jednego bajtu uzupełnienia, ponieważ <ph id="ph2">`d5`</ph> teraz wyrównuje 2-bajtowe granice zamiast granicy 4-bajtowych.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>If <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 8, the size of the structure is the same as in the default case, because all the alignment requirements in this structure are less than 8.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> jest ustawiony na 8, rozmiar struktury jest takie same jak w przypadku domyślnej, ponieważ wszystkie wymagania wyrównania struktury są mniej niż 8.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> field is frequently used when structures are exported during disk and network write operations.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> Pole jest często używane podczas operacji zapisu w sieci i struktury są eksportowane podczas dysku.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The field is also frequently used during platform invoke and interop operations.</source>
          <target state="translated">To pole jest również często używane podczas platformy wywołania i działania interop.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Occasionally, the field is used to reduce memory requirements by producing a tighter packing size.</source>
          <target state="translated">Czasami pole umożliwia Zmniejsz wymagania dotyczące pamięci, przedstawiając większego rozmiaru pakowania.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>However, this usage requires careful consideration of actual hardware constraints, and may actually degrade performance.</source>
          <target state="translated">Jednak to użycie wymaga zaplanowania dokładne ograniczeń sprzętem i faktycznie może obniżyć wydajność.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Size">
          <source>Indicates the absolute size of the class or structure.</source>
          <target state="translated">Wskazuje rozmiar bezwzględny klasy lub struktury.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Size">
          <source>This field must be equal or greater than the total size, in bytes, of the members of the class or structure.</source>
          <target state="translated">To pole musi być większa lub równa całkowity rozmiar w bajtach elementów członkowskich klasy lub struktury.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Size">
          <source>This field is primarily for compiler writers who want to extend the memory occupied by a structure for direct, unmanaged access.</source>
          <target state="translated">To pole jest przeznaczone głównie dla autorów kompilatora, którzy chcą rozszerzyć pamięci zajmowane przez strukturę dostępu bezpośredniego, niezarządzany.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Size">
          <source>For example, you can use this field when working with unions that are not represented in metadata directly.</source>
          <target state="translated">Na przykład można użyć tego pola, podczas pracy z Unii, które nie znajdują się w metadanych bezpośrednio.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="P:System.Runtime.InteropServices.StructLayoutAttribute.Value">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> value that specifies how the class or structure is arranged.</source>
          <target state="translated">Pobiera <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> wartość, która określa sposób rozmieszczenia klasy lub struktury.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.StructLayoutAttribute.Value">
          <source>One of the enumeration values that specifies how the class or structure is arranged.</source>
          <target state="translated">Jedna z wartości wyliczenia, które określa sposób rozmieszczenia klasy lub struktury.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>
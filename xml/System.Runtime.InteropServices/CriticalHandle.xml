<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="CriticalHandle.xml" source-language="en-US" target-language="pl-PL">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac556d9d023a154981435b37666fa081861ca0100c2.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">56d9d023a154981435b37666fa081861ca0100c2</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>Represents a wrapper class for handle resources.</source>
          <target state="translated">Reprezentuje klasę otoki dla zasobów dojścia.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class is similar to the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class, except that <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> implements reference counting.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> Klasy jest podobna do <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> klasy, z wyjątkiem <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> implementuje liczenie odwołań.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>You can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> instead of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> to address performance considerations when you can provide the necessary synchronization more efficiently yourself.</source>
          <target state="translated">Można użyć <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> zamiast <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> do zagadnienia dotyczące wydajności adres podczas synchronizacji niezbędne można podać więcej wydajnie samodzielnie.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>Because the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class does not perform reference counting, it does not provide protection from handle recycling security attacks.</source>
          <target state="translated">Ponieważ <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> klasy nie przeprowadza liczenie odwołań, nie zapewnia ochrony dojścia odtwarzania ataki.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>Because the reference counting algorithm implicitly serializes operations, a certain amount of thread safety is also lost.</source>
          <target state="translated">Ponieważ zliczanie algorytm niejawnie serializuje operacje, określoną ilość bezpieczeństwo wątków jest również utracone.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>If you call the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> method while an operation that is using the handle is outstanding on another thread, or if you call <ph id="ph3">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph4">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> from two threads at the same time, the results are non-deterministic.</source>
          <target state="translated">Jeśli należy wywołać <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> lub <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> — metoda podczas operacji jest przy użyciu dojścia jest oczekujących na inny wątek lub jeśli wywołujesz <ph id="ph3">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> lub <ph id="ph4">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> z dwoma wątkami w tym samym czasie, wyniki są deterministyczna.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class still provides the guaranteed critical finalization provided by the <ph id="ph2">&lt;xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> Klasy nadal zapewnia gwarantowane finalizacji krytyczne pochodzącymi <ph id="ph2">&lt;xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>for full trust for inheritors.</source>
          <target state="translated">aby uzyskać pełne zaufanie dla obiektów dziedziczących.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>This member cannot be inherited by partially trusted code.</source>
          <target state="translated">Ten element członkowski nie może być dziedziczona przez kod częściowo zaufany.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>This class cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Nie można użyć tej klasy w kodzie częściowo zaufanym lub przezroczyste.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>The value of an invalid handle (usually 0 or -1).</source>
          <target state="translated">Wartość nieprawidłowego dojścia (zazwyczaj 0 lub wartość-1).</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph> class with the specified invalid handle value.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph> klasy z wartością określony nieprawidłowy uchwyt.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>The derived class resides in an assembly without unmanaged code access permission.</source>
          <target state="translated">Klasa pochodna znajduje się w zestawie bez uprawnienia dostępu do kodu niezarządzanego.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>for full trust for inheritors.</source>
          <target state="translated">aby uzyskać pełne zaufanie dla obiektów dziedziczących.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>This member cannot be inherited by partially trusted code.</source>
          <target state="translated">Ten element członkowski nie może być dziedziczona przez kod częściowo zaufany.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>This class cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Nie można użyć tej klasy w kodzie częściowo zaufanym lub przezroczyste.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Marks the handle for releasing and freeing resources.</source>
          <target state="translated">Oznacza dojście do zwalniania i zwolnić zasoby.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method allows the resources to be freed.</source>
          <target state="translated">Wywoływanie <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> lub <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> metoda pozwala zasoby, które ma zostać zwolniony.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Unlike the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.</source>
          <target state="translated">W odróżnieniu od <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> klasy, nastąpi to zawsze natychmiast ponieważ nie istnieje żadna liczba odwołania, aby wskazać, że inne wątki są przy użyciu tego uchwytu.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> method.</source>
          <target state="translated">W związku z tym należy zastosować mechanizm synchronizacji, aby upewnić się, można bezpiecznie wywołać <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Although most classes that use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</source>
          <target state="translated">Mimo że większość klas, które używają <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> klasy nie trzeba podać finalizator, czasami jest to konieczne, (na przykład, aby opróżnić limit buforów plików lub do zapisu niektóre dane z powrotem do pamięci).</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>In this case, the class can provide a finalizer that is guaranteed to run before the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> critical finalizer runs.</source>
          <target state="translated">W takim przypadku klasa może zapewnić finalizatorze działanie przed <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> działa finalizator krytyczne.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method when you are finished using the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object.</source>
          <target state="translated">Wywołanie <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> lub <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> metody po zakończeniu przy użyciu <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> method leaves the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object in an unusable state.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> Pozostawia metody <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> obiektu w stanie uniemożliwiającym jego używanie.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> Always call <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> before you release your last reference to the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object.</source>
          <target state="translated"><bpt id="p1">**</bpt>Uwaga<ept id="p1">**</ept> wywołania zawsze <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> lub <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> przed zwolnieniem ostatniego odwołania do <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object's <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">W przeciwnym razie używa zasobów nie zostanie zwolniona do wywołania modułu zbierającego elementy bezużyteczne <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> obiektu <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>Marks the handle for releasing and freeing resources.</source>
          <target state="translated">Oznacza dojście do zwalniania i zwolnić zasoby.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Releases all resources used by the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph>.</source>
          <target state="translated">Zwalnia wszelkie zasoby używane przez <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method allows the resources to be freed.</source>
          <target state="translated">Wywoływanie <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> lub <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> metoda pozwala zasoby, które ma zostać zwolniony.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Unlike the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.</source>
          <target state="translated">W odróżnieniu od <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> klasy, nastąpi to zawsze natychmiast ponieważ nie istnieje żadna liczba odwołania, aby wskazać, że inne wątki są przy użyciu tego uchwytu.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method.</source>
          <target state="translated">W związku z tym należy zastosować mechanizm synchronizacji, aby upewnić się, można bezpiecznie wywołać <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Although most classes that use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</source>
          <target state="translated">Mimo że większość klas, które używają <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> klasy nie trzeba podać finalizator, czasami jest to konieczne, (na przykład, aby opróżnić limit buforów plików lub do zapisu niektóre dane z powrotem do pamięci).</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>In this case, the class can provide a finalizer that is guaranteed to run before the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> critical finalizer runs.</source>
          <target state="translated">W takim przypadku klasa może zapewnić finalizatorze działanie przed <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> działa finalizator krytyczne.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method when you are finished using the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object.</source>
          <target state="translated">Wywołanie <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> lub <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> metody po zakończeniu przy użyciu <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> method leaves the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object in an unusable state.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> Pozostawia metody <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> obiektu w stanie uniemożliwiającym jego używanie.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> Always call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method before you release your last reference to the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object.</source>
          <target state="translated"><bpt id="p1">**</bpt>Uwaga<ept id="p1">**</ept> wywołania zawsze <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> lub <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> metoda przed zwolnieniem ostatniego odwołania do <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object's <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">W przeciwnym razie używa zasobów nie zostanie zwolniona do wywołania modułu zbierającego elementy bezużyteczne <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> obiektu <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> for a normal dispose operation; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to finalize the handle.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> dla zwykłym dispose operacji. <ph id="ph2">&lt;see langword="false" /&gt;</ph> celu sfinalizowania dojście.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph> class specifying whether to perform a normal dispose operation.</source>
          <target state="translated">Zwalnia zasoby niezarządzane używane przez <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph> klasa określająca, czy do wykonania zwykłym dispose operacji.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)">
          <source>You should never explicitly call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method with the <ph id="ph2">`disposing`</ph> parameter set to <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Należy nigdy nie jawnie wywołać <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> metody z <ph id="ph2">`disposing`</ph> ustawiono parametr <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Finalize">
          <source>Frees all resources associated with the handle.</source>
          <target state="translated">Zwalnia wszystkie zasoby skojarzone z dojścia.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> method is the destructor for the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> Metoda jest destruktor dla elementu <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Finalize">
          <source>Application code should not call this method directly.</source>
          <target state="translated">Kod aplikacji nie należy bezpośrednio wywołać tej metody.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.CriticalHandle.handle">
          <source>Specifies the handle to be wrapped.</source>
          <target state="translated">Określa dojście w celu jej opakowania.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.CriticalHandle.handle">
          <source>Do not expose the handle publicly (that is, outside of the derived class).</source>
          <target state="translated">Nie ujawniaj dojście publicznie (to znaczy poza klasy pochodnej).</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>Gets a value indicating whether the handle is closed.</source>
          <target state="translated">Pobiera wartość wskazującą, czy dojście jest zamknięty.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the handle is closed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli zostanie zamknięty dojście; w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> method returns a value indicating whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object's handle is no longer associated with a native resource.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> Metoda zwraca wartość wskazującą czy <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> obiektu dojście nie jest już skojarzony z zasobem macierzystego.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>This differs from the definition of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> property, which computes whether a given handle is always considered invalid.</source>
          <target state="translated">Ta różni się od definicji <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> właściwość, która oblicza, czy podanym dojściu zawsze jest uznawane za nieprawidłowe.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> method returns a <ph id="ph2">`true`</ph> value in the following cases:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> Metoda zwraca <ph id="ph2">`true`</ph> wartość w następujących przypadkach:</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> method was called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> Wywołano metodę.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> method was called and there are no references to the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object on other threads.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> Metody lub <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> wywołano metodę i nie żadnych odwołań do <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> obiektu na inne wątki.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>When overridden in a derived class, gets a value indicating whether the handle value is invalid.</source>
          <target state="translated">W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy wartość dojście jest nieprawidłowe.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the handle is valid; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli dojście jest nieprawidłowy; w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>Derived classes must implement the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> property so that the common language runtime can determine whether critical finalization is required.</source>
          <target state="translated">Klasy pochodne muszą implementować <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> właściwości tak, aby środowisko uruchomieniowe języka wspólnego można określić, czy finalizacji krytyczne jest wymagana.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid).</source>
          <target state="translated">Klasa pochodna musi zapewniać implementację pasujące do typu ogólnego uchwytu, które obsługują (0 albo -1 jest nieprawidłowy).</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>These classes can then be further derived for specific safe handle types.</source>
          <target state="translated">Te klasy można następnie dalsze pochodnych typów określonych bezpieczne dojście.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>Unlike the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> property, which reports whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object has finished using the underlying handle, the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> property calculates whether the given handle value is always considered invalid.</source>
          <target state="translated">W odróżnieniu od <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> właściwość, która zgłasza czy <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> obiektu zakończył przy użyciu dojścia podstawowej <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> właściwości oblicza, czy wartość podanym dojściu zawsze jest uznawane za nieprawidłowe.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>Therefore, the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> property always returns the same value for any one handle value.</source>
          <target state="translated">W związku z tym <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> właściwość zawsze zwraca tę samą wartość dowolną wartość z określonego dojścia.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>When overridden in a derived class, executes the code required to free the handle.</source>
          <target state="translated">W przypadku przesłonięcia w klasie pochodnej, wykonuje kod wymagany do zwolnienia dojście.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the handle is released successfully; otherwise, in the event of a catastrophic failure, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli dojście zwolnieniu pomyślnie; w przeciwnym razie poważnej awarii, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>In this case, it generates a <bpt id="p1">[</bpt>releaseHandleFailed<ept id="p1">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept> Managed Debugging Assistant.</source>
          <target state="translated">W takim przypadku generuje <bpt id="p1">[</bpt>releaseHandleFailed<ept id="p1">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept> Asystent debugowania zarządzanego.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> method is guaranteed to be called only once, provided that you employ proper synchronization mechanisms to ensure that only one call to the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method is made.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> Metody jest gwarantowane, można wywołać tylko raz, pod warunkiem, że zostanie zastosowana mechanizmów prawidłowego synchronizacji, aby upewnić się, że tylko jedno wywołanie <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> lub <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> staje się metody.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> method will not be called if the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> property is <ph id="ph4">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> Nie będzie można wywołać metody, jeśli <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> lub <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> jest właściwość <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>Implement this method in your <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> derived classes to execute any code that is required to free the handle.</source>
          <target state="translated">Zaimplementuj tę metodę w Twojej <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> klas do wykonania kodu, który jest wymagany, aby zwolnić dojścia pochodnych.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>Because one of the functions of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> is to guarantee prevention of resource leaks, the code in your implementation of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> must never fail.</source>
          <target state="translated">Ponieważ jeden z funkcji <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> jest zapewnienie zapobiegania przecieków zasobów, kod w implementacji <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> musi nigdy się nie powieść.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>The garbage collector calls <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> after normal finalizers have been run for objects that were garbage collected at the same time, and guarantees the resources to invoke it and that it will not be interrupted while it is in progress.</source>
          <target state="translated">Wywołania modułu zbierającego elementy bezużyteczne <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> po finalizatory normalne zostały uruchomione dla obiektów, które zostały zebrane w tym samym czasie pamięci i gwarancji zasobów do wywołania go i że nie zostanie ona przerwana podczas jego jest w toku.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph).</source>
          <target state="translated">Ta metoda będzie gotowa jako region ograniczonego wykonania (CER) w czasie tworzenia wystąpienia (wraz ze wszystkich metod jej wykresu wywołań statycznie możliwa do ustalenia).</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> method.</source>
          <target state="translated">Mimo że zapobiega to przerwania przerwania wątku, nadal należy pamiętać, że żadnych ścieżek błędów w Twojej przesłoniętych <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>In particular, apply the <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> attribute to any methods you call from <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph>.</source>
          <target state="translated">W szczególności, zastosuj <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> atrybutu metody należy wywołać z <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>In most cases this code should be:</source>
          <target state="translated">W większości przypadków należy ten kod:</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>Additionally, for simple cleanup (for example, calling the Win32 API <ph id="ph1">`CloseHandle`</ph> on a file handle) you can check the return value for the single platform invoke call.</source>
          <target state="translated">Ponadto w przypadku prostego oczyszczania (na przykład wywołanie interfejsu API Win32 <ph id="ph1">`CloseHandle`</ph> na dojście do pliku) można sprawdzić wartość zwrotną dla pojedynczą platformę wywołania wywołania.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail.</source>
          <target state="translated">Złożone oczyszczania może mieć wiele logice programu i wielu wywołań metody, z których część może zakończyć się niepowodzeniem.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>You must ensure that your program logic has fallback code for each of those cases.</source>
          <target state="translated">Należy upewnij się, że logika program ma rezerwowy kod dla każdego z tych przypadkach.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>If the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> method returns <ph id="ph2">`false`</ph> for any reason, it generates a <bpt id="p1">[</bpt>releaseHandleFailed<ept id="p1">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept> Managed Debugging Assistant.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> metoda zwraca <ph id="ph2">`false`</ph> z jakiejkolwiek przyczyny, generuje <bpt id="p1">[</bpt>releaseHandleFailed<ept id="p1">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept> Asystent debugowania zarządzanego.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)">
          <source>The pre-existing handle to use.</source>
          <target state="translated">Istniejące dojście do użycia.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)">
          <source>Sets the handle to the specified pre-existing handle.</source>
          <target state="translated">Ustawia określone dojście istniejące dojście.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)">
          <source>Use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A&gt;</ph> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling handles in a structure.</source>
          <target state="translated">Użyj <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A&gt;</ph> obsługuje metoda tylko wtedy, gdy wymaganych do obsługi istniejącego dojścia (na przykład jeśli dojście jest zwracany w strukturze), ponieważ infrastruktury międzyoperacyjnego modelu COM programu .NET Framework nie obsługuje przekazywanie w strukturze.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>Marks a handle as invalid.</source>
          <target state="translated">Oznacza dojścia jako nieprawidłowy.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>Call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> method only when you know that your handle is invalid and you want to mark it as such.</source>
          <target state="translated">Wywołanie <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> metody tylko wtedy, gdy wiesz, że uchwyt jest nieprawidłowy i chcesz oznaczyć ją jako takie.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>Doing so does not change the value of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.handle&gt;</ph> field; it only marks the handle as invalid.</source>
          <target state="translated">Dzięki temu nie zmienia wartości <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.handle&gt;</ph> pole; tylko oznacza dojście jako nieprawidłowe.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>The handle might then contain a potentially stale value.</source>
          <target state="translated">Dojście następnie może zawierać potencjalnie starych wartości.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>The effect of this call is that no attempt is made to free the resources.</source>
          <target state="translated">To wywołanie powoduje, że nie są podejmowane próby zwolnienia zasobów.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>As with the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> only if you need to support a pre-existing handle.</source>
          <target state="translated">Jak <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A&gt;</ph> metody, użyj <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> tylko wtedy, gdy wymagana jest obsługa istniejące dojście.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>
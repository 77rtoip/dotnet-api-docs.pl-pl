<Type Name="Marshal" FullName="System.Runtime.InteropServices.Marshal">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9682b1007b8196a81024e49726aee195dc120b2c" /><Meta Name="ms.sourcegitcommit" Value="43c8e74d92c78325492baf27e41b400443f0dfbf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/08/2019" /><Meta Name="ms.locfileid" Value="68858830" /></Metadata><TypeSignature Language="C#" Value="public static class Marshal" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Marshal extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.Marshal" />
  <TypeSignature Language="VB.NET" Value="Public Class Marshal" />
  <TypeSignature Language="C++ CLI" Value="public ref class Marshal abstract sealed" />
  <TypeSignature Language="F#" Value="type Marshal = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zawiera kolekcję metod przydzielania pamięci niezarządzanej, kopiowania niezarządzanych bloków pamięci oraz konwertowania zarządzanych do typów niezarządzanych, a także innych różnych metod używanych podczas korzystania z kodu niezarządzanego.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `static` Metody zdefiniowane<xref:System.Runtime.InteropServices.Marshal> w klasie są niezbędne do pracy z niezarządzanym kodem. Większość metod zdefiniowanych w tej klasie jest zwykle używana przez deweloperów, którzy chcą zapewnić Most między zarządzanymi i niezarządzanymi modelami programowania. Na przykład <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> Metoda kopiuje znaki ANSI z określonego ciągu (w stercie zarządzanym) do buforu w niezarządzanej stercie. Przypisuje również stos docelowy o odpowiednim rozmiarze.  
  
 Środowisko uruchomieniowe języka wspólnego zapewnia określone możliwości organizowania. Aby uzyskać szczegółowe informacje dotyczące sposobu organizowania, zobacz [organizowanie](~/docs/framework/interop/interop-marshaling.md)międzyoperacyjnych.  
  
 Metody `Read` i `Write` w<xref:System.Runtime.InteropServices.Marshal> klasie obsługują zarówno wyrównany, jak i niewyrównany dostęp.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać różnych metod zdefiniowanych przez <xref:System.Runtime.InteropServices.Marshal> klasę.  
  
 [!code-cpp[Marshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#1)]
 [!code-csharp[Marshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#1)]
 [!code-vb[Marshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddRef">
      <MemberSignature Language="C#" Value="public static int AddRef (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 AddRef(native int pUnk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddRef (pUnk As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int AddRef(IntPtr pUnk);" />
      <MemberSignature Language="F#" Value="static member AddRef : nativeint -&gt; int" Usage="System.Runtime.InteropServices.Marshal.AddRef pUnk" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pUnk">Liczba odwołań do interfejsu do zwiększenia.</param>
        <summary>Zwiększa liczbę odwołań w określonym interfejsie.</summary>
        <returns>Nowa wartość liczby odwołań dla <paramref name="pUnk" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisko uruchomieniowe języka wspólnego zarządza liczbą odwołań obiektu COM, co sprawia, że nie jest konieczne bezpośrednie używanie tej metody. W rzadkich przypadkach, takich jak testowanie organizatora niestandardowego, może okazać się konieczne ręczne manipulowanie okresem istnienia obiektu. Po wywołaniu <xref:System.Runtime.InteropServices.Marshal.AddRef%2A>należy zmniejszyć liczbę odwołań przy użyciu metody, takiej jak <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType>. Nie należy polegać na zwracanej wartości <xref:System.Runtime.InteropServices.Marshal.AddRef%2A>, ponieważ może to czasami być niestabilne.  
  
 Można wywołać <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>lub <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> [](https://go.microsoft.com/fwlink/?LinkId=148003) , aby uzyskać wartość<xref:System.IntPtr> reprezentującą wskaźnik interfejsu IUnknown. Za pomocą tych metod i <xref:System.Runtime.InteropServices.Marshal.AddRef%2A> metody obiektów zarządzanych można także uzyskać interfejsy com reprezentowane przez wywoływaną otokę com obiektu zarządzanego. Jeśli nie znasz szczegółów tego typu otoki, zapoznaj się z otoką wywoływaną przez [com](~/docs/framework/interop/com-callable-wrapper.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=148625">IUnknown:: AddRef</related>
      </Docs>
    </Member>
    <Member MemberName="AllocCoTaskMem">
      <MemberSignature Language="C#" Value="public static IntPtr AllocCoTaskMem (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocCoTaskMem(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocCoTaskMem (cb As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr AllocCoTaskMem(int cb);" />
      <MemberSignature Language="F#" Value="static member AllocCoTaskMem : int -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.AllocCoTaskMem cb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb">Rozmiar bloku pamięci do przydzielenia.</param>
        <summary>Przydziela blok pamięci o określonym rozmiarze z alokatora pamięci zadania COM.</summary>
        <returns>Liczba całkowita reprezentująca adres bloku przydzieloną pamięć. Ta pamięć musi być wydana w <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />systemie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A>jest jedną z dwóch metod interfejsu API alokacji pamięci w <xref:System.Runtime.InteropServices.Marshal> klasie. (<xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> czy jest to druga). Zwracana zawartość pamięci początkowej jest niezdefiniowana, a przydzieloną ilość pamięci może być większa niż żądana liczba bajtów. Ta metoda przedstawia funkcję [COTASKMEMALLOC](https://go.microsoft.com/fwlink/?LinkId=148626) com, która jest określana jako Alokator pamięci zadania com.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Brak wystarczającej ilości pamięci do spełnienia żądania.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AllocHGlobal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przydziela pamięć z niezarządzanej pamięci procesu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr AllocHGlobal (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocHGlobal(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocHGlobal (cb As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr AllocHGlobal(int cb);" />
      <MemberSignature Language="F#" Value="static member AllocHGlobal : int -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.AllocHGlobal cb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb">Wymagana liczba bajtów w pamięci.</param>
        <summary>Przydziela pamięć z niezarządzanej pamięci procesu przy użyciu określonej liczby bajtów.</summary>
        <returns>Wskaźnik do nowo przydzieloną pamięć. Tę pamięć należy zwolnić przy użyciu <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /> metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>jest jedną z dwóch metod alokacji pamięci w <xref:System.Runtime.InteropServices.Marshal> klasie. (<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType> czy jest to druga). Ta metoda udostępnia funkcję Win32 [LocalAlloc](https://go.microsoft.com/fwlink/?LinkId=148628) z pliku Kernel32. dll.  
  
 Gdy <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> wywołuje `LocalAlloc`, przekazuje`LMEM_FIXED` flagę, która powoduje, że przydzieloną pamięć zostanie zablokowana. Ponadto przydzieloną pamięć nie jest wypełniona zerem.  
  
   
  
## Examples  
 Poniższy przykład demonstruje wywołanie <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> metody. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Runtime.InteropServices.Marshal> klasy.  
  
 [!code-cpp[Marshal#4](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#4)]
 [!code-csharp[Marshal#4](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#4)]
 [!code-vb[Marshal#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Brak wystarczającej ilości pamięci do spełnienia żądania.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="AllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr AllocHGlobal (IntPtr cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocHGlobal(native int cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocHGlobal (cb As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr AllocHGlobal(IntPtr cb);" />
      <MemberSignature Language="F#" Value="static member AllocHGlobal : nativeint -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.AllocHGlobal cb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="cb">Wymagana liczba bajtów w pamięci.</param>
        <summary>Przydziela pamięć z niezarządzanej pamięci procesu za pomocą wskaźnika do określonej liczby bajtów.</summary>
        <returns>Wskaźnik do nowo przydzieloną pamięć. Tę pamięć należy zwolnić przy użyciu <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /> metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>jest jedną z dwóch metod alokacji pamięci w <xref:System.Runtime.InteropServices.Marshal> klasie. (<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType> czy jest to druga). Ta metoda udostępnia funkcję Win32 [LocalAlloc](https://go.microsoft.com/fwlink/?LinkID=148628) z pliku Kernel32. dll.  
  
 Gdy <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> wywołuje `LocalAlloc`, przekazuje`LMEM_FIXED` flagę, która powoduje, że przydzieloną pamięć zostanie zablokowana. Ponadto przydzieloną pamięć nie jest wypełniona zerem.  
  
 Na przykład kod, zobacz <xref:System.Runtime.InteropServices.Marshal> i <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Brak wystarczającej ilości pamięci do spełnienia żądania.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="AreComObjectsAvailableForCleanup">
      <MemberSignature Language="C#" Value="public static bool AreComObjectsAvailableForCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool AreComObjectsAvailableForCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AreComObjectsAvailableForCleanup () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool AreComObjectsAvailableForCleanup();" />
      <MemberSignature Language="F#" Value="static member AreComObjectsAvailableForCleanup : unit -&gt; bool" Usage="System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy wywoływane otoki środowiska uruchomieniowego (RCW) z dowolnego kontekstu są dostępne do oczyszczenia.</summary>
        <returns><see langword="true" />Jeśli istnieją jakieś RCW dostępne do oczyszczenia; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli istnieje wiele odwołań między kodem zarządzanym i natywnym ze szczegółowymi wykresami zależności, może upłynąć dużo czasu na wyczyszczenie wszystkich obiektów. Za każdym razem, gdy zostanie uruchomiona GC, zostanie zwolniona pewna liczba RCW, co spowoduje zwolnienie bazowych obiektów COM. Te obiekty COM następnie zwolnią zarządzane odwołania i udostępnią więcej obiektów do oczyszczenia przy następnym uruchomieniu wykazu globalnego, co spowoduje ponowne uruchomienie procesu.  
  
 <xref:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup%2A> Metoda umożliwia aplikacji określenie liczby cykli GC. Zbierz i GC. Aby wyczyścić wszystko, WaitForPendingFinalizers musi mieć miejsce.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="BindToMoniker">
      <MemberSignature Language="C#" Value="public static object BindToMoniker (string monikerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object BindToMoniker(string monikerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindToMoniker (monikerName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ BindToMoniker(System::String ^ monikerName);" />
      <MemberSignature Language="F#" Value="static member BindToMoniker : string -&gt; obj" Usage="System.Runtime.InteropServices.Marshal.BindToMoniker monikerName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="monikerName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="monikerName">Moniker odpowiadający żądanemu wskaźnikowi interfejsu.</param>
        <summary>Pobiera wskaźnik interfejsu identyfikowany przez określoną moniker.</summary>
        <returns>Obiekt zawierający odwołanie do wskaźnika interfejsu identyfikowanego przez <paramref name="monikerName" /> parametr. Moniker jest nazwą, a w tym przypadku moniker jest definiowany przez interfejs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.BindToMoniker%2A>udostępnia metodę com `BindToMoniker` , która tworzy obiekt, który można rzutować na dowolny wymagany interfejs com. Ta metoda zapewnia takie same funkcje jak `GetObject` Metoda w Visual Basic 6,0 i. [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">Nierozpoznany element HRESULT został zwrócony przez niezarządzaną <see langword="BindToMoniker" /> metodę.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="BufferToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr BufferToBSTR (Array ptr, int slen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int BufferToBSTR(class System.Array ptr, int32 slen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.BufferToBSTR(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BufferToBSTR (ptr As Array, slen As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr BufferToBSTR(Array ^ ptr, int slen);" />
      <MemberSignature Language="F#" Value="static member BufferToBSTR : Array * int -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.BufferToBSTR (ptr, slen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Array" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="slen" Type="System.Int32" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="ptr">To be added.</param>
        <param name="slen">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeWrapperHandleStrength">
      <MemberSignature Language="C#" Value="public static void ChangeWrapperHandleStrength (object otp, bool fIsWeak);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ChangeWrapperHandleStrength(object otp, bool fIsWeak) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ChangeWrapperHandleStrength (otp As Object, fIsWeak As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChangeWrapperHandleStrength(System::Object ^ otp, bool fIsWeak);" />
      <MemberSignature Language="F#" Value="static member ChangeWrapperHandleStrength : obj * bool -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength (otp, fIsWeak)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otp" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="fIsWeak" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="otp">Obiekt, którego CCW przechowuje dojście zliczane jako odwołanie. Dojście jest silna, jeśli liczba odwołań na CCW jest większa niż zero; w przeciwnym razie jest to słabe.</param>
        <param name="fIsWeak"><see langword="true" />Aby zmienić siłę uchwytu w <paramref name="otp" /> parametrze na słaby, niezależnie od jego liczby odwołań; Aby zresetować siłę dojścia w <paramref name="otp" /> celu odliczenia odwołania. <see langword="false" /></param>
        <summary>Zmienia siłę dojścia [otoki modelu COM](~/docs/framework/interop/com-callable-wrapper.md) (CCW) obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength%2A>jest używany na potrzeby funkcji buforowania obiektów i nigdy nie powinien być wywoływany bezpośrednio przez kod użytkownika.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="CleanupUnusedObjectsInCurrentContext">
      <MemberSignature Language="C#" Value="public static void CleanupUnusedObjectsInCurrentContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CleanupUnusedObjectsInCurrentContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CleanupUnusedObjectsInCurrentContext ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CleanupUnusedObjectsInCurrentContext();" />
      <MemberSignature Language="F#" Value="static member CleanupUnusedObjectsInCurrentContext : unit -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powiadamia środowisko uruchomieniowe o czyszczeniu wszystkich wywoływanych otok (RCW) <see href="https://docs.microsoft.com/dotnet/framework/interop/runtime-callable-wrapper">środowiska uruchomieniowego</see> w bieżącym kontekście.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Komunikaty z pompą systemu międzyoperacyjnego podczas próby oczyszczenia RCW. Dzięki temu oczyszczanie dla jednowątkowego apartamentu (STA) RCW jest wykonywane we wszystkich aplikacjach, w tym w przypadku aplikacji, które nie są wystarczająco często wystarczające. Niektóre aplikacje, które odpowiadają odpowiednio pompie, są jednak bardzo wrażliwe na miejsce pompowania. Gdy system międzyoperacyjny pompuje komunikaty w tych aplikacjach, w miejscach, które są nieoczekiwane, aplikacja może napotkać problemy współużytkowania wątkowości, które są trudne do zdiagnozowania. W związku z tym aplikacje muszą być w stanie kontrolować własną pompę dla określonego STA i kontrolować oczyszczanie RCW.  
  
 Jednak deweloperzy często kontrolują podzestaw wątków w swojej aplikacji i w ten sposób nie mogą zapewnić, że wszystkie wątki odpowiednio pompą.  
  
 Aby rozwiązać ten problem:  
  
1.  <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A?displayProperty=nameWithType> Użyj metody, aby wyłączyć automatyczne czyszczenie RCW oraz komunikat informujący o tym, że występuje na wątku. Pozwala to deweloperom na rezygnację z automatycznego czyszczenia i odpowiadające im komunikaty.  
  
2.  <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A> Użyj metody, aby powiadomić środowisko uruchomieniowe o czyszczeniu wszystkich RCW, które są przydzielono w bieżącym kontekście. Ta metoda towarzysząca pozwala deweloperom precyzyjnie kontrolować, kiedy środowisko uruchomieniowe wykonuje oczyszczanie w bieżącym kontekście.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiuje dane z zarządzanej tablicy do wskaźnika pamięci niezarządzanej lub ze wskaźnika pamięci niezarządzanej do tablicy zarządzanej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (byte[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(unsigned int8[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Byte(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;System::Byte&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : byte[] * int * nativeint * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, startIndex, destination, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Tablica Jednowymiarowa do skopiowania.</param>
        <param name="startIndex">Indeks (liczony od zera) w tablicy źródłowej, w której należy rozpocząć kopiowanie.</param>
        <param name="destination">Wskaźnik pamięci do skopiowania.</param>
        <param name="length">Liczba elementów tablicy do skopiowania.</param>
        <summary>Kopiuje dane z jednowymiarowej, zarządzanej 8-bitowej tablicy liczb całkowitych bez znaku do niezarządzanego wskaźnika pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tej metody można skopiować podzbiór tablicy zarządzanej jednowymiarowej do niezarządzanej tablicy w stylu C.  
  
   
  
## Examples  
 Poniższy przykład kopiuje tablicę do pamięci niezarządzanej przy użyciu <xref:System.Runtime.InteropServices.Marshal.Copy%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.IntPtr%2CSystem.Int32%29> przeciążenia, a następnie kopiuje niezarządzaną tablicę z powrotem do pamięci zarządzanej przy <xref:System.Runtime.InteropServices.Marshal.Copy%28System.IntPtr%2CSystem.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> użyciu przeciążenia.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />i <paramref name="length" /> są nieprawidłowe.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, lub <paramref name="length" /> jest .<see langword="null" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (char[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(char[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Char(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;char&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : char[] * int * nativeint * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, startIndex, destination, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Tablica Jednowymiarowa do skopiowania.</param>
        <param name="startIndex">Indeks (liczony od zera) w tablicy źródłowej, w której należy rozpocząć kopiowanie.</param>
        <param name="destination">Wskaźnik pamięci do skopiowania.</param>
        <param name="length">Liczba elementów tablicy do skopiowania.</param>
        <summary>Kopiuje dane z jednowymiarowej, zarządzanej tablicy znaków na wskaźnik niezarządzanej pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tej metody można skopiować podzbiór tablicy zarządzanej jednowymiarowej do niezarządzanej tablicy w stylu C.  
  
   
  
## Examples  
 Poniższy przykład kopiuje tablicę do pamięci niezarządzanej, a następnie kopiuje niezarządzaną tablicę z powrotem do pamięci zarządzanej.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />i <paramref name="length" /> są nieprawidłowe.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="startIndex" />, <paramref name="destination" />, lub <paramref name="length" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (double[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(float64[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Double(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;double&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : double[] * int * nativeint * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, startIndex, destination, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Double[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Tablica Jednowymiarowa do skopiowania.</param>
        <param name="startIndex">Indeks (liczony od zera) w tablicy źródłowej, w której należy rozpocząć kopiowanie.</param>
        <param name="destination">Wskaźnik pamięci do skopiowania.</param>
        <param name="length">Liczba elementów tablicy do skopiowania.</param>
        <summary>Kopiuje dane z jednowymiarowej, zarządzanej tablicy liczb zmiennoprzecinkowych o podwójnej precyzji do niezarządzanego wskaźnika pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tej metody można skopiować podzbiór tablicy zarządzanej jednowymiarowej do niezarządzanej tablicy w stylu C.  
  
   
  
## Examples  
 Poniższy przykład kopiuje tablicę do pamięci niezarządzanej, a następnie kopiuje niezarządzaną tablicę z powrotem do pamięci zarządzanej.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />i <paramref name="length" /> są nieprawidłowe.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, lub <paramref name="length" /> jest .<see langword="null" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (short[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int16[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Short(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;short&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : int16[] * int * nativeint * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, startIndex, destination, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int16[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Tablica Jednowymiarowa do skopiowania.</param>
        <param name="startIndex">Indeks (liczony od zera) w tablicy źródłowej, w której należy rozpocząć kopiowanie.</param>
        <param name="destination">Wskaźnik pamięci do skopiowania.</param>
        <param name="length">Liczba elementów tablicy do skopiowania.</param>
        <summary>Kopiuje dane z jednowymiarowej, zarządzanej 16-bitowej tablicy całkowitej ze znakiem do niezarządzanej pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tej metody można skopiować podzbiór tablicy zarządzanej jednowymiarowej do niezarządzanej tablicy w stylu C.  
  
   
  
## Examples  
 Poniższy przykład kopiuje tablicę do pamięci niezarządzanej, a następnie kopiuje niezarządzaną tablicę z powrotem do pamięci zarządzanej.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />i <paramref name="length" /> są nieprawidłowe.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, lub <paramref name="length" /> jest .<see langword="null" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (int[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int32[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Integer(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;int&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : int[] * int * nativeint * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, startIndex, destination, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int32[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Tablica Jednowymiarowa do skopiowania.</param>
        <param name="startIndex">Indeks (liczony od zera) w tablicy źródłowej, w której należy rozpocząć kopiowanie.</param>
        <param name="destination">Wskaźnik pamięci do skopiowania.</param>
        <param name="length">Liczba elementów tablicy do skopiowania.</param>
        <summary>Kopiuje dane z jednowymiarowej, zarządzanej 32-bitowej tablicy całkowitej ze znakiem do niezarządzanej pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tej metody można skopiować podzbiór tablicy zarządzanej jednowymiarowej do niezarządzanej tablicy w stylu C.  
  
   
  
## Examples  
 Poniższy przykład kopiuje tablicę do pamięci niezarządzanej, a następnie kopiuje niezarządzaną tablicę z powrotem do pamięci zarządzanej.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />i <paramref name="length" /> są nieprawidłowe.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="startIndex" />lub <paramref name="length" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (long[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int64[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Long(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;long&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : int64[] * int * nativeint * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, startIndex, destination, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int64[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Tablica Jednowymiarowa do skopiowania.</param>
        <param name="startIndex">Indeks (liczony od zera) w tablicy źródłowej, w której należy rozpocząć kopiowanie.</param>
        <param name="destination">Wskaźnik pamięci do skopiowania.</param>
        <param name="length">Liczba elementów tablicy do skopiowania.</param>
        <summary>Kopiuje dane z jednowymiarowej, zarządzanej 64-bitowej tablicy całkowitej ze znakiem do niezarządzanej pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tej metody można skopiować podzbiór tablicy zarządzanej jednowymiarowej do niezarządzanej tablicy w stylu C.  
  
   
  
## Examples  
 Poniższy przykład kopiuje tablicę do pamięci niezarządzanej, a następnie kopiuje niezarządzaną tablicę z powrotem do pamięci zarządzanej.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />i <paramref name="length" /> są nieprawidłowe.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, lub <paramref name="length" /> jest .<see langword="null" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, byte[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, unsigned int8[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Byte(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;System::Byte&gt; ^ destination, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : nativeint * byte[] * int * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, destination, startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Wskaźnik pamięci do skopiowania.</param>
        <param name="destination">Tablica, do której mają zostać skopiowane.</param>
        <param name="startIndex">Indeks (liczony od zera) w tablicy docelowej, w której należy rozpocząć kopiowanie.</param>
        <param name="length">Liczba elementów tablicy do skopiowania.</param>
        <summary>Kopiuje dane ze wskaźnika pamięci niezarządzanej do zarządzanej 8-bitowej tablicy liczb całkowitych bez znaku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niezarządzane tablice języka C nie zawierają informacji o granicach, co uniemożliwia `startIndex` sprawdzenie poprawności parametrów i. `length` W związku z tym dane niezarządzane odpowiadające `source` parametrowi wypełniają tablicę zarządzaną bez względu na ich użyteczność. Musisz zainicjować zarządzaną tablicę o odpowiednim rozmiarze przed wywołaniem tej metody.  
  
   
  
## Examples  
 Poniższy przykład kopiuje tablicę do pamięci niezarządzanej, a następnie kopiuje niezarządzaną tablicę z powrotem do pamięci zarządzanej.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, lub <paramref name="length" /> jest .<see langword="null" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, char[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, char[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;char&gt; ^ destination, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : nativeint * char[] * int * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, destination, startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Wskaźnik pamięci do skopiowania.</param>
        <param name="destination">Tablica, do której mają zostać skopiowane.</param>
        <param name="startIndex">Indeks (liczony od zera) w tablicy docelowej, w której należy rozpocząć kopiowanie.</param>
        <param name="length">Liczba elementów tablicy do skopiowania.</param>
        <summary>Kopiuje dane ze wskaźnika pamięci niezarządzanej do tablicy znaków zarządzanych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niezarządzane tablice języka C nie zawierają informacji o granicach, co uniemożliwia `startIndex` sprawdzenie poprawności parametrów i. `length` W związku z tym dane niezarządzane odpowiadające `source` parametrowi wypełniają tablicę zarządzaną bez względu na ich użyteczność. Musisz zainicjować zarządzaną tablicę o odpowiednim rozmiarze przed wywołaniem tej metody.  
  
   
  
## Examples  
 Poniższy przykład kopiuje tablicę do pamięci niezarządzanej, a następnie kopiuje niezarządzaną tablicę z powrotem do pamięci zarządzanej.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, lub <paramref name="length" /> jest .<see langword="null" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, double[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, float64[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Double(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;double&gt; ^ destination, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : nativeint * double[] * int * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, destination, startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Double[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Wskaźnik pamięci do skopiowania.</param>
        <param name="destination">Tablica, do której mają zostać skopiowane.</param>
        <param name="startIndex">Indeks (liczony od zera) w tablicy docelowej, w której należy rozpocząć kopiowanie.</param>
        <param name="length">Liczba elementów tablicy do skopiowania.</param>
        <summary>Kopiuje dane ze wskaźnika pamięci niezarządzanej do zarządzanej tablicy liczb zmiennoprzecinkowych o podwójnej precyzji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niezarządzane tablice języka C nie zawierają informacji o granicach, co uniemożliwia `startIndex` sprawdzenie poprawności parametrów i. `length` W związku z tym dane niezarządzane odpowiadające `source` parametrowi wypełniają tablicę zarządzaną bez względu na ich użyteczność. Musisz zainicjować zarządzaną tablicę o odpowiednim rozmiarze przed wywołaniem tej metody.  
  
   
  
## Examples  
 Poniższy przykład kopiuje tablicę do pamięci niezarządzanej, a następnie kopiuje niezarządzaną tablicę z powrotem do pamięci zarządzanej.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, lub <paramref name="length" /> jest .<see langword="null" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, short[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int16[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Short(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;short&gt; ^ destination, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : nativeint * int16[] * int * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, destination, startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int16[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Wskaźnik pamięci do skopiowania.</param>
        <param name="destination">Tablica, do której mają zostać skopiowane.</param>
        <param name="startIndex">Indeks (liczony od zera) w tablicy docelowej, w której należy rozpocząć kopiowanie.</param>
        <param name="length">Liczba elementów tablicy do skopiowania.</param>
        <summary>Kopiuje dane ze wskaźnika pamięci niezarządzanej do zarządzanej 16-bitowej tablicy liczb całkowitych ze znakiem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niezarządzane tablice języka C nie zawierają informacji o granicach, co uniemożliwia `startIndex` sprawdzenie poprawności parametrów i. `length` W związku z tym dane niezarządzane odpowiadające `source` parametrowi wypełniają tablicę zarządzaną bez względu na ich użyteczność. Musisz zainicjować zarządzaną tablicę o odpowiednim rozmiarze przed wywołaniem tej metody.  
  
   
  
## Examples  
 Poniższy przykład kopiuje tablicę do pamięci niezarządzanej, a następnie kopiuje niezarządzaną tablicę z powrotem do pamięci zarządzanej.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, lub <paramref name="length" /> jest .<see langword="null" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, int[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int32[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Integer(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;int&gt; ^ destination, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : nativeint * int[] * int * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, destination, startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int32[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Wskaźnik pamięci do skopiowania.</param>
        <param name="destination">Tablica, do której mają zostać skopiowane.</param>
        <param name="startIndex">Indeks (liczony od zera) w tablicy docelowej, w której należy rozpocząć kopiowanie.</param>
        <param name="length">Liczba elementów tablicy do skopiowania.</param>
        <summary>Kopiuje dane ze wskaźnika pamięci niezarządzanej do zarządzanej 32-bitowej tablicy całkowitej ze znakiem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niezarządzane tablice języka C nie zawierają informacji o granicach, co uniemożliwia `startIndex` sprawdzenie poprawności parametrów i. `length` W związku z tym dane niezarządzane odpowiadające `source` parametrowi wypełniają tablicę zarządzaną bez względu na ich użyteczność. Musisz zainicjować zarządzaną tablicę o odpowiednim rozmiarze przed wywołaniem tej metody.  
  
   
  
## Examples  
 Poniższy przykład kopiuje tablicę do pamięci niezarządzanej, a następnie kopiuje niezarządzaną tablicę z powrotem do pamięci zarządzanej.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, lub <paramref name="length" /> jest .<see langword="null" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, long[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int64[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Long(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;long&gt; ^ destination, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : nativeint * int64[] * int * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, destination, startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int64[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Wskaźnik pamięci do skopiowania.</param>
        <param name="destination">Tablica, do której mają zostać skopiowane.</param>
        <param name="startIndex">Indeks (liczony od zera) w tablicy docelowej, w której należy rozpocząć kopiowanie.</param>
        <param name="length">Liczba elementów tablicy do skopiowania.</param>
        <summary>Kopiuje dane ze wskaźnika pamięci niezarządzanej do zarządzanej 64-bitowej tablicy całkowitej ze znakiem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niezarządzane tablice języka C nie zawierają informacji o granicach, co uniemożliwia `startIndex` sprawdzenie poprawności parametrów i. `length` W związku z tym dane niezarządzane odpowiadające`source` parametrowi wypełniają tablicę zarządzaną bez względu na ich użyteczność. Musisz zainicjować zarządzaną tablicę o odpowiednim rozmiarze przed wywołaniem tej metody.  
  
   
  
## Examples  
 Poniższy przykład kopiuje tablicę do pamięci niezarządzanej, a następnie kopiuje niezarządzaną tablicę z powrotem do pamięci zarządzanej.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, lub <paramref name="length" /> jest .<see langword="null" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, IntPtr[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, native int[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As IntPtr(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;IntPtr&gt; ^ destination, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : nativeint * nativeint[] * int * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, destination, startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destination" Type="System.IntPtr[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="source">Wskaźnik pamięci do skopiowania.</param>
        <param name="destination">Tablica, do której mają zostać skopiowane.</param>
        <param name="startIndex">Indeks (liczony od zera) w tablicy docelowej, w której należy rozpocząć kopiowanie.</param>
        <param name="length">Liczba elementów tablicy do skopiowania.</param>
        <summary>Kopiuje dane ze wskaźnika pamięci niezarządzanej do tablicy <see cref="T:System.IntPtr" /> zarządzanej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niezarządzane tablice języka C nie zawierają informacji o granicach, co uniemożliwia `startIndex` sprawdzenie poprawności parametrów i. `length` W związku z tym dane niezarządzane, które odpowiadają `source` parametrowi wypełniają tablicę zarządzaną niezależnie od ich użyteczności. Musisz zainicjować zarządzaną tablicę o odpowiednim rozmiarze przed wywołaniem <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, lub <paramref name="length" /> jest .<see langword="null" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, float[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, float32[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Single(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;float&gt; ^ destination, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : nativeint * single[] * int * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, destination, startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Single[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Wskaźnik pamięci do skopiowania.</param>
        <param name="destination">Tablica, do której mają zostać skopiowane.</param>
        <param name="startIndex">Indeks (liczony od zera) w tablicy docelowej, w której należy rozpocząć kopiowanie.</param>
        <param name="length">Liczba elementów tablicy do skopiowania.</param>
        <summary>Kopiuje dane ze wskaźnika pamięci niezarządzanej do zarządzanej tablicy liczb zmiennoprzecinkowych o pojedynczej precyzji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niezarządzane tablice języka C nie zawierają informacji o granicach, co uniemożliwia `startIndex` sprawdzenie poprawności parametrów i. `length` W związku z tym dane niezarządzane odpowiadające `source` parametrowi wypełniają tablicę zarządzaną bez względu na ich użyteczność. Musisz zainicjować zarządzaną tablicę o odpowiednim rozmiarze przed wywołaniem tej metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, lub <paramref name="length" /> jest .<see langword="null" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;IntPtr&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : nativeint[] * int * nativeint * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, startIndex, destination, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destination" Type="System.IntPtr" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="source">Tablica Jednowymiarowa do skopiowania.</param>
        <param name="startIndex">Indeks (liczony od zera) w tablicy źródłowej, w której należy rozpocząć kopiowanie.</param>
        <param name="destination">Wskaźnik pamięci do skopiowania.</param>
        <param name="length">Liczba elementów tablicy do skopiowania.</param>
        <summary>Kopiuje dane z jednowymiarowej, zarządzanej <see cref="T:System.IntPtr" /> tablicy do wskaźnika niezarządzanej pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tej metody można skopiować podzbiór tablicy zarządzanej <xref:System.IntPtr> jednowymiarowej do niezarządzanej tablicy w stylu C.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, lub <paramref name="length" /> jest .<see langword="null" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (float[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(float32[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Single(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;float&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : single[] * int * nativeint * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, startIndex, destination, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Single[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Tablica Jednowymiarowa do skopiowania.</param>
        <param name="startIndex">Indeks (liczony od zera) w tablicy źródłowej, w której należy rozpocząć kopiowanie.</param>
        <param name="destination">Wskaźnik pamięci do skopiowania.</param>
        <param name="length">Liczba elementów tablicy do skopiowania.</param>
        <summary>Kopiuje dane z jednowymiarowej, zarządzanej tablicy liczb zmiennoprzecinkowych o pojedynczej precyzji do niezarządzanego wskaźnika pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tej metody można skopiować podzbiór tablicy zarządzanej jednowymiarowej do niezarządzanej tablicy w stylu C.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />i <paramref name="length" /> są nieprawidłowe.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, lub <paramref name="length" /> jest .<see langword="null" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateAggregatedObject">
      <MemberSignature Language="C#" Value="public static IntPtr CreateAggregatedObject (IntPtr pOuter, object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateAggregatedObject(native int pOuter, object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateAggregatedObject (pOuter As IntPtr, o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CreateAggregatedObject(IntPtr pOuter, System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member CreateAggregatedObject : nativeint * obj -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.CreateAggregatedObject (pOuter, o)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;dotnet-uwp-10.0">
          <AttributeName>System.Obsolete("CreateAggregatedObject(IntPtr, Object) may be unavailable in future releases. Instead, use CreateAggregatedObject&lt;T&gt;(IntPtr, T). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296518")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pOuter" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="o" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pOuter">Zewnętrzny <see langword="IUnknown" /> wskaźnik.</param>
        <param name="o">Obiekt do zagregowania.</param>
        <summary>Agreguje zarządzany obiekt z określonym obiektem COM.</summary>
        <returns>Wewnętrzny <see langword="IUnknown" /> wskaźnik obiektu zarządzanego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda agreguje wewnętrzny zarządzany wskaźnik obiektu zarządzanego z określonym zewnętrznym wskaźnikiem, a następnie zwraca wewnętrzny wskaźnik IUnknown obiektu zarządzanego. [](https://go.microsoft.com/fwlink/?LinkId=148003) <xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="o" />[!INCLUDE[wrt](~/includes/wrt-md.md)] jest obiektem.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateAggregatedObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr CreateAggregatedObject&lt;T&gt; (IntPtr pOuter, T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateAggregatedObject&lt;T&gt;(native int pOuter, !!T o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateAggregatedObject(Of T) (pOuter As IntPtr, o As T) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static IntPtr CreateAggregatedObject(IntPtr pOuter, T o);" />
      <MemberSignature Language="F#" Value="static member CreateAggregatedObject : nativeint * 'T -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.CreateAggregatedObject (pOuter, o)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="pOuter" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="o" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zarządzanego obiektu do zagregowania.</typeparam>
        <param name="pOuter">Wskaźnik zewnętrznego elementu [IUnknown](https://go.microsoft.com/fwlink/?LinkId=148003) .</param>
        <param name="o">Obiekt zarządzany do zagregowania.</param>
        <summary>[Obsługiwane w .NET Framework 4.5.1 i nowszych wersjach]  
  
 Agreguje obiekt zarządzany określonego typu z określonym obiektem COM.</summary>
        <returns>Wewnętrzny wskaźnik <see href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</see> obiektu zarządzanego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda agreguje wewnętrzny zarządzany wskaźnik obiektu zarządzanego określonego typu z określonym zewnętrznym wskaźnikiem i zwraca wewnętrzny wskaźnik IUnknown obiektu zarządzanego. [](https://go.microsoft.com/fwlink/?LinkId=148003) <xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="o" />[!INCLUDE[wrt](~/includes/wrt-md.md)] jest obiektem.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateWrapperOfType">
      <MemberSignature Language="C#" Value="public static object CreateWrapperOfType (object o, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateWrapperOfType(object o, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateWrapperOfType (o As Object, t As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateWrapperOfType(System::Object ^ o, Type ^ t);" />
      <MemberSignature Language="F#" Value="static member CreateWrapperOfType : obj * Type -&gt; obj" Usage="System.Runtime.InteropServices.Marshal.CreateWrapperOfType (o, t)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;dotnet-uwp-10.0">
          <AttributeName>System.Obsolete("CreateWrapperOfType(Object, Type) may be unavailable in future releases. Instead, use CreateWrapperOfType&lt;T,T2&gt;(T). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296519")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">Obiekt, który ma być opakowany.</param>
        <param name="t">Typ otoki do utworzenia.</param>
        <summary>Zawija określony obiekt COM w obiekcie określonego typu.</summary>
        <returns>Nowo opakowany obiekt będący wystąpieniem żądanego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%2A>Konwertuje jeden typ klasy com, zazwyczaj typ podstawowy `__ComObject` , na inny typ klasy com. Wejściowy obiekt com, reprezentowany przez parametr `o`, jest wywoływanym [otoką środowiska uruchomieniowego](~/docs/framework/interop/runtime-callable-wrapper.md) (otoką).  
  
 Oba parametry `o` <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType>i muszą być klasami, których sygnatury są przypisane do. `t` Narzędzie [Tlbimp. exe (Importer biblioteki typów)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) stosuje ten atrybut podczas importowania biblioteki typów. W przypadku ręcznego tworzenia OTOKi w kodzie źródłowym należy zastosować ten atrybut do sygnatury zarządzanej, która reprezentuje pierwotną klasę coclass do oznaczania jej pochodzenia COM.  
  
 Tlbimp. exe importuje [klasę coclass](https://msdn.microsoft.com/library/333d0904-ffa2-4d25-878d-7422bcd40582) modelu COM jako klasę zarządzaną i interfejs. Interfejs klasy coclass ma taką samą nazwę jak oryginalna Klasa coclass, a zarządzana Klasa ma oryginalną nazwę klasy coclass dołączoną do "Class". Na przykład Klasa coclass `MyCoclass` jest interfejsem klasy coclass o nazwie `MyCoclass` i zarządzaną klasą o nazwie `MyCoclassClass`. Ponieważ `t` musi być klasą, a nie interfejsem, należy określić klasę zarządzaną (`MyCoclassClass`), a nie interfejs klasy coclass.  
  
> [!NOTE]
>  Utracisz tożsamość wejściowego obiektu COM, ponieważ nowe wystąpienie OTOKi zawija wskaźnik [IUnknown](https://go.microsoft.com/fwlink/?LinkId=148003) uwidoczniony przez ORYGINALną otokę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="t" />musi pochodzić od <see langword="__ComObject" />.  
  
—lub— 
 <paramref name="t" />[!INCLUDE[wrt](~/includes/wrt-md.md)] jest typem.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="t" /></exception>
        <exception cref="T:System.InvalidCastException"><paramref name="o" />nie można przekonwertować na typ docelowy, ponieważ nie obsługuje on wszystkich wymaganych interfejsów.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CreateWrapperOfType&lt;T,TWrapper&gt;">
      <MemberSignature Language="C#" Value="public static TWrapper CreateWrapperOfType&lt;T,TWrapper&gt; (T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TWrapper CreateWrapperOfType&lt;T, TWrapper&gt;(!!T o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateWrapperOfType(Of T, TWrapper) (o As T) As TWrapper" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TWrapper&gt;&#xA; static TWrapper CreateWrapperOfType(T o);" />
      <MemberSignature Language="F#" Value="static member CreateWrapperOfType : 'T -&gt; 'Wrapper" Usage="System.Runtime.InteropServices.Marshal.CreateWrapperOfType o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TWrapper</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TWrapper" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="o" Type="T" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ obiektu do zawinięcia.</typeparam>
        <typeparam name="TWrapper">Typ obiektu, który będzie zwracany.</typeparam>
        <param name="o">Obiekt, który ma być opakowany.</param>
        <summary>[Obsługiwane w .NET Framework 4.5.1 i nowszych wersjach]  
  
 Zawija określony obiekt COM w obiekcie określonego typu.</summary>
        <returns>Nowo opakowany obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%60%602%28%60%600%29>Konwertuje obiekt com typu `T` `TWrapper` na typ klasy com. Wejściowy obiekt com, reprezentowany przez parametr `o`, jest wywoływanym [otoką środowiska uruchomieniowego](~/docs/framework/interop/runtime-callable-wrapper.md) (otoką).  
  
 Oba parametry typu `o` <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType> ogólnego i parametru muszą być klasami, których sygnatury są przypisane do atrybutu. `T` Narzędzie [Tlbimp. exe (Importer biblioteki typów)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) stosuje ten atrybut podczas importowania biblioteki typów. W przypadku ręcznego tworzenia OTOKi w kodzie źródłowym należy zastosować ten atrybut do sygnatury zarządzanej, która reprezentuje pierwotną klasę coclass do oznaczania jej pochodzenia COM.  
  
 Tlbimp. exe importuje [klasę coclass](https://msdn.microsoft.com/library/333d0904-ffa2-4d25-878d-7422bcd40582) modelu COM jako klasę zarządzaną i interfejs. Interfejs klasy coclass ma taką samą nazwę jak oryginalna Klasa coclass, a zarządzana Klasa ma oryginalną nazwę klasy coclass dołączoną do "Class". Na przykład Klasa coclass `MyCoclass` jest interfejsem klasy coclass o nazwie `MyCoclass` i zarządzaną klasą o nazwie `MyCoclassClass`. Ponieważ`T` musi być klasą, a nie interfejsem, należy określić klasę zarządzaną (`MyCoclassClass`), a nie `coclass` interfejs.  
  
> [!NOTE]
>  Utracisz tożsamość wejściowego obiektu COM, ponieważ nowe wystąpienie OTOKi zawija wskaźnik [IUnknown](https://go.microsoft.com/fwlink/?LinkId=148003) uwidoczniony przez ORYGINALną otokę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><typeparamref name="T" />musi pochodzić od <see langword="__ComObject" />.  
  
—lub— 
 <typeparamref name="T" />[!INCLUDE[wrt](~/includes/wrt-md.md)] jest typem.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="o" />nie można przekonwertować na element <paramref name="TWrapper" /> , ponieważ nie obsługuje on wszystkich wymaganych interfejsów.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="DestroyStructure">
      <MemberSignature Language="C#" Value="public static void DestroyStructure (IntPtr ptr, Type structuretype);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DestroyStructure(native int ptr, class System.Type structuretype) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DestroyStructure (ptr As IntPtr, structuretype As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DestroyStructure(IntPtr ptr, Type ^ structuretype);" />
      <MemberSignature Language="F#" Value="static member DestroyStructure : nativeint * Type -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.DestroyStructure (ptr, structuretype)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;dotnet-uwp-10.0">
          <AttributeName>System.Obsolete("DestroyStructure(IntPtr, Type) may be unavailable in future releases. Instead, use DestroyStructure&lt;T&gt;(IntPtr). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296520")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structuretype" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ptr">Wskaźnik do niezarządzanego bloku pamięci.</param>
        <param name="structuretype">Typ sformatowanej klasy. Zapewnia to informacje o układzie niezbędne do usunięcia bufora w <paramref name="ptr" /> parametrze.</param>
        <summary>Zwalnia wszystkie struktury, do których odwołuje się określony blok pamięci niezarządzanej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody można użyć do zwolnienia pól typu odwołania, takich jak ciągi, struktury niezarządzanej. W przeciwieństwie do jego pól, struktura może być typem wartości lub typem referencyjnym. Struktury typu wartości zawierające pola typu wartości (wszystkie danych kopiowalnych) nie mają odwołań, których pamięć musi być zwolniona. <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType> Metoda używa tej metody, aby zapobiec przeciekom pamięci podczas wielokrotnego wykorzystywania pamięci zajętej przez strukturę.  
  
 <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A>wywołuje funkcję [SYSFREESTRING](https://go.microsoft.com/fwlink/?LinkId=148633) com, która z kolei zwalnia przydzieloną ciąg.  
  
 Oprócz <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A>klasy są <xref:System.Runtime.InteropServices.Marshal> dostępne dwie inne metody alokacji pamięci: <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> i <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="structureType" />ma automatyczny układ. Zamiast tego użyj sekwencyjnego lub jawnego.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
        <related type="Article" href="https://msdn.microsoft.com/library/~/docs/framework/interop/blittable-and-non-blittable-types.md">Danych kopiowalnych i typy inne niż danych kopiowalnych</related>
      </Docs>
    </Member>
    <Member MemberName="DestroyStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void DestroyStructure&lt;T&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DestroyStructure&lt;T&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DestroyStructure(Of T) (ptr As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void DestroyStructure(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member DestroyStructure : nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.DestroyStructure ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ sformatowanej struktury. Zapewnia to informacje o układzie niezbędne do usunięcia bufora w <paramref name="ptr" /> parametrze.</typeparam>
        <param name="ptr">Wskaźnik do niezarządzanego bloku pamięci.</param>
        <summary>[Obsługiwane w .NET Framework 4.5.1 i nowszych wersjach]  
  
 Zwalnia wszystkie podstruktury określonego typu, do których odwołuje się określony blok pamięci niezarządzanej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody można użyć do zwolnienia pól typu odwołania, takich jak ciągi, struktury niezarządzanej. W przeciwieństwie do jego pól, struktura może być typem wartości lub typem referencyjnym. Struktury typu wartości zawierające pola typu wartości (wszystkie danych kopiowalnych) nie mają odwołań, których pamięć musi być zwolniona. <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType> Metoda używa tej metody, aby zapobiec przeciekom pamięci podczas wielokrotnego wykorzystywania pamięci zajętej przez strukturę.  
  
 <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A>wywołuje funkcję [SYSFREESTRING](https://go.microsoft.com/fwlink/?LinkId=148633) com, która z kolei zwalnia przydzieloną ciąg.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><typeparamref name="T" />ma automatyczny układ. Zamiast tego użyj sekwencyjnego lub jawnego.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="FinalReleaseComObject">
      <MemberSignature Language="C#" Value="public static int FinalReleaseComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FinalReleaseComObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FinalReleaseComObject (o As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FinalReleaseComObject(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member FinalReleaseComObject : obj -&gt; int" Usage="System.Runtime.InteropServices.Marshal.FinalReleaseComObject o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="o">Otoka RCW do zwolnienia.</param>
        <summary>Zwalnia wszystkie odwołania do wywołanej <see href="https://docs.microsoft.com/dotnet/framework/interop/runtime-callable-wrapper">otoki środowiska uruchomieniowego</see> (RCW) przez ustawienie jej liczby odwołań na 0.</summary>
        <returns>Nowa wartość liczby odwołań otoki RCW skojarzonej z <paramref name="o" /> parametrem, która jest równa 0 (zero), jeśli wydanie zakończyło się pomyślnie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> Metoda zwalnia odwołanie zarządzane do obiektu com. Wywołanie tej metody jest równoważne wywołaniu <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> metody w pętli, dopóki nie zwróci 0 (zero).  
  
 Gdy liczba odwołań obiektu COM zmieni się na 0, obiekt COM jest zwykle zwolniony, chociaż zależy to od implementacji obiektu COM i wykracza poza kontrolę środowiska uruchomieniowego. Jednak otoka RCW nadal może istnieć, oczekując na przetworzenie elementów bezużytecznych.  
  
 Nie można użyć obiektu COM, gdy został oddzielony od jego podstawowej otoki RCW. Jeśli spróbujesz wywołać metodę dla otoki RCW, gdy jej liczba odwołań zmieni się na <xref:System.Runtime.InteropServices.InvalidComObjectException> 0, zostanie zgłoszony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="o" />nie jest prawidłowym obiektem COM.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="o" />jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)" />
        <altmember cref="T:System.NullReferenceException" />
      </Docs>
    </Member>
    <Member MemberName="FreeBSTR">
      <MemberSignature Language="C#" Value="public static void FreeBSTR (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeBSTR(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeBSTR (ptr As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeBSTR(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member FreeBSTR : nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.FreeBSTR ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres typu BSTR, który ma zostać zwolniony.</param>
        <summary>Zwalnia przy użyciu funkcji com [SysFreeString.](https://go.microsoft.com/fwlink/?LinkID=148633) <see langword="BSTR" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podobnie <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType> jak <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType>i, można użyć tej metody do cofnięcia przydziału pamięci. <xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A>wywołuje funkcję [SYSFREESTRING](https://go.microsoft.com/fwlink/?LinkID=148633) com, która zwalnia pamięć przydzieloną przez jedną z następujących metod niezarządzanych: `SysAllocString` `SysReAllocStringLen`, `SysAllocStringByteLen`, `SysAllocStringLen` `SysReAllocString`,. Można wywołać metody niezarządzane, takie jak te z wywołaniem platformy. Aby uzyskać szczegółowe informacje, zobacz wykorzystywanie [niezarządzanych funkcji DLL](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="FreeCoTaskMem">
      <MemberSignature Language="C#" Value="public static void FreeCoTaskMem (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeCoTaskMem(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeCoTaskMem (ptr As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeCoTaskMem(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member FreeCoTaskMem : nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.FreeCoTaskMem ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres pamięci, która ma zostać zwolniona.</param>
        <summary>Zwalnia blok pamięci przydzielonej przez niezarządzany Alokator pamięci zadania COM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> , aby zwolnić pamięć przydzieloną przez <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A>, <xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A>lub dowolną równoważną metodę niezarządzaną. Jeśli parametr ma `null`wartość, metoda nic nie robi. `ptr`  
  
 <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>uwidacznia funkcję [CoTaskMemFree](https://go.microsoft.com/fwlink/?LinkId=148638) com, która zwalnia wszystkie bajty, dzięki czemu nie można już używać pamięci, `ptr` do której wskazuje parametr.  
  
 Oprócz <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>klasy są <xref:System.Runtime.InteropServices.Marshal> dostępne dwie inne metody alokacji pamięci: <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> i <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="FreeHGlobal">
      <MemberSignature Language="C#" Value="public static void FreeHGlobal (IntPtr hglobal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeHGlobal(native int hglobal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeHGlobal (hglobal As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeHGlobal(IntPtr hglobal);" />
      <MemberSignature Language="F#" Value="static member FreeHGlobal : nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.FreeHGlobal hglobal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hglobal" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hglobal">Dojście zwrócone przez oryginalne wywołanie zgodne z <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />.</param>
        <summary>Zwalnia pamięć, która została wcześniej przypisana z niezarządzanej pamięci procesu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> , aby zwolnić dowolną pamięć z sterty globalnej przydzielonej <xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A>przez <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>, lub dowolną równoważną niezarządzaną metodę interfejsu API. Jeśli parametr jest <xref:System.IntPtr.Zero?displayProperty=nameWithType> metodą, nic nie robi. `hglobal`  
  
 <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>udostępnia funkcję [LocalFree](https://go.microsoft.com/fwlink/?LinkId=148640) z pliku Kernel32. dll, która zwalnia wszystkie bajty, dzięki czemu nie można już używać pamięci wskazanej przez `hglobal`.  
  
 Oprócz <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> , Klasa oferuje dwie inne metody interfejsu API alokacji pamięci: i <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>. <xref:System.Runtime.InteropServices.Marshal>  
  
   
  
## Examples  
 Poniższy przykład demonstruje wywołanie <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> metody. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Runtime.InteropServices.Marshal> klasy.  
  
 [!code-cpp[Marshal#4](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#4)]
 [!code-csharp[Marshal#4](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#4)]
 [!code-vb[Marshal#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#4)]  
  
 W poniższym przykładzie pokazano, jak przekonwertować zawartość klasy zarządzanej <xref:System.String> na niezarządzaną pamięć, a następnie usunąć niezarządzaną pamięć po zakończeniu.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/CPP/stringtohglobalansi.cpp#1)]
 [!code-csharp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/cs/stringtohglobalansi.cs#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="GenerateGuidForType">
      <MemberSignature Language="C#" Value="public static Guid GenerateGuidForType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GenerateGuidForType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GenerateGuidForType(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GenerateGuidForType : Type -&gt; Guid" Usage="System.Runtime.InteropServices.Marshal.GenerateGuidForType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">Typ, dla którego ma zostać wygenerowany identyfikator GUID.</param>
        <summary>Zwraca unikatowy identyfikator globalny (GUID) dla określonego typu lub generuje identyfikator GUID przy użyciu algorytmu używanego przez eksportera biblioteki typów (Tlbexp. exe).</summary>
        <returns>Identyfikator określonego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli typ ma identyfikator GUID w metadanych, zostanie zwrócony. W przeciwnym razie identyfikator GUID jest generowany automatycznie. Tej metody można użyć do programistycznego określania identyfikatora GUID modelu COM dla dowolnego typu zarządzanego, w tym typów niewidocznych dla modelu COM. Interfejsy klasy są jedynym wyjątkiem, ponieważ nie odpowiadają typowi zarządzanemu. <xref:System.Runtime.InteropServices.Marshal.GenerateGuidForType%2A>zapewnia te same funkcje co <xref:System.Type.GUID%2A?displayProperty=nameWithType> właściwość.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="P:System.Type.GUID" />
      </Docs>
    </Member>
    <Member MemberName="GenerateProgIdForType">
      <MemberSignature Language="C#" Value="public static string GenerateProgIdForType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GenerateProgIdForType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GenerateProgIdForType(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GenerateProgIdForType : Type -&gt; string" Usage="System.Runtime.InteropServices.Marshal.GenerateProgIdForType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">Typ, dla którego ma zostać pobrany identyfikator ProgID.</param>
        <summary>Zwraca identyfikator programowy (ProgID) dla określonego typu.</summary>
        <returns>Identyfikator ProgID określonego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli typ ma identyfikator ProgID w metadanych, zwracany jest ten ProgID. W przeciwnym razie identyfikator ProgID jest generowany na podstawie w pełni kwalifikowanej nazwy typu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> Parametr nie jest klasą, którą można utworzyć przy użyciu modelu com. Klasa musi być publiczna, mieć publiczny Konstruktor bez parametrów i być widoczny dla modelu COM.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="type" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetActiveObject">
      <MemberSignature Language="C#" Value="public static object GetActiveObject (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetActiveObject(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetActiveObject (progID As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetActiveObject(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetActiveObject : string -&gt; obj" Usage="System.Runtime.InteropServices.Marshal.GetActiveObject progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="progID">Identyfikator programowy (ProgID) żądanego obiektu.</param>
        <summary>Uzyskuje uruchomione wystąpienie określonego obiektu z tabeli uruchomionego obiektu (GNICIa).</summary>
        <returns>Obiekt, którego zażądano; w <see langword="null" />przeciwnym razie. Ten obiekt można rzutować na dowolny obsługiwany przez niego interfejs COM.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A>udostępnia funkcję COM [](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx) GetActiveObject z Oleaut32. BIBLIOTECE Jednak ten ostatni oczekuje identyfikatora klasy (CLSID) zamiast identyfikatora programistycznego (`ProgID`) oczekiwanego przez tę metodę. Aby uzyskać uruchomione wystąpienie obiektu COM bez zarejestrowanego `ProgID`, użyj wywołania platformy, aby zdefiniować funkcję com GetActiveObject. [](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx) Opis wywołania platformy można znaleźć w temacie [Używanie niezarządzanych funkcji DLL](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).  
  
## <a name="progid-and-clsid"></a>ProgID i CLSID  
 Klucze w poddrzewie HKEY_CLASSES_ROOT klucza rejestru zawierają różne typy podkluczy. Większość podkluczy to ProgID, które mapują ciąg przyjazny dla użytkownika na identyfikator CLSID. Aplikacje często używają tych ciągów, które można odczytać przez człowieka zamiast liczbowych identyfikatorów CLSID. Często składnik ma niezależny od wersji ProgID, który jest mapowany do najnowszej wersji składnika zainstalowanego w systemie.  
  
 Aplikacje i składniki używają przede wszystkim identyfikatorów ProgID, aby pobrać odpowiadające im identyfikatory CLSID.  
  
   
  
## Examples  
 Poniższy przykład został uruchomiony na komputerze, który został skonfigurowany z uruchomionym wystąpieniem programu Microsoft Word. Nie ma uruchomionych wystąpień programu Microsoft Excel.  
  
 Przykład wywołuje <xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A> dwa razy. Pierwsze wywołanie próbuje pobrać odwołanie do wystąpienia programu Microsoft Word (wystąpienie `Word.Application` obiektu). Drugie wywołanie próbuje pobrać odwołanie do wystąpienia programu Microsoft Excel (wystąpienie `Excel.Application` obiektu).  
  
 Kod pobiera odwołanie do wystąpienia programu Microsoft Word pomyślnie. Jednak ponieważ program Microsoft Excel nie jest uruchomiony, próba pobrania drugiego obiektu podnosi wartość <xref:System.Runtime.InteropServices.COMException>.  
  
 [!code-csharp[System.Runtime.InteropServices.Marshal.GetActiveObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.marshal.getactiveobject/cs/marshal.getactiveobject.cs#1)]
 [!code-vb[System.Runtime.InteropServices.Marshal.GetActiveObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.marshal.getactiveobject/vb/marshal.getactiveobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">Nie znaleziono obiektu.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetComInterfaceForObject">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wskaźnik interfejsu, który reprezentuje interfejs dla obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetComInterfaceForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject (object o, Type T);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject(object o, class System.Type T) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComInterfaceForObject (o As Object, T As Type) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetComInterfaceForObject(System::Object ^ o, Type ^ T);" />
      <MemberSignature Language="F#" Value="static member GetComInterfaceForObject : obj * Type -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetComInterfaceForObject (o, T)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;dotnet-uwp-10.0">
          <AttributeName>System.Obsolete("GetComInterfaceForObject(Object, Type) may be unavailable in future releases. Instead, use GetComInterfaceForObject&lt;T,T2&gt;(T). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296509")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="T" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">Obiekt, który dostarcza interfejs.</param>
        <param name="T">Typ żądanego interfejsu.</param>
        <summary>Zwraca wskaźnik do interfejsu <see href="https://go.microsoft.com/fwlink/?LinkId=148003">IUnknown</see> , który reprezentuje określony interfejs określonego obiektu. Niestandardowy dostęp do interfejsu zapytania jest domyślnie włączony.</summary>
        <returns>Wskaźnik interfejsu, który reprezentuje określony interfejs dla obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca wskaźnik interfejsu, który reprezentuje żądany interfejs określonego obiektu. Jest to szczególnie przydatne, jeśli masz niezarządzaną metodę, która oczekuje na przekazanie wskaźnika interfejsu. Wywołanie obiektu za pomocą tej metody powoduje zwiększenie liczby odwołań na wskaźniku interfejsu przed zwróceniem wskaźnika. Zawsze używaj <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> , aby zmniejszyć liczbę odwołań po zakończeniu wskaźnika. Należy przestrzegać reguł zdefiniowanych przez COM podczas korzystania ze wskaźników interfejsu COM raw.  
  
 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29>jest przydatne podczas wywoływania metody, która uwidacznia parametr obiektu com jako <xref:System.IntPtr> typ lub z organizatorem niestandardowym. Chociaż rzadziej, można użyć tej metody na zarządzanym obiekcie, aby uzyskać wskaźnik do wywoływanej otoki COM obiektu. Można na przykład użyć <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> obiektu zarządzanego, który został wyeksportowany do modelu COM, aby uzyskać wskaźnik interfejsu dla. <xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType> Nie można uzyskać wskaźnika do interfejsu klasy, ponieważ interfejs klasy nie ma odpowiedniego typu do przekazania do drugiego parametru (`t`). Zamiast tego należy <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> użyć do wywołania elementów członkowskich w domyślnym interfejsie otoki wywołującej com, która zazwyczaj jest interfejs klasy autowysyłania.  
  
 Przeciążenie <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> metody domyślnie zezwala na Dostosowywanie interfejsu zapytań. Aby określić, czy zastosować Dostosowywanie interfejsu zapytania, użyj <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> przeciążenia metody.  
  
 Aby uzyskać dodatkowe informacje, zobacz informacje o wywoływanej [otoki com](~/docs/framework/interop/com-callable-wrapper.md) i w [czasie wykonywania](~/docs/framework/interop/runtime-callable-wrapper.md) .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><typeparamref name="T" /> Parametr nie jest interfejsem.  
  
—lub— 
Typ nie jest widoczny dla modelu COM.  
  
—lub— 
<typeparamref name="T" /> Parametr jest definicją typu ogólnego.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="o" /> Parametr nie obsługuje żądanego interfejsu.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="o" />  
  
—lub— 
Parametr ma wartość <see langword="null" />. <typeparamref name="T" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="T:System.Runtime.InteropServices.UCOMIConnectionPointContainer" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject (object o, Type T, System.Runtime.InteropServices.CustomQueryInterfaceMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject(object o, class System.Type T, valuetype System.Runtime.InteropServices.CustomQueryInterfaceMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComInterfaceForObject (o As Object, T As Type, mode As CustomQueryInterfaceMode) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetComInterfaceForObject(System::Object ^ o, Type ^ T, System::Runtime::InteropServices::CustomQueryInterfaceMode mode);" />
      <MemberSignature Language="F#" Value="static member GetComInterfaceForObject : obj * Type * System.Runtime.InteropServices.CustomQueryInterfaceMode -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetComInterfaceForObject (o, T, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;dotnet-uwp-10.0">
          <AttributeName>System.Obsolete("GetComInterfaceForObject(Object, Type, CustomQueryInterfaceMode) and support for ICustomQueryInterface may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="T" Type="System.Type" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.Runtime.InteropServices.CustomQueryInterfaceMode" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="o">Obiekt, który dostarcza interfejs.</param>
        <param name="T">Typ żądanego interfejsu.</param>
        <param name="mode">Jedna z wartości wyliczenia, która wskazuje, czy zastosować <see langword="IUnknown::QueryInterface" /> dostosowanie dostarczone <see cref="T:System.Runtime.InteropServices.ICustomQueryInterface" />przez.</param>
        <summary>Zwraca wskaźnik do interfejsu <see href="https://go.microsoft.com/fwlink/?LinkId=148003">IUnknown</see> , który reprezentuje określony interfejs określonego obiektu. Niestandardowy dostęp do interfejsu zapytania jest kontrolowany przez określony tryb dostosowywania.</summary>
        <returns>Wskaźnik interfejsu, który reprezentuje interfejs obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29>pozwala określić, czy zastosować Dostosowywanie interfejsu zapytania. Użyj przeciążenia <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> , aby zastosować domyślne Dostosowywanie interfejsu zapytań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><typeparamref name="T" /> Parametr nie jest interfejsem.  
  
—lub— 
Typ nie jest widoczny dla modelu COM.  
  
—lub— 
<typeparamref name="T" /> Parametr jest definicją typu ogólnego.</exception>
        <exception cref="T:System.InvalidCastException">Obiekt <paramref name="o" /> nie obsługuje żądanego interfejsu.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="o" />  
  
—lub— 
Parametr ma wartość <see langword="null" />. <typeparamref name="T" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObject&lt;T,TInterface&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject&lt;T,TInterface&gt; (T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject&lt;T, TInterface&gt;(!!T o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComInterfaceForObject(Of T, TInterface) (o As T) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TInterface&gt;&#xA; static IntPtr GetComInterfaceForObject(T o);" />
      <MemberSignature Language="F#" Value="static member GetComInterfaceForObject : 'T -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetComInterfaceForObject o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TInterface" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="o" Type="T" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ <paramref name="o" />.</typeparam>
        <typeparam name="TInterface">Typ interfejsu do zwrócenia.</typeparam>
        <param name="o">Obiekt, który dostarcza interfejs.</param>
        <summary>[Obsługiwane w .NET Framework 4.5.1 i nowszych wersjach] 
Zwraca wskaźnik do interfejsu [IUnknown](https://go.microsoft.com/fwlink/?LinkId=148003) , który reprezentuje określony interfejs w obiekcie określonego typu. Niestandardowy dostęp do interfejsu zapytania jest domyślnie włączony.</summary>
        <returns>Wskaźnik interfejsu, który reprezentuje <paramref name="TInterface" /> interfejs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca wskaźnik interfejsu, który reprezentuje `TInterface` interfejs określonego obiektu. Jest to szczególnie przydatne, jeśli masz niezarządzaną metodę, która oczekuje na przekazanie wskaźnika interfejsu. Wywołanie obiektu za pomocą tej metody powoduje zwiększenie liczby odwołań na wskaźniku interfejsu przed zwróceniem wskaźnika. Zawsze używaj <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> metody, aby zmniejszyć liczbę odwołań po zakończeniu wskaźnika. Należy przestrzegać reguł zdefiniowanych przez COM podczas korzystania ze wskaźników interfejsu COM raw.  
  
 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29>jest przydatne podczas wywoływania metody, która uwidacznia parametr obiektu com jako <xref:System.IntPtr> typ lub z organizatorem niestandardowym. Można również użyć tej metody na zarządzanym obiekcie, aby uzyskać wskaźnik do możliwej otoki COM obiektu, chociaż jest to mniej typowe. Można na przykład użyć <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> obiektu zarządzanego, który został wyeksportowany do modelu COM, aby uzyskać wskaźnik interfejsu dla. <xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType>  
  
 Przeciążenie <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> metody domyślnie zezwala na Dostosowywanie interfejsu zapytań. Aby określić, czy zastosować Dostosowywanie interfejsu zapytania, użyj <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> przeciążenia metody.  
  
 Aby uzyskać dodatkowe informacje, zobacz informacje o wywoływanej [otoki com](~/docs/framework/interop/com-callable-wrapper.md) i w [czasie wykonywania](~/docs/framework/interop/runtime-callable-wrapper.md) .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="TInterface" /> Parametr nie jest interfejsem.  
  
—lub— 
Typ nie jest widoczny dla modelu COM.  
  
—lub— 
<typeparamref name="T" /> Parametr jest otwartym typem ogólnym.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="o" /> Parametr nie<paramref name="TInterface" /> obsługuje interfejsu.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="o" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObjectInContext (object o, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObjectInContext(object o, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComInterfaceForObjectInContext (o As Object, t As Type) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetComInterfaceForObjectInContext(System::Object ^ o, Type ^ t);" />
      <MemberSignature Language="F#" Value="static member GetComInterfaceForObjectInContext : obj * Type -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext (o, t)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="t" Type="System.Type" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="o">Obiekt, który dostarcza interfejs.</param>
        <param name="t">Typ żądanego interfejsu.</param>
        <summary>Zwraca wskaźnik interfejsu reprezentujący określony interfejs obiektu, jeśli obiekt wywołujący znajduje się w tym samym kontekście co ten obiekt.</summary>
        <returns>Wskaźnik interfejsu określony przez <paramref name="t" /> , który reprezentuje interfejs określonego obiektu lub <see langword="null" /> Jeśli obiekt wywołujący nie znajduje się w tym samym kontekście co obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest taka sama jak <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A> z tą różnicą `null` , że nie zwraca, jeśli obiekt wywołujący nie znajduje się w tym samym kontekście co obiekt. Jest to szczególnie przydatne, jeśli masz niezarządzaną metodę, która oczekuje na przekazanie wskaźnika interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="t" />nie jest interfejsem.  
  
—lub— 
Typ nie jest widoczny dla modelu COM.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="o" />nie obsługuje żądanego interfejsu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="o" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="t" />jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="T:System.Runtime.InteropServices.UCOMIConnectionPointContainer" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetComObjectData">
      <MemberSignature Language="C#" Value="public static object GetComObjectData (object obj, object key);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetComObjectData(object obj, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComObjectData (obj As Object, key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetComObjectData(System::Object ^ obj, System::Object ^ key);" />
      <MemberSignature Language="F#" Value="static member GetComObjectData : obj * obj -&gt; obj" Usage="System.Runtime.InteropServices.Marshal.GetComObjectData (obj, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="key" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt COM zawierający dane, które chcesz.</param>
        <param name="key">Klucz w tabeli <paramref name="obj" /> wewnętrznego skrótu, z którego mają zostać pobrane dane.</param>
        <summary>Pobiera dane, do których odwołuje się określony klucz z określonego obiektu COM.</summary>
        <returns>Dane reprezentowane przez <paramref name="key" /> parametr w wewnętrznej tabeli <paramref name="obj" /> skrótów parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie obiekty com otoczone otoką w [czasie wykonywania](~/docs/framework/interop/runtime-callable-wrapper.md) mają skojarzoną tabelę skrótów, <xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A> która pobiera. <xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A?displayProperty=nameWithType>Dodaje dane do tabeli skrótów. Nigdy nie należy wywoływać żadnej metody z kodu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="key" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="obj" />nie jest obiektem COM.  
  
—lub— 
 <paramref name="obj" />[!INCLUDE[wrt](~/includes/wrt-md.md)] jest obiektem.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetComSlotForMethodInfo">
      <MemberSignature Language="C#" Value="public static int GetComSlotForMethodInfo (System.Reflection.MemberInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetComSlotForMethodInfo(class System.Reflection.MemberInfo m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComSlotForMethodInfo (m As MemberInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetComSlotForMethodInfo(System::Reflection::MemberInfo ^ m);" />
      <MemberSignature Language="F#" Value="static member GetComSlotForMethodInfo : System.Reflection.MemberInfo -&gt; int" Usage="System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MemberInfo" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="m">Obiekt, który reprezentuje metodę interfejsu.</param>
        <summary>Pobiera gniazdo tabeli funkcji wirtualnych (v-table lub VTBL) dla określonego <see cref="T:System.Reflection.MemberInfo" /> typu, gdy ten typ jest uwidoczniony dla modelu com.</summary>
        <returns>Identyfikator gniazda <paramref name="m" /> VTBL, gdy jest on narażony na model com.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numer gniazda (liczony od zera) zwracanego przez tę metodę dla trzech [IUnknown](https://go.microsoft.com/fwlink/?LinkId=148003) i prawdopodobnie czterech metod [IDispatch](https://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) , która wprowadza wartość pierwszego dostępnego gniazda 3 lub 7. <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A>zapewnia odwrotną funkcjonalność programu <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType>.  
  
 Za pomocą tej metody można pobrać numery gniazd dla elementów członkowskich interfejsów, które nie są widoczne dla modelu COM i dla elementów członkowskich interfejsów prywatnych. Zwracane numery miejsc odpowiadają numerom tabeli v, które byłyby zarezerwowane, jeśli typ został ujawniony w modelu COM. Elementy członkowskie niewidoczne dla modelu COM faktycznie zajmują miejsce w uwidocznionej tabeli, nawet jeśli klient COM nie może użyć gniazda. Nie można użyć <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A> w interfejsie klasy przez przekazanie <xref:System.Reflection.MemberInfo> z klasy. Aby uzyskać dodatkowe informacje, zobacz [wprowadzenie do interfejsu klasy](~/docs/framework/interop/com-callable-wrapper.md#introducing-the-class-interface).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="m" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="m" /> Parametr<see cref="T:System.Reflection.MemberInfo" /> nie jest obiektem.  
  
—lub— 
<paramref name="m" /> Parametr nie jest metodą interfejsu.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      </Docs>
    </Member>
    <Member MemberName="GetDelegateForFunctionPointer">
      <MemberSignature Language="C#" Value="public static Delegate GetDelegateForFunctionPointer (IntPtr ptr, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate GetDelegateForFunctionPointer(native int ptr, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateForFunctionPointer (ptr As IntPtr, t As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ GetDelegateForFunctionPointer(IntPtr ptr, Type ^ t);" />
      <MemberSignature Language="F#" Value="static member GetDelegateForFunctionPointer : nativeint * Type -&gt; Delegate" Usage="System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer (ptr, t)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;dotnet-uwp-10.0">
          <AttributeName>System.Obsolete("GetDelegateForFunctionPointer(IntPtr, Type) may be unavailable in future releases. Instead, use GetDelegateForFunctionPointer&lt;T&gt;(IntPtr). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296521")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="t" Type="System.Type" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="ptr">Wskaźnik funkcji niezarządzanej do przekonwertowania.</param>
        <param name="t">Typ delegata, który ma zostać zwrócony.</param>
        <summary>Konwertuje wskaźnik funkcji niezarządzanej na delegata.</summary>
        <returns>Wystąpienie delegata, które może być rzutowane na odpowiedni typ delegata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W wersjach 1,0 i 1,1 .NET Framework można przekazać delegat reprezentujący zarządzaną metodę do niezarządzanego kodu jako wskaźnik funkcji, umożliwiając kod niezarządzany wywoływanie metody zarządzanej za pomocą wskaźnika funkcji. Możliwe jest również, że niezarządzany kod przeszedł wskaźnik funkcji z powrotem do kodu zarządzanego, a wskaźnik został prawidłowo rozpoznany dla bazowej metody zarządzanej.  
  
 W .NET Framework 2,0 i nowszych wersjach można użyć <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A> metod i <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A> do organizowania delegatów w obu kierunkach. <xref:System.IntPtr?displayProperty=nameWithType>Program <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A> wprogramie`ptr` jest importowany jako. Można uzyskać dla zarządzanego delegata przez wywołanie <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A> i przekazanie jako parametr; można go następnie wywołać z wewnątrz metody niezarządzanej. <xref:System.IntPtr?displayProperty=nameWithType> Należy zauważyć, że organizator parametrów może również kierować wskaźniki funkcji do delegatów w .NET Framework 2,0 i nowszych wersjach.  
  
 <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A> Metoda ma następujące ograniczenia:  
  
-   Typy ogólne nie są obsługiwane w scenariuszach międzyoperacyjnych.  
  
-   Nie można przekazać nieprawidłowego wskaźnika funkcji do tej metody.  
  
-   Tej metody można użyć tylko w przypadku czystych wskaźników funkcji niezarządzanych.  
  
-   Nie można użyć tej metody ze wskaźnikami funkcji uzyskanymi za pośrednictwem C++ lub z <xref:System.RuntimeMethodHandle.GetFunctionPointer%2A> metody.  
  
-   Nie można użyć tej metody, aby utworzyć delegata ze wskaźnika funkcji do innego zarządzanego delegata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="t" /> Parametr nie jest obiektem delegowanym ani jest ogólny.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="ptr" />  
  
—lub— 
Parametr ma wartość <see langword="null" />. <paramref name="t" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateForFunctionPointer&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static TDelegate GetDelegateForFunctionPointer&lt;TDelegate&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TDelegate GetDelegateForFunctionPointer&lt;TDelegate&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateForFunctionPointer(Of TDelegate) (ptr As IntPtr) As TDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static TDelegate GetDelegateForFunctionPointer(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member GetDelegateForFunctionPointer : nativeint -&gt; 'Delegate" Usage="System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TDelegate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Typ delegata do zwrócenia.</typeparam>
        <param name="ptr">Wskaźnik funkcji niezarządzanej do przekonwertowania.</param>
        <summary>[Obsługiwane w .NET Framework 4.5.1 i nowszych wersjach]  
  
 Konwertuje wskaźnik funkcji niezarządzanej na delegata określonego typu.</summary>
        <returns>Wystąpienie określonego typu delegata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29> metod i <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%60%601%28%60%600%29> do organizowania delegatów w obu kierunkach.  
  
 <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29> Metoda ma następujące ograniczenia:  
  
-   Nie można przekazać nieprawidłowego wskaźnika funkcji do tej metody.  
  
-   Tej metody można użyć tylko w przypadku czystych wskaźników funkcji niezarządzanych.  
  
-   Nie można użyć tej metody ze wskaźnikami funkcji uzyskanymi za pośrednictwem C++ lub z <xref:System.RuntimeMethodHandle.GetFunctionPointer%2A> metody.  
  
-   Nie można użyć tej metody, aby utworzyć delegata ze wskaźnika funkcji do innego zarządzanego delegata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Parametr <paramref name="TDelegate" /> generyczny nie jest delegatem lub jest otwartym typem ogólnym.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="ptr" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetEndComSlot">
      <MemberSignature Language="C#" Value="public static int GetEndComSlot (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetEndComSlot(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEndComSlot (t As Type) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetEndComSlot(Type ^ t);" />
      <MemberSignature Language="F#" Value="static member GetEndComSlot : Type -&gt; int" Usage="System.Runtime.InteropServices.Marshal.GetEndComSlot t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="t">Typ, który reprezentuje interfejs lub klasę.</param>
        <summary>Pobiera ostatnie miejsce w tabeli funkcji wirtualnych (v-table lub VTBL) typu, gdy zostanie uwidocznione w modelu COM.</summary>
        <returns>Ostatnie VTBL gniazdo interfejsu w przypadku udostępnienia modelu COM. <paramref name="t" /> Jeśli parametr jest klasą, zwrócone gniazdo VTBL jest ostatnim gniazdem w interfejsie, który jest generowany na podstawie klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca numer tabeli (liczony od zera) dla interfejsu lub klasy. W przypadku użycia w klasie, zwracany numer gniazda odnosi się do interfejsu klasy klasy. Jeśli interfejs klasy jest wysyłany do autowysyłania, ta metoda zawsze zwraca wartość-1, aby wskazać, że interfejs tylko do wysyłania nie uwidacznia tabeli v dla zarządzanych klientów. Możesz użyć <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A> programu i w połączeniu z <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType> usługą, <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType> aby przekazywać gniazda w określonym zakresie. Aby uzyskać dodatkowe informacje, zobacz [wprowadzenie do interfejsu klasy](~/docs/framework/interop/com-callable-wrapper.md#introducing-the-class-interface).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      </Docs>
    </Member>
    <Member MemberName="GetExceptionCode">
      <MemberSignature Language="C#" Value="public static int GetExceptionCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetExceptionCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExceptionCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetExceptionCode();" />
      <MemberSignature Language="F#" Value="static member GetExceptionCode : unit -&gt; int" Usage="System.Runtime.InteropServices.Marshal.GetExceptionCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("GetExceptionCode() may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kod, który identyfikuje typ wyjątku, który wystąpił.</summary>
        <returns>Typ wyjątku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetExceptionCode%2A>jest narażony na obsługę kompilatora dla obsługi wyjątków strukturalnych (SEH). Jeśli ta metoda jest wywoływana przed zgłoszeniem wyjątku, zwraca 0x0.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetExceptionForHR">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje kod błędu HRESULT na odpowiedni <see cref="T:System.Exception" /> obiekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetExceptionForHR">
      <MemberSignature Language="C#" Value="public static Exception GetExceptionForHR (int errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception GetExceptionForHR(int32 errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExceptionForHR (errorCode As Integer) As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Exception ^ GetExceptionForHR(int errorCode);" />
      <MemberSignature Language="F#" Value="static member GetExceptionForHR : int -&gt; Exception" Usage="System.Runtime.InteropServices.Marshal.GetExceptionForHR errorCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="errorCode">WYNIK HRESULT do przekonwertowania.</param>
        <summary>Konwertuje określony kod błędu HRESULT na odpowiedni <see cref="T:System.Exception" /> obiekt.</summary>
        <returns>Obiekt reprezentujący przekonwertowane HRESULT lub <see langword="null" /> Jeśli wartość HRESULT nie reprezentuje kodu błędu (na <see langword="S_OK" /> przykład lub <see langword="S_FALSE" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj metody, aby <xref:System.Exception> uzyskać w oparciu o wynik HRESULT <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> bez konieczności wywoływania metody i przechwytywania wyjątku. <xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A>  
  
 Bieżący interfejs [IErrorInfo](https://msdn.microsoft.com/library/4dda6909-2d9a-4727-ae0c-b5f90dcfa447) jest używany do konstruowania wyjątku.  
  
 Aby uzyskać mapowanie z każdego HRESULT do jego porównywalnej klasy Exception w .NET Framework, zobacz [How to: Mapuj HRESULTs i Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="Overload:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms221233(v=vs.85).aspx">IErrorInfo, interfejs</related>
      </Docs>
    </Member>
    <Member MemberName="GetExceptionForHR">
      <MemberSignature Language="C#" Value="public static Exception GetExceptionForHR (int errorCode, IntPtr errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception GetExceptionForHR(int32 errorCode, native int errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExceptionForHR (errorCode As Integer, errorInfo As IntPtr) As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Exception ^ GetExceptionForHR(int errorCode, IntPtr errorInfo);" />
      <MemberSignature Language="F#" Value="static member GetExceptionForHR : int * nativeint -&gt; Exception" Usage="System.Runtime.InteropServices.Marshal.GetExceptionForHR (errorCode, errorInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorInfo" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="errorCode">WYNIK HRESULT do przekonwertowania.</param>
        <param name="errorInfo">Wskaźnik do <see langword="IErrorInfo" /> interfejsu, który zawiera więcej informacji o błędzie. Można określić <c>IntPtr (0)</c> , aby użyć bieżącego <see langword="IErrorInfo" /> interfejsu lub <c>IntPtr (-1)</c> do ignorowania bieżącego <see langword="IErrorInfo" /> interfejsu i konstruowania wyjątku bezpośrednio od kodu błędu.</param>
        <summary>Konwertuje określony kod błędu HRESULT na odpowiedni <see cref="T:System.Exception" /> obiekt, z dodatkowymi informacjami o błędzie przekazaną w interfejsie [IErrorInfo](https://msdn.microsoft.com/library/4dda6909-2d9a-4727-ae0c-b5f90dcfa447) dla obiektu Exception.</summary>
        <returns>Obiekt reprezentujący przekonwertowane wartości HRESULT i informacje uzyskane z <paramref name="errorInfo" />lub <see langword="null" /> Jeśli wartość HRESULT nie reprezentuje <see langword="S_OK" /> kodu błędu (na przykład lub <see langword="S_FALSE" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj metody, aby <xref:System.Exception> uzyskać na podstawie HRESULT, <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> bez konieczności wywoływania metody i wychwycić wyjątek (w ten sposób unikając odpowiedniego obciążenia wydajności). <xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A> `errorInfo` Parametr dostarcza dodatkowych informacji o błędzie, takich jak opis tekstowy i unikatowy identyfikator globalny (GUID) dla interfejsu, który definiuje błąd.  
  
 Użyj tego przeciążenia metody, jeśli masz niestandardowe informacje o błędzie, które należy podać w konwersji.  
  
 Aby uzyskać mapowanie z każdego HRESULT do jego porównywalnej klasy Exception w .NET Framework, zobacz [How to: Mapuj HRESULTs i Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="Overload:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms221233(v=vs.85).aspx">IErrorInfo, interfejs</related>
      </Docs>
    </Member>
    <Member MemberName="GetExceptionPointers">
      <MemberSignature Language="C#" Value="public static IntPtr GetExceptionPointers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetExceptionPointers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionPointers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExceptionPointers () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetExceptionPointers();" />
      <MemberSignature Language="F#" Value="static member GetExceptionPointers : unit -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetExceptionPointers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera niezależny od komputera opis wyjątku i informacje o stanie istniały dla wątku, gdy wystąpił wyjątek.</summary>
        <returns>Wskaźnik do struktury <see href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-_exception_pointers">EXCEPTION_POINTERS</see> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetExceptionPointers%2A>jest narażony na obsługę kompilatora dla obsługi wyjątków strukturalnych (SEH).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetFunctionPointerForDelegate">
      <MemberSignature Language="C#" Value="public static IntPtr GetFunctionPointerForDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetFunctionPointerForDelegate(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFunctionPointerForDelegate (d As Delegate) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetFunctionPointerForDelegate(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="static member GetFunctionPointerForDelegate : Delegate -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;dotnet-uwp-10.0">
          <AttributeName>System.Obsolete("GetFunctionPointerForDelegate(Delegate) may be unavailable in future releases. Instead, use GetFunctionPointerForDelegate&lt;T&gt;(T). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296522")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d">Delegat do przekazania do niezarządzanego kodu.</param>
        <summary>Konwertuje delegata na wskaźnik funkcji, który jest wywoływany z kodu niezarządzanego.</summary>
        <returns>Wartość, która może zostać przeniesiona do niezarządzanego kodu, która z kolei może użyć go do wywołania podstawowego zarządzanego delegata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat `d` jest konwertowany na wskaźnik funkcji, który można przekazać do niezarządzanego kodu przy użyciu konwencji wywoływania [__stdcall](https://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8) .  
  
 Należy ręcznie zachować delegata, który ma być zbierany przez moduł wyrzucania elementów bezużytecznych z kodu zarządzanego. Moduł wyrzucania elementów bezużytecznych nie śledzi odwołań do kodu niezarządzanego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="d" /> Parametr jest definicją typu ogólnego.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="d" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetFunctionPointerForDelegate&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr GetFunctionPointerForDelegate&lt;TDelegate&gt; (TDelegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetFunctionPointerForDelegate&lt;TDelegate&gt;(!!TDelegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFunctionPointerForDelegate(Of TDelegate) (d As TDelegate) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static IntPtr GetFunctionPointerForDelegate(TDelegate d);" />
      <MemberSignature Language="F#" Value="static member GetFunctionPointerForDelegate : 'Delegate -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="d" Type="TDelegate" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Typ delegata do przekonwertowania.</typeparam>
        <param name="d">Delegat do przekazania do niezarządzanego kodu.</param>
        <summary>[Obsługiwane w .NET Framework 4.5.1 i nowszych wersjach]  
  
 Konwertuje delegat określonego typu na wskaźnik funkcji, która jest wywoływana z kodu niezarządzanego.</summary>
        <returns>Wartość, która może zostać przeniesiona do niezarządzanego kodu, która z kolei może użyć go do wywołania podstawowego zarządzanego delegata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat `d` jest konwertowany na wskaźnik funkcji, który można przekazać do niezarządzanego kodu przy użyciu konwencji wywoływania [__stdcall](https://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8) .  
  
 Należy ręcznie zachować delegata, który ma być zbierany przez moduł wyrzucania elementów bezużytecznych z kodu zarządzanego. Moduł wyrzucania elementów bezużytecznych nie śledzi odwołań do kodu niezarządzanego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="d" /> Parametr jest definicją typu ogólnego.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="d" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetHINSTANCE">
      <MemberSignature Language="C#" Value="public static IntPtr GetHINSTANCE (System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetHINSTANCE(class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetHINSTANCE(System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHINSTANCE (m As Module) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetHINSTANCE(System::Reflection::Module ^ m);" />
      <MemberSignature Language="F#" Value="static member GetHINSTANCE : System.Reflection.Module -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetHINSTANCE m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.Module" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="m">Moduł, którego HINSTANCE jest pożądany.</param>
        <summary>Zwraca dojście wystąpienia (HINSTANCE) dla określonego modułu.</summary>
        <returns>HINSTANCE dla <paramref name="m" />; lub-1, jeśli moduł nie ma HINSTANCE.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy dynamiczne lub w pamięci, moduły nie mają HINSTANCE.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="m" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetHRForException">
      <MemberSignature Language="C#" Value="public static int GetHRForException (Exception e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHRForException(class System.Exception e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHRForException (e As Exception) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHRForException(Exception ^ e);" />
      <MemberSignature Language="F#" Value="static member GetHRForException : Exception -&gt; int" Usage="System.Runtime.InteropServices.Marshal.GetHRForException e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="e">Wyjątek do przekonwertowania na wynik HRESULT.</param>
        <summary>Konwertuje określony wyjątek na wynik HRESULT.</summary>
        <returns>Wartość HRESULT zamapowana do podanego wyjątku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A>konfiguruje również interfejs [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) dla wyjątku, który można uzyskać, WYWOŁUJĄC funkcję com GetErrorInfoNEEDGUID. Za pomocą tej funkcji można zwrócić wartość HRESULT dla implementacji klasy zarządzanej interfejsu com, w której zastosowano <xref:System.Runtime.InteropServices.PreserveSigAttribute> atrybut. Metoda z atrybutem Przechwytuj wszystkie wyjątki i Użyj <xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> metody, aby zwrócić odpowiednią wartość HRESULT. Umożliwienie wyjątku do propagowania poza metodą daje nieprawidłowe zachowanie. (W rzeczywistości środowisko uruchomieniowe języka wspólnego nie przeszedł do klienta COM, który wywołuje taką metodę za pomocą tabeli v).  
  
 Należy zauważyć, <xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> że metoda ustawia interfejs [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) bieżącego wątku. Może to spowodować nieoczekiwane wyniki dla metod <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> , takich jak metody, które domyślnie używają [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) bieżącego wątku, jeśli jest ustawiony.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.InteropServices.PreserveSigAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetHRForLastWin32Error">
      <MemberSignature Language="C#" Value="public static int GetHRForLastWin32Error ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHRForLastWin32Error() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHRForLastWin32Error () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHRForLastWin32Error();" />
      <MemberSignature Language="F#" Value="static member GetHRForLastWin32Error : unit -&gt; int" Usage="System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość HRESULT odpowiadającą ostatniemu błędowi związanemu z kodem Win32 <see cref="T:System.Runtime.InteropServices.Marshal" />wykonywanym przy użyciu polecenia.</summary>
        <returns>WYNIK HRESULT odpowiadający ostatniemu kodowi błędu Win32.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Funkcja docelowa musi mieć `setLastError` ustawioną flagę metadanych. Na przykład `SetLastError` pole musi mieć `true`wartość <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType> . Proces ustawiania tej flagi zależy od używanego języka źródłowego: C#i C++ są `false` `true`domyślnie, ale instrukcja w Visual Basic ma wartość. `Declare`  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak pobrać wynik HRESULT odpowiadający kodowi błędu Win32 przy użyciu <xref:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error%2A> metody.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetHRForLastWin32Error#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetHRForLastWin32Error/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetHRForLastWin32Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetHRForLastWin32Error/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetIDispatchForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetIDispatchForObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIDispatchForObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIDispatchForObject (o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetIDispatchForObject(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetIDispatchForObject : obj -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetIDispatchForObject o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="o">Obiekt, którego <see langword="IDispatch" /> żądany jest interfejs.</param>
        <summary>Zwraca interfejs <see href="https://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5">IDispatch</see> z obiektu zarządzanego.</summary>
        <returns><see langword="IDispatch" /> Wskaźnik<paramref name="o" /> dla parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kodzie zarządzanym rzadko Pracujesz bezpośrednio z `IDispatch` interfejsem. Jednak jest to przydatne podczas wywoływania metody, która uwidacznia parametr obiektu com <xref:System.IntPtr> jako typ lub z organizatorem niestandardowym. <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A> Wywołanie obiektu za pomocą tej metody powoduje zwiększenie liczby odwołań na wskaźniku interfejsu przed zwróceniem wskaźnika. Zawsze używaj <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> , aby zmniejszyć liczbę odwołań po zakończeniu wskaźnika.  
  
 Można również użyć tej metody na zarządzanym obiekcie, aby uzyskać wskaźnik interfejsu do przystosowanej otoki COM dla obiektu. Dodatkowe informacje można znaleźć w temacie wywoływanie [otoki com](~/docs/framework/interop/com-callable-wrapper.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException"><paramref name="o" />nie obsługuje żądanego interfejsu.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetIDispatchForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetIDispatchForObjectInContext (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIDispatchForObjectInContext(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIDispatchForObjectInContext (o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetIDispatchForObjectInContext(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetIDispatchForObjectInContext : obj -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="o">Obiekt, którego <see langword="IDispatch" /> żądany jest interfejs.</param>
        <summary>Zwraca wskaźnik interfejsu <see href="https://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5">IDispatch</see> z obiektu zarządzanego, jeśli obiekt wywołujący znajduje się w tym samym kontekście co ten obiekt.</summary>
        <returns>Wskaźnik interfejsu dla określonego obiektu lub <see langword="null" /> Jeśli obiekt wywołujący nie znajduje się w tym samym kontekście co określony obiekt. <see langword="IDispatch" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest taka sama jak <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A> z tą różnicą `null` , że nie zwraca, jeśli obiekt wywołujący nie znajduje się w tym samym kontekście co obiekt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException"><paramref name="o" />nie obsługuje żądanego interfejsu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="o" />jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetITypeInfoForType">
      <MemberSignature Language="C#" Value="public static IntPtr GetITypeInfoForType (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetITypeInfoForType(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetITypeInfoForType (t As Type) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetITypeInfoForType(Type ^ t);" />
      <MemberSignature Language="F#" Value="static member GetITypeInfoForType : Type -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetITypeInfoForType t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="t">Typ, którego <see langword="ITypeInfo" /> interfejs jest żądany.</param>
        <summary><see cref="T:System.Runtime.InteropServices.ComTypes.ITypeInfo" /> Zwraca interfejs z typu zarządzanego.</summary>
        <returns>Wskaźnik do <see langword="ITypeInfo" /> interfejsu <paramref name="t" /> dla parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca wskaźnik do `ITypeInfo` implementacji, która jest oparta na oryginalnym typie. Wywołanie obiektu z <xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A> powoduje, że licznik odwołań zostanie zwiększony na wskaźniku interfejsu przed zwróceniem wskaźnika. Zawsze używaj <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> , aby zmniejszyć liczbę odwołań po zakończeniu wskaźnika. Można zastosować, <xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType> aby zastąpić standardowe zachowanie organizowania międzyoperacyjności z tym organizatorem niestandardowym.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak pobrać wskaźnik do `ITypeInfo` interfejsu dla typu <xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A> za pomocą metody.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetITypeInfoForType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetITypeInfoForType/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetITypeInfoForType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetITypeInfoForType/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="t" />nie jest widocznym typem w modelu COM.  
  
—lub— 
 <paramref name="t" />[!INCLUDE[wrt](~/includes/wrt-md.md)] jest typem.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Biblioteka typów jest zarejestrowana dla zestawu, który zawiera typ, ale nie można odnaleźć definicji typu.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)" />
        <altmember cref="T:System.Runtime.InteropServices.MarshalAsAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetIUnknownForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetIUnknownForObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIUnknownForObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIUnknownForObject (o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetIUnknownForObject(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetIUnknownForObject : obj -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetIUnknownForObject o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Obiekt, którego <see langword="IUnknown" /> żądany jest interfejs.</param>
        <summary>Zwraca interfejs <see href="https://go.microsoft.com/fwlink/?LinkId=148003">IUnknown</see> z obiektu zarządzanego.</summary>
        <returns><see langword="IUnknown" /> Wskaźnik<paramref name="o" /> dla parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kodzie zarządzanym rzadko Pracujesz bezpośrednio z `IUnknown` interfejsem. Jednak jest to przydatne podczas wywoływania metody, która uwidacznia parametr obiektu com <xref:System.IntPtr> jako typ lub z organizatorem niestandardowym. <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> Wywołanie obiektu za pomocą tej metody powoduje zwiększenie liczby odwołań na wskaźniku interfejsu przed zwróceniem wskaźnika. Zawsze używaj <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> , aby zmniejszyć liczbę odwołań po zakończeniu wskaźnika. Ta metoda zapewnia odwrotną funkcjonalność <xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A?displayProperty=nameWithType> metody.  
  
 Można również użyć tej metody na zarządzanym obiekcie, aby uzyskać wskaźnik interfejsu do przystosowanej [otoki com](~/docs/framework/interop/com-callable-wrapper.md) dla obiektu.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób pobierania interfejsu [IUnknown](https://go.microsoft.com/fwlink/?LinkId=148003) dla obiektu zarządzanego przy użyciu <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> metody.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="GetIUnknownForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetIUnknownForObjectInContext (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIUnknownForObjectInContext(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIUnknownForObjectInContext (o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetIUnknownForObjectInContext(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetIUnknownForObjectInContext : obj -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="o">Obiekt, którego <see langword="IUnknown" /> żądany jest interfejs.</param>
        <summary>Zwraca interfejs <see href="https://go.microsoft.com/fwlink/?LinkId=148003">IUnknown</see> z obiektu zarządzanego, jeśli obiekt wywołujący znajduje się w tym samym kontekście co ten obiekt.</summary>
        <returns>Wskaźnik dla określonego obiektu lub <see langword="null" /> Jeśli obiekt wywołujący nie znajduje się w tym samym kontekście co określony obiekt. <see langword="IUnknown" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest taka sama jak <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> z tą różnicą `null` , że nie zwraca, jeśli obiekt wywołujący nie znajduje się w tym samym kontekście co obiekt.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób pobierania `IUnknown` interfejsu dla obiektu zarządzanego <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext%2A> przy użyciu metody.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="GetLastWin32Error">
      <MemberSignature Language="C#" Value="public static int GetLastWin32Error ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetLastWin32Error() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWin32Error () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetLastWin32Error();" />
      <MemberSignature Language="F#" Value="static member GetLastWin32Error : unit -&gt; int" Usage="System.Runtime.InteropServices.Marshal.GetLastWin32Error " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod błędu zwracany przez ostatnią niezarządzaną funkcję, która została wywołana przy użyciu wywołania platformy z <see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /> ustawioną flagą.</summary>
        <returns>Kod ostatniego błędu ustawiany przez wywołanie funkcji Win32 <see href="https://msdn.microsoft.com/library/ms680627.aspx">SetLastError</see> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

W systemach <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> Windows udostępnia funkcję [GetLastError](/windows/desktop/ms679360) Win32 z pliku Kernel32. dll. Ta metoda istnieje, ponieważ nie jest to niezawodne, aby umożliwić bezpośrednie wywołanie `GetLastError` tej platformy w celu uzyskania tych informacji. Jeśli chcesz uzyskać dostęp do tego kodu błędu, należy wywołać <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> zamiast pisać własną definicję wywołania platformy dla `GetLastError` i wywołując go. Środowisko uruchomieniowe języka wspólnego może wykonywać wywołania wewnętrzne interfejsów API, które `GetLastError` zastępują obsługiwane przez system operacyjny.  

Tej metody można użyć do uzyskania kodów błędów tylko w przypadku zastosowania <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType> do sygnatury metody i <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError?displayProperty=nameWithType> ustawienia pola na`true`. Ten proces zależy od używanego języka źródłowego: C#i C++ są `false` `true`domyślnie, ale instrukcja w Visual Basic ma wartość. `Declare`  
  
Istnieje różnica w zachowaniu `GetLastWin32Error` metody na platformie .NET Core i .NET Framework, gdy <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError?displayProperty=nameWithType> jest `true`. Na .NET Framework `GetLastWin32Error` Metoda może zachować informacje o błędzie z jednego wywołania P/Invoke do następnego. W przypadku platformy .NET Core informacje o błędzie są czyszczone przed wywołaniem P/ `GetLastWin32Error` Invoke i reprezentują tylko informacje o błędzie z ostatniego wywołania metody.

## Examples  
 Poniższy przykład wywołuje `GetLastWin32Error` metodę. Przykład najpierw demonstruje wywołanie metody bez błędu, a następnie demonstruje wywołanie metody z obecnym błędem.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetLastWin32Error#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetLastWin32Error/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetLastWin32Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetLastWin32Error/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetManagedThunkForUnmanagedMethodPtr">
      <MemberSignature Language="C#" Value="public static IntPtr GetManagedThunkForUnmanagedMethodPtr (IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetManagedThunkForUnmanagedMethodPtr(native int pfnMethodToWrap, native int pbSignature, int32 cbSignature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetManagedThunkForUnmanagedMethodPtr (pfnMethodToWrap As IntPtr, pbSignature As IntPtr, cbSignature As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetManagedThunkForUnmanagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberSignature Language="F#" Value="static member GetManagedThunkForUnmanagedMethodPtr : nativeint * nativeint * int -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr (pfnMethodToWrap, pbSignature, cbSignature)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The GetManagedThunkForUnmanagedMethodPtr method has been deprecated and will be removed in a future release.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pfnMethodToWrap" Type="System.IntPtr" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pbSignature" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="cbSignature" Type="System.Int32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pfnMethodToWrap">Wskaźnik do metody Marshal.</param>
        <param name="pbSignature">Wskaźnik do sygnatury metody.</param>
        <param name="cbSignature">Liczba bajtów w <paramref name="pbSignature" />.</param>
        <summary>Pobiera wskaźnik do funkcji generowanej przez środowisko uruchomieniowe, która umożliwia kierowanie wywołania z zarządzanego do niezarządzanego kodu.</summary>
        <returns>Wskaźnik do funkcji, która będzie kierować wywołanie z <paramref name="pfnMethodToWrap" /> parametru do kodu niezarządzanego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr%2A>jest udostępniany tylko do obsługi kompilatora.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodInfoForComSlot">
      <MemberSignature Language="C#" Value="public static System.Reflection.MemberInfo GetMethodInfoForComSlot (Type t, int slot, ref System.Runtime.InteropServices.ComMemberType memberType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MemberInfo GetMethodInfoForComSlot(class System.Type t, int32 slot, valuetype System.Runtime.InteropServices.ComMemberType&amp; memberType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodInfoForComSlot (t As Type, slot As Integer, ByRef memberType As ComMemberType) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MemberInfo ^ GetMethodInfoForComSlot(Type ^ t, int slot, System::Runtime::InteropServices::ComMemberType % memberType);" />
      <MemberSignature Language="F#" Value="static member GetMethodInfoForComSlot : Type * int *  -&gt; System.Reflection.MemberInfo" Usage="System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot (t, slot, memberType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="slot" Type="System.Int32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="memberType" Type="System.Runtime.InteropServices.ComMemberType" RefType="ref" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="t">Typ, dla którego <see cref="T:System.Reflection.MemberInfo" /> ma zostać pobrany.</param>
        <param name="slot">Gniazdo VTBL.</param>
        <param name="memberType">Po pomyślnym powrocie, jedna z wartości wyliczenia, która określa typ elementu członkowskiego.</param>
        <summary><see cref="T:System.Reflection.MemberInfo" /> Pobiera obiekt dla określonego gniazda tabeli funkcji wirtualnych (v-table lub VTBL).</summary>
        <returns>Obiekt, który reprezentuje element członkowski w określonym gnieździe VTBL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwracana wartość może być <xref:System.Reflection.FieldInfo>obiektem, <xref:System.Reflection.MethodInfo>lub. <xref:System.Reflection.PropertyInfo> Wartość zwracana jest zależna od typu zarządzanego elementu członkowskiego, który istnieje w danym gnieździe com (w związku z tym uogólniony typ <xref:System.Reflection.MemberInfo> zwracany, z którego wszystkie trzy pochodne).  
  
 Numer gniazda (liczony od zera), który jest zwracany przez te metody dla trzech [IUnknown](https://go.microsoft.com/fwlink/?LinkId=148003) i prawdopodobnie czterech metod [IDispatch](https://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) , przy czym wartość pierwszego dostępnego gniazda to 3 lub 7. <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A>zapewnia odwrotną funkcjonalność programu <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A?displayProperty=nameWithType>. Możesz użyć <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType> programu i w połączeniu z <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A> usługą, <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType> aby przekazywać gniazda w określonym zakresie.  
  
 `memberType` Parametr jest ważny tylko w przypadku powrotu. Zawiera typ elementu członkowskiego com (Metoda zwykła lub akcesor właściwości) odpowiadający zwróconemu <xref:System.Reflection.MemberInfo> obiektowi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="t" />nie jest widoczny dla modelu COM.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.ComMemberType" />
      </Docs>
    </Member>
    <Member MemberName="GetNativeVariantForObject">
      <MemberSignature Language="C#" Value="public static void GetNativeVariantForObject (object obj, IntPtr pDstNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetNativeVariantForObject(object obj, native int pDstNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetNativeVariantForObject (obj As Object, pDstNativeVariant As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetNativeVariantForObject(System::Object ^ obj, IntPtr pDstNativeVariant);" />
      <MemberSignature Language="F#" Value="static member GetNativeVariantForObject : obj * nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.GetNativeVariantForObject (obj, pDstNativeVariant)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netstandard-2.1">
          <AttributeName>System.Obsolete("GetNativeVariantForObject(Object, IntPtr) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="pDstNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, dla którego ma zostać pobrany wariant COM.</param>
        <param name="pDstNativeVariant">Wskaźnik otrzymywania wariantu odpowiadający <paramref name="obj" /> parametrowi.</param>
        <summary>Konwertuje obiekt na wariant COM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pDstNativeVariant` Parametr musi wskazywać wystarczającą ilość pamięci do przechowywania otrzymanego wariantu. Ponadto implementacja tej metody wywołuje funkcję [VariantInit](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx) w pamięci nieprzetworzonej, do której `pDstNativeVariant` wskazuje parametr.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="obj" /> Parametr jest wystąpieniem typu ogólnego.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetNativeVariantForObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void GetNativeVariantForObject&lt;T&gt; (T obj, IntPtr pDstNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetNativeVariantForObject&lt;T&gt;(!!T obj, native int pDstNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetNativeVariantForObject(Of T) (obj As T, pDstNativeVariant As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void GetNativeVariantForObject(T obj, IntPtr pDstNativeVariant);" />
      <MemberSignature Language="F#" Value="static member GetNativeVariantForObject : 'T * nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.GetNativeVariantForObject (obj, pDstNativeVariant)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netstandard-2.1">
          <AttributeName>System.Obsolete("GetNativeVariantForObject&lt;T&gt;(T, IntPtr) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="obj" Type="T" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pDstNativeVariant" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ obiektu do przekonwertowania.</typeparam>
        <param name="obj">Obiekt, dla którego ma zostać pobrany wariant COM.</param>
        <param name="pDstNativeVariant">Wskaźnik otrzymywania wariantu odpowiadający <paramref name="obj" /> parametrowi.</param>
        <summary>[Obsługiwane w .NET Framework 4.5.1 i nowszych wersjach]  
  
 Konwertuje obiekt określonego typu na wariant COM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pDstNativeVariant` Parametr musi wskazywać wystarczającą ilość pamięci do przechowywania otrzymanego wariantu. Ponadto implementacja tej metody wywołuje funkcję [VariantInit](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx) w pamięci nieprzetworzonej, do której `pDstNativeVariant` wskazuje parametr.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetObjectForIUnknown (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectForIUnknown(native int pUnk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectForIUnknown (pUnk As IntPtr) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObjectForIUnknown(IntPtr pUnk);" />
      <MemberSignature Language="F#" Value="static member GetObjectForIUnknown : nativeint -&gt; obj" Usage="System.Runtime.InteropServices.Marshal.GetObjectForIUnknown pUnk" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pUnk">Wskaźnik do <see langword="IUnknown" /> interfejsu.</param>
        <summary>Zwraca wystąpienie typu, który reprezentuje obiekt COM za pomocą wskaźnika do jego interfejsu <see href="https://go.microsoft.com/fwlink/?LinkId=148003">IUnknown</see> .</summary>
        <returns>Obiekt reprezentujący określony niezarządzany obiekt COM.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda otacza `IUnknown` obiekt zarządzany. Ma to wpływ na zwiększenie liczby odwołań składnika COM. Liczba odwołań zostanie zmniejszona, gdy środowisko uruchomieniowe wykonuje wyrzucanie elementów bezużytecznych w zarządzanym obiekcie, który reprezentuje obiekt COM.  
  
 Parametr reprezentuje wskaźnik interfejsu;`IUnknown`jednak ponieważ wszystkie interfejsy com pochodzą bezpośrednio lub pośrednio z, można przekazać dowolny interfejs com do tej metody. `IUnknown` `pUnk` Obiekt zwrócony przez to <xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A> wywoływany [otoka środowiska uruchomieniowego](~/docs/framework/interop/runtime-callable-wrapper.md), która jest zarządzana przez środowisko uruchomieniowe języka wspólnego, tak jak każdy inny obiekt zarządzany. Typ tej otoki jest często typem podstawowym `System.__ComObject` , który jest typem ukrytym używanym, gdy typ otoki jest niejednoznaczny. Nadal można wykonywać wywołania z późnym wiązaniem do takiego typu podstawowego, o ile obiekt COM implementuje interfejs [IDispatch](https://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5(vs.85)) . Analogicznie, można rzutować zwracany obiekt na odpowiedni interfejs COM.  
  
 W przypadku obiektu, który ma być opakowany na określony typ klasy zarządzanej (a nie typ otoki ogólnej), należy przestrzegać następujących wymagań:  
  
-   Zaimplementuj Interfejs [IProvideClassInfo](https://go.microsoft.com/fwlink/?LinkID=148012) dla obiektu com.  
  
-   Zarejestruj zawierający go zestaw za pomocą [Regasm. exe (Narzędzie rejestracji zestawów)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 Alternatywnie można uniknąć tych wymagań i nadal uzyskać obiekt, który jest opakowany z określonym typem klasy zarządzanej przy użyciu <xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:SystemArgumentNullException"><paramref name="pUnk" />jest <see cref="F:System.IntPtr.Zero" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectForNativeVariant">
      <MemberSignature Language="C#" Value="public static object GetObjectForNativeVariant (IntPtr pSrcNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectForNativeVariant(native int pSrcNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectForNativeVariant (pSrcNativeVariant As IntPtr) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObjectForNativeVariant(IntPtr pSrcNativeVariant);" />
      <MemberSignature Language="F#" Value="static member GetObjectForNativeVariant : nativeint -&gt; obj" Usage="System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant pSrcNativeVariant" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netstandard-2.1">
          <AttributeName>System.Obsolete("GetObjectForNativeVariant(IntPtr) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pSrcNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pSrcNativeVariant">Wskaźnik do elementu COM VARIANT.</param>
        <summary>Konwertuje wariant COM na obiekt.</summary>
        <returns>Obiekt, który odnosi się do <paramref name="pSrcNativeVariant" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A>zwraca obiekt zarządzany, który odpowiada pierwotnemu wskaźnikowi do niezarządzanego typu VARIANT. Interopmarshaler wykonuje identyczną transformację podczas ujawniania typu WARIANTu w kodzie zarządzanym.  
  
 <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A>zapewnia odwrotną funkcjonalność programu <xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%2A?displayProperty=nameWithType>.  
  
 Gdy typ Variant to VT_ERROR, zwraca <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> obiekt typu `Int32` , a nie `UInt32`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.InvalidOleVariantTypeException"><paramref name="pSrcNativeVariant" />nie jest prawidłowym typem VARIANT.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="pSrcNativeVariant" />ma nieobsługiwany typ.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectForNativeVariant&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T GetObjectForNativeVariant&lt;T&gt; (IntPtr pSrcNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T GetObjectForNativeVariant&lt;T&gt;(native int pSrcNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectForNativeVariant(Of T) (pSrcNativeVariant As IntPtr) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T GetObjectForNativeVariant(IntPtr pSrcNativeVariant);" />
      <MemberSignature Language="F#" Value="static member GetObjectForNativeVariant : nativeint -&gt; 'T" Usage="System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant pSrcNativeVariant" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netstandard-2.1">
          <AttributeName>System.Obsolete("GetObjectForNativeVariant&lt;T&gt;(IntPtr) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="pSrcNativeVariant" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ, do którego ma zostać przekonwertowany wariant COM.</typeparam>
        <param name="pSrcNativeVariant">Wskaźnik do elementu COM VARIANT.</param>
        <summary>[Obsługiwane w .NET Framework 4.5.1 i nowszych wersjach]  
  
 Konwertuje wariant COM na obiekt określonego typu.</summary>
        <returns>Obiekt określonego typu, który odnosi się do <paramref name="pSrcNativeVariant" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29>zwraca obiekt zarządzany typu `T` , który odpowiada pierwotnemu wskaźnikowi do niezarządzanego typu variant. Interopmarshaler wykonuje identyczną transformację podczas ujawniania typu WARIANTu w kodzie zarządzanym.  
  
 <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29>zapewnia odwrotną funkcjonalność programu <xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%60%601%28%60%600%2CSystem.IntPtr%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.InvalidOleVariantTypeException"><paramref name="pSrcNativeVariant" />nie jest prawidłowym typem VARIANT.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="pSrcNativeVariant" />ma nieobsługiwany typ.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectsForNativeVariants">
      <MemberSignature Language="C#" Value="public static object[] GetObjectsForNativeVariants (IntPtr aSrcNativeVariant, int cVars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object[] GetObjectsForNativeVariants(native int aSrcNativeVariant, int32 cVars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectsForNativeVariants (aSrcNativeVariant As IntPtr, cVars As Integer) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Object ^&gt; ^ GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);" />
      <MemberSignature Language="F#" Value="static member GetObjectsForNativeVariants : nativeint * int -&gt; obj[]" Usage="System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants (aSrcNativeVariant, cVars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netstandard-2.1">
          <AttributeName>System.Obsolete("GetObjectsForNativeVariants(IntPtr, Int32) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="aSrcNativeVariant" Type="System.IntPtr" />
        <Parameter Name="cVars" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="aSrcNativeVariant">Wskaźnik do pierwszego elementu tablicy wariantów COM.</param>
        <param name="cVars">Liczba wariantów COM w <paramref name="aSrcNativeVariant" />.</param>
        <summary>Konwertuje tablicę <see href="https://go.microsoft.com/fwlink/?LinkId=148670">wariantów</see> com na tablicę obiektów.</summary>
        <returns>Tablica obiektów, która odnosi się <paramref name="aSrcNativeVariant" />do.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%2A>zwraca tablicę obiektów zarządzanych, która odpowiada pierwotnemu wskaźnikowi do tablicy w stylu C niezarządzanych typów wariantów. Interopmarshaler wykonuje identyczną transformację podczas ujawniania typu WARIANTu w kodzie zarządzanym. Metoda zwraca pustą tablicę, `cVars` gdy parametr ma wartość 0.  
  
 Tablica obiektów (wartość zwracana) Pobiera elementy bezużyteczne w zwykły sposób. Niezarządzana Tablica wejściowa lub pojedyncze warianty w tablicy wejściowej nie są zwalniane. W związku z tym jest odpowiedzialny za ich zwolnienie w zależności od potrzeb.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="cVars" />jest liczbą ujemną.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectsForNativeVariants&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] GetObjectsForNativeVariants&lt;T&gt; (IntPtr aSrcNativeVariant, int cVars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] GetObjectsForNativeVariants&lt;T&gt;(native int aSrcNativeVariant, int32 cVars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectsForNativeVariants(Of T) (aSrcNativeVariant As IntPtr, cVars As Integer) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);" />
      <MemberSignature Language="F#" Value="static member GetObjectsForNativeVariants : nativeint * int -&gt; 'T[]" Usage="System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants (aSrcNativeVariant, cVars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netstandard-2.1">
          <AttributeName>System.Obsolete("GetObjectsForNativeVariants&lt;T&gt;(IntPtr, Int32) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="aSrcNativeVariant" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cVars" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ tablicy do zwrócenia.</typeparam>
        <param name="aSrcNativeVariant">Wskaźnik do pierwszego elementu tablicy wariantów COM.</param>
        <param name="cVars">Liczba wariantów COM w <paramref name="aSrcNativeVariant" />.</param>
        <summary>[Obsługiwane w .NET Framework 4.5.1 i nowszych wersjach]  
  
 Konwertuje tablicę wariantów COM na tablicę określonego typu.</summary>
        <returns>Tablica <typeparamref name="T" /> obiektów, które odnoszą się do <paramref name="aSrcNativeVariant" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%60%601%28System.IntPtr%2CSystem.Int32%29>zwraca tablicę `T` , która odpowiada surowemu wskaźnikowi do tablicy w stylu C niezarządzanych typów wariantów. Interopmarshaler wykonuje identyczną transformację podczas ujawniania typu WARIANTu w kodzie zarządzanym. Metoda zwraca pustą tablicę, `cVars` gdy parametr ma wartość 0.  
  
 Zwracana tablica jest w zwykły sposób odzyskiwana. Niezarządzana Tablica wejściowa lub pojedyncze warianty w tablicy wejściowej nie są zwalniane. W związku z tym jest odpowiedzialny za ich zwolnienie w zależności od potrzeb.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="cVars" />jest liczbą ujemną.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetStartComSlot">
      <MemberSignature Language="C#" Value="public static int GetStartComSlot (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetStartComSlot(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetStartComSlot (t As Type) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetStartComSlot(Type ^ t);" />
      <MemberSignature Language="F#" Value="static member GetStartComSlot : Type -&gt; int" Usage="System.Runtime.InteropServices.Marshal.GetStartComSlot t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">Typ, który reprezentuje interfejs lub klasę.</param>
        <summary>Pobiera pierwsze gniazdo w tabeli funkcji wirtualnych (v-table lub VTBL), które zawiera metody zdefiniowane przez użytkownika.</summary>
        <returns>Pierwsze gniazdo VTBL, które zawiera metody zdefiniowane przez użytkownika. Pierwsze gniazdo to 3, jeśli interfejs jest oparty na <see href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</see>i 7, jeśli interfejs jest oparty na [wywołaniu IDispatch](https://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca numer tabeli v (liczony od zera) dla interfejsu lub klasy. W przypadku użycia w klasie numer gniazda, który jest zwracany, odnosi się do interfejsu klasy dla klasy. Jeśli interfejs klasy jest wysyłany do autowysyłania, ta metoda zawsze zwraca wartość-1, aby wskazać, że interfejs tylko do wysyłania nie uwidacznia tabeli v dla zarządzanych klientów. Możesz użyć <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A> programu i w połączeniu z <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType> usługą, <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType> aby przekazywać gniazda w określonym zakresie. Aby uzyskać dodatkowe informacje, zobacz [wprowadzenie do interfejsu klasy](~/docs/framework/interop/com-callable-wrapper.md#introducing-the-class-interface).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="t" />nie jest widoczny dla modelu COM.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      </Docs>
    </Member>
    <Member MemberName="GetThreadFromFiberCookie">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread GetThreadFromFiberCookie (int cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Thread GetThreadFromFiberCookie(int32 cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetThreadFromFiberCookie (cookie As Integer) As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Thread ^ GetThreadFromFiberCookie(int cookie);" />
      <MemberSignature Language="F#" Value="static member GetThreadFromFiberCookie : int -&gt; System.Threading.Thread" Usage="System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The GetThreadFromFiberCookie method has been deprecated.  Use the hosting API to perform this operation.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Int32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cookie">Liczba całkowita reprezentująca plik cookie włókna.</param>
        <summary>Konwertuje plik cookie Fiber na odpowiednie <see cref="T:System.Threading.Thread" /> wystąpienie.</summary>
        <returns>Wątek, który odnosi się do <paramref name="cookie" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pliki cookie Fiber są nieprzezroczystymi tokenami używanymi przez hosta podczas wysyłania alertów do środowiska uruchomieniowego języka wspólnego do jego decyzji o planowaniu włókien. Składają się one z kontekstu stosu i rejestru.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="cookie" /> Parametr ma wartość 0.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="GetTypedObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetTypedObjectForIUnknown (IntPtr pUnk, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetTypedObjectForIUnknown(native int pUnk, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypedObjectForIUnknown (pUnk As IntPtr, t As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetTypedObjectForIUnknown(IntPtr pUnk, Type ^ t);" />
      <MemberSignature Language="F#" Value="static member GetTypedObjectForIUnknown : nativeint * Type -&gt; obj" Usage="System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown (pUnk, t)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="t" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="pUnk">Wskaźnik do <see langword="IUnknown" /> interfejsu obiektu niezarządzanego.</param>
        <param name="t">Typ żądanej klasy zarządzanej.</param>
        <summary>Zwraca obiekt zarządzany o określonym typie, który reprezentuje obiekt COM.</summary>
        <returns>Wystąpienie klasy odpowiadające <see cref="T:System.Type" /> obiektowi, który reprezentuje żądany niezarządzany obiekt com.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `t` Parametr musi być typem importowanym com lub podtypem typu zaimportowanego przez com. Ponadto musi być `t` typem, którego metadane zostały zaimportowane przez [Tlbimp. exe (Importer biblioteki typów)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) . Ten typ musi być klasą, a nie skojarzonym interfejsem klasy coclass, który przenosi nazwę klasy COM. Jeśli na przykład Tlbimp. exe importuje `Myclass` jako klasę o nazwie `MyclassClass` i jako interfejs klasy coclass o nazwie `Myclass`, należy użyć `MyclassClass` (nie `Myclass`) z tą metodą. Aby uzyskać dodatkowe informacje na temat zaimportowanych klas i interfejsów klasy coclass, zobacz [Konwersja typu](https://msdn.microsoft.com/library/cb1ee67d-8ef0-4e40-b2a5-13714b9f33c3)zaimportowanego.  
  
 Jeśli obiekt został już uzyskany dla `pUnk` parametru, `t` jest ignorowany i zwracany jest istniejący obiekt. `pUnk`reprezentuje wskaźnik interfejsu [IUnknown](https://go.microsoft.com/fwlink/?LinkId=148003) ; Jednak ze względu na to, że wszystkie interfejsy com `IUnknown`pochodzą bezpośrednio lub pośrednio z, można przekazać dowolny interfejs com do tej metody. Obiekt zwrócony przez to <xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A> wywoływany [otoka środowiska uruchomieniowego](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW), która jest zarządzana przez środowisko uruchomieniowe języka wspólnego, tak jak każdy inny obiekt zarządzany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="t" />nie jest przypisany do <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />.  
  
—lub— 
 <paramref name="t" />[!INCLUDE[wrt](~/includes/wrt-md.md)] jest typem.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeForITypeInfo">
      <MemberSignature Language="C#" Value="public static Type GetTypeForITypeInfo (IntPtr piTypeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeForITypeInfo(native int piTypeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeForITypeInfo (piTypeInfo As IntPtr) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeForITypeInfo(IntPtr piTypeInfo);" />
      <MemberSignature Language="F#" Value="static member GetTypeForITypeInfo : nativeint -&gt; Type" Usage="System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo piTypeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="piTypeInfo" Type="System.IntPtr" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="piTypeInfo"><see langword="ITypeInfo" /> Interfejs do organizowania.</param>
        <summary>Konwertuje niezarządzany obiekt [Metoda ITypeInfo](https://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680) na obiekt <see cref="T:System.Type" /> zarządzany.</summary>
        <returns>Zarządzany typ, który reprezentuje obiekt niezarządzany <see langword="ITypeInfo" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A><xref:System.Type?displayProperty=nameWithType> zwraca wystąpienie, które jest oparte na oryginalnym typie. Można zastosować, <xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType> aby zastąpić standardowe zachowanie organizowania międzyoperacyjności z tym organizatorem niestandardowym. Narzędzie [Tlbimp. exe (Importer biblioteki typów)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) używa organizatora niestandardowego do tłumaczenia `ITypeInfo` parametrów do <xref:System.Type?displayProperty=nameWithType> parametrów. Jeśli jednak `ITypeInfo` interfejs jest uzyskiwany za pomocą innych metod niż Tlbimp. exe, można użyć <xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A> programu do ręcznego wykonania tego samego tłumaczenia.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.MarshalAsAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Runtime.InteropServices.Marshal.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="clsid">Identyfikator CLSID typu do zwrócenia.</param>
        <summary>Zwraca typ skojarzony z określonym identyfikatorem klasy (CLSID).</summary>
        <returns><see langword="System.__ComObject" />bez względu na to, czy identyfikator CLSID jest prawidłowy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeInfoName">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera nazwę typu reprezentowanego przez obiekt [Metoda ITypeInfo](https://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680) .</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeInfoName">
      <MemberSignature Language="C#" Value="public static string GetTypeInfoName (System.Runtime.InteropServices.ComTypes.ITypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeInfoName(class System.Runtime.InteropServices.ComTypes.ITypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeInfoName (typeInfo As ITypeInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTypeInfoName(System::Runtime::InteropServices::ComTypes::ITypeInfo ^ typeInfo);" />
      <MemberSignature Language="F#" Value="static member GetTypeInfoName : System.Runtime.InteropServices.ComTypes.ITypeInfo -&gt; string" Usage="System.Runtime.InteropServices.Marshal.GetTypeInfoName typeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Runtime.InteropServices.ComTypes.ITypeInfo" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typeInfo">Obiekt, który reprezentuje <see langword="ITypeInfo" /> wskaźnik.</param>
        <summary>Pobiera nazwę typu reprezentowanego przez obiekt [Metoda ITypeInfo](https://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680) .</summary>
        <returns>Nazwa typu, do którego <paramref name="typeInfo" /> wskazuje parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz również pobrać nazwę typu reprezentowanego przez `ITypeInfo` <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> wywołanie metody i przekazanie-1 pierwszego parametru.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="typeInfo" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeInfoName">
      <MemberSignature Language="C#" Value="public static string GetTypeInfoName (System.Runtime.InteropServices.UCOMITypeInfo pTI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeInfoName(class System.Runtime.InteropServices.UCOMITypeInfo pTI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.UCOMITypeInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeInfoName (pTI As UCOMITypeInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTypeInfoName(System::Runtime::InteropServices::UCOMITypeInfo ^ pTI);" />
      <MemberSignature Language="F#" Value="static member GetTypeInfoName : System.Runtime.InteropServices.UCOMITypeInfo -&gt; string" Usage="System.Runtime.InteropServices.Marshal.GetTypeInfoName pTI" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use System.Runtime.InteropServices.Marshal.GetTypeInfoName(ITypeInfo pTLB) instead. http://go.microsoft.com/fwlink/?linkid=14202&amp;ID=0000011.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTI" Type="System.Runtime.InteropServices.UCOMITypeInfo" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pTI">Obiekt, który reprezentuje <see langword="ITypeInfo" /> wskaźnik.</param>
        <summary>Pobiera nazwę typu reprezentowanego przez obiekt [Metoda ITypeInfo](https://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680) .</summary>
        <returns>Nazwa typu, do którego <paramref name="pTI" /> wskazuje parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz również pobrać nazwę typu reprezentowanego przez `ITypeInfo` obiekt przez <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> wywołanie metody i przekazanie-1 pierwszego parametru.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeLibGuid">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera identyfikator biblioteki (identyfikatora LIBID) biblioteki typów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeLibGuid">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuid (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuid(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibGuid (typelib As ITypeLib) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetTypeLibGuid(System::Runtime::InteropServices::ComTypes::ITypeLib ^ typelib);" />
      <MemberSignature Language="F#" Value="static member GetTypeLibGuid : System.Runtime.InteropServices.ComTypes.ITypeLib -&gt; Guid" Usage="System.Runtime.InteropServices.Marshal.GetTypeLibGuid typelib" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typelib">Biblioteka typów, której identyfikatora LIBID ma zostać pobrany.</param>
        <summary>Pobiera identyfikator biblioteki (identyfikatora LIBID) biblioteki typów.</summary>
        <returns>IDENTYFIKATORA LIBID określonej biblioteki typów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A>wyodrębnia identyfikatora LIBID bezpośrednio z istniejącej biblioteki typów. Ta akcja różni się od <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType> metody, która oblicza, co identyfikatora LIBID powinna być oparta na bieżącym zestawie.  
  
 Aby uzyskać więcej informacji na temat identyfikatorów bibliotek, zobacz wyeksportowana [Konwersja zestawu](https://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)" />
        <altmember cref="T:System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibGuid">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuid (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuid(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibGuid (pTLB As UCOMITypeLib) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetTypeLibGuid(System::Runtime::InteropServices::UCOMITypeLib ^ pTLB);" />
      <MemberSignature Language="F#" Value="static member GetTypeLibGuid : System.Runtime.InteropServices.UCOMITypeLib -&gt; Guid" Usage="System.Runtime.InteropServices.Marshal.GetTypeLibGuid pTLB" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use System.Runtime.InteropServices.Marshal.GetTypeLibGuid(ITypeLib pTLB) instead. http://go.microsoft.com/fwlink/?linkid=14202&amp;ID=0000011.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pTLB">Biblioteka typów, której identyfikatora LIBID ma zostać pobrany.</param>
        <summary>Pobiera identyfikator biblioteki (identyfikatora LIBID) biblioteki typów.</summary>
        <returns>Identyfikatora LIBID biblioteki typów, do której <paramref name="pTLB" /> wskazuje parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A>wyodrębnia identyfikatora LIBID bezpośrednio z istniejącej biblioteki typów. Ta akcja różni się od <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType> metody, która oblicza, co identyfikatora LIBID powinna być oparta na bieżącym zestawie.  
  
 Aby uzyskać więcej informacji na temat identyfikatorów bibliotek, zobacz wyeksportowana [Konwersja zestawu](https://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)" />
        <altmember cref="T:System.Runtime.InteropServices.UCOMITypeLib" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibGuidForAssembly">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuidForAssembly (System.Reflection.Assembly asm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuidForAssembly(class System.Reflection.Assembly asm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibGuidForAssembly (asm As Assembly) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetTypeLibGuidForAssembly(System::Reflection::Assembly ^ asm);" />
      <MemberSignature Language="F#" Value="static member GetTypeLibGuidForAssembly : System.Reflection.Assembly -&gt; Guid" Usage="System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly asm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asm" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asm">Zestaw, z którego została wyeksportowana biblioteka typów.</param>
        <summary>Pobiera identyfikator biblioteki (identyfikatora LIBID), który jest przypisany do biblioteki typów, gdy został wyeksportowany z określonego zestawu.</summary>
        <returns>IDENTYFIKATORA LIBID, który jest przypisany do biblioteki typów podczas eksportowania z określonego zestawu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy zestawy są eksportowane do bibliotek typów, biblioteka typów jest przypisana identyfikatora LIBID. Można ustawić identyfikatora LIBID jawnie poprzez zastosowanie <xref:System.Runtime.InteropServices.GuidAttribute?displayProperty=nameWithType> na poziomie zestawu lub może być wygenerowany automatycznie. Narzędzie [Tlbimp. exe (Importer biblioteki typów)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) oblicza wartość identyfikatora LIBID w oparciu o tożsamość zestawu. <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A>zwraca identyfikatora LIBID <xref:System.Runtime.InteropServices.GuidAttribute>, która jest skojarzona z, jeśli atrybut jest stosowany. W przeciwnym razie zwraca obliczoną wartość. <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A> Alternatywnie możesz użyć <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> metody, aby wyodrębnić rzeczywiste identyfikatora LIBID z istniejącej biblioteki typów.  
  
 Aby uzyskać więcej informacji na temat identyfikatorów bibliotek, zobacz sekcję [wyeksportowany zestaw konwersji](https://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86) .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asm" />jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.InteropServices.GuidAttribute" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeLibLcid">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera identyfikator LCID biblioteki typów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeLibLcid">
      <MemberSignature Language="C#" Value="public static int GetTypeLibLcid (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetTypeLibLcid(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.ComTypes.ITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibLcid (typelib As ITypeLib) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetTypeLibLcid(System::Runtime::InteropServices::ComTypes::ITypeLib ^ typelib);" />
      <MemberSignature Language="F#" Value="static member GetTypeLibLcid : System.Runtime.InteropServices.ComTypes.ITypeLib -&gt; int" Usage="System.Runtime.InteropServices.Marshal.GetTypeLibLcid typelib" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typelib">Biblioteka typów, której identyfikator LCID ma zostać pobrany.</param>
        <summary>Pobiera identyfikator LCID biblioteki typów.</summary>
        <returns>Identyfikator LCID biblioteki typów, do której <paramref name="typelib" /> wskazuje parametr.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibLcid">
      <MemberSignature Language="C#" Value="public static int GetTypeLibLcid (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetTypeLibLcid(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.UCOMITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibLcid (pTLB As UCOMITypeLib) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetTypeLibLcid(System::Runtime::InteropServices::UCOMITypeLib ^ pTLB);" />
      <MemberSignature Language="F#" Value="static member GetTypeLibLcid : System.Runtime.InteropServices.UCOMITypeLib -&gt; int" Usage="System.Runtime.InteropServices.Marshal.GetTypeLibLcid pTLB" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use System.Runtime.InteropServices.Marshal.GetTypeLibLcid(ITypeLib pTLB) instead. http://go.microsoft.com/fwlink/?linkid=14202&amp;ID=0000011.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pTLB">Biblioteka typów, której identyfikator LCID ma zostać pobrany.</param>
        <summary>Pobiera identyfikator LCID biblioteki typów.</summary>
        <returns>Identyfikator LCID biblioteki typów, do której <paramref name="pTLB" /> wskazuje parametr.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeLibName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera nazwę biblioteki typów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeLibName">
      <MemberSignature Language="C#" Value="public static string GetTypeLibName (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeLibName(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibName (typelib As ITypeLib) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTypeLibName(System::Runtime::InteropServices::ComTypes::ITypeLib ^ typelib);" />
      <MemberSignature Language="F#" Value="static member GetTypeLibName : System.Runtime.InteropServices.ComTypes.ITypeLib -&gt; string" Usage="System.Runtime.InteropServices.Marshal.GetTypeLibName typelib" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typelib">Biblioteka typów, której nazwa ma zostać pobrana.</param>
        <summary>Pobiera nazwę biblioteki typów.</summary>
        <returns>Nazwa biblioteki typów, do której <paramref name="typelib" /> wskazuje parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwa zwrócona przez tę metodę jest identyfikatorem używanym z instrukcją Library, taką jak ADODB dla biblioteki typów Microsoft ADO. Nazwa nie jest nazwą pliku.  
  
 Możesz również pobrać nazwę biblioteki typów, wywołując <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> metodę i przekazując-1 jako pierwszy parametr.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="typelib" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeLib.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibName">
      <MemberSignature Language="C#" Value="public static string GetTypeLibName (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeLibName(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibName (pTLB As UCOMITypeLib) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTypeLibName(System::Runtime::InteropServices::UCOMITypeLib ^ pTLB);" />
      <MemberSignature Language="F#" Value="static member GetTypeLibName : System.Runtime.InteropServices.UCOMITypeLib -&gt; string" Usage="System.Runtime.InteropServices.Marshal.GetTypeLibName pTLB" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use System.Runtime.InteropServices.Marshal.GetTypeLibName(ITypeLib pTLB) instead. http://go.microsoft.com/fwlink/?linkid=14202&amp;ID=0000011.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pTLB">Biblioteka typów, której nazwa ma zostać pobrana.</param>
        <summary>Pobiera nazwę biblioteki typów.</summary>
        <returns>Nazwa biblioteki typów, do której <paramref name="pTLB" /> wskazuje parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwa zwrócona przez tę metodę jest identyfikatorem używanym z instrukcją Library, taką jak ADODB dla biblioteki typów Microsoft ADO. Nazwa nie jest nazwą pliku.  
  
 Możesz również pobrać nazwę biblioteki typów, wywołując <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> metodę i przekazując-1 jako pierwszy parametr.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeLib.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibVersionForAssembly">
      <MemberSignature Language="C#" Value="public static void GetTypeLibVersionForAssembly (System.Reflection.Assembly inputAssembly, out int majorVersion, out int minorVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetTypeLibVersionForAssembly(class System.Reflection.Assembly inputAssembly, [out] int32&amp; majorVersion, [out] int32&amp; minorVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetTypeLibVersionForAssembly (inputAssembly As Assembly, ByRef majorVersion As Integer, ByRef minorVersion As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetTypeLibVersionForAssembly(System::Reflection::Assembly ^ inputAssembly, [Runtime::InteropServices::Out] int % majorVersion, [Runtime::InteropServices::Out] int % minorVersion);" />
      <MemberSignature Language="F#" Value="static member GetTypeLibVersionForAssembly : System.Reflection.Assembly *  *  -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly (inputAssembly, majorVersion, minorVersion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputAssembly" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="majorVersion" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="minorVersion" Type="System.Int32" RefType="out" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="inputAssembly">Zestaw zarządzany.</param>
        <param name="majorVersion">Główny numer wersji.</param>
        <param name="minorVersion">Pomocniczy numer wersji.</param>
        <summary>Pobiera numer wersji biblioteki typów, która zostanie wyeksportowana z określonego zestawu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed wyeksportowaniem zestawu przy <xref:System.Runtime.InteropServices.TypeLibExporterFlags> użyciu `CallerResolvedReferences` wartości z wartością, można użyć tej metody do pobrania wersji biblioteki typów z zestawu.  
  
 Jeśli nie zastosujesz <xref:System.Runtime.InteropServices.TypeLibVersionAttribute> atrybutu do wyeksportowanego zestawu, aby jawnie kontrolować numer wersji wygenerowanej biblioteki typów, biblioteka typów będzie mieć ten sam numer wersji co zestaw.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="inputAssembly" />jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.InteropServices.TypeLibExporterFlags" />
        <altmember cref="T:System.Runtime.InteropServices.TypeLibVersionAttribute" />
        <altmember cref="T:System.Runtime.InteropServices.ITypeLibConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetUniqueObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetUniqueObjectForIUnknown (IntPtr unknown);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetUniqueObjectForIUnknown(native int unknown) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUniqueObjectForIUnknown (unknown As IntPtr) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetUniqueObjectForIUnknown(IntPtr unknown);" />
      <MemberSignature Language="F#" Value="static member GetUniqueObjectForIUnknown : nativeint -&gt; obj" Usage="System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown unknown" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unknown" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="unknown">Zarządzany wskaźnik do <see langword="IUnknown" /> interfejsu.</param>
        <summary>Tworzy unikatowy obiekt otoki (RCW) w [środowisku uruchomieniowym](~/docs/framework/interop/runtime-callable-wrapper.md) dla danego interfejsu <see href="https://go.microsoft.com/fwlink/?LinkId=148003">IUnknown</see> .</summary>
        <returns>Unikatowa Otoka RCW dla <see langword="IUnknown" /> określonego interfejsu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zapewnia, że otrzymasz unikatową otokę RCW, ponieważ nie `IUnknown` pasuje ona do wskaźnika do istniejącego obiektu. <xref:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown%2A> Tej metody należy użyć, gdy konieczne jest utworzenie unikatowej otoki RCW, która nie ma wpływu na inny kod <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> , który wywołuje metodę.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetUnmanagedThunkForManagedMethodPtr">
      <MemberSignature Language="C#" Value="public static IntPtr GetUnmanagedThunkForManagedMethodPtr (IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetUnmanagedThunkForManagedMethodPtr(native int pfnMethodToWrap, native int pbSignature, int32 cbSignature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnmanagedThunkForManagedMethodPtr (pfnMethodToWrap As IntPtr, pbSignature As IntPtr, cbSignature As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetUnmanagedThunkForManagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberSignature Language="F#" Value="static member GetUnmanagedThunkForManagedMethodPtr : nativeint * nativeint * int -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr (pfnMethodToWrap, pbSignature, cbSignature)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The GetUnmanagedThunkForManagedMethodPtr method has been deprecated and will be removed in a future release.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pfnMethodToWrap" Type="System.IntPtr" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pbSignature" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="cbSignature" Type="System.Int32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pfnMethodToWrap">Wskaźnik do metody Marshal.</param>
        <param name="pbSignature">Wskaźnik do sygnatury metody.</param>
        <param name="cbSignature">Liczba bajtów w <paramref name="pbSignature" />.</param>
        <summary>Pobiera wskaźnik do funkcji generowanej przez środowisko uruchomieniowe, która zarządza wywołaniem z niezarządzanego kodu zarządzanego.</summary>
        <returns>Wskaźnik do funkcji, która będzie kierować wywołanie z <paramref name="pfnMethodToWrap" /> do kodu zarządzanego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr%2A>jest udostępniany tylko do obsługi kompilatora.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsComObject">
      <MemberSignature Language="C#" Value="public static bool IsComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsComObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsComObject (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsComObject(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member IsComObject : obj -&gt; bool" Usage="System.Runtime.InteropServices.Marshal.IsComObject o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Obiekt do sprawdzenia.</param>
        <summary>Wskazuje, czy określony obiekt reprezentuje obiekt COM.</summary>
        <returns><see langword="true" />Jeśli parametr jest typu com; w przeciwnym razie, <see langword="false" />. <paramref name="o" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.IsComObject%2A>zwraca `true` wartość, jeśli typ klasy wystąpienia jest przypisany do <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType> atrybutu lub, jeśli dziedziczy bezpośrednio lub pośrednio z klasy przypisanej <xref:System.Runtime.InteropServices.ComImportAttribute>do. Narzędzie [Tlbimp. exe (Importer biblioteki typów)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) stosuje ten atrybut podczas importowania biblioteki typów.  
  
 Dwie inne metody określają również, czy określony obiekt reprezentuje obiekt com, ale wymagania dotyczące powrotu `true` różnią się w zależności od wymagań tej metody. <xref:System.Type.IsImport%2A?displayProperty=nameWithType>zwraca `true` , czy Klasa (lub interfejs) ma przypisany <xref:System.Runtime.InteropServices.ComImportAttribute> bezpośrednio element, nie zwraca `true` dla typów pochodnych. <xref:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType%2A?displayProperty=nameWithType>zwraca `true` czy typ jest przypisany <xref:System.Runtime.InteropServices.ComImportAttribute> do typu z tym samym identyfikatorem GUID.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="o" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
        <altmember cref="P:System.Type.IsImport" />
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsTypeVisibleFromCom">
      <MemberSignature Language="C#" Value="public static bool IsTypeVisibleFromCom (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsTypeVisibleFromCom(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsTypeVisibleFromCom (t As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsTypeVisibleFromCom(Type ^ t);" />
      <MemberSignature Language="F#" Value="static member IsTypeVisibleFromCom : Type -&gt; bool" Usage="System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="t">Typ do sprawdzenia widoczności COM.</param>
        <summary>Wskazuje, czy typ jest widoczny dla klientów modelu COM.</summary>
        <returns><see langword="true" />Jeśli typ jest widoczny dla modelu COM; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom%2A>umożliwia sprawdzenie widoczności modelu COM w jednym kroku. Typy, które nie są widoczne, nie mogą być używane z modelu COM. Typ jest widoczny, jeśli jest i `public` nie jest ukryty <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>z.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />
      </Docs>
    </Member>
    <Member MemberName="NumParamBytes">
      <MemberSignature Language="C#" Value="public static int NumParamBytes (System.Reflection.MethodInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 NumParamBytes(class System.Reflection.MethodInfo m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NumParamBytes (m As MethodInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int NumParamBytes(System::Reflection::MethodInfo ^ m);" />
      <MemberSignature Language="F#" Value="static member NumParamBytes : System.Reflection.MethodInfo -&gt; int" Usage="System.Runtime.InteropServices.Marshal.NumParamBytes m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MethodInfo" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="m">Metoda, która ma być sprawdzona.</param>
        <summary>Oblicza liczbę bajtów w pamięci niezarządzanej, które są wymagane do przechowywania parametrów dla określonej metody.</summary>
        <returns>Liczba bajtów wymagana do reprezentowania parametrów metody w pamięci niezarządzanej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.NumParamBytes%2A> Metoda zwraca rozmiar stosu (w bajtach), który jest wymagany do reprezentowania parametrów sygnatury metody w pamięci niezarządzanej.  
  
 Zwróć uwagę, że wartość zwracana przez tę metodę jest zależna od platformy. Na przykład sygnatura z pojedynczym parametrem Integer zwraca wartość 4 na platformach 32-bitowych i wartość 8 na platformach 64-bitowych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="m" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="m" /> Parametr<see cref="T:System.Reflection.MethodInfo" /> nie jest obiektem.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="OffsetOf">
      <MemberSignature Language="C#" Value="public static IntPtr OffsetOf (Type t, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int OffsetOf(class System.Type t, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OffsetOf (t As Type, fieldName As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr OffsetOf(Type ^ t, System::String ^ fieldName);" />
      <MemberSignature Language="F#" Value="static member OffsetOf : Type * string -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.OffsetOf (t, fieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;dotnet-uwp-10.0">
          <AttributeName>System.Obsolete("OffsetOf(Type, string) may be unavailable in future releases. Instead, use OffsetOf&lt;T&gt;(string). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296511")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="t">Typ wartości lub sformatowany typ referencyjny, który określa klasę zarządzaną. Należy zastosować <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> do klasy.</param>
        <param name="fieldName">Pole znajdujące się <paramref name="t" /> w parametrze.</param>
        <summary>Zwraca przesunięcie pola w niezarządzanej postaci zarządzanej klasy.</summary>
        <returns>Przesunięcie, w bajtach, dla <paramref name="fieldName" /> parametru w określonej klasie, która jest zadeklarowana przez wywołanie platformy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A>zapewnia przesunięcie w warunkach układu niezarządzanej struktury, który nie musi odpowiadać przesunięciu układu zarządzanej struktury. Kierowanie struktury może przekształcić układ i zmienić przesunięcie. `t` Parametr może być typem wartości lub sformatowanym typem referencyjnym (z układem sekwencyjnym lub jawnym). Możesz uzyskać rozmiar całego układu przy użyciu <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A?displayProperty=nameWithType> metody. Aby uzyskać dodatkowe informacje, zobacz [domyślne kierowanie dla typów wartości](https://msdn.microsoft.com/library/4d9a876c-e05a-40ba-bd85-bd22877f984a).  
  
> [!NOTE]
>  Począwszy od .NET Framework w wersji 2,0, <xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> mogą uwidaczniać pola prywatne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie można wyeksportować klasy jako struktury lub pole jest niepubliczne. Począwszy od .NET Framework w wersji 2,0, pole może być prywatne.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="t" /></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OffsetOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr OffsetOf&lt;T&gt; (string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int OffsetOf&lt;T&gt;(string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OffsetOf(Of T) (fieldName As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static IntPtr OffsetOf(System::String ^ fieldName);" />
      <MemberSignature Language="F#" Value="static member OffsetOf : string -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.OffsetOf fieldName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ wartości zarządzanej lub sformatowany typ referencyjny. Należy zastosować <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> atrybut do klasy.</typeparam>
        <param name="fieldName">Nazwa pola w <paramref name="T" /> typie.</param>
        <summary>[Obsługiwane w .NET Framework 4.5.1 i nowszych wersjach]  
  
 Zwraca przesunięcie pola dla niezarządzanej formy określonej klasy zarządzanej.</summary>
        <returns>Przesunięcie, w bajtach, dla <paramref name="fieldName" /> parametru w określonej klasie, która jest zadeklarowana przez wywołanie platformy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.OffsetOf%60%601%28System.String%29>zapewnia przesunięcie w warunkach układu niezarządzanej struktury, który nie musi odpowiadać przesunięciu układu zarządzanej struktury. Kierowanie struktury może przekształcić układ i zmienić przesunięcie. Parametr `T` typu generycznego może być typem wartościowym lub sformatowanym typem referencyjnym (z układem sekwencyjnym lub jawnym). Możesz uzyskać rozmiar całego układu przy użyciu <xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29> metody. Aby uzyskać dodatkowe informacje, zobacz [domyślne kierowanie dla typów wartości](https://msdn.microsoft.com/library/4d9a876c-e05a-40ba-bd85-bd22877f984a).  
  
> [!NOTE]
>  Począwszy od .NET Framework w wersji 2,0, <xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> mogą uwidaczniać pola prywatne.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="Prelink">
      <MemberSignature Language="C#" Value="public static void Prelink (System.Reflection.MethodInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Prelink(class System.Reflection.MethodInfo m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Prelink (m As MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Prelink(System::Reflection::MethodInfo ^ m);" />
      <MemberSignature Language="F#" Value="static member Prelink : System.Reflection.MethodInfo -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Prelink m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MethodInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="m">Metoda, która ma być sprawdzona.</param>
        <summary>Wykonuje jednorazowe zadania konfiguracji metody bez wywoływania metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zadania Instalatora zapewniają wczesne Inicjowanie i są wykonywane automatycznie po wywołaniu metody docelowej. Zadania po raz pierwszy obejmują następujące elementy:  
  
-   Weryfikowanie, czy metadane wywołania platformy są poprawnie sformatowane.  
  
-   Sprawdzanie, czy wszystkie typy zarządzane są prawidłowymi parametrami funkcji Invoke platformy.  
  
-   Lokalizowanie i ładowanie niezarządzanej biblioteki DLL do procesu.  
  
-   Lokalizowanie punktu wejścia w procesie.  
  
 Wywołanie <xref:System.Runtime.InteropServices.Marshal.Prelink%2A> metody poza wywołaniem platformy nie ma żadnego wpływu. Aby wykonać zadania instalacyjne na wszystkich metodach wywoływanych przez platformę <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A?displayProperty=nameWithType>w typie, użyj.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="m" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="m" /> Parametr<see cref="T:System.Reflection.MethodInfo" /> nie jest obiektem.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="PrelinkAll">
      <MemberSignature Language="C#" Value="public static void PrelinkAll (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrelinkAll(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrelinkAll (c As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrelinkAll(Type ^ c);" />
      <MemberSignature Language="F#" Value="static member PrelinkAll : Type -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.PrelinkAll c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c">Klasa, której metody mają być sprawdzane.</param>
        <summary>Wykonuje wstępne wyszukiwanie dla wszystkich metod klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A> Metoda wywołuje<xref:System.Runtime.InteropServices.Marshal.Prelink%2A?displayProperty=nameWithType> dla każdej metody dla danego typu. <xref:System.Runtime.InteropServices.Marshal.Prelink%2A>wykonuje jednorazowe zadania konfiguracji, bez wywołania każdej metody. Można używać <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A> tylko dla wywołań wywołania platformy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="c" /></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PtrToStringAnsi">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Alokuje zarządzane <see cref="T:System.String" /> i kopiuje całość lub część niezarządzanego ciągu ANSI do niego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PtrToStringAnsi">
      <MemberSignature Language="C#" Value="public static string PtrToStringAnsi (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAnsi(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringAnsi (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringAnsi(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member PtrToStringAnsi : nativeint -&gt; string" Usage="System.Runtime.InteropServices.Marshal.PtrToStringAnsi ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres pierwszego znaku niezarządzanego ciągu.</param>
        <summary>Kopiuje wszystkie znaki do pierwszego znaku null z niezarządzanego ciągu ANSI do zarządzanego <see cref="T:System.String" />i rozszerza każdy znak ANSI na Unicode.</summary>
        <returns>Zarządzany ciąg, który przechowuje kopię niezarządzanego ciągu ANSI. Jeśli <paramref name="ptr" /> jest<see langword="null" />, metoda zwraca ciąg o wartości null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>jest przydatne w przypadku organizowania niestandardowego lub podczas mieszania kodu zarządzanego i niezarządzanego. Ponieważ ta metoda tworzy kopię zawartości niezarządzanego ciągu, należy bezpłatnie zwolnić oryginalny ciąg. Ta metoda zapewnia odwrotną funkcjonalność <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType> metod i. <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType>  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> metodę, aby utworzyć zarządzany ciąg z tablicy niezarządzanej. `char`  
  
 [!code-cpp[Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringAnsi">
      <MemberSignature Language="C#" Value="public static string PtrToStringAnsi (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAnsi(native int ptr, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringAnsi (ptr As IntPtr, len As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringAnsi(IntPtr ptr, int len);" />
      <MemberSignature Language="F#" Value="static member PtrToStringAnsi : nativeint * int -&gt; string" Usage="System.Runtime.InteropServices.Marshal.PtrToStringAnsi (ptr, len)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres pierwszego znaku niezarządzanego ciągu.</param>
        <param name="len">Liczba bajtów ciągu wejściowego do skopiowania.</param>
        <summary>Przypisuje zarządzane <see cref="T:System.String" />, kopiuje określoną liczbę znaków z niezarządzanego ciągu ANSI do niego i poszerza każdy znak ANSI do Unicode.</summary>
        <returns>Zarządzany ciąg, który przechowuje kopię natywnego ciągu ANSI, jeśli wartość <paramref name="ptr" /> parametru nie <see langword="null" />jest; w przeciwnym razie metoda ta zwraca <see langword="null" />wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>jest przydatne w przypadku organizowania niestandardowego lub podczas mieszania kodu zarządzanego i niezarządzanego. Ponieważ ta metoda tworzy kopię zawartości niezarządzanego ciągu, należy bezpłatnie zwolnić oryginalny ciąg. Ta metoda zapewnia odwrotną funkcjonalność <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType> metod i. <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType>  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> metodę, aby utworzyć zarządzany ciąg z tablicy niezarządzanej.`char`  
  
 [!code-cpp[Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr-int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr-int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="len" />jest mniejsza od zera.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PtrToStringAuto">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Alokuje zarządzane <see cref="T:System.String" /> i kopiuje wszystkie lub część niezarządzanego ciągu do niego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PtrToStringAuto">
      <MemberSignature Language="C#" Value="public static string PtrToStringAuto (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAuto(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringAuto (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringAuto(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member PtrToStringAuto : nativeint -&gt; string" Usage="System.Runtime.InteropServices.Marshal.PtrToStringAuto ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ptr">W przypadku platform Unicode adres pierwszego znaku Unicode.  
  
 —lub—  
  
 W przypadku platform ANSI adres pierwszego znaku ANSI.</param>
        <summary>Alokuje zarządzane <see cref="T:System.String" /> i kopiuje wszystkie znaki do pierwszego znaku null z ciągu przechowywanego w pamięci niezarządzanej.</summary>
        <returns>Zarządzany ciąg, który przechowuje kopię niezarządzanego ciągu, jeśli wartość <paramref name="ptr" /> parametru nie <see langword="null" />jest; w przeciwnym razie metoda ta zwraca wartość <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżąca platforma jest w formacie Unicode, każdy znak ANSI jest poszerzany do znaku Unicode i wywoływana <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>Metoda. W przeciwnym razie ta metoda <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>wywołuje metodę.  
  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A>jest przydatne w przypadku organizowania niestandardowego lub podczas mieszania kodu zarządzanego i niezarządzanego. Ponieważ ta metoda tworzy kopię zawartości niezarządzanego ciągu, należy bezpłatnie zwolnić oryginalny ciąg. <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A>zapewnia odwrotną funkcjonalność <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType> metod i <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringAuto">
      <MemberSignature Language="C#" Value="public static string PtrToStringAuto (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAuto(native int ptr, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringAuto (ptr As IntPtr, len As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringAuto(IntPtr ptr, int len);" />
      <MemberSignature Language="F#" Value="static member PtrToStringAuto : nativeint * int -&gt; string" Usage="System.Runtime.InteropServices.Marshal.PtrToStringAuto (ptr, len)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="len" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ptr">W przypadku platform Unicode adres pierwszego znaku Unicode.  
  
 —lub—  
  
 W przypadku platform ANSI adres pierwszego znaku ANSI.</param>
        <param name="len">Liczba znaków do skopiowania.</param>
        <summary>Alokuje zarządzane <see cref="T:System.String" /> i kopiuje określoną liczbę znaków z ciągu przechowywanego w pamięci niezarządzanej.</summary>
        <returns>Zarządzany ciąg, który przechowuje kopię ciągu natywnego, jeśli wartość <paramref name="ptr" /> parametru nie <see langword="null" />jest; w przeciwnym razie metoda ta zwraca wartość <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na platformach Unicode ta metoda wywołuje <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>; na platformach ANSI, wywołuje. <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> Przed wywołaniem tych metod nie są wykonywane żadne przekształcenia.  
  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A>jest przydatne w przypadku organizowania niestandardowego lub podczas mieszania kodu zarządzanego i niezarządzanego. Ponieważ ta metoda tworzy kopię zawartości niezarządzanego ciągu, należy bezpłatnie zwolnić oryginalny ciąg. <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A>zapewnia odwrotną funkcjonalność <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType> i <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="len" />jest mniejsza od zera.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringBSTR">
      <MemberSignature Language="C#" Value="public static string PtrToStringBSTR (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringBSTR(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringBSTR (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringBSTR(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member PtrToStringBSTR : nativeint -&gt; string" Usage="System.Runtime.InteropServices.Marshal.PtrToStringBSTR ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres pierwszego znaku niezarządzanego ciągu.</param>
        <summary>Alokuje zarządzane <see cref="T:System.String" /> i kopiuje [ciąg binarny (BSTR)](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx) , który jest przechowywany w pamięci niezarządzanej.</summary>
        <returns>Zarządzany ciąg, który przechowuje kopię niezarządzanego ciągu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę tylko dla ciągów, które zostały przydzieloną z niezarządzanymi funkcjami [SysAllocString](https://msdn.microsoft.com/library/ms221458\(v=vs.85\).aspx) i [SysAllocStringLen](https://msdn.microsoft.com/library/ms221639\(v=vs.85\).aspx) .  
  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A>jest przydatne w przypadku organizowania niestandardowego lub podczas mieszania kodu zarządzanego i niezarządzanego. Ponieważ ta metoda tworzy kopię zawartości niezarządzanego ciągu, należy bezpłatnie zwolnić oryginalny ciąg. Ta metoda zapewnia odwrotną funkcjonalność <xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="ptr" />równa <see cref="F:System.IntPtr.Zero" />się.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PtrToStringUni">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Alokuje zarządzane <see cref="T:System.String" /> i kopiuje całość lub część niezarządzanego ciągu Unicode do niego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PtrToStringUni">
      <MemberSignature Language="C#" Value="public static string PtrToStringUni (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUni(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringUni (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringUni(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member PtrToStringUni : nativeint -&gt; string" Usage="System.Runtime.InteropServices.Marshal.PtrToStringUni ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres pierwszego znaku niezarządzanego ciągu.</param>
        <summary>Alokuje zarządzane <see cref="T:System.String" /> i kopiuje wszystkie znaki do pierwszego znaku null z niezarządzanego ciągu Unicode do niego.</summary>
        <returns>Zarządzany ciąg, który przechowuje kopię niezarządzanego ciągu, jeśli wartość <paramref name="ptr" /> parametru nie <see langword="null" />jest; w przeciwnym razie metoda ta zwraca wartość <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>jest przydatne do organizowania niestandardowego lub do użycia podczas mieszania kodu zarządzanego i niezarządzanego. Ponieważ ta metoda tworzy kopię zawartości niezarządzanego ciągu, należy bezpłatnie zwolnić oryginalny ciąg. Ta metoda zapewnia odwrotną funkcjonalność <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType> metod i. <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUni">
      <MemberSignature Language="C#" Value="public static string PtrToStringUni (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUni(native int ptr, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringUni (ptr As IntPtr, len As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringUni(IntPtr ptr, int len);" />
      <MemberSignature Language="F#" Value="static member PtrToStringUni : nativeint * int -&gt; string" Usage="System.Runtime.InteropServices.Marshal.PtrToStringUni (ptr, len)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres pierwszego znaku niezarządzanego ciągu.</param>
        <param name="len">Liczba znaków Unicode do skopiowania.</param>
        <summary>Alokuje zarządzane <see cref="T:System.String" /> i kopiuje określoną liczbę znaków z niezarządzanego ciągu Unicode do niego.</summary>
        <returns>Zarządzany ciąg, który przechowuje kopię niezarządzanego ciągu, jeśli wartość <paramref name="ptr" /> parametru nie <see langword="null" />jest; w przeciwnym razie metoda ta zwraca wartość <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>jest przydatne w przypadku organizowania niestandardowego lub podczas mieszania kodu zarządzanego i niezarządzanego. Ponieważ ta metoda tworzy kopię zawartości niezarządzanego ciągu, należy bezpłatnie zwolnić oryginalny ciąg. Ta metoda zapewnia odwrotną funkcjonalność <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType> metod i. <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUTF8">
      <MemberSignature Language="C#" Value="public static string PtrToStringUTF8 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUTF8(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUTF8(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringUTF8 (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringUTF8(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member PtrToStringUTF8 : nativeint -&gt; string" Usage="System.Runtime.InteropServices.Marshal.PtrToStringUTF8 ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.1">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ptr">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUTF8">
      <MemberSignature Language="C#" Value="public static string PtrToStringUTF8 (IntPtr ptr, int byteLen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUTF8(native int ptr, int32 byteLen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUTF8(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringUTF8 (ptr As IntPtr, byteLen As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringUTF8(IntPtr ptr, int byteLen);" />
      <MemberSignature Language="F#" Value="static member PtrToStringUTF8 : nativeint * int -&gt; string" Usage="System.Runtime.InteropServices.Marshal.PtrToStringUTF8 (ptr, byteLen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.1">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="byteLen" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ptr">To be added.</param>
        <param name="byteLen">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PtrToStructure">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kierowanie danych z niezarządzanego bloku pamięci do obiektu zarządzanego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PtrToStructure">
      <MemberSignature Language="C#" Value="public static void PtrToStructure (IntPtr ptr, object structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PtrToStructure(native int ptr, object structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PtrToStructure (ptr As IntPtr, structure As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PtrToStructure(IntPtr ptr, System::Object ^ structure);" />
      <MemberSignature Language="F#" Value="static member PtrToStructure : nativeint * obj -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.PtrToStructure (ptr, structure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;dotnet-uwp-10.0">
          <AttributeName>System.Obsolete("PtrToStructure(IntPtr, Object) may be unavailable in future releases. Instead, use PtrToStructure&lt;T&gt;(IntPtr). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296512")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structure" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="ptr">Wskaźnik do niezarządzanego bloku pamięci.</param>
        <param name="structure">Obiekt, do którego mają zostać skopiowane dane. Musi to być wystąpienie sformatowanej klasy.</param>
        <summary>Kierowanie danych z niezarządzanego bloku pamięci do obiektu zarządzanego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A>jest często konieczne w przypadku międzyoperacyjności modelu COM i wywołania platformy, gdy parametry <xref:System.IntPtr?displayProperty=nameWithType> struktury są reprezentowane jako wartość. Nie można użyć tej metody przeciążenia z typami wartości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Układ struktury nie jest sekwencyjny ani jawny.  
  
 —lub—  
  
 Struktura jest opakowanym typem wartościowym.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure">
      <MemberSignature Language="C#" Value="public static object PtrToStructure (IntPtr ptr, Type structureType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object PtrToStructure(native int ptr, class System.Type structureType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStructure (ptr As IntPtr, structureType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ PtrToStructure(IntPtr ptr, Type ^ structureType);" />
      <MemberSignature Language="F#" Value="static member PtrToStructure : nativeint * Type -&gt; obj" Usage="System.Runtime.InteropServices.Marshal.PtrToStructure (ptr, structureType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;dotnet-uwp-10.0">
          <AttributeName>System.Obsolete("PtrToStructure(IntPtr, Type) may be unavailable in future releases. Instead, use PtrToStructure&lt;T&gt;(IntPtr). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296513")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structureType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ptr">Wskaźnik do niezarządzanego bloku pamięci.</param>
        <param name="structureType">Typ obiektu, który ma zostać utworzony. Ten obiekt musi reprezentować sformatowaną klasę lub strukturę.</param>
        <summary>Kierowanie danych z niezarządzanego bloku pamięci do nowo przydzielony obiekt zarządzany określonego typu.</summary>
        <returns>Obiekt zarządzany zawierający dane wskazywane przez <paramref name="ptr" /> parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A>jest często konieczne w przypadku międzyoperacyjności modelu COM i wywołania platformy, gdy parametry <xref:System.IntPtr?displayProperty=nameWithType> struktury są reprezentowane jako wartość. Do tej metody przeciążenia można przekazać typ wartości. W takim przypadku zwracany obiekt jest wystąpieniem w ramce.  
  
   
  
## Examples  
 Poniższy przykład tworzy strukturę zarządzaną, przesyła ją do pamięci niezarządzanej, a następnie przesyła ją z powrotem do pamięci zarządzanej przy użyciu <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> metody.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/vb/sample.vb#1)]  
  
 W poniższym przykładzie pokazano, <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> jak zorganizować niezarządzany blok pamięci do zarządzanej struktury przy użyciu metody.  
  
> [!IMPORTANT]
>  Ten kod zakłada kompilację 32-bitową. Przed użyciem kompilatora 64-bitowego należy zastąpić <xref:System.IntPtr.ToInt32%2A?displayProperty=nameWithType> <xref:System.IntPtr.ToInt64%2A?displayProperty=nameWithType>poleceniem.  
  
 [!code-cpp[PtrToStructure#1](~/samples/snippets/cpp/VS_Snippets_CLR/PtrToStructure/CPP/pts.cpp#1)]
 [!code-csharp[PtrToStructure#1](~/samples/snippets/csharp/VS_Snippets_CLR/PtrToStructure/CS/pts.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Układ <paramref name="structureType" /> parametru nie jest sekwencyjny ani jawny.  
  
—lub— 
<paramref name="structureType" /> Parametr jest definicją typu ogólnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="structureType" />jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Klasa określona przez <paramref name="structureType" /> nie ma dostępnego konstruktora bez parametrów.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeInfo.GetTypeAttr(System.IntPtr@)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T PtrToStructure&lt;T&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T PtrToStructure&lt;T&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStructure(Of T) (ptr As IntPtr) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T PtrToStructure(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member PtrToStructure : nativeint -&gt; 'T" Usage="System.Runtime.InteropServices.Marshal.PtrToStructure ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ obiektu, do którego mają zostać skopiowane dane. Musi to być sformatowana Klasa lub struktura.</typeparam>
        <param name="ptr">Wskaźnik do niezarządzanego bloku pamięci.</param>
        <summary>[Obsługiwane w .NET Framework 4.5.1 i nowszych wersjach]  
  
 Kierowanie danych z niezarządzanego bloku pamięci do nowo przydzielonego obiektu zarządzanego typu określonego przez parametr typu ogólnego.</summary>
        <returns>Obiekt zarządzany, który zawiera dane, do których <paramref name="ptr" /> wskazuje parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%29>jest często konieczne w przypadku międzyoperacyjności modelu COM i wywołania platformy, gdy <xref:System.IntPtr?displayProperty=nameWithType> parametry struktury są reprezentowane jako wartości. Do tego przeciążenia metody można przekazać typ wartości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Układ <typeparamref name="T" /> nie jest sekwencyjny ani jawny.</exception>
        <exception cref="T:System.MissingMethodException">Klasa określona przez <typeparamref name="T" /> nie ma dostępnego konstruktora bez parametrów.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void PtrToStructure&lt;T&gt; (IntPtr ptr, T structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PtrToStructure&lt;T&gt;(native int ptr, !!T structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PtrToStructure(Of T) (ptr As IntPtr, structure As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void PtrToStructure(IntPtr ptr, T structure);" />
      <MemberSignature Language="F#" Value="static member PtrToStructure : nativeint * 'T -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.PtrToStructure (ptr, structure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="structure" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ <paramref name="structure" />. Ta wartość musi być sformatowaną klasą.</typeparam>
        <param name="ptr">Wskaźnik do niezarządzanego bloku pamięci.</param>
        <param name="structure">Obiekt, do którego mają zostać skopiowane dane.</param>
        <summary>[Obsługiwane w .NET Framework 4.5.1 i nowszych wersjach]  
  
 Kierowanie danych z niezarządzanego bloku pamięci do obiektu zarządzanego określonego typu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%2C%60%600%29>jest często konieczne w przypadku międzyoperacyjności modelu COM i wywołania platformy, gdy <xref:System.IntPtr> parametry struktury są reprezentowane jako wartości. Nie można użyć tego przeciążenia metody z typami wartości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Układ struktury nie jest sekwencyjny ani jawny.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="QueryInterface">
      <MemberSignature Language="C#" Value="public static int QueryInterface (IntPtr pUnk, ref Guid iid, out IntPtr ppv);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 QueryInterface(native int pUnk, valuetype System.Guid&amp; iid, [out] native int&amp; ppv) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueryInterface (pUnk As IntPtr, ByRef iid As Guid, ByRef ppv As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int QueryInterface(IntPtr pUnk, Guid % iid, [Runtime::InteropServices::Out] IntPtr % ppv);" />
      <MemberSignature Language="F#" Value="static member QueryInterface : nativeint *  *  -&gt; int" Usage="System.Runtime.InteropServices.Marshal.QueryInterface (pUnk, iid, ppv)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
        <Parameter Name="iid" Type="System.Guid" RefType="ref" />
        <Parameter Name="ppv" Type="System.IntPtr" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pUnk">Interfejs, który ma być wysyłany do zapytania.</param>
        <param name="iid">Identyfikator interfejsu (IID) żądanego interfejsu.</param>
        <param name="ppv">Gdy ta metoda zwraca, zawiera odwołanie do zwracanego interfejsu.</param>
        <summary>Żąda wskaźnika do określonego interfejsu z obiektu COM.</summary>
        <returns>WYNIK HRESULT wskazujący powodzenie lub Niepowodzenie wywołania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda uwidacznia metodę [IUnknown:: QueryInterface](https://go.microsoft.com/fwlink/?LinkID=144867) obiektu com, który próbuje uzyskać określony wskaźnik interfejsu. <xref:System.Runtime.InteropServices.Marshal.QueryInterface%2A> Używanie `QueryInterface` na obiekcie com jest takie samo jak wykonywanie operacji Cast w kodzie zarządzanym. Wywołanie obiektu za pomocą tej metody powoduje zwiększenie liczby odwołań na wskaźniku interfejsu przed zwróceniem wskaźnika. Zawsze używaj <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> , aby zmniejszyć liczbę odwołań po zakończeniu wskaźnika. Aby uzyskać <xref:System.IntPtr> wartość reprezentującą wskaźnik interfejsu [IUnknown](https://go.microsoft.com/fwlink/?LinkId=148003) , można wywołać <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>lub <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadByte">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje pojedynczy bajt z pamięci niezarządzanej. Obsługiwane jest odczytywanie z niewyrównanych lokalizacji pamięci.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadByte (ptr As IntPtr) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte ReadByte(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member ReadByte : nativeint -&gt; byte" Usage="System.Runtime.InteropServices.Marshal.ReadByte ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres w pamięci niezarządzanej, z której ma zostać odczytany.</param>
        <summary>Odczytuje pojedynczy bajt z pamięci niezarządzanej.</summary>
        <returns>Bajt odczytany z pamięci niezarządzanej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A>ma implikowane przesunięcie równe 0. Ta metoda umożliwia bezpośrednią interakcję z niezarządzaną tablicą bajtów w stylu C, eliminując koszty kopiowania całej tablicy niezarządzanej (przy użyciu <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) do oddzielnej zarządzanej tablicy przed przeczytaniem jej wartości elementów.  
  
 Obsługiwane jest odczytywanie z niewyrównanych lokalizacji pamięci.  
  
   
  
## Examples  
 Poniższy przykład tworzy blok pamięci niezarządzanej, zapisuje bajty w pamięci niezarządzanej, odczytuje bajt z pamięci niezarządzanej, a następnie usuwa niezarządzaną pamięć.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/vb/example.vb#1)]  
  
 Poniższy przykład ilustruje sposób użycia <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> metody do odczytu wartości niezarządzanego znaku.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadByte#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><paramref name="ptr" />nie jest rozpoznawanym formatem.  
  
—lub— 
 <paramref name="ptr" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="ptr" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadByte (ptr As IntPtr, ofs As Integer) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte ReadByte(IntPtr ptr, int ofs);" />
      <MemberSignature Language="F#" Value="static member ReadByte : nativeint * int -&gt; byte" Usage="System.Runtime.InteropServices.Marshal.ReadByte (ptr, ofs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres podstawowy w pamięci niezarządzanej, z której ma zostać odczytany.</param>
        <param name="ofs">Dodatkowe przesunięcie bajtowe, które jest dodawane do <paramref name="ptr" /> parametru przed odczytem.</param>
        <summary>Odczytuje pojedynczy bajt w danym przesunięciu (lub indeksie) z pamięci niezarządzanej.</summary>
        <returns>Bajt odczytany z pamięci niezarządzanej przy podanym przesunięciu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A>Włącza bezpośrednią interakcję z niezarządzaną tablicą bajtów w stylu C, eliminując koszty kopiowania całej tablicy niezarządzanej (przy użyciu <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) do oddzielnej zarządzanej tablicy przed przeczytaniem jej wartości elementów.  
  
 Obsługiwane jest odczytywanie z niewyrównanych lokalizacji pamięci.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób odczytu i zapisu do niezarządzanej tablicy przy użyciu <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> metod i. <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#3)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#3)]  
  
 Poniższy przykład ilustruje sposób użycia <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> metody do odczytu wartości niezarządzanego znaku.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadByte-IntPtr-int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte-IntPtr-int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Adres podstawowy (<paramref name="ptr" />) i bajt przesunięcia<paramref name="ofs" />() tworzą wartość null lub nieprawidłowy adres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadByte (ptr As Object, ofs As Integer) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte ReadByte(System::Object ^ ptr, int ofs);" />
      <MemberSignature Language="F#" Value="static member ReadByte : obj * int -&gt; byte" Usage="System.Runtime.InteropServices.Marshal.ReadByte (ptr, ofs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("ReadByte(Object, Int32) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres podstawowy w pamięci niezarządzanej obiektu źródłowego.</param>
        <param name="ofs">Dodatkowe przesunięcie bajtowe, które jest dodawane do <paramref name="ptr" /> parametru przed odczytem.</param>
        <summary>Odczytuje pojedynczy bajt w danym przesunięciu (lub indeksie) z pamięci niezarządzanej.</summary>
        <returns>Bajt odczytany z pamięci niezarządzanej przy podanym przesunięciu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A>Włącza bezpośrednią interakcję z niezarządzaną tablicą bajtów w stylu C, eliminując koszty kopiowania całej tablicy niezarządzanej (przy użyciu <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) do oddzielnej zarządzanej tablicy przed przeczytaniem jej wartości elementów.  
  
 Obsługiwane jest odczytywanie z niewyrównanych lokalizacji pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Adres podstawowy (<paramref name="ptr" />) i bajt przesunięcia<paramref name="ofs" />() tworzą wartość null lub nieprawidłowy adres.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="ptr" /><see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> jest obiektem. Ta metoda nie akceptuje <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parametrów.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadInt16">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje 16-bitową liczbę całkowitą ze znakiem z pamięci niezarządzanej. Obsługiwane jest odczytywanie z niewyrównanych lokalizacji pamięci.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16 (ptr As IntPtr) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member ReadInt16 : nativeint -&gt; int16" Usage="System.Runtime.InteropServices.Marshal.ReadInt16 ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres w pamięci niezarządzanej, z której ma zostać odczytany.</param>
        <summary>Odczytuje 16-bitową liczbę całkowitą ze znakiem z pamięci niezarządzanej.</summary>
        <returns>16-bitowa liczba całkowita ze znakiem odczytana z pamięci niezarządzanej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A>ma implikowane przesunięcie równe 0. Ta metoda umożliwia bezpośrednią interakcję z niezarządzaną `Int16` tablicą języka C, eliminując koszty kopiowania całej tablicy niezarządzanej <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>(przy użyciu) do oddzielnej zarządzanej tablicy przed przeczytaniem jej wartości elementów.  
  
 Obsługiwane jest odczytywanie z niewyrównanych lokalizacji pamięci.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób odczytu i zapisu do niezarządzanej tablicy przy użyciu <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> metod i. <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 Poniższy przykład ilustruje sposób użycia <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> metody do odczytu wartości zmiennej niezarządzanej. `short`  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt16#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt16/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><paramref name="ptr" />nie jest rozpoznawanym formatem.  
  
—lub— 
 <paramref name="ptr" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="ptr" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16 (ptr As IntPtr, ofs As Integer) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16(IntPtr ptr, int ofs);" />
      <MemberSignature Language="F#" Value="static member ReadInt16 : nativeint * int -&gt; int16" Usage="System.Runtime.InteropServices.Marshal.ReadInt16 (ptr, ofs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres podstawowy w pamięci niezarządzanej, z której ma zostać odczytany.</param>
        <param name="ofs">Dodatkowe przesunięcie bajtowe, które jest dodawane do <paramref name="ptr" /> parametru przed odczytem.</param>
        <summary>Odczytuje 16-bitową liczbę całkowitą ze znakiem z danego przesunięcia z pamięci niezarządzanej.</summary>
        <returns>16-bitowa liczba całkowita ze znakiem odczytana z pamięci niezarządzanej przy podanym przesunięciu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A>Włącza bezpośrednią interakcję z niezarządzaną 16-bitową tablicą podpisaną, eliminując koszty kopiowania całej tablicy <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>niezarządzanej (przy użyciu) do oddzielnej zarządzanej tablicy przed przeczytaniem jej wartości elementów.  
  
 Obsługiwane jest odczytywanie z niewyrównanych lokalizacji pamięci.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób odczytu i zapisu do niezarządzanej tablicy przy użyciu <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> metod i. <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 Poniższy przykład ilustruje sposób użycia <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> metody do odczytu wartości zmiennej niezarządzanej. `short`  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt16-IntPtr-Int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt16-IntPtr-Int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Adres podstawowy (<paramref name="ptr" />) i bajt przesunięcia<paramref name="ofs" />() tworzą wartość null lub nieprawidłowy adres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16 (ptr As Object, ofs As Integer) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16(System::Object ^ ptr, int ofs);" />
      <MemberSignature Language="F#" Value="static member ReadInt16 : obj * int -&gt; int16" Usage="System.Runtime.InteropServices.Marshal.ReadInt16 (ptr, ofs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("ReadInt16(Object, Int32) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres podstawowy w pamięci niezarządzanej obiektu źródłowego.</param>
        <param name="ofs">Dodatkowe przesunięcie bajtowe, które jest dodawane do <paramref name="ptr" /> parametru przed odczytem.</param>
        <summary>Odczytuje 16-bitową liczbę całkowitą ze znakiem z danego przesunięcia z pamięci niezarządzanej.</summary>
        <returns>16-bitowa liczba całkowita ze znakiem odczytana z pamięci niezarządzanej przy podanym przesunięciu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A>Włącza bezpośrednią interakcję z niezarządzaną 16-bitową tablicą podpisaną, eliminując koszty kopiowania całej tablicy <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>niezarządzanej (przy użyciu) do oddzielnej zarządzanej tablicy przed przeczytaniem jej wartości elementów.  
  
 Obsługiwane jest odczytywanie z niewyrównanych lokalizacji pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Adres podstawowy (<paramref name="ptr" />) i bajt przesunięcia<paramref name="ofs" />() tworzą wartość null lub nieprawidłowy adres.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="ptr" /><see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> jest obiektem. Ta metoda nie akceptuje <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parametrów.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadInt32">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje 32-bitową liczbę całkowitą ze znakiem z pamięci niezarządzanej. Obsługiwane jest odczytywanie z niewyrównanych lokalizacji pamięci.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32 (ptr As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member ReadInt32 : nativeint -&gt; int" Usage="System.Runtime.InteropServices.Marshal.ReadInt32 ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres w pamięci niezarządzanej, z której ma zostać odczytany.</param>
        <summary>Odczytuje 32-bitową liczbę całkowitą ze znakiem z pamięci niezarządzanej.</summary>
        <returns>32-bitowa liczba całkowita ze znakiem odczytana z pamięci niezarządzanej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A>ma implikowane przesunięcie równe 0. Ta metoda umożliwia bezpośrednią interakcję z niezarządzaną `Int32` tablicą języka C, eliminując koszty kopiowania całej tablicy niezarządzanej <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>(przy użyciu) do oddzielnej zarządzanej tablicy przed przeczytaniem jej wartości elementów.  
  
 Obsługiwane jest odczytywanie z niewyrównanych lokalizacji pamięci.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób odczytu i zapisu do niezarządzanej tablicy przy użyciu <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> metod i. <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 Poniższy przykład ilustruje sposób użycia <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> metody do odczytu wartości zmiennej niezarządzanej. `int`  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt32#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt32/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><paramref name="ptr" />nie jest rozpoznawanym formatem.  
  
—lub— 
 <paramref name="ptr" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="ptr" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32 (ptr As IntPtr, ofs As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32(IntPtr ptr, int ofs);" />
      <MemberSignature Language="F#" Value="static member ReadInt32 : nativeint * int -&gt; int" Usage="System.Runtime.InteropServices.Marshal.ReadInt32 (ptr, ofs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres podstawowy w pamięci niezarządzanej, z której ma zostać odczytany.</param>
        <param name="ofs">Dodatkowe przesunięcie bajtowe, które jest dodawane do <paramref name="ptr" /> parametru przed odczytem.</param>
        <summary>Odczytuje 32-bitową liczbę całkowitą ze znakiem w danym przesunięciu z pamięci niezarządzanej.</summary>
        <returns>32-bitowa liczba całkowita ze znakiem odczytana z pamięci niezarządzanej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A>Włącza bezpośrednią interakcję z niezarządzaną, 32 bitową tablicą, eliminując koszty kopiowania całej tablicy niezarządzanej (przy użyciu <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) do oddzielnej zarządzanej tablicy przed przeczytaniem jej wartości elementów.  
  
 Obsługiwane jest odczytywanie z niewyrównanych lokalizacji pamięci.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób odczytu i zapisu do niezarządzanej tablicy przy użyciu <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> metod i. <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 Poniższy przykład ilustruje sposób użycia <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> metody do odczytu wartości zmiennej niezarządzanej. `int`  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt32-IntPtr-Int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt32-IntPtr-Int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Adres podstawowy (<paramref name="ptr" />) i bajt przesunięcia<paramref name="ofs" />() tworzą wartość null lub nieprawidłowy adres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32 (ptr As Object, ofs As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32(System::Object ^ ptr, int ofs);" />
      <MemberSignature Language="F#" Value="static member ReadInt32 : obj * int -&gt; int" Usage="System.Runtime.InteropServices.Marshal.ReadInt32 (ptr, ofs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("ReadInt32(Object, Int32) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres podstawowy w pamięci niezarządzanej obiektu źródłowego.</param>
        <param name="ofs">Dodatkowe przesunięcie bajtowe, które jest dodawane do <paramref name="ptr" /> parametru przed odczytem.</param>
        <summary>Odczytuje 32-bitową liczbę całkowitą ze znakiem w danym przesunięciu z pamięci niezarządzanej.</summary>
        <returns>32-bitowa liczba całkowita ze znakiem odczytana z pamięci niezarządzanej przy podanym przesunięciu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A>Włącza bezpośrednią interakcję z niezarządzaną, 32 bitową tablicą, eliminując koszty kopiowania całej tablicy niezarządzanej (przy użyciu <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) do oddzielnej zarządzanej tablicy przed przeczytaniem jej wartości elementów.  
  
 Obsługiwane jest odczytywanie z niewyrównanych lokalizacji pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Adres podstawowy (<paramref name="ptr" />) i bajt przesunięcia<paramref name="ofs" />() tworzą wartość null lub nieprawidłowy adres.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="ptr" /><see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> jest obiektem. Ta metoda nie akceptuje <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parametrów.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadInt64">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje 64-bitową liczbę całkowitą ze znakiem z pamięci niezarządzanej. Obsługiwane jest odczytywanie z niewyrównanych lokalizacji pamięci.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64 (ptr As IntPtr) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member ReadInt64 : nativeint -&gt; int64" Usage="System.Runtime.InteropServices.Marshal.ReadInt64 ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres w pamięci niezarządzanej, z której ma zostać odczytany.</param>
        <summary>Odczytuje 64-bitową liczbę całkowitą ze znakiem z pamięci niezarządzanej.</summary>
        <returns>64-bitowa liczba całkowita ze znakiem odczytana z pamięci niezarządzanej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A>ma implikowane przesunięcie równe 0. Ta metoda umożliwia bezpośrednią interakcję z niezarządzaną `Int64` tablicą języka C, eliminując koszty kopiowania całej tablicy niezarządzanej <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>(przy użyciu) do oddzielnej zarządzanej tablicy przed przeczytaniem jej wartości elementów.  
  
 Obsługiwane jest odczytywanie z niewyrównanych lokalizacji pamięci.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób odczytu i zapisu do niezarządzanej tablicy przy użyciu <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> metod i. <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 Poniższy przykład ilustruje sposób użycia <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> metody do odczytu wartości zmiennej niezarządzanej. `__int64`  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt64/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><paramref name="ptr" />nie jest rozpoznawanym formatem.  
  
—lub— 
 <paramref name="ptr" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="ptr" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64 (ptr As IntPtr, ofs As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64(IntPtr ptr, int ofs);" />
      <MemberSignature Language="F#" Value="static member ReadInt64 : nativeint * int -&gt; int64" Usage="System.Runtime.InteropServices.Marshal.ReadInt64 (ptr, ofs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres podstawowy w pamięci niezarządzanej, z której ma zostać odczytany.</param>
        <param name="ofs">Dodatkowe przesunięcie bajtowe, które jest dodawane do <paramref name="ptr" /> parametru przed odczytem.</param>
        <summary>Odczytuje 64-bitową liczbę całkowitą ze znakiem w danym przesunięciu z pamięci niezarządzanej.</summary>
        <returns>64-bitowa liczba całkowita ze znakiem odczytana z pamięci niezarządzanej przy podanym przesunięciu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A>Włącza bezpośrednią interakcję z niezarządzaną, 64 bitową tablicą, eliminując koszty kopiowania całej tablicy niezarządzanej (przy użyciu <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) do oddzielnej zarządzanej tablicy przed przeczytaniem jej wartości elementów.  
  
 Obsługiwane jest odczytywanie z niewyrównanych lokalizacji pamięci.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób odczytu i zapisu do niezarządzanej tablicy przy użyciu <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> metod i. <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 Poniższy przykład ilustruje sposób użycia <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> metody do odczytu wartości zmiennej niezarządzanej. `__int64`  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt64-IntPtr-Int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt64-IntPtr-Int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Adres podstawowy (<paramref name="ptr" />) i bajt przesunięcia<paramref name="ofs" />() tworzą wartość null lub nieprawidłowy adres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64 (ptr As Object, ofs As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64(System::Object ^ ptr, int ofs);" />
      <MemberSignature Language="F#" Value="static member ReadInt64 : obj * int -&gt; int64" Usage="System.Runtime.InteropServices.Marshal.ReadInt64 (ptr, ofs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("ReadInt64(Object, Int32) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres podstawowy w pamięci niezarządzanej obiektu źródłowego.</param>
        <param name="ofs">Dodatkowe przesunięcie bajtowe, które jest dodawane do <paramref name="ptr" /> parametru przed odczytem.</param>
        <summary>Odczytuje 64-bitową liczbę całkowitą ze znakiem w danym przesunięciu z pamięci niezarządzanej.</summary>
        <returns>64-bitowa liczba całkowita ze znakiem odczytana z pamięci niezarządzanej przy podanym przesunięciu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A>Włącza bezpośrednią interakcję z niezarządzaną, 64 bitową tablicą, eliminując koszty kopiowania całej tablicy niezarządzanej (przy użyciu <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) do oddzielnej zarządzanej tablicy przed przeczytaniem jej wartości elementów.  
  
 Obsługiwane jest odczytywanie z niewyrównanych lokalizacji pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Adres podstawowy (<paramref name="ptr" />) i bajt przesunięcia<paramref name="ofs" />() tworzą wartość null lub nieprawidłowy adres.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="ptr" /><see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> jest obiektem. Ta metoda nie akceptuje <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parametrów.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadIntPtr">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje liczbę całkowitą z pamięci niezarządzanej procesora. Obsługiwane jest odczytywanie z niewyrównanych lokalizacji pamięci.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadIntPtr (ptr As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReadIntPtr(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member ReadIntPtr : nativeint -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.ReadIntPtr ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres w pamięci niezarządzanej, z której ma zostać odczytany.</param>
        <summary>Odczytuje liczbę całkowitą procesora od pamięci niezarządzanej.</summary>
        <returns>Liczba całkowita odczytana z pamięci niezarządzanej. Na maszynach bitowych 32 jest zwracana 32-bitowa liczba całkowita, a na komputerach 64 z systemem 64 jest zwracana niebitowa liczba całkowita.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A>ma implikowane przesunięcie równe 0. Ta metoda umożliwia bezpośrednią interakcję z niezarządzaną `IntPtr` tablicą języka C, eliminując koszty kopiowania całej tablicy niezarządzanej <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>(przy użyciu) do oddzielnej zarządzanej tablicy przed przeczytaniem jej wartości elementów.  
  
 Obsługiwane jest odczytywanie z niewyrównanych lokalizacji pamięci.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób odczytu i zapisu do niezarządzanej tablicy przy użyciu <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> metod i. <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><paramref name="ptr" />nie jest rozpoznawanym formatem.  
  
—lub— 
 <paramref name="ptr" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="ptr" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadIntPtr (ptr As IntPtr, ofs As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReadIntPtr(IntPtr ptr, int ofs);" />
      <MemberSignature Language="F#" Value="static member ReadIntPtr : nativeint * int -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.ReadIntPtr (ptr, ofs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres podstawowy w pamięci niezarządzanej, z której ma zostać odczytany.</param>
        <param name="ofs">Dodatkowe przesunięcie bajtowe, które jest dodawane do <paramref name="ptr" /> parametru przed odczytem.</param>
        <summary>Odczytuje liczbę całkowitą z zakresu natywnego procesora dla danego przesunięcia z pamięci niezarządzanej.</summary>
        <returns>Liczba całkowita odczytana z pamięci niezarządzanej przy podanym przesunięciu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A>Włącza bezpośrednią interakcję z niezarządzaną `IntPtr` tablicą języka C, eliminując koszty kopiowania całej tablicy niezarządzanej <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>(przy użyciu) do oddzielnej zarządzanej tablicy przed przeczytaniem jej wartości elementów.  
  
 Obsługiwane jest odczytywanie z niewyrównanych lokalizacji pamięci.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób odczytu i zapisu do niezarządzanej tablicy przy użyciu <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> metod i. <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Adres podstawowy (<paramref name="ptr" />) i bajt przesunięcia<paramref name="ofs" />() tworzą wartość null lub nieprawidłowy adres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadIntPtr (ptr As Object, ofs As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReadIntPtr(System::Object ^ ptr, int ofs);" />
      <MemberSignature Language="F#" Value="static member ReadIntPtr : obj * int -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.ReadIntPtr (ptr, ofs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("ReadIntPtr(Object, Int32) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres podstawowy w pamięci niezarządzanej obiektu źródłowego.</param>
        <param name="ofs">Dodatkowe przesunięcie bajtowe, które jest dodawane do <paramref name="ptr" /> parametru przed odczytem.</param>
        <summary>Odczytuje liczbę całkowitą z pamięci niezarządzanej procesora.</summary>
        <returns>Liczba całkowita odczytana z pamięci niezarządzanej przy podanym przesunięciu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A>Włącza bezpośrednią interakcję z niezarządzaną `IntPtr` tablicą języka C, eliminując koszty kopiowania całej tablicy niezarządzanej <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>(przy użyciu) do oddzielnej zarządzanej tablicy przed przeczytaniem jej wartości elementów.  
  
 Obsługiwane jest odczytywanie z niewyrównanych lokalizacji pamięci.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Adres podstawowy (<paramref name="ptr" />) i bajt przesunięcia<paramref name="ofs" />() tworzą wartość null lub nieprawidłowy adres.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="ptr" /><see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> jest obiektem. Ta metoda nie akceptuje <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parametrów.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReAllocCoTaskMem">
      <MemberSignature Language="C#" Value="public static IntPtr ReAllocCoTaskMem (IntPtr pv, int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReAllocCoTaskMem(native int pv, int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReAllocCoTaskMem (pv As IntPtr, cb As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReAllocCoTaskMem(IntPtr pv, int cb);" />
      <MemberSignature Language="F#" Value="static member ReAllocCoTaskMem : nativeint * int -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem (pv, cb)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pv" Type="System.IntPtr" />
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pv">Wskaźnik do pamięci przydzielonyj <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />za pomocą.</param>
        <param name="cb">Nowy rozmiar przydzielonych bloków.</param>
        <summary>Zmienia rozmiar bloku pamięci, który został wcześniej przydzielony <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />do.</summary>
        <returns>Liczba całkowita reprezentująca adres ponownie przydzielonych bloków pamięci. Ta pamięć musi być wydana w <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />systemie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A>jest jedną z dwóch metod ponownej alokacji pamięci w <xref:System.Runtime.InteropServices.Marshal> klasie. (<xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A> czy jest to druga). Początek ponownie przydzieloną zawartość pamięci jest taka sama jak oryginalna zawartość; jednak cały blok pamięci może znajdować się w innej lokalizacji. Ta metoda przedstawia funkcję [COTASKMEMREALLOC](https://go.microsoft.com/fwlink/?LinkId=148778) com, która jest określana jako Alokator pamięci zadania com.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Brak wystarczającej ilości pamięci do spełnienia żądania.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="ReAllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr ReAllocHGlobal (IntPtr pv, IntPtr cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReAllocHGlobal(native int pv, native int cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReAllocHGlobal (pv As IntPtr, cb As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReAllocHGlobal(IntPtr pv, IntPtr cb);" />
      <MemberSignature Language="F#" Value="static member ReAllocHGlobal : nativeint * nativeint -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.ReAllocHGlobal (pv, cb)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pv" Type="System.IntPtr" />
        <Parameter Name="cb" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pv">Wskaźnik do pamięci przydzielonyj <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />za pomocą.</param>
        <param name="cb">Nowy rozmiar przydzielonych bloków. To nie jest wskaźnik; jest to liczba bajtów, którą żądasz, Rzutowanie na typ <see cref="T:System.IntPtr" />. Jeśli wskaźnik zostanie przekazany, jest traktowany jako rozmiar.</param>
        <summary>Zmienia rozmiar bloku pamięci, który został wcześniej przydzielony <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />do.</summary>
        <returns>Wskaźnik do ponownie przydzieloną pamięć. Ta pamięć musi być wydana przy <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />użyciu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A>jest jedną z dwóch metod ponownej alokacji pamięci w <xref:System.Runtime.InteropServices.Marshal> klasie. (<xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A?displayProperty=nameWithType> czy jest to druga).  
  
 Ta metoda udostępnia funkcję Win32 [GlobalReAlloc](https://go.microsoft.com/fwlink/?LinkId=148780) z pliku Kernel32. dll. Zwrócony wskaźnik może się różnić od oryginału. Jeśli jest inna, zawartość oryginalnego bloku pamięci została skopiowana do nowego bloku, a oryginalny blok pamięci został zwolniony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Brak wystarczającej ilości pamięci do spełnienia żądania.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=148781">GlobalAlloc Function</related>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public static int Release (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Release(native int pUnk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Release (pUnk As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Release(IntPtr pUnk);" />
      <MemberSignature Language="F#" Value="static member Release : nativeint -&gt; int" Usage="System.Runtime.InteropServices.Marshal.Release pUnk" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pUnk">Interfejs do wydania.</param>
        <summary>Zmniejsza liczbę odwołań w określonym interfejsie.</summary>
        <returns>Nowa wartość liczby odwołań w interfejsie określonym przez <paramref name="pUnk" /> parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisko uruchomieniowe języka wspólnego zarządza liczbą odwołań obiektu COM, co sprawia, że nie jest konieczne bezpośrednie używanie tej metody. Tej wartości należy używać tylko do celów testowych. W rzadkich przypadkach, takich jak testowanie organizatora niestandardowego, może okazać się konieczne ręczne manipulowanie okresem istnienia obiektu. Tylko programy, które <xref:System.Runtime.InteropServices.Marshal.AddRef%2A?displayProperty=nameWithType> wywołują <xref:System.Runtime.InteropServices.Marshal.Release%2A>, powinny wywołać. Wywoływanie <xref:System.Runtime.InteropServices.Marshal.Release%2A> po osiągnięciu przez licznik odwołań wartości zero powoduje niezdefiniowane zachowanie.  
  
 Można wywołać <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>lub <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> [](https://go.microsoft.com/fwlink/?LinkId=148003) , aby uzyskać wartośćreprezentującą<xref:System.IntPtr> wskaźnik interfejsu IUnknown do wydania. Można również użyć tych metod i <xref:System.Runtime.InteropServices.Marshal.Release%2A> metody obiektów zarządzanych do zwolnienia interfejsów com reprezentowanych przez wywoływaną otokę [com](~/docs/framework/interop/com-callable-wrapper.md)obiektu zarządzanego.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób pobierania `IUnknown` interfejsu dla obiektu zarządzanego <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> przy użyciu metody. Przykład następnie zwalnia wskaźnik interfejsu przez wywołanie <xref:System.Runtime.InteropServices.Marshal.Release%2A> metody.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseComObject">
      <MemberSignature Language="C#" Value="public static int ReleaseComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReleaseComObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReleaseComObject (o As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReleaseComObject(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member ReleaseComObject : obj -&gt; int" Usage="System.Runtime.InteropServices.Marshal.ReleaseComObject o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Obiekt COM do zwolnienia.</param>
        <summary>Zmniejsza liczbę odwołań otoki wywoływanych przez [środowisko uruchomieniowe](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) skojarzonych z określonym obiektem com.</summary>
        <returns>Nowa wartość liczby odwołań otoki RCW skojarzonej z <paramref name="o" />. Ta wartość jest zwykle równa zero, ponieważ OTOKa utrzymuje tylko jedno odwołanie do zapakowanego obiektu COM, niezależnie od liczby klientów zarządzanych wywołujących ją.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do jawnej kontroli okresu istnienia obiektu COM używanego z kodu zarządzanego. Tej metody należy użyć do zwolnienia bazowego obiektu COM, który przechowuje odwołania do zasobów w odpowiednim czasie lub gdy obiekty muszą być zwolnione w określonej kolejności.  
  
 Za każdym razem, gdy wskaźnik interfejsu COM przechodzi do środowiska uruchomieniowego języka wspólnego (CLR), jest opakowany w otokę RCW.  
  
 Otoka RCW ma licznik odwołań, który jest zwiększany za każdym razem, gdy wskaźnik interfejsu COM jest mapowany na go. <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> Metoda zmniejsza liczbę odwołań otoki RCW. Gdy liczba odwołań osiągnie wartość zero, środowisko uruchomieniowe zwolni wszystkie odwołania do niezarządzanego obiektu com i zgłosi <xref:System.NullReferenceException?displayProperty=nameWithType> Jeśli spróbujesz użyć obiektu. Jeśli ten sam interfejs com przeszedł więcej niż jeden raz z niezarządzanego do kodu zarządzanego, liczba odwołań dla otoki jest zwiększana za każdym razem, <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> a wywołanie zwraca liczbę pozostałych odwołań.  
  
 Ta metoda pozwala wymusić wymuszanie wersji referencyjnej OTOKi, tak aby była dokładnie wykonywana, gdy chcesz. Jednak nieprawidłowe użycie programu <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> może spowodować niepowodzenie działania aplikacji lub spowodować naruszenie zasad dostępu.  
  
 Rozważmy scenariusz, w którym kod zarządzany w domenie aplikacji znajduje się na otoki RCW, która reprezentuje składnik COM. W przypadku wywołania <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> metody dla otoki RCW kod zarządzany nie będzie mógł uzyskać dostępu do otoki RCW i spowoduje <xref:System.Runtime.InteropServices.InvalidComObjectException> wystąpienie wyjątku.  
  
 Może wystąpić bardziej poważny błąd, jeśli wywołanie OTOKi jest wykonywane po wydaniu OTOKi. W takim przypadku istnieje dobry szansa, że wątek wywołujący wywołanie spowoduje naruszenie zasad dostępu. Jednak pamięć procesu może ulec uszkodzeniu, a proces może nadal działać do momentu, gdy nie powiedzie się to z przyczyn, które są bardzo trudne do debugowania.  
  
 To ryzyko jest złożone, gdy używany składnik COM jest pojedyncza, z następującej przyczyny: Środowisko CLR aktywuje składniki COM przez wywołanie funkcji [CoCreateInstance](https://go.microsoft.com/fwlink/?LinkID=142894) języka com, która zwraca ten sam wskaźnik interfejsu za każdym razem, gdy jest wywoływana dla pojedynczych składników modelu com. W ten sposób oddzielne i niezależne fragmenty kodu zarządzanego w domenie aplikacji mogą używać tej samej otoki dla pojedynczego składnika com, a jeśli jedna wywołuje <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> metodę w składniku com, drugi zostanie przerwany.  
  
 Z <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> tego względu należy użyć tylko wtedy, gdy jest to absolutnie wymagane. Jeśli chcesz wywołać tę metodę, aby upewnić się, że składnik com jest wydawany w określonym czasie, rozważ <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> użycie metody zamiast. <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A>spowoduje zwolnienie bazowego składnika COM niezależnie od tego, ile razy ponownie wprowadzono środowisko CLR. Wewnętrzna liczba odwołań dla otoki RCW jest zwiększana o jeden po każdym ponownym wprowadzeniu środowiska CLR przez składnik COM. W związku z tym, można <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> wywołać metodę w pętli do momentu zwrócenia wartości zero. Osiąga to ten sam wynik, co <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> Metoda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="o" />nie jest prawidłowym obiektem COM.</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="o" />jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)" />
        <altmember cref="T:System.NullReferenceException" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseThreadCache">
      <MemberSignature Language="C#" Value="public static void ReleaseThreadCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReleaseThreadCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReleaseThreadCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReleaseThreadCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReleaseThreadCache();" />
      <MemberSignature Language="F#" Value="static member ReleaseThreadCache : unit -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.ReleaseThreadCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This API did not perform any operation and will be removed in future versions of the CLR.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia pamięć podręczną wątków.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToBSTR (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToBSTR(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToBSTR (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToBSTR(System::Security::SecureString ^ s);" />
      <MemberSignature Language="F#" Value="static member SecureStringToBSTR : System.Security.SecureString -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.SecureStringToBSTR s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">Zarządzany obiekt do skopiowania.</param>
        <summary>Przydziela niezarządzany [ciąg binarny (BSTR)](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx) i kopiuje do niego zawartość obiektu <see cref="T:System.Security.SecureString" /> zarządzanego.</summary>
        <returns>Adres, w pamięci niezarządzanej, gdzie <paramref name="s" /> parametr został skopiowany do, lub 0, jeśli podano obiekt o wartości null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A> Metoda jest przydatna w przypadku organizowania niestandardowego lub podczas mieszania kodu zarządzanego i niezarządzanego. Ponieważ ta metoda przydziela niezarządzaną pamięć wymaganą dla ciągu, zawsze zwalniaj `BSTR` po zakończeniu przez <xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A> wywołanie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="s" /></exception>
        <exception cref="T:System.NotSupportedException">Na bieżącym komputerze nie jest uruchomiony system Windows 2000 z dodatkiem Service Pack 3 lub nowszym.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało dostępnej pamięci.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <block subset="none" type="usage"><para>Ta metoda jest obsługiwana tylko na komputerach z systemem Windows 2000 z dodatkiem Service Pack 3 lub nowszym.</para></block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToCoTaskMemAnsi (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToCoTaskMemAnsi(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToCoTaskMemAnsi (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToCoTaskMemAnsi(System::Security::SecureString ^ s);" />
      <MemberSignature Language="F#" Value="static member SecureStringToCoTaskMemAnsi : System.Security.SecureString -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">Zarządzany obiekt do skopiowania.</param>
        <summary>Kopiuje zawartość obiektu zarządzanego <see cref="T:System.Security.SecureString" /> do bloku pamięci przydzieloną z niezarządzanego alokatora zadań com.</summary>
        <returns>Adres, w pamięci niezarządzanej, gdzie <paramref name="s" /> parametr został skopiowany do, lub 0, jeśli podano obiekt o wartości null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> Metoda jest przydatna w przypadku organizowania niestandardowego lub podczas mieszania kodu zarządzanego i niezarządzanego. Ponieważ ta metoda przydziela niezarządzaną pamięć wymaganą dla ciągu, program zawsze zwalnia pamięć, wywołując <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A>metodę. Znaki ciągu są kopiowane jako znaki ANSI.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> metody do organizowania i odszyfrowywania zawartości <xref:System.Security.SecureString> obiektu w bloku pamięci niezarządzanej. Następnie używa <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> metody do zerowania i usuwania niezarządzanego bloku.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="s" /></exception>
        <exception cref="T:System.NotSupportedException">Na bieżącym komputerze nie jest uruchomiony system Windows 2000 z dodatkiem Service Pack 3 lub nowszym.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało dostępnej pamięci.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <block subset="none" type="usage"><para>Ta metoda jest obsługiwana tylko na komputerach z systemem Windows 2000 z dodatkiem Service Pack 3 lub nowszym.</para></block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToCoTaskMemUnicode">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToCoTaskMemUnicode (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToCoTaskMemUnicode(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToCoTaskMemUnicode (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToCoTaskMemUnicode(System::Security::SecureString ^ s);" />
      <MemberSignature Language="F#" Value="static member SecureStringToCoTaskMemUnicode : System.Security.SecureString -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">Zarządzany obiekt do skopiowania.</param>
        <summary>Kopiuje zawartość obiektu zarządzanego <see cref="T:System.Security.SecureString" /> do bloku pamięci przydzieloną z niezarządzanego alokatora zadań com.</summary>
        <returns>Adres, w pamięci niezarządzanej, gdzie <paramref name="s" /> parametr został skopiowany do, lub 0, jeśli podano obiekt o wartości null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> Metoda jest przydatna w przypadku organizowania niestandardowego lub podczas mieszania kodu zarządzanego i niezarządzanego. Ponieważ ta metoda przydziela niezarządzaną pamięć wymaganą dla ciągu, program zawsze zwalnia pamięć, wywołując <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> metodę. Znaki ciągu są kopiowane jako znaki Unicode.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> metody do organizowania i odszyfrowywania zawartości <xref:System.Security.SecureString> obiektu w bloku pamięci niezarządzanej. Następnie używa <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> metody do zerowania i usuwania niezarządzanego bloku.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="s" /></exception>
        <exception cref="T:System.NotSupportedException">Na bieżącym komputerze nie jest uruchomiony system Windows 2000 z dodatkiem Service Pack 3 lub nowszym.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało dostępnej pamięci.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <block subset="none" type="usage"><para>Ta metoda jest obsługiwana tylko na komputerach z systemem Windows 2000 z dodatkiem Service Pack 3 lub nowszym.</para></block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToGlobalAllocAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToGlobalAllocAnsi (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToGlobalAllocAnsi(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToGlobalAllocAnsi (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToGlobalAllocAnsi(System::Security::SecureString ^ s);" />
      <MemberSignature Language="F#" Value="static member SecureStringToGlobalAllocAnsi : System.Security.SecureString -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">Zarządzany obiekt do skopiowania.</param>
        <summary>Kopiuje zawartość zarządzanego <see cref="T:System.Security.SecureString" /> do pamięci niezarządzanej, konwertując do formatu ANSI w miarę jego kopiowania.</summary>
        <returns>Adres, w pamięci niezarządzanej, do lokalizacji <paramref name="s" /> , w której został skopiowany parametr, lub 0, jeśli podano obiekt o wartości null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> Metoda jest przydatna w przypadku organizowania niestandardowego lub podczas mieszania kodu zarządzanego i niezarządzanego. Ponieważ ta metoda przydziela niezarządzaną pamięć wymaganą dla ciągu, program zawsze zwalnia pamięć, wywołując <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> metodę.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> metody do organizowania i odszyfrowywania zawartości <xref:System.Security.SecureString> obiektu w bloku pamięci niezarządzanej. Następnie używa <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> metody do zerowania i usuwania niezarządzanego bloku.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="s" /></exception>
        <exception cref="T:System.NotSupportedException">Na bieżącym komputerze nie jest uruchomiony system Windows 2000 z dodatkiem Service Pack 3 lub nowszym.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało dostępnej pamięci.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <block subset="none" type="usage"><para>Ta metoda jest obsługiwana tylko na komputerach z systemem Windows 2000 z dodatkiem Service Pack 3 lub nowszym.</para></block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToGlobalAllocUnicode">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToGlobalAllocUnicode (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToGlobalAllocUnicode(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToGlobalAllocUnicode (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToGlobalAllocUnicode(System::Security::SecureString ^ s);" />
      <MemberSignature Language="F#" Value="static member SecureStringToGlobalAllocUnicode : System.Security.SecureString -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">Zarządzany obiekt do skopiowania.</param>
        <summary>Kopiuje zawartość obiektu zarządzanego <see cref="T:System.Security.SecureString" /> do pamięci niezarządzanej.</summary>
        <returns>Adres, w pamięci niezarządzanej, <paramref name="s" /> gdzie został skopiowany, lub 0 <paramref name="s" /> , <see cref="T:System.Security.SecureString" /> jeśli jest obiektem, którego długość wynosi 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> Metoda jest przydatna do organizowania niestandardowego lub do użycia podczas mieszania kodu zarządzanego i niezarządzanego. Ponieważ ta metoda przydziela niezarządzaną pamięć wymaganą dla ciągu, program zawsze zwalnia pamięć, wywołując <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> metodę.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> metody z niezarządzaną `LogonUser` funkcją <xref:System.Security.SecureString> do wykonania personifikacji z klasą. W przykładzie zostanie użyta <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> Metoda wyzerowania i zwolnienia niezarządzanego odwołania do ciągu.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="s" /></exception>
        <exception cref="T:System.NotSupportedException">Na bieżącym komputerze nie jest uruchomiony system Windows 2000 z dodatkiem Service Pack 3 lub nowszym.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało dostępnej pamięci.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <block subset="none" type="usage"><para>Ta metoda jest obsługiwana tylko na komputerach z systemem Windows 2000 z dodatkiem Service Pack 3 lub nowszym.</para></block>
      </Docs>
    </Member>
    <Member MemberName="SetComObjectData">
      <MemberSignature Language="C#" Value="public static bool SetComObjectData (object obj, object key, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetComObjectData(object obj, object key, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetComObjectData (obj As Object, key As Object, data As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetComObjectData(System::Object ^ obj, System::Object ^ key, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member SetComObjectData : obj * obj * obj -&gt; bool" Usage="System.Runtime.InteropServices.Marshal.SetComObjectData (obj, key, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="key" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="data" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt COM, w którym mają być przechowywane dane.</param>
        <param name="key">Klucz w wewnętrznej tabeli skrótów obiektu COM, w którym mają być przechowywane dane.</param>
        <param name="data">Dane, które mają zostać ustawione.</param>
        <summary>Ustawia dane, do których odwołuje się określony klucz w określonym obiekcie COM.</summary>
        <returns><see langword="true" />Jeśli dane zostały ustawione pomyślnie; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie obiekty com otoczone otoką (RCW) w [czasie wykonywania](~/docs/framework/interop/runtime-callable-wrapper.md) mają skojarzoną tabelę skrótów, do <xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A> której dodawane są dane. <xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A?displayProperty=nameWithType>Pobiera dane z tabeli skrótów. Nigdy nie należy wywoływać żadnej metody z kodu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="key" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="obj" />nie jest obiektem COM.  
  
—lub— 
 <paramref name="obj" />[!INCLUDE[wrt](~/includes/wrt-md.md)] jest obiektem.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SizeOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca niezarządzany rozmiar klasy w bajtach.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SizeOf">
      <MemberSignature Language="C#" Value="public static int SizeOf (object structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf(object structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf (structure As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int SizeOf(System::Object ^ structure);" />
      <MemberSignature Language="F#" Value="static member SizeOf : obj -&gt; int" Usage="System.Runtime.InteropServices.Marshal.SizeOf structure" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;dotnet-uwp-10.0">
          <AttributeName>System.Obsolete("SizeOf(Object) may be unavailable in future releases. Instead, use SizeOf&lt;T&gt;(). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296514")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="structure" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="structure">Obiekt, którego rozmiar ma zostać zwrócony.</param>
        <summary>Zwraca niezarządzany rozmiar obiektu w bajtach.</summary>
        <returns>Rozmiar określonego obiektu w kodzie niezarządzanym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda akceptuje wystąpienie struktury, które może być typem referencyjnym lub opakowanym typem wartościowym. Układ musi być sekwencyjny lub jawny.  
  
 Zwrócony rozmiar jest rozmiarem niezarządzanego obiektu. Rozmiary niezarządzanych i zarządzanych obiektów mogą się różnić. W przypadku typów znaków rozmiar ma wpływ <xref:System.Runtime.InteropServices.CharSet> na wartość zastosowana do tej klasy.  
  
 Można użyć <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> metody, aby określić ilość pamięci niezarządzanej do przydzielenia <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> przy <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> użyciu metod i.  
  
   
  
## Examples  
 Poniższy przykład tworzy strukturę zarządzaną, przesyła ją do pamięci niezarządzanej, a następnie przesyła ją z powrotem do pamięci zarządzanej. W tym przykładzie zastosowano metodę, <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> aby określić ilość pamięci niezarządzanej do przydzielenia.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="structure" /></exception>
        <altmember cref="T:System.Runtime.InteropServices.CharSet" />
      </Docs>
    </Member>
    <Member MemberName="SizeOf">
      <MemberSignature Language="C#" Value="public static int SizeOf (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf (t As Type) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int SizeOf(Type ^ t);" />
      <MemberSignature Language="F#" Value="static member SizeOf : Type -&gt; int" Usage="System.Runtime.InteropServices.Marshal.SizeOf t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;dotnet-uwp-10.0">
          <AttributeName>System.Obsolete("SizeOf(Type) may be unavailable in future releases. Instead, use SizeOf&lt;T&gt;(). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296515")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">Typ, którego rozmiar ma zostać zwrócony.</param>
        <summary>Zwraca rozmiar niezarządzanego typu w bajtach.</summary>
        <returns>Rozmiar określonego typu w kodzie niezarządzanym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody można użyć, jeśli nie masz struktury. Układ musi być sekwencyjny lub jawny.  
  
 Zwrócony rozmiar jest rozmiarem niezarządzanego typu. Rozmiary niezarządzanych i zarządzanych obiektów mogą się różnić. W przypadku typów znaków rozmiar ma wpływ <xref:System.Runtime.InteropServices.CharSet> na wartość zastosowana do tej klasy.  
  
   
  
## Examples  
 Poniższy przykład demonstruje wywołanie <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> metody. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Runtime.InteropServices.Marshal> klasy.  
  
 [!code-cpp[Marshal#3](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#3)]
 [!code-csharp[Marshal#3](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#3)]
 [!code-vb[Marshal#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="t" /> Parametr jest definicją typu ogólnego.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="t" /></exception>
        <altmember cref="T:System.Runtime.InteropServices.CharSet" />
      </Docs>
    </Member>
    <Member MemberName="SizeOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SizeOf&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf(Of T) () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int SizeOf();" />
      <MemberSignature Language="F#" Value="static member SizeOf : unit -&gt; int" Usage="System.Runtime.InteropServices.Marshal.SizeOf " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Typ, którego rozmiar ma zostać zwrócony.</typeparam>
        <summary>[Obsługiwane w .NET Framework 4.5.1 i nowszych wersjach]  
  
 Zwraca rozmiar niezarządzanego typu w bajtach.</summary>
        <returns>Rozmiar (w bajtach) typu określonego przez <typeparamref name="T" /> parametr typu ogólnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody można użyć, jeśli nie masz struktury. Układ musi być sekwencyjny lub jawny.  
  
 Zwrócony rozmiar jest rozmiarem niezarządzanego typu. Rozmiary niezarządzanych i zarządzanych obiektów mogą się różnić. W przypadku typów znaków rozmiar ma wpływ <xref:System.Runtime.InteropServices.CharSet> na wartość zastosowana do tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SizeOf&lt;T&gt; (T structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf&lt;T&gt;(!!T structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf(Of T) (structure As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int SizeOf(T structure);" />
      <MemberSignature Language="F#" Value="static member SizeOf : 'T -&gt; int" Usage="System.Runtime.InteropServices.Marshal.SizeOf structure" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="structure" Type="T" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ <paramref name="structure" /> parametru.</typeparam>
        <param name="structure">Obiekt, którego rozmiar ma zostać zwrócony.</param>
        <summary>[Obsługiwane w .NET Framework 4.5.1 i nowszych wersjach]  
  
 Zwraca niezarządzany rozmiar obiektu określonego typu w bajtach.</summary>
        <returns>Rozmiar (w bajtach) określonego obiektu w kodzie niezarządzanym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda akceptuje wystąpienie struktury, które może być typem referencyjnym lub opakowanym typem wartościowym. Układ musi być sekwencyjny lub jawny.  
  
 Zwrócony rozmiar jest rozmiarem niezarządzanego obiektu. Rozmiary niezarządzanych i zarządzanych obiektów mogą się różnić. W przypadku typów znaków rozmiar ma wpływ <xref:System.Runtime.InteropServices.CharSet> na wartość zastosowana do tej klasy.  
  
 Można użyć <xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29> metody, aby określić ilość pamięci niezarządzanej do przydzielenia przy <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> użyciu <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> metod i.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="structure" /></exception>
      </Docs>
    </Member>
    <Member MemberName="StringToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr StringToBSTR (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToBSTR(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToBSTR (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToBSTR(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member StringToBSTR : string -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.StringToBSTR s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Zarządzany ciąg, który ma zostać skopiowany.</param>
        <summary>Przypisuje element [BSTR](https://msdn.microsoft.com/library/ms221069.aspx) i kopiuje do niego zawartość, która <see cref="T:System.String" /> jest w nim zarządzana.</summary>
        <returns>Niezarządzany wskaźnik do <see langword="BSTR" />, lub 0, <paramref name="s" /> Jeśli ma wartość null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A>jest przydatne w przypadku organizowania niestandardowego lub podczas mieszania kodu zarządzanego i niezarządzanego. Ponieważ ta metoda przydziela niezarządzaną pamięć wymaganą dla ciągu, zawsze zwalniaj `BSTR` po zakończeniu przez wywołanie <xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A?displayProperty=nameWithType>. Ta metoda zapewnia odwrotną funkcjonalność programu <xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Za mało dostępnej pamięci.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Długość elementu <paramref name="s" /> jest poza zakresem.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemAnsi (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemAnsi(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToCoTaskMemAnsi (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToCoTaskMemAnsi(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member StringToCoTaskMemAnsi : string -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Zarządzany ciąg, który ma zostać skopiowany.</param>
        <summary>Kopiuje zawartość zarządzanego <see cref="T:System.String" /> do bloku pamięci przydzieloną z niezarządzanego alokatora zadań com.</summary>
        <returns>Liczba całkowita reprezentująca wskaźnik do bloku pamięci przydzieloną dla ciągu lub 0 if <paramref name="s" /> is. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A>jest przydatne w przypadku organizowania niestandardowego lub podczas mieszania kodu zarządzanego i niezarządzanego. Ponieważ ta metoda przydziela niezarządzaną pamięć wymaganą dla ciągu, program zawsze zwalnia pamięć, wywołując <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>metodę. Ta metoda zapewnia odwrotną funkcjonalność programu <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>. Znaki ciągu są kopiowane jako znaki ANSI.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Za mało dostępnej pamięci.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="s" /> Parametr przekracza maksymalną dozwoloną długość systemu operacyjnego.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemAuto">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemAuto (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemAuto(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToCoTaskMemAuto (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToCoTaskMemAuto(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member StringToCoTaskMemAuto : string -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">Zarządzany ciąg, który ma zostać skopiowany.</param>
        <summary>Kopiuje zawartość zarządzanego <see cref="T:System.String" /> do bloku pamięci przydzieloną z niezarządzanego alokatora zadań com.</summary>
        <returns>Przydzielony blok pamięci lub 0 Jeśli <paramref name="s" /> jest. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A>jest przydatne do organizowania niestandardowego lub do użycia podczas mieszania kodu zarządzanego i niezarządzanego. Ponieważ ta metoda przydziela niezarządzaną pamięć wymaganą dla ciągu, program zawsze zwalnia pamięć, wywołując <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>metodę. Ta metoda zapewnia odwrotną funkcjonalność programu <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType>.  
  
 Znaki ciągu są kopiowane jako znaki ANSI lub Unicode, w zależności od systemu operacyjnego, w którym wykonywany jest kod. W systemie Windows 98 znaki są kopiowane jako znaki ANSI. W systemach Windows NT 4,0, Windows 2000, Windows XP i rodziny Windows Server 2003 znaki są kopiowane jako znaki Unicode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Za mało dostępnej pamięci.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Długość elementu <paramref name="s" /> jest poza zakresem.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemUni">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemUni (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemUni(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToCoTaskMemUni (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToCoTaskMemUni(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member StringToCoTaskMemUni : string -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Zarządzany ciąg, który ma zostać skopiowany.</param>
        <summary>Kopiuje zawartość zarządzanego <see cref="T:System.String" /> do bloku pamięci przydzieloną z niezarządzanego alokatora zadań com.</summary>
        <returns>Liczba całkowita reprezentująca wskaźnik do bloku pamięci przydzieloną dla ciągu lub 0, jeśli s ma <see langword="null" />wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A>jest przydatne do organizowania niestandardowego lub do użycia podczas mieszania kodu zarządzanego i niezarządzanego. Ponieważ ta metoda przydziela niezarządzaną pamięć wymaganą dla ciągu, program zawsze zwalnia pamięć, wywołując <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType>metodę. Ta metoda zapewnia odwrotną funkcjonalność programu <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType>. Znaki ciągu są kopiowane jako znaki Unicode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="s" /> Parametr przekracza maksymalną dozwoloną długość systemu operacyjnego.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało dostępnej pamięci.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemUTF8">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemUTF8 (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemUTF8(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUTF8(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToCoTaskMemUTF8 (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToCoTaskMemUTF8(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member StringToCoTaskMemUTF8 : string -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.StringToCoTaskMemUTF8 s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.1">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalAnsi (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalAnsi(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToHGlobalAnsi (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToHGlobalAnsi(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member StringToHGlobalAnsi : string -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Zarządzany ciąg, który ma zostać skopiowany.</param>
        <summary>Kopiuje zawartość zarządzanego <see cref="T:System.String" /> do pamięci niezarządzanej, konwertując do formatu ANSI w miarę jego kopiowania.</summary>
        <returns>Adres, w pamięci niezarządzanej, do <paramref name="s" /> lokalizacji, do której został skopiowany <paramref name="s" /> , <see langword="null" />lub 0, jeśli jest.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A>jest przydatne w przypadku organizowania niestandardowego lub podczas mieszania kodu zarządzanego i niezarządzanego. Ponieważ ta metoda przydziela niezarządzaną pamięć wymaganą dla ciągu, program zawsze zwalnia pamięć, wywołując <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>metodę. <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A>zapewnia odwrotną funkcjonalność programu <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>.  
  
 Ta metoda kopiuje osadzone znaki null i zawiera kończący znak null.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak przekonwertować zawartość klasy zarządzanej <xref:System.String> na niezarządzaną pamięć, a następnie usunąć niezarządzaną pamięć po zakończeniu.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/CPP/stringtohglobalansi.cpp#1)]
 [!code-csharp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/cs/stringtohglobalansi.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Za mało dostępnej pamięci.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="s" /> Parametr przekracza maksymalną dozwoloną długość systemu operacyjnego.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalAuto">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalAuto (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalAuto(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToHGlobalAuto (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToHGlobalAuto(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member StringToHGlobalAuto : string -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.StringToHGlobalAuto s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">Zarządzany ciąg, który ma zostać skopiowany.</param>
        <summary>Kopiuje zawartość zarządzaną <see cref="T:System.String" /> do pamięci niezarządzanej, w razie potrzeby, konwertując do formatu ANSI.</summary>
        <returns>Adres, w pamięci niezarządzanej, do lokalizacji, w której został skopiowany ciąg, <paramref name="s" /> lub <see langword="null" />0, jeśli jest.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A>jest przydatne do organizowania niestandardowego lub do użycia podczas mieszania kodu zarządzanego i niezarządzanego. Ponieważ ta metoda przydziela niezarządzaną pamięć wymaganą dla ciągu, program zawsze zwalnia pamięć, wywołując <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>metodę. Ta metoda zapewnia odwrotną funkcjonalność programu <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType>.  
  
 Ta metoda kopiuje osadzone znaki null i zawiera kończący znak null.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak przekonwertować zawartość klasy zarządzanej <xref:System.String> na niezarządzaną pamięć, a następnie usunąć niezarządzaną pamięć po zakończeniu.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.StringToHGlobalAuto#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAuto/CPP/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Za mało dostępnej pamięci.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalUni">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalUni (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalUni(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToHGlobalUni (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToHGlobalUni(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member StringToHGlobalUni : string -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.StringToHGlobalUni s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Zarządzany ciąg, który ma zostać skopiowany.</param>
        <summary>Kopiuje zawartość zarządzaną <see cref="T:System.String" /> w pamięci niezarządzanej.</summary>
        <returns>Adres, w pamięci niezarządzanej, do lokalizacji <paramref name="s" /> , do której został skopiowany, <paramref name="s" /> lub <see langword="null" />0, jeśli jest.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A>jest przydatne do organizowania niestandardowego lub do użycia podczas mieszania kodu zarządzanego i niezarządzanego. Ponieważ ta metoda przydziela niezarządzaną pamięć wymaganą dla ciągu, program zawsze zwalnia pamięć, wywołując <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>metodę. Ta metoda zapewnia odwrotną funkcjonalność programu <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType>.  
  
 Ta metoda kopiuje osadzone znaki null i zawiera kończący znak null.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Metoda nie może przydzielić wystarczającej ilości pamięci sterty natywnej.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="s" /> Parametr przekracza maksymalną dozwoloną długość systemu operacyjnego.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StructureToPtr">
      <MemberSignature Language="C#" Value="public static void StructureToPtr (object structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void StructureToPtr(object structure, native int ptr, bool fDeleteOld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub StructureToPtr (structure As Object, ptr As IntPtr, fDeleteOld As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void StructureToPtr(System::Object ^ structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberSignature Language="F#" Value="static member StructureToPtr : obj * nativeint * bool -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.StructureToPtr (structure, ptr, fDeleteOld)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;dotnet-uwp-10.0">
          <AttributeName>System.Obsolete("StructureToPtr(Object, IntPtr, Boolean) may be unavailable in future releases. Instead, use StructureToPtr&lt;T&gt;(T, IntPtr, Boolean). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296516")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="structure" Type="System.Object" />
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="fDeleteOld" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="structure">Obiekt zarządzany, który przechowuje dane, które mają być organizowane. Ten obiekt musi być strukturą lub wystąpieniem sformatowanej klasy.</param>
        <param name="ptr">Wskaźnik do niezarządzanego bloku pamięci, który musi zostać przydzielony przed wywołaniem tej metody.</param>
        <param name="fDeleteOld"><see langword="true" />Aby wywołać <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" /> metodę <paramref name="ptr" /> na parametrze przed skopiowaniem danych przez tę metodę. Blok musi zawierać prawidłowe dane. Należy zauważyć, <see langword="false" /> że przekazywanie, gdy blok pamięci zawiera już dane, może prowadzić do przecieku pamięci.</param>
        <summary>Kierowanie danych z zarządzanego obiektu do niezarządzanego bloku pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `structure` jest typem wartości, może być opakowany lub nieopakowany. Jeśli jest opakowany, nie jest opakowany przed kopiowaniem.  
  
 Sformatowana Klasa jest typem referencyjnym, którego układ jest określony przez <xref:System.Runtime.InteropServices.StructLayoutAttribute> atrybut, <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> lub <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>.  
  
 <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A>Kopiuje zawartość `structure` do wstępnie przydzielonych bloków pamięci `ptr` , do której wskazuje parametr. Jeśli `structure` zawiera typy odwołań, które są organizowane do wskaźników interfejsu COM (interfejsy, klasy bez układu <xref:System.Object?displayProperty=nameWithType>i), zarządzane obiekty są utrzymywane z użyciem liczby odwołań. Wszystkie inne typy odwołań (na przykład ciągi i tablice) są organizowane do kopiowania. Aby zwolnić te obiekty zarządzane lub niezarządzane, należy wywołać <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A?displayProperty=nameWithType> metodę przed zwolnieniem bloku pamięci.  
  
 Jeśli używasz <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> metody do kopiowania innego wystąpienia do bloku pamięci w późniejszym czasie, `fDeleteOld` Określ `true` , aby usunąć liczby odwołań dla typów odwołań w poprzednim wystąpieniu. W przeciwnym razie zarządzane typy odwołań i niezarządzane kopie są skutecznie wyciekami.  
  
 Ogólny wzorzec korzystania <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> z programu jest następujący:  
  
1.  Na pierwszym wywołaniu <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> metody po `fDeleteOld` przydzieleniu bloku pamięci musi być `false`, ponieważ nie ma zawartości do wyczyszczenia.  
  
    > [!IMPORTANT]
    >  Określ `true`tylko,jeśli blokzawieraprawidłowedane.`fDeleteOld`  
  
2.  Jeśli skopiujesz inne wystąpienie do bloku pamięci, a obiekt zawiera typy odwołań, `fDeleteOld` w starej zawartości musi być możliwe `true` zwolnienie typów odwołań.  
  
3.  Jeśli obiekt zawiera typy odwołań, należy wywołać <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> metodę przed zwolnieniem bloku pamięci.  
  
> [!NOTE]
>  Aby przypiąć istniejącą strukturę zamiast kopiowania, użyj <xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType> typu, aby utworzyć przypięty uchwyt dla struktury. Aby uzyskać szczegółowe informacje na temat sposobu przypinania, zobacz [kopiowanie i Przypinanie](~/docs/framework/interop/copying-and-pinning.md).  
  
   
  
## Examples  
 Poniższy przykład tworzy strukturę zarządzaną, przenosi ją do pamięci niezarządzanej przy <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> użyciu metody, a następnie przesyła ją z powrotem do pamięci zarządzanej <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> przy użyciu metody.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="structure" />jest typem referencyjnym, który nie jest sformatowaną klasą.  
  
—lub— 
 <paramref name="structure" />jest wystąpieniem typu ogólnego (tylko w .NET Framework 4,5 i wcześniejszych wersjach).</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.GCHandle" />
      </Docs>
    </Member>
    <Member MemberName="StructureToPtr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void StructureToPtr&lt;T&gt; (T structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void StructureToPtr&lt;T&gt;(!!T structure, native int ptr, bool fDeleteOld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub StructureToPtr(Of T) (structure As T, ptr As IntPtr, fDeleteOld As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void StructureToPtr(T structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberSignature Language="F#" Value="static member StructureToPtr : 'T * nativeint * bool -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.StructureToPtr (structure, ptr, fDeleteOld)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="structure" Type="T" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ptr" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="fDeleteOld" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ zarządzanego obiektu.</typeparam>
        <param name="structure">Obiekt zarządzany, który przechowuje dane, które mają być organizowane. Obiekt musi być strukturą lub wystąpieniem sformatowanej klasy.</param>
        <param name="ptr">Wskaźnik do niezarządzanego bloku pamięci, który musi zostać przydzielony przed wywołaniem tej metody.</param>
        <param name="fDeleteOld"><see langword="true" />Aby wywołać <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" /> metodę <paramref name="ptr" /> na parametrze przed skopiowaniem danych przez tę metodę. Blok musi zawierać prawidłowe dane. Należy zauważyć, <see langword="false" /> że przekazywanie, gdy blok pamięci zawiera już dane, może prowadzić do przecieku pamięci.</param>
        <summary>[Obsługiwane w .NET Framework 4.5.1 i nowszych wersjach]  
  
 Kierowanie danych z zarządzanego obiektu określonego typu do niezarządzanego bloku pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sformatowana Klasa jest typem referencyjnym, którego układ jest określony przez <xref:System.Runtime.InteropServices.StructLayoutAttribute> atrybut, <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> lub <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>.  
  
 <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29>Kopiuje zawartość `structure` do wstępnie przydzielonych bloków pamięci `ptr` , do której wskazuje parametr. Jeśli `structure` zawiera typy odwołań, które są organizowane do wskaźników interfejsu COM (interfejsy, klasy bez układu <xref:System.Object?displayProperty=nameWithType>i), zarządzane obiekty są utrzymywane z użyciem liczby odwołań. Wszystkie inne typy odwołań (na przykład ciągi i tablice) są organizowane do kopiowania. Aby zwolnić te obiekty zarządzane lub niezarządzane, należy wywołać <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%60%601%28System.IntPtr%29> metodę przed zwolnieniem bloku pamięci.  
  
 Jeśli używasz <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> metody do kopiowania innego wystąpienia do bloku pamięci w późniejszym czasie, `fDeleteOld` Określ `true` , aby usunąć liczby odwołań dla typów odwołań w poprzednim wystąpieniu. W przeciwnym razie zarządzane typy odwołań i niezarządzane kopie są skutecznie wyciekami.  
  
 Ogólny wzorzec korzystania <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> z programu jest następujący:  
  
1.  Na pierwszym wywołaniu <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> metody po `fDeleteOld` przydzieleniu bloku pamięci musi być `false`, ponieważ nie ma zawartości do wyczyszczenia.  
  
    > [!IMPORTANT]
    >  Określ `true`tylko,jeśli blokzawieraprawidłowedane.`fDeleteOld`  
  
2.  Jeśli skopiujesz inne wystąpienie do bloku pamięci, a obiekt zawiera typy odwołań, `fDeleteOld` w starej zawartości musi być możliwe `true` zwolnienie typów odwołań.  
  
3.  Jeśli obiekt zawiera typy odwołań, należy wywołać <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> metodę przed zwolnieniem bloku pamięci.  
  
> [!NOTE]
>  Aby przypiąć istniejącą strukturę zamiast kopiowania, użyj <xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType> typu, aby utworzyć przypięty uchwyt dla struktury. Aby uzyskać szczegółowe informacje na temat sposobu przypinania, zobacz [kopiowanie i Przypinanie](~/docs/framework/interop/copying-and-pinning.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="structure" />jest typem referencyjnym, który nie jest sformatowaną klasą.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" />
        <altmember cref="T:System.Runtime.InteropServices.GCHandle" />
      </Docs>
    </Member>
    <Member MemberName="SystemDefaultCharSize">
      <MemberSignature Language="C#" Value="public static readonly int SystemDefaultCharSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 SystemDefaultCharSize" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SystemDefaultCharSize As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int SystemDefaultCharSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable SystemDefaultCharSize : int" Usage="System.Runtime.InteropServices.Marshal.SystemDefaultCharSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje domyślny rozmiar znaku w systemie; wartość domyślna to 2 dla systemów Unicode i 1 dla systemów ANSI. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize> pole. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Runtime.InteropServices.Marshal> klasy.  
  
 [!code-cpp[Marshal#2](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#2)]
 [!code-csharp[Marshal#2](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#2)]
 [!code-vb[Marshal#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SystemMaxDBCSCharSize">
      <MemberSignature Language="C#" Value="public static readonly int SystemMaxDBCSCharSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 SystemMaxDBCSCharSize" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SystemMaxDBCSCharSize As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int SystemMaxDBCSCharSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable SystemMaxDBCSCharSize : int" Usage="System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje maksymalny rozmiar (w bajtach) rozmiaru zestawu znaków dwubajtowych (DBCS) dla bieżącego systemu operacyjnego. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize> pole. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Runtime.InteropServices.Marshal> klasy.  
  
 [!code-cpp[Marshal#2](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#2)]
 [!code-csharp[Marshal#2](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#2)]
 [!code-vb[Marshal#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ThrowExceptionForHR">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zgłasza wyjątek z określoną wartością HRESULT błędu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThrowExceptionForHR">
      <MemberSignature Language="C#" Value="public static void ThrowExceptionForHR (int errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ThrowExceptionForHR(int32 errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ThrowExceptionForHR (errorCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ThrowExceptionForHR(int errorCode);" />
      <MemberSignature Language="F#" Value="static member ThrowExceptionForHR : int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.ThrowExceptionForHR errorCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="errorCode">WYNIK HRESULT odpowiadający żądanemu wyjątku.</param>
        <summary>Zgłasza wyjątek z określoną wartością HRESULT błędu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy obiekt wyjątku dla określonego błędu HRESULT. Jeśli HRESULT ma wartość 0 lub dodatni (kod sukcesu), metoda zwraca bez tworzenia lub zgłaszania wyjątku.  
  
 Należy zauważyć, <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%28System.Int32%29> że metoda zwraca wyjątek oparty na interfejsie [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) bieżącego wątku, jeśli został ustawiony. W `errorCode` takim przypadku parametr zostanie zignorowany.  
  
 Niektóre HRESULT o niepowodzeniu są mapowane na zdefiniowane wyjątki, a inne nie. Jeśli wynik HRESULT mapuje do zdefiniowanego wyjątku <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> , tworzy wystąpienie wyjątku i zgłasza go. W przeciwnym razie tworzy wystąpienie <xref:System.Runtime.InteropServices.COMException>, inicjuje pole kod błędu z wartością HRESULT i zgłasza ten wyjątek. Gdy <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> jest wywoływana, próbuje pobrać dodatkowe informacje dotyczące błędu za pomocą niezarządzanej funkcji [GetErrorInfo](https://msdn.microsoft.com/library/ms221032\(v=vs.85\).aspx) .  
  
 Aby uzyskać mapowanie z każdego HRESULT do jego porównywalnej klasy Exception w .NET Framework, zobacz [How to: Mapuj HRESULTs i Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).  
  
 <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> Czasami może zwrócić wyjątek z poprzedniego wywołania com. W takim przypadku można użyć poniższego obejścia i przekazać `IntPtr(-1)` jako drugi parametr (`errorInfo`):  
  
```  
[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]  
public static void ThrowExceptionForHR(interrorCode,IntPtrerrorInfo)  
```  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.InteropServices.COMException" />
      </Docs>
    </Member>
    <Member MemberName="ThrowExceptionForHR">
      <MemberSignature Language="C#" Value="public static void ThrowExceptionForHR (int errorCode, IntPtr errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ThrowExceptionForHR(int32 errorCode, native int errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ThrowExceptionForHR (errorCode As Integer, errorInfo As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ThrowExceptionForHR(int errorCode, IntPtr errorInfo);" />
      <MemberSignature Language="F#" Value="static member ThrowExceptionForHR : int * nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.ThrowExceptionForHR (errorCode, errorInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
        <Parameter Name="errorInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="errorCode">WYNIK HRESULT odpowiadający żądanemu wyjątku.</param>
        <param name="errorInfo">Wskaźnik do interfejsu [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) , który zawiera więcej informacji o błędzie. Można określić <c>IntPtr (0)</c> , aby użyć bieżącego interfejsu [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) lub <c>IntPtr (-1)</c> do ignorowania bieżącego interfejsu [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) i konstruowania wyjątku bezpośrednio od kodu błędu.</param>
        <summary>Zgłasza wyjątek z określonym błędem HRESULT, na podstawie określonego interfejsu <see href="https://msdn.microsoft.com/library/ms221233\(v=vs.85\">IErrorInfo</see>. aspx).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy obiekt wyjątku dla określonego błędu HRESULT. Jeśli HRESULT ma wartość 0 lub dodatni (kod sukcesu), metoda zwraca bez tworzenia lub zgłaszania wyjątku.  
  
 Metoda zwalnia parametr, zmniejszając liczbę odwołań com interfejsu [IErrorInfo.](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> `errorInfo`  
  
 Należy zauważyć, <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> że metoda zwraca wyjątek oparty na interfejsie [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) bieżącego wątku, jeśli został ustawiony. W `errorCode` takim przypadku parametr zostanie zignorowany.  
  
 Niektóre HRESULT o niepowodzeniu są mapowane na zdefiniowane wyjątki, a inne nie. Jeśli wynik HRESULT mapuje do zdefiniowanego wyjątku <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> , tworzy wystąpienie wyjątku i zgłasza go. W przeciwnym razie tworzy wystąpienie <xref:System.Runtime.InteropServices.COMException?displayProperty=nameWithType>, inicjuje pole kod błędu z wartością HRESULT i zgłasza ten wyjątek. Ten `errorInfo` parametr służy do pobierania dodatkowych informacji dotyczących błędu.  
  
 Aby uzyskać mapowanie z każdego HRESULT do jego porównywalnej klasy Exception w .NET Framework, zobacz [How to: Mapuj HRESULTs i Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.InteropServices.COMException" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeAddrOfPinnedArrayElement">
      <MemberSignature Language="C#" Value="public static IntPtr UnsafeAddrOfPinnedArrayElement (Array arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int UnsafeAddrOfPinnedArrayElement(class System.Array arr, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeAddrOfPinnedArrayElement (arr As Array, index As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr UnsafeAddrOfPinnedArrayElement(Array ^ arr, int index);" />
      <MemberSignature Language="F#" Value="static member UnsafeAddrOfPinnedArrayElement : Array * int -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement (arr, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;dotnet-uwp-10.0">
          <AttributeName>System.Obsolete("UnsafeAddrOfPinnedArrayElement(Array, Int32) may be unavailable in future releases. Instead, use UnsafeAddrOfPinnedArrayElement&lt;T&gt;(T[], Int32). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296517")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arr" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="arr">Tablica zawierająca żądany element.</param>
        <param name="index">Indeks w <paramref name="arr" /> parametrze żądanego elementu.</param>
        <summary>Pobiera adres elementu w określonym indeksie w określonej tablicy.</summary>
        <returns>Adres <paramref name="index" /> wewnątrz <paramref name="arr" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablica musi być przypięta przy <xref:System.Runtime.InteropServices.GCHandle> użyciu elementu przed przekazaniem do tej metody. W celu uzyskania maksymalnej wydajności ta metoda nie sprawdza poprawności przenoszonej tablicy; może to spowodować nieoczekiwane zachowanie.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.InteropServices.GCHandle" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeAddrOfPinnedArrayElement&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr UnsafeAddrOfPinnedArrayElement&lt;T&gt; (T[] arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int UnsafeAddrOfPinnedArrayElement&lt;T&gt;(!!T[] arr, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeAddrOfPinnedArrayElement(Of T) (arr As T(), index As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static IntPtr UnsafeAddrOfPinnedArrayElement(cli::array &lt;T&gt; ^ arr, int index);" />
      <MemberSignature Language="F#" Value="static member UnsafeAddrOfPinnedArrayElement : 'T[] * int -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement (arr, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arr" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ tablicy.</typeparam>
        <param name="arr">Tablica zawierająca żądany element.</param>
        <param name="index">Indeks żądanego elementu w <paramref name="arr" /> tablicy.</param>
        <summary>[Obsługiwane w .NET Framework 4.5.1 i nowszych wersjach]  
  
 Pobiera adres elementu pod określonym indeksem w tablicy określonego typu.</summary>
        <returns>Adres <paramref name="index" /> w <paramref name="arr" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablica musi być przypięta przy użyciu <xref:System.Runtime.InteropServices.GCHandle> elementu przed przekazaniem do tej metody. W celu uzyskania maksymalnej wydajności ta metoda nie sprawdza poprawności przenoszonej tablicy; może to spowodować nieoczekiwane zachowanie.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.InteropServices.GCHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteByte">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje wartość pojedynczego bajtu w pamięci niezarządzanej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (IntPtr ptr, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte(native int ptr, unsigned int8 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteByte (ptr As IntPtr, val As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteByte(IntPtr ptr, System::Byte val);" />
      <MemberSignature Language="F#" Value="static member WriteByte : nativeint * byte -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteByte (ptr, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres w pamięci niezarządzanej, w której ma zostać zapisany.</param>
        <param name="val">Wartość do zapisu.</param>
        <summary>Zapisuje wartość pojedynczego bajtu w pamięci niezarządzanej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A>Włącza bezpośrednią interakcję z niezarządzaną tablicą bajtów w stylu C, eliminując koszty kopiowania całej tablicy niezarządzanej (przy użyciu <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) do oddzielnej zarządzanej tablicy przed ustawieniem jej wartości elementów.  
  
   
  
## Examples  
 Poniższy przykład tworzy blok pamięci niezarządzanej, zapisuje bajty w pamięci niezarządzanej, odczytuje bajt z pamięci niezarządzanej, a następnie usuwa niezarządzaną pamięć.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><paramref name="ptr" />nie jest rozpoznawanym formatem.  
  
—lub— 
 <paramref name="ptr" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="ptr" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (IntPtr ptr, int ofs, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte(native int ptr, int32 ofs, unsigned int8 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteByte (ptr As IntPtr, ofs As Integer, val As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteByte(IntPtr ptr, int ofs, System::Byte val);" />
      <MemberSignature Language="F#" Value="static member WriteByte : nativeint * int * byte -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteByte (ptr, ofs, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres podstawowy w pamięci niezarządzanej, w której ma zostać zapisany.</param>
        <param name="ofs">Dodatkowe przesunięcie bajtowe, które jest dodawane do <paramref name="ptr" /> parametru przed zapisem.</param>
        <param name="val">Wartość do zapisu.</param>
        <summary>Zapisuje wartość pojedynczego bajtu w pamięci niezarządzanej w określonym przesunięciu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A>Włącza bezpośrednią interakcję z niezarządzaną tablicą bajtów w stylu C, eliminując koszty kopiowania całej tablicy niezarządzanej (przy użyciu <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) do oddzielnej zarządzanej tablicy przed ustawieniem jej wartości elementów.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób odczytu i zapisu do niezarządzanej tablicy przy użyciu <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> metod i. <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#3)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Adres podstawowy (<paramref name="ptr" />) i bajt przesunięcia<paramref name="ofs" />() tworzą wartość null lub nieprawidłowy adres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (object ptr, int ofs, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte([out] object ptr, int32 ofs, unsigned int8 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteByte (ptr As Object, ofs As Integer, val As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteByte(System::Object ^ ptr, int ofs, System::Byte val);" />
      <MemberSignature Language="F#" Value="static member WriteByte : obj * int * byte -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteByte (ptr, ofs, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("WriteByte(Object, Int32, Byte) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres podstawowy w niezarządzanej pamięci obiektu docelowego.</param>
        <param name="ofs">Dodatkowe przesunięcie bajtowe, które jest dodawane do <paramref name="ptr" /> parametru przed zapisem.</param>
        <param name="val">Wartość do zapisu.</param>
        <summary>Zapisuje wartość pojedynczego bajtu w pamięci niezarządzanej w określonym przesunięciu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A>Włącza bezpośrednią interakcję z niezarządzaną tablicą bajtów w stylu C, eliminując koszty kopiowania całej tablicy niezarządzanej (przy użyciu <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) do oddzielnej zarządzanej tablicy przed ustawieniem jej wartości elementów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Adres podstawowy (<paramref name="ptr" />) i bajt przesunięcia<paramref name="ofs" />() tworzą wartość null lub nieprawidłowy adres.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="ptr" /><see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> jest obiektem. Ta metoda nie akceptuje <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parametrów.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteInt16">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje 16-bitową liczbę całkowitą ze znakiem w pamięci niezarządzanej. Zapisywanie w niewyrównanych lokalizacjach pamięci jest obsługiwane.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, char val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As IntPtr, val As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(IntPtr ptr, char val);" />
      <MemberSignature Language="F#" Value="static member WriteInt16 : nativeint * char -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteInt16 (ptr, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres w pamięci niezarządzanej, w której ma zostać zapisany.</param>
        <param name="val">Wartość do zapisu.</param>
        <summary>Zapisuje znak jako 16-bitową liczbę całkowitą do niezarządzanej pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>Włącza bezpośrednią interakcję z niezarządzaną 16-bitową tablicą podpisaną, eliminując koszty kopiowania całej tablicy <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>niezarządzanej (przy użyciu) do oddzielnej zarządzanej tablicy przed ustawieniem jej wartości elementów.  
  
 Zapisywanie w niewyrównanych lokalizacjach pamięci jest obsługiwane.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób odczytu i zapisu do niezarządzanej tablicy przy użyciu <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> metod i. <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><paramref name="ptr" />nie jest rozpoznawanym formatem.  
  
—lub— 
 <paramref name="ptr" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="ptr" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int16 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As IntPtr, val As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(IntPtr ptr, short val);" />
      <MemberSignature Language="F#" Value="static member WriteInt16 : nativeint * int16 -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteInt16 (ptr, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres w pamięci niezarządzanej, w której ma zostać zapisany.</param>
        <param name="val">Wartość do zapisu.</param>
        <summary>Zapisuje 16-bitową wartość całkowitą do pamięci niezarządzanej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>Włącza bezpośrednią interakcję z niezarządzaną 16-bitową tablicą podpisaną, eliminując koszty kopiowania całej tablicy <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>niezarządzanej (przy użyciu) do oddzielnej zarządzanej tablicy przed ustawieniem jej wartości elementów.  
  
 Zapisywanie w niewyrównanych lokalizacjach pamięci jest obsługiwane.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób odczytu i zapisu do niezarządzanej tablicy przy użyciu <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> metod i. <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><paramref name="ptr" />nie jest rozpoznawanym formatem.  
  
—lub— 
 <paramref name="ptr" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="ptr" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, int ofs, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int32 ofs, char val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As IntPtr, ofs As Integer, val As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(IntPtr ptr, int ofs, char val);" />
      <MemberSignature Language="F#" Value="static member WriteInt16 : nativeint * int * char -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteInt16 (ptr, ofs, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres podstawowy w stercie natywnym, w którym ma zostać zapisany.</param>
        <param name="ofs">Dodatkowe przesunięcie bajtowe, które jest dodawane do <paramref name="ptr" /> parametru przed zapisem.</param>
        <param name="val">Wartość do zapisu.</param>
        <summary>Zapisuje 16-bitową liczbę całkowitą ze znakiem do pamięci niezarządzanej w określonym przesunięciu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>Włącza bezpośrednią interakcję z niezarządzaną 16-bitową tablicą podpisaną, eliminując koszty kopiowania całej tablicy <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>niezarządzanej (przy użyciu) do oddzielnej zarządzanej tablicy przed ustawieniem jej wartości elementów.  
  
 Zapisywanie w niewyrównanych lokalizacjach pamięci jest obsługiwane.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób odczytu i zapisu do niezarządzanej tablicy przy użyciu <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> metod i. <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Adres podstawowy (<paramref name="ptr" />) i bajt przesunięcia<paramref name="ofs" />() tworzą wartość null lub nieprawidłowy adres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, int ofs, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int32 ofs, int16 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As IntPtr, ofs As Integer, val As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(IntPtr ptr, int ofs, short val);" />
      <MemberSignature Language="F#" Value="static member WriteInt16 : nativeint * int * int16 -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteInt16 (ptr, ofs, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres podstawowy w pamięci niezarządzanej, w której ma zostać zapisany.</param>
        <param name="ofs">Dodatkowe przesunięcie bajtowe, które jest dodawane do <paramref name="ptr" /> parametru przed zapisem.</param>
        <param name="val">Wartość do zapisu.</param>
        <summary>Zapisuje 16-bitową liczbę całkowitą ze znakiem w niezarządzanej pamięci w określonym przesunięciu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>Włącza bezpośrednią interakcję z niezarządzaną 16-bitową tablicą podpisaną, eliminując koszty kopiowania całej tablicy <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>niezarządzanej (przy użyciu) do oddzielnej zarządzanej tablicy przed ustawieniem jej wartości elementów.  
  
 Zapisywanie w niewyrównanych lokalizacjach pamięci jest obsługiwane.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób odczytu i zapisu do niezarządzanej tablicy przy użyciu <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> metod i. <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Adres podstawowy (<paramref name="ptr" />) i bajt przesunięcia<paramref name="ofs" />() tworzą wartość null lub nieprawidłowy adres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (object ptr, int ofs, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16([out] object ptr, int32 ofs, char val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As Object, ofs As Integer, val As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(System::Object ^ ptr, int ofs, char val);" />
      <MemberSignature Language="F#" Value="static member WriteInt16 : obj * int * char -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteInt16 (ptr, ofs, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("WriteInt16(Object, Int32, Char) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres podstawowy w niezarządzanej pamięci obiektu docelowego.</param>
        <param name="ofs">Dodatkowe przesunięcie bajtowe, które jest dodawane do <paramref name="ptr" /> parametru przed zapisem.</param>
        <param name="val">Wartość do zapisu.</param>
        <summary>Zapisuje 16-bitową liczbę całkowitą ze znakiem do pamięci niezarządzanej w określonym przesunięciu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>Włącza bezpośrednią interakcję z niezarządzaną 16-bitową tablicą podpisaną, eliminując koszty kopiowania całej tablicy <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>niezarządzanej (przy użyciu) do oddzielnej zarządzanej tablicy przed ustawieniem jej wartości elementów.  
  
 Zapisywanie w niewyrównanych lokalizacjach pamięci jest obsługiwane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Adres podstawowy (<paramref name="ptr" />) i bajt przesunięcia<paramref name="ofs" />() tworzą wartość null lub nieprawidłowy adres.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="ptr" /><see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> jest obiektem. Ta metoda nie akceptuje <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parametrów.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (object ptr, int ofs, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16([out] object ptr, int32 ofs, int16 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As Object, ofs As Integer, val As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(System::Object ^ ptr, int ofs, short val);" />
      <MemberSignature Language="F#" Value="static member WriteInt16 : obj * int * int16 -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteInt16 (ptr, ofs, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("WriteInt16(Object, Int32, Int16) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres podstawowy w niezarządzanej pamięci obiektu docelowego.</param>
        <param name="ofs">Dodatkowe przesunięcie bajtowe, które jest dodawane do <paramref name="ptr" /> parametru przed zapisem.</param>
        <param name="val">Wartość do zapisu.</param>
        <summary>Zapisuje 16-bitową liczbę całkowitą ze znakiem do pamięci niezarządzanej w określonym przesunięciu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>Włącza bezpośrednią interakcję z niezarządzaną 16-bitową tablicą podpisaną, eliminując koszty kopiowania całej tablicy <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>niezarządzanej (przy użyciu) do oddzielnej zarządzanej tablicy przed ustawieniem jej wartości elementów.  
  
 Zapisywanie w niewyrównanych lokalizacjach pamięci jest obsługiwane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Adres podstawowy (<paramref name="ptr" />) i bajt przesunięcia<paramref name="ofs" />() tworzą wartość null lub nieprawidłowy adres.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="ptr" /><see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> jest obiektem. Ta metoda nie akceptuje <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parametrów.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteInt32">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje 32-bitową liczbę całkowitą ze znakiem do pamięci niezarządzanej. Zapisywanie w niewyrównanych lokalizacjach pamięci jest obsługiwane.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (IntPtr ptr, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32(native int ptr, int32 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32 (ptr As IntPtr, val As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32(IntPtr ptr, int val);" />
      <MemberSignature Language="F#" Value="static member WriteInt32 : nativeint * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteInt32 (ptr, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres w pamięci niezarządzanej, w której ma zostać zapisany.</param>
        <param name="val">Wartość do zapisu.</param>
        <summary>Zapisuje 32-bitową liczbę całkowitą ze znakiem do pamięci niezarządzanej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A>Włącza bezpośrednią interakcję z niezarządzaną, 32 bitową tablicą, eliminując koszty kopiowania całej tablicy niezarządzanej (przy użyciu <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) do oddzielnej zarządzanej tablicy przed ustawieniem jej wartości elementów.  
  
 Zapisywanie w niewyrównanych lokalizacjach pamięci jest obsługiwane.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób odczytu i zapisu do niezarządzanej tablicy przy użyciu <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> metod i. <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><paramref name="ptr" />nie jest rozpoznawanym formatem.  
  
—lub— 
 <paramref name="ptr" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="ptr" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (IntPtr ptr, int ofs, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32(native int ptr, int32 ofs, int32 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32 (ptr As IntPtr, ofs As Integer, val As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32(IntPtr ptr, int ofs, int val);" />
      <MemberSignature Language="F#" Value="static member WriteInt32 : nativeint * int * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteInt32 (ptr, ofs, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres podstawowy w pamięci niezarządzanej, w której ma zostać zapisany.</param>
        <param name="ofs">Dodatkowe przesunięcie bajtowe, które jest dodawane do <paramref name="ptr" /> parametru przed zapisem.</param>
        <param name="val">Wartość do zapisu.</param>
        <summary>Zapisuje 32-bitową liczbę całkowitą ze znakiem w niezarządzanej pamięci w określonym przesunięciu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A>Włącza bezpośrednią interakcję z niezarządzaną, 32 bitową tablicą, eliminując koszty kopiowania całej tablicy niezarządzanej (przy użyciu <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) do oddzielnej zarządzanej tablicy przed ustawieniem jej wartości elementów.  
  
 Zapisywanie w niewyrównanych lokalizacjach pamięci jest obsługiwane.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób odczytu i zapisu do niezarządzanej tablicy przy użyciu <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> metod i. <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Adres podstawowy (<paramref name="ptr" />) i bajt przesunięcia<paramref name="ofs" />() tworzą wartość null lub nieprawidłowy adres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (object ptr, int ofs, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32([out] object ptr, int32 ofs, int32 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32 (ptr As Object, ofs As Integer, val As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32(System::Object ^ ptr, int ofs, int val);" />
      <MemberSignature Language="F#" Value="static member WriteInt32 : obj * int * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteInt32 (ptr, ofs, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("WriteInt32(Object, Int32, Int32) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres podstawowy w niezarządzanej pamięci obiektu docelowego.</param>
        <param name="ofs">Dodatkowe przesunięcie bajtowe, które jest dodawane do <paramref name="ptr" /> parametru przed zapisem.</param>
        <param name="val">Wartość do zapisu.</param>
        <summary>Zapisuje 32-bitową liczbę całkowitą ze znakiem do pamięci niezarządzanej w określonym przesunięciu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A>Włącza bezpośrednią interakcję z niezarządzaną, 32 bitową tablicą, eliminując koszty kopiowania całej tablicy niezarządzanej (przy użyciu <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) do oddzielnej zarządzanej tablicy przed ustawieniem jej wartości elementów.  
  
 Zapisywanie w niewyrównanych lokalizacjach pamięci jest obsługiwane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Adres podstawowy (<paramref name="ptr" />) i bajt przesunięcia<paramref name="ofs" />() tworzą wartość null lub nieprawidłowy adres.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="ptr" /><see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> jest obiektem. Ta metoda nie akceptuje <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parametrów.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteInt64">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje 64-bitową liczbę całkowitą ze znakiem do pamięci niezarządzanej. Zapisywanie w niewyrównanych lokalizacjach pamięci jest obsługiwane.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (IntPtr ptr, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64(native int ptr, int64 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64 (ptr As IntPtr, val As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64(IntPtr ptr, long val);" />
      <MemberSignature Language="F#" Value="static member WriteInt64 : nativeint * int64 -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteInt64 (ptr, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres w pamięci niezarządzanej, w której ma zostać zapisany.</param>
        <param name="val">Wartość do zapisu.</param>
        <summary>Zapisuje 64-bitową liczbę całkowitą ze znakiem do pamięci niezarządzanej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A>Włącza bezpośrednią interakcję z niezarządzaną, 64 bitową tablicą, eliminując koszty kopiowania całej tablicy niezarządzanej (przy użyciu <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) do oddzielnej zarządzanej tablicy przed ustawieniem jej wartości elementów.  
  
 Zapisywanie w niewyrównanych lokalizacjach pamięci jest obsługiwane.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób odczytu i zapisu do niezarządzanej tablicy przy użyciu <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> metod i. <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><paramref name="ptr" />nie jest rozpoznawanym formatem.  
  
—lub— 
 <paramref name="ptr" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="ptr" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (IntPtr ptr, int ofs, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64(native int ptr, int32 ofs, int64 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64 (ptr As IntPtr, ofs As Integer, val As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64(IntPtr ptr, int ofs, long val);" />
      <MemberSignature Language="F#" Value="static member WriteInt64 : nativeint * int * int64 -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteInt64 (ptr, ofs, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres podstawowy w pamięci niezarządzanej do zapisania.</param>
        <param name="ofs">Dodatkowe przesunięcie bajtowe, które jest dodawane do <paramref name="ptr" /> parametru przed zapisem.</param>
        <param name="val">Wartość do zapisu.</param>
        <summary>Zapisuje 64-bitową liczbę całkowitą ze znakiem do pamięci niezarządzanej w określonym przesunięciu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A>Włącza bezpośrednią interakcję z niezarządzaną, 64 bitową tablicą, eliminując koszty kopiowania całej tablicy niezarządzanej (przy użyciu <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) do oddzielnej zarządzanej tablicy przed ustawieniem jej wartości elementów.  
  
 Zapisywanie w niewyrównanych lokalizacjach pamięci jest obsługiwane.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób odczytu i zapisu do niezarządzanej tablicy przy użyciu <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> metod i. <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Adres podstawowy (<paramref name="ptr" />) i bajt przesunięcia<paramref name="ofs" />() tworzą wartość null lub nieprawidłowy adres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (object ptr, int ofs, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64([out] object ptr, int32 ofs, int64 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64 (ptr As Object, ofs As Integer, val As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64(System::Object ^ ptr, int ofs, long val);" />
      <MemberSignature Language="F#" Value="static member WriteInt64 : obj * int * int64 -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteInt64 (ptr, ofs, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("WriteInt64(Object, Int32, Int64) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres podstawowy w niezarządzanej pamięci obiektu docelowego.</param>
        <param name="ofs">Dodatkowe przesunięcie bajtowe, które jest dodawane do <paramref name="ptr" /> parametru przed zapisem.</param>
        <param name="val">Wartość do zapisu.</param>
        <summary>Zapisuje 64-bitową liczbę całkowitą ze znakiem do pamięci niezarządzanej w określonym przesunięciu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A>Włącza bezpośrednią interakcję z niezarządzaną, 64 bitową tablicą, eliminując koszty kopiowania całej tablicy niezarządzanej (przy użyciu <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) do oddzielnej zarządzanej tablicy przed ustawieniem jej wartości elementów.  
  
 Zapisywanie w niewyrównanych lokalizacjach pamięci jest obsługiwane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Adres podstawowy (<paramref name="ptr" />) i bajt przesunięcia<paramref name="ofs" />() tworzą wartość null lub nieprawidłowy adres.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="ptr" /><see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> jest obiektem. Ta metoda nie akceptuje <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parametrów.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteIntPtr">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje w pamięci niezarządzanej liczbę całkowitą od natywnego rozmiaru procesora. 32-bitowe liczby całkowite są zapisywane w systemach 32-bitowych, a 64-bitowe liczby całkowite są zapisywane w systemach 64-bitowych. Zapisywanie w niewyrównanych lokalizacjach pamięci jest obsługiwane.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (IntPtr ptr, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr(native int ptr, native int val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIntPtr (ptr As IntPtr, val As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIntPtr(IntPtr ptr, IntPtr val);" />
      <MemberSignature Language="F#" Value="static member WriteIntPtr : nativeint * nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteIntPtr (ptr, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres w pamięci niezarządzanej, w której ma zostać zapisany.</param>
        <param name="val">Wartość do zapisu.</param>
        <summary>Zapisuje wartość całkowitą liczby całkowitej procesora w pamięci niezarządzanej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A>Włącza bezpośrednią interakcję z niezarządzaną `IntPtr` tablicą języka C, eliminując koszty kopiowania całej tablicy niezarządzanej <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>(przy użyciu) do oddzielnej zarządzanej tablicy przed ustawieniem jej wartości elementów.  
  
 Zapisywanie w niewyrównanych lokalizacjach pamięci jest obsługiwane.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób odczytu i zapisu do niezarządzanej tablicy przy użyciu <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> metod i. <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><paramref name="ptr" />nie jest rozpoznawanym formatem.  
  
—lub— 
 <paramref name="ptr" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="ptr" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (IntPtr ptr, int ofs, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr(native int ptr, int32 ofs, native int val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIntPtr (ptr As IntPtr, ofs As Integer, val As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIntPtr(IntPtr ptr, int ofs, IntPtr val);" />
      <MemberSignature Language="F#" Value="static member WriteIntPtr : nativeint * int * nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteIntPtr (ptr, ofs, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres podstawowy w pamięci niezarządzanej, w której ma zostać zapisany.</param>
        <param name="ofs">Dodatkowe przesunięcie bajtowe, które jest dodawane do <paramref name="ptr" /> parametru przed zapisem.</param>
        <param name="val">Wartość do zapisu.</param>
        <summary>Zapisuje w określonym przesunięciu wartość całkowitą o rozmiarze wyznaczonym przez natywny procesor do niezarządzanej pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zapisuje 32-bitową liczbę całkowitą w systemach 32 bitowych i 64 bitową liczbę całkowitą w systemach 64 bitowych.  
  
 <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A>Włącza bezpośrednią interakcję z niezarządzaną `IntPtr` tablicą języka C, eliminując koszty kopiowania całej tablicy niezarządzanej <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>(przy użyciu) do oddzielnej zarządzanej tablicy przed ustawieniem jej wartości elementów.  
  
 Zapisywanie w niewyrównanych lokalizacjach pamięci jest obsługiwane.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób odczytu i zapisu do niezarządzanej tablicy przy użyciu <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> metod i. <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Adres podstawowy (<paramref name="ptr" />) i bajt przesunięcia<paramref name="ofs" />() tworzą wartość null lub nieprawidłowy adres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (object ptr, int ofs, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr([out] object ptr, int32 ofs, native int val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIntPtr (ptr As Object, ofs As Integer, val As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIntPtr(System::Object ^ ptr, int ofs, IntPtr val);" />
      <MemberSignature Language="F#" Value="static member WriteIntPtr : obj * int * nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteIntPtr (ptr, ofs, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("WriteIntPtr(Object, Int32, IntPtr) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Adres podstawowy w niezarządzanej pamięci obiektu docelowego.</param>
        <param name="ofs">Dodatkowe przesunięcie bajtowe, które jest dodawane do <paramref name="ptr" /> parametru przed zapisem.</param>
        <param name="val">Wartość do zapisu.</param>
        <summary>Zapisuje wartość całkowitą liczby całkowitej procesora w pamięci niezarządzanej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A>Włącza bezpośrednią interakcję z niezarządzaną tablicą bajtów w stylu C, eliminując koszty kopiowania całej tablicy niezarządzanej (przy użyciu <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) do oddzielnej zarządzanej tablicy przed ustawieniem jej wartości elementów.  
  
 Zapisywanie w niewyrównanych lokalizacjach pamięci jest obsługiwane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Adres podstawowy (<paramref name="ptr" />) i bajt przesunięcia<paramref name="ofs" />() tworzą wartość null lub nieprawidłowy adres.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="ptr" /><see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> jest obiektem. Ta metoda nie akceptuje <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parametrów.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeBSTR">
      <MemberSignature Language="C#" Value="public static void ZeroFreeBSTR (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeBSTR(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeBSTR (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeBSTR(IntPtr s);" />
      <MemberSignature Language="F#" Value="static member ZeroFreeBSTR : nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.ZeroFreeBSTR s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Adres <see langword="BSTR" /> do zwolnienia.</param>
        <summary>Zwalnia wskaźnik [BSTR](https://msdn.microsoft.com/library/ms221069.aspx) , który został przydzielony przy użyciu <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A> Metoda najpierw ustawia zawartość BSTR na zero, a następnie zwalnia wartość BSTR.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemAnsi (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemAnsi(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeCoTaskMemAnsi (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeCoTaskMemAnsi(IntPtr s);" />
      <MemberSignature Language="F#" Value="static member ZeroFreeCoTaskMemAnsi : nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Adres niezarządzanego ciągu do zwolnienia.</param>
        <summary>Zwalnia niezarządzany wskaźnik ciągu, który został przydzielony <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" /> przy użyciu metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda najpierw zeruje i zwolni niezarządzaną pamięć, która została przypisana <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> przy użyciu metody. <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A>  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> metody do organizowania i odszyfrowywania zawartości <xref:System.Security.SecureString> obiektu w bloku pamięci niezarządzanej. Następnie używa <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> metody do zerowania i usuwania niezarządzanego bloku.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemUnicode">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemUnicode (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemUnicode(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeCoTaskMemUnicode (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeCoTaskMemUnicode(IntPtr s);" />
      <MemberSignature Language="F#" Value="static member ZeroFreeCoTaskMemUnicode : nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Adres niezarządzanego ciągu do zwolnienia.</param>
        <summary>Zwalnia niezarządzany wskaźnik ciągu, który został przydzielony <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" /> przy użyciu metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda najpierw zeruje i zwolni niezarządzaną pamięć, która została przypisana <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> przy użyciu metody. <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemUTF8">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemUTF8 (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemUTF8(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUTF8(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeCoTaskMemUTF8 (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeCoTaskMemUTF8(IntPtr s);" />
      <MemberSignature Language="F#" Value="static member ZeroFreeCoTaskMemUTF8 : nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUTF8 s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.1">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeGlobalAllocAnsi">
      <MemberSignature Language="C#" Value="public static void ZeroFreeGlobalAllocAnsi (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeGlobalAllocAnsi(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeGlobalAllocAnsi (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeGlobalAllocAnsi(IntPtr s);" />
      <MemberSignature Language="F#" Value="static member ZeroFreeGlobalAllocAnsi : nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Adres niezarządzanego ciągu do zwolnienia.</param>
        <summary>Zwalnia niezarządzany wskaźnik ciągu, który został przydzielony <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" /> przy użyciu metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda najpierw zeruje i zwolni niezarządzaną pamięć, która została przypisana <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> przy użyciu metody. <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A>  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> metody do organizowania i odszyfrowywania zawartości <xref:System.Security.SecureString> obiektu w bloku pamięci niezarządzanej. Następnie używa <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> metody do zerowania i usuwania niezarządzanego bloku.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeGlobalAllocUnicode">
      <MemberSignature Language="C#" Value="public static void ZeroFreeGlobalAllocUnicode (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeGlobalAllocUnicode(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeGlobalAllocUnicode (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeGlobalAllocUnicode(IntPtr s);" />
      <MemberSignature Language="F#" Value="static member ZeroFreeGlobalAllocUnicode : nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Adres niezarządzanego ciągu do zwolnienia.</param>
        <summary>Zwalnia niezarządzany wskaźnik ciągu, który został przydzielony <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" /> przy użyciu metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda najpierw zeruje i zwolni niezarządzaną pamięć, która została przypisana <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> przy użyciu metody. <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A>  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> metody z niezarządzaną `LogonUser` funkcją <xref:System.Security.SecureString> do wykonania personifikacji z klasą. W przykładzie zostanie użyta <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> Metoda wyzerowania i zwolnienia niezarządzanego odwołania do ciągu.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
  </Members>
</Type>

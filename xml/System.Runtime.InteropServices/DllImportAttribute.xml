<Type Name="DllImportAttribute" FullName="System.Runtime.InteropServices.DllImportAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bddc7213fba3d261507ce7a3e8139a0d7b952b10" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69270289" /></Metadata><TypeSignature Language="C#" Value="public sealed class DllImportAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DllImportAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.DllImportAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DllImportAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class DllImportAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type DllImportAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Wskazuje, że metoda z atrybutem jest uwidaczniana przez niezarządzaną bibliotekę dołączaną dynamicznie (DLL) jako statyczny punkt wejścia.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten atrybut można zastosować do metod.  
  
 Ten <xref:System.Runtime.InteropServices.DllImportAttribute> atrybut zawiera informacje konieczne do wywołania funkcji wyeksportowanej z niezarządzanej biblioteki DLL. Minimalnym wymaganiem jest podanie nazwy biblioteki DLL zawierającej punkt wejścia.  
  
 Ten atrybut jest stosowany bezpośrednio do C# definicji C++ metod i. Jednak kompilator Visual Basic emituje ten atrybut przy użyciu `Declare` instrukcji. W przypadku złożonych definicji metod, <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping>które <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention>zawierają <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling>pola <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>, <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError>,, <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> , lub, należy zastosować ten atrybut bezpośrednio do Visual Basic definicji metod.  
  
 **Uwaga** Język JScript nie obsługuje tego atrybutu. Klasy otoki C# można użyć lub Visual Basic, aby uzyskać dostęp do niezarządzanych metod interfejsu API z programów JScript.  
  
 Aby uzyskać dodatkowe informacje dotyczące korzystania z usługi wywołania platformy w celu uzyskania dostępu do funkcji w niezarządzanych bibliotekach DLL, zobacz wykorzystywanie [niezarządzanych funkcji DLL](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).  
  
> [!NOTE]
>  Program <xref:System.Runtime.InteropServices.DllImportAttribute> nie obsługuje organizowania typów ogólnych.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Runtime.InteropServices.DllImportAttribute> jak używać atrybutu do importowania funkcji Win32. `MessageBox`  Przykład kodu wywołuje metodę zaimportowaną.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DllImportAttribute (string dllName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.DllImportAttribute.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dllName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DllImportAttribute(System::String ^ dllName);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.DllImportAttribute : string -&gt; System.Runtime.InteropServices.DllImportAttribute" Usage="new System.Runtime.InteropServices.DllImportAttribute dllName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dllName">Nazwa biblioteki DLL, która zawiera niezarządzaną metodę. Może to obejmować nazwę wyświetlaną zestawu, jeśli biblioteka DLL jest dołączona do zestawu.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Runtime.InteropServices.DllImportAttribute" /> klasy z nazwą biblioteki DLL zawierającej metodę do zaimportowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli niezarządzany plik DLL jest zawarty w zestawie, na przykład za pomocą konsolidatora lub `/linkresource` opcji kompilatora, można określić nazwę wyświetlaną zestawu jako `dllName`część. Na przykład jeśli niezarządzana biblioteka DLL `unmanaged.dll` o nazwie jest uwzględniona w zarządzanym zestawie o nazwie `MyAssembly`, atrybut może być określony, jak pokazano w poniższym kodzie.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#2)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#2)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#2)]  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Runtime.InteropServices.DllImportAttribute> jak używać atrybutu do importowania funkcji Win32. `MessageBox`  Przykład kodu wywołuje metodę zaimportowaną.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BestFitMapping">
      <MemberSignature Language="C#" Value="public bool BestFitMapping;" />
      <MemberSignature Language="ILAsm" Value=".field public bool BestFitMapping" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberSignature Language="VB.NET" Value="Public BestFitMapping As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool BestFitMapping;" />
      <MemberSignature Language="F#" Value="val mutable BestFitMapping : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Włącza lub wyłącza zachowanie mapowania najlepszego dopasowania podczas konwertowania znaków Unicode na znaki ANSI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `true`zachowanie mapowania najlepszego dopasowania jest włączone; w przeciwnym razie Mapowanie najlepszego dopasowania jest wyłączone. <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> Pole jest`true` domyślnie. Ustawienia dla tego pola zastępują ustawienia wszystkich poziomów dla <xref:System.Runtime.InteropServices.BestFitMappingAttribute?displayProperty=nameWithType> atrybutu.  
  
 Środowisko uruchomieniowe języka wspólnego konwertuje na znaki ANSI wszystkie zarządzane znaki Unicode przesłane do niezarządzanej metody wykonywanej w systemie Windows 98 lub Windows Me. Najwygodniejsze mapowanie umożliwia Organizatorowi międzyoperacyjnego dostarczenie znaku zbliżonego do najlepszego, gdy nie istnieje dokładne dopasowanie. Na przykład Organizator konwertuje znak Copyright Unicode na "c" dla niezarządzanych metod, które akceptują znaki ANSI. Niektóre znaki nie mają najlepiej pasującej reprezentacji; te znaki są nazywane napotkano. Znaki napotkano są zwykle konwertowane na domyślne "?" Znak ANSI.  
  
> [!CAUTION]
>  Niektóre znaki Unicode są konwertowane na niebezpieczne znaki, takie jak znak ukośnika odwrotnego "\\", co może przypadkowo zmienić ścieżkę. Ustawiając <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> pole na `true`, można sygnalizować obecność znaku napotkano do obiektu wywołującego, zgłaszając wyjątek.  
  
> [!CAUTION]
>  Nie można zmienić wartości domyślnych dostarczonych przez <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> i <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> pól podczas przekazywania tablicy zarządzanej, której elementy są znakami ANSI lub LPSTRs do niezarządzanej bezpiecznej tablicy. Mapowanie najlepiej dopasowane jest zawsze włączone i nie jest zgłaszany żaden wyjątek. Należy pamiętać, że ta kombinacja może naruszyć bezpieczeństwo modelu zabezpieczeń.  
  
   
  
## Examples  
 W niektórych przypadkach Visual Basic deweloperzy używają <xref:System.Runtime.InteropServices.DllImportAttribute>zamiast `Declare` instrukcji, aby zdefiniować funkcję DLL w kodzie zarządzanym. <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> Ustawienie pola jest jednym z tych przypadków. W poniższym przykładzie pokazano, jak zastosować rygorystyczne mapowanie znaków zabezpieczenia na platformie Wywołaj definicje metod, określając zestaw znaków ANSI, wyłączając zachowanie mapowania najlepszego dopasowania i zgłaszając wyjątek dla niezamapowanych znaków Unicode.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="T:System.Runtime.InteropServices.BestFitMappingAttribute" />
        <related type="Article" href="https://msdn.microsoft.com/library/115f7a2f-d422-4605-ab36-13a8dd28142a">Organizowanie międzyoperacyjne</related>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CallingConvention CallingConvention;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CallingConvention CallingConvention" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public CallingConvention As CallingConvention " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CallingConvention CallingConvention;" />
      <MemberSignature Language="F#" Value="val mutable CallingConvention : System.Runtime.InteropServices.CallingConvention" Usage="System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CallingConvention</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje konwencję wywoływania punktu wejścia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To pole jest ustawiane na jeden z <xref:System.Runtime.InteropServices.CallingConvention> elementów członkowskich wyliczenia. Wartość domyślna dla <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> pola to <xref:System.Runtime.InteropServices.CallingConvention.Winapi>, co z kolei powoduje <xref:System.Runtime.InteropServices.CallingConvention.StdCall> domyślne ustawienie Konwencji.  
  
   
  
## Examples  
 W niektórych przypadkach Visual Basic deweloperzy używają <xref:System.Runtime.InteropServices.DllImportAttribute>zamiast `Declare` instrukcji, aby zdefiniować funkcję DLL w kodzie zarządzanym. <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> Ustawienie pola jest jednym z tych przypadków.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#1)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.CallingConvention" />
      </Docs>
    </Member>
    <Member MemberName="CharSet">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CharSet CharSet;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CharSet CharSet" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberSignature Language="VB.NET" Value="Public CharSet As CharSet " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CharSet CharSet;" />
      <MemberSignature Language="F#" Value="val mutable CharSet : System.Runtime.InteropServices.CharSet" Usage="System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CharSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje sposób kierowania parametrów ciągu do metody i kontrolek Name dekorowanie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego pola z elementem członkowskim <xref:System.Runtime.InteropServices.CharSet> wyliczenia, aby określić zachowanie organizowania parametrów i określić nazwę punktu wejścia do wywołania (dokładną nazwę podaną lub nazwę kończącą się od "a" lub "w"). Domyślny element członkowski wyliczenia dla C# i Visual Basic jest `CharSet.Ansi` i domyślny element członkowski wyliczenia dla C++ elementu `CharSet.None` `CharSet.Ansi`is, który jest odpowiednikiem. W Visual Basic Użyj `Declare` instrukcji, aby `CharSet` określić pole.  
  
 Pole <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> ma wpływ na zachowanie `CharSet` pola podczas określania, która nazwa punktu wejścia ma zostać wywołana. Szczegółowy opis i przykłady zachowania związanego z kierowaniem ciągu i dopasowaniem nazw skojarzonych z `CharSet` polem zawiera temat [Określanie zestawu znaków](~/docs/framework/interop/specifying-a-character-set.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Runtime.InteropServices.DllImportAttribute> jak używać atrybutu do importowania funkcji Win32. `MessageBox`  Przykład kodu wywołuje metodę zaimportowaną.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public string EntryPoint;" />
      <MemberSignature Language="ILAsm" Value=".field public string EntryPoint" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public EntryPoint As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ EntryPoint;" />
      <MemberSignature Language="F#" Value="val mutable EntryPoint : string" Usage="System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje nazwę lub numer porządkowy punktu wejścia biblioteki DLL, który ma zostać wywołany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz określić nazwę punktu wejścia, podając ciąg wskazujący nazwę biblioteki DLL zawierającej punkt wejścia lub można zidentyfikować punkt wejścia za pomocą numeru porządkowego. Liczby porządkowe są poprzedzone znakiem #, na przykład #1. W przypadku pominięcia tego pola środowisko uruchomieniowe języka wspólnego używa nazwy metody the.NET oznaczonej za <xref:System.Runtime.InteropServices.DllImportAttribute>pomocą.  
  
 Aby uzyskać dodatkowe informacje, zobacz temat [Identyfikowanie funkcji w bibliotekach DLL](~/docs/framework/interop/identifying-functions-in-dlls.md). Przykłady pokazujące, jak używać <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> pola, zobacz [Określanie punktu wejścia](~/docs/framework/interop/specifying-an-entry-point.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Runtime.InteropServices.DllImportAttribute> jak używać atrybutu do importowania funkcji Win32. `MessageBox`  W przykładzie kodu jest stosowana <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> właściwość, aby określić funkcję do zaimportowania, a następnie zmienić `MyNewMessageBoxMethod`nazwę na.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ExactSpelling">
      <MemberSignature Language="C#" Value="public bool ExactSpelling;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ExactSpelling" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberSignature Language="VB.NET" Value="Public ExactSpelling As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ExactSpelling;" />
      <MemberSignature Language="F#" Value="val mutable ExactSpelling : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy <see cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" /> pole powoduje, że środowisko uruchomieniowe języka wspólnego przeszuka niezarządzaną bibliotekę DLL dla nazw punktów wejścia innych niż określona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `false`, nazwa punktu wejścia dołączona z literą A jest wywoływana, <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> gdy pole jest ustawione na `CharSet.Ansi`, a nazwa punktu wejścia dołączona <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> z literą w jest `CharSet.Unicode`wywoływana, gdy pole jest ustawione na. Zazwyczaj zarządzane kompilatory ustawiają to pole.  
  
 W poniższej tabeli przedstawiono relacje między <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet> polami i <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> w oparciu o wartości domyślne narzucone przez język programowania. Ustawienie domyślne można zastąpić, ale należy zachować ostrożność.  
  
|Język|ANSI|Unicode|Auto|  
|--------------|----------|-------------|----------|  
|Visual Basic|ExactSpelling:=True|ExactSpelling:=True|ExactSpelling: = false|  
|C#|ExactSpelling=false|ExactSpelling=false|ExactSpelling=false|  
|C++|ExactSpelling=false|ExactSpelling=false|ExactSpelling=false|  
  
   
  
## Examples  
 W niektórych przypadkach Visual Basic deweloperzy używają <xref:System.Runtime.InteropServices.DllImportAttribute>, zamiast `Declare` używać instrukcji, do definiowania funkcji DLL w kodzie zarządzanym. <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> Ustawienie pola jest jednym z tych przypadków.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#4)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#4)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveSig">
      <MemberSignature Language="C#" Value="public bool PreserveSig;" />
      <MemberSignature Language="ILAsm" Value=".field public bool PreserveSig" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberSignature Language="VB.NET" Value="Public PreserveSig As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool PreserveSig;" />
      <MemberSignature Language="F#" Value="val mutable PreserveSig : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy metody niezarządzane, <see langword="HRESULT" /> które <see langword="retval" /> mają lub zwracają wartości są <see langword="retval" /> bezpośrednio tłumaczone <see langword="HRESULT" /> lub czy zwracane wartości są automatycznie konwertowane na wyjątki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `HRESULT` `retval` `HRESULT` `false` `retval` Ustaw <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> poletak,abymożnabyłobezpośrednioprzetłumaczyćpodpisyniezarządzanenalubwartości;Ustawdlaniegoautomatycznekonwertowanielub`true` wartości na wyjątki. Domyślnie <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> pole ma `true`wartość.  
  
 Kiedy `true`, sygnatura wynikowej metody zwraca wartość całkowitą, która `HRESULT` zawiera wartość.  W takim przypadku należy ręcznie sprawdzić wartość zwracaną i odpowiednio odpowiedzieć w aplikacji.  
  
 Po ustawieniu <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> pola na `false`, sygnatura wynikowej metody zawiera typ zwracany void zamiast liczby całkowitej (`HRESULT`) zwracanego typu.  Gdy metoda niezarządzana tworzy `HRESULT`, środowisko uruchomieniowe automatycznie ignoruje `S_OK` wartość zwracaną (lub 0) i nie zgłasza wyjątku.  W `HRESULT`przypadku innych niż `S_OK`środowisko uruchomieniowe automatycznie zgłasza wyjątek `HRESULT`, który odnosi się do.  Należy zauważyć, <xref:System.Runtime.InteropServices.DllImportAttribute> że ten atrybut wykonuje tylko tę konwersję tylko do `HRESULT`metod, które zwracają.  
  
 Możesz zdecydować się na zmianę domyślnego zachowania raportowania błędów z `HRESULT`usługi s na wyjątki w przypadkach, w których wyjątki lepiej pasują do struktury raportowania błędów aplikacji.  
  
 To pole jest podobne do <xref:System.Runtime.InteropServices.PreserveSigAttribute>, ale w przeciwieństwie <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> do pola, wartość domyślna atrybutu to `false`.  
  
 W niektórych przypadkach Visual Basic deweloperzy używają <xref:System.Runtime.InteropServices.DllImportAttribute>, zamiast `Declare` używać instrukcji, do definiowania funkcji DLL w kodzie zarządzanym. <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> Ustawienie pola jest jednym z tych przypadków.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Runtime.InteropServices.DllImportAttribute> do zaimportowania funkcji niezarządzanej `SHAutoComplete` raz z <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> polem ustawionym `true` na i ponownie z <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> polem ustawionym `false`na.  Ten przykład kodu powoduje, `SHAutoComplete` że funkcja generuje wszystkie błędy z wyjątkiem jednego czasu `HRESULT` i następnego.  
  
 [!code-csharp[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.PreserveSigAttribute" />
      </Docs>
    </Member>
    <Member MemberName="SetLastError">
      <MemberSignature Language="C#" Value="public bool SetLastError;" />
      <MemberSignature Language="ILAsm" Value=".field public bool SetLastError" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberSignature Language="VB.NET" Value="Public SetLastError As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool SetLastError;" />
      <MemberSignature Language="F#" Value="val mutable SetLastError : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy wywoływany wywołuje <see langword="SetLastError" /> funkcję interfejsu API systemu Windows przed zwróceniem z metody z atrybutem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true`w celu wskazania, że wywoływany `SetLastError`obiekt wywoła; `false`w przeciwnym razie. Wartość domyślna to `false`.  
  
 Organizator środowiska uruchomieniowego wywołuje `GetLastError` i buforuje zwracaną wartość, aby zapobiec nadpisaniu jej przez inne wywołania interfejsu API. Kod błędu można pobrać, wywołując <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>metodę.  
  
   
  
## Examples  
 W niektórych przypadkach Visual Basic deweloperzy używają <xref:System.Runtime.InteropServices.DllImportAttribute>, zamiast `Declare` używać instrukcji, do definiowania funkcji DLL w kodzie zarządzanym. <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> Ustawienie pola jest jednym z tych przypadków.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#5)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#5)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      </Docs>
    </Member>
    <Member MemberName="ThrowOnUnmappableChar">
      <MemberSignature Language="C#" Value="public bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ThrowOnUnmappableChar" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberSignature Language="VB.NET" Value="Public ThrowOnUnmappableChar As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="F#" Value="val mutable ThrowOnUnmappableChar : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Włącza lub wyłącza wyrzucanie wyjątków dla znaku Unicode napotkano, który jest konwertowany na znak ANSI "?".</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true`Aby wskazać, że wyjątek jest zgłaszany za każdym razem, gdy organizator międzyoperacyjny konwertuje znak napotkano; ,abywskazać,żepolejestwyłączone.`false` <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> To pole jest `false` domyślnie.  
  
 Środowisko uruchomieniowe języka wspólnego konwertuje na znaki ANSI wszystkie zarządzane znaki Unicode przesłane do niezarządzanej metody wykonywanej w systemie Windows 98 lub Windows Me. Najwygodniejsze mapowanie umożliwia Organizatorowi międzyoperacyjnego dostarczenie znaku zbliżonego do najlepszego, gdy nie istnieje dokładne dopasowanie. Na przykład Organizator konwertuje znak Copyright Unicode na "c" dla niezarządzanych metod, które akceptują znaki ANSI. Niektóre znaki nie mają najlepiej pasującej reprezentacji; te znaki są nazywane napotkano. Znaki napotkano są zwykle konwertowane na domyślne "?" Znak ANSI.  
  
> [!CAUTION]
>  Niektóre znaki Unicode są konwertowane na niebezpieczne znaki, takie jak znak ukośnika odwrotnego "\\", co może przypadkowo zmienić ścieżkę. Ustawiając <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> pole na `true`, można sygnalizować obecność znaku napotkano do obiektu wywołującego, zgłaszając wyjątek.  
  
> [!CAUTION]
>  Nie można zmienić wartości domyślnych dostarczonych przez <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> i <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> pól podczas przekazywania tablicy zarządzanej, której elementy są znakami ANSI lub LPSTRs do niezarządzanej bezpiecznej tablicy. Mapowanie najlepiej dopasowane jest zawsze włączone i nie jest zgłaszany żaden wyjątek. Należy pamiętać, że ta kombinacja może naruszyć bezpieczeństwo modelu zabezpieczeń.  
  
   
  
## Examples  
 W niektórych przypadkach Visual Basic deweloperzy używają <xref:System.Runtime.InteropServices.DllImportAttribute> do definiowania funkcji DLL w kodzie zarządzanym, a nie `Declare` przy użyciu instrukcji. <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> Ustawienie pola jest jednym z tych przypadków. W poniższym przykładzie pokazano, jak zastosować rygorystyczne mapowanie znaków zabezpieczenia na platformie Wywołaj definicje metod, określając zestaw znaków ANSI, wyłączając zachowanie mapowania najlepszego dopasowania i zgłaszając wyjątek dla niezamapowanych znaków Unicode.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
        <related type="Article" href="https://msdn.microsoft.com/library/115f7a2f-d422-4605-ab36-13a8dd28142a">Organizowanie międzyoperacyjne</related>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę pliku DLL, który zawiera punkt wejścia.</summary>
        <value>Nazwa pliku DLL, który zawiera punkt wejścia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można podać pełną lub względną ścieżkę. Jeśli nie podasz ścieżki, biblioteka DLL musi znajdować się w bieżącej ścieżce w czasie wykonywania, chyba że biblioteka DLL jest załadowana w inny sposób. Należy jednak pamiętać, że użycie w pełni kwalifikowanej ścieżki może spowodować niedokładność, jeśli biblioteka DLL jest przenoszona.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

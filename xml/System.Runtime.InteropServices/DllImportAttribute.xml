<Type Name="DllImportAttribute" FullName="System.Runtime.InteropServices.DllImportAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="de7a53beeda19e530806d2978aadf945a5d39e91" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52247553" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DllImportAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DllImportAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.DllImportAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DllImportAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class DllImportAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type DllImportAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Wskazuje, że metoda opartego na atrybutach jest uwidaczniany przez niezarządzane biblioteki dołączanej (dynamicznie DLL) jako punkt wejścia statyczne.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten atrybut można stosować do metody.  
  
 <xref:System.Runtime.InteropServices.DllImportAttribute> Atrybut zawiera informacje potrzebne do wywoływania funkcji wyeksportowanej z niezarządzaną biblioteką DLL. Jako minimalne wymaganie należy podać nazwę pliku DLL zawierającego punkt wejścia.  
  
 Zastosowanie tego atrybutu bezpośrednio do języka C# i C++ definicje metod; Jednak kompilator Visual Basic emituje tego atrybutu, gdy używasz `Declare` instrukcji. Dla metody złożone definicje, które obejmują <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping>, <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention>, <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling>, <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>, <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError>, lub <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> pól bezpośrednio do definicji metod języka Visual Basic stosuje się ten atrybut.  
  
 **Uwaga** JScript nie obsługuje tego atrybutu. Dostęp do niezarządzanego metody interfejsu API z programów w języku JScript można użyć C# lub Visual Basic klasy otoki.  
  
 Aby uzyskać dodatkowe informacje o korzystaniu z platformy wywołania usługi dostępu do funkcji niezarządzanych bibliotek DLL, zobacz [wykorzystywanie niezarządzanych funkcji DLL](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).  
  
> [!NOTE]
>  <xref:System.Runtime.InteropServices.DllImportAttribute> Nie obsługuje przekazywanie typów ogólnych.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Runtime.InteropServices.DllImportAttribute> atrybutu, aby zaimportować Win32 `MessageBox` funkcji.  Przykładowy kod wywołuje metodę zaimportowane.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DllImportAttribute (string dllName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.DllImportAttribute.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dllName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DllImportAttribute(System::String ^ dllName);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.DllImportAttribute : string -&gt; System.Runtime.InteropServices.DllImportAttribute" Usage="new System.Runtime.InteropServices.DllImportAttribute dllName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dllName">Nazwa biblioteki DLL, która zawiera metodę niezarządzanych. Może to być nazwa wyświetlana zestawu, jeśli biblioteka DLL jest uwzględniony w zestawie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.InteropServices.DllImportAttribute" /> klasy o nazwie pliku DLL zawierającego metodę do zaimportowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli niezarządzane pliku DLL znajduje się w zestawie, na przykład za pomocą konsolidatora lub `/linkresource` — opcja kompilatora, można określić nazwę wyświetlaną zestawu jako część `dllName`. Na przykład, jeśli niezarządzaną biblioteką DLL o nazwie `unmanaged.dll` znajduje się w zarządzanym zestawie o nazwie `MyAssembly`, może być określony atrybut, jak pokazano w poniższym kodzie.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#2)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#2)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#2)]  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Runtime.InteropServices.DllImportAttribute> atrybutu, aby zaimportować Win32 `MessageBox` funkcji.  Przykładowy kod wywołuje metodę zaimportowane.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BestFitMapping">
      <MemberSignature Language="C#" Value="public bool BestFitMapping;" />
      <MemberSignature Language="ILAsm" Value=".field public bool BestFitMapping" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberSignature Language="VB.NET" Value="Public BestFitMapping As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool BestFitMapping;" />
      <MemberSignature Language="F#" Value="val mutable BestFitMapping : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Włącza lub wyłącza mapowanie najlepszego dopasowania zachowanie podczas konwersji znaków Unicode znaki ANSI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `true`, najlepszego dopasowania mapowania zachowanie jest włączone; w przeciwnym razie najlepszego dopasowania mapowania jest wyłączony. <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> Pole jest `true` domyślnie. Ustawienia dla tego pola zastąpić wszelkie ustawienia poziomu dla <xref:System.Runtime.InteropServices.BestFitMappingAttribute?displayProperty=nameWithType> atrybutu.  
  
 Środowisko uruchomieniowe języka wspólnego konwertuje znaki ANSI, zarządzane dowolne znaki Unicode przekazywany do metody niezarządzanego wykonywania na Windows 98 lub Windows Me. Mapowanie umożliwia Organizator międzyoperacyjny zapewnienie dopasowania w pobliżu znaku, gdy istnieje dokładnego dopasowania. Na przykład Organizator konwertuje znak Unicode o prawach autorskich "c", niezarządzanych metod, które akceptują znaki ANSI. Niektóre znaki nie mają reprezentacji najlepszego dopasowania; następujące znaki są nazywane którego nie można zmapować. Którego nie można zmapować znaki zwykle są konwertowane na wartość domyślna "?" Znaków ANSI.  
  
> [!CAUTION]
>  Niektóre znaki Unicode są konwertowane na niebezpiecznych znaków, takich jak ukośnik odwrotny "\\" znaków, które przypadkowo można zmienić ścieżkę. Ustawiając <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> pole `true`, można sygnał obecności, którego nie można zmapować znaku do obiektu wywołującego, zostanie zgłoszony wyjątek.  
  
> [!CAUTION]
>  Nie można zmienić wartości domyślne, dostarczone przez <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> i <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> pól podczas przekazywania tablicy zarządzanej, której elementy są znaki ANSI lub LPSTRs do bezpiecznej tablicy niezarządzanych. Mapowanie najlepszego dopasowania jest zawsze włączona i jest zgłaszany żaden wyjątek. Należy pamiętać, że ta kombinacja może naruszyć bezpieczeństwo modelu zabezpieczeń.  
  
   
  
## Examples  
 W niektórych przypadkach użycia deweloperów programu Visual Basic <xref:System.Runtime.InteropServices.DllImportAttribute>, zamiast `Declare` instrukcji, aby zdefiniować funkcję DLL w kodzie zarządzanym. Ustawienie <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> pole jest jednym z tych przypadków. Poniższy przykład pokazuje, jak zastosować najbardziej rygorystyczne zabezpieczenia mapowanie znaków na platformie wywołania definicje metod Określanie zestawu znaków ANSI, wyłączając najlepsze zachowanie mapowanie i zostanie zgłoszony wyjątek niezamapowane znaków Unicode.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="T:System.Runtime.InteropServices.BestFitMappingAttribute" />
        <related type="Article" href="https://msdn.microsoft.com/library/115f7a2f-d422-4605-ab36-13a8dd28142a">Marshaling międzyoperacyjny</related>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CallingConvention CallingConvention;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CallingConvention CallingConvention" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public CallingConvention As CallingConvention " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CallingConvention CallingConvention;" />
      <MemberSignature Language="F#" Value="val mutable CallingConvention : System.Runtime.InteropServices.CallingConvention" Usage="System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CallingConvention</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje Konwencja wywoływania punktu wejścia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To pole jest ustawiony na jedną z <xref:System.Runtime.InteropServices.CallingConvention> elementów członkowskich wyliczenia. Wartością domyślną dla <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> pole jest <xref:System.Runtime.InteropServices.CallingConvention.Winapi>, który z kolei wartość domyślna to <xref:System.Runtime.InteropServices.CallingConvention.StdCall> Konwencji.  
  
 Aby uzyskać więcej informacji zobacz konwencji wywoływania w bibliotece MSDN.  
  
   
  
## Examples  
 W niektórych przypadkach użycia deweloperów programu Visual Basic <xref:System.Runtime.InteropServices.DllImportAttribute>, zamiast `Declare` instrukcji, aby zdefiniować funkcję DLL w kodzie zarządzanym. Ustawienie <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> pole jest jednym z tych przypadków.  
  
 System.Runtime.InteropServices.DllImportAttribute#1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.CallingConvention" />
      </Docs>
    </Member>
    <Member MemberName="CharSet">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CharSet CharSet;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CharSet CharSet" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberSignature Language="VB.NET" Value="Public CharSet As CharSet " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CharSet CharSet;" />
      <MemberSignature Language="F#" Value="val mutable CharSet : System.Runtime.InteropServices.CharSet" Usage="System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CharSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa sposób organizowania parametry ciągu do metody i dekorowanie nazw kontrolek.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego pola z elementem członkowskim <xref:System.Runtime.InteropServices.CharSet> wyliczenie, aby określić zachowanie marshalingu parametrów ciągu i aby określić, która nazwa punktu wejścia do wywołania (dokładną nazwą podany lub nazwy kończą się ciągiem "A" lub "T"). Domyślny element członkowski wyliczenia w języku C# i Visual Basic jest `CharSet.Ansi` i domyślny element członkowski wyliczenia języka C++ jest `CharSet.None`, który jest odpowiednikiem `CharSet.Ansi`. W języku Visual Basic można użyć `Declare` instrukcję, aby określić `CharSet` pola.  
  
 <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> Pole ma wpływ na zachowanie `CharSet` pola w określeniu, która nazwa punktu wejścia do wywołania. Szczegółowy opis i przykłady organizowania ciągu i zachowania związanego z nazwą `CharSet` pola, zobacz [Określanie zestawu znaków](~/docs/framework/interop/specifying-a-character-set.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Runtime.InteropServices.DllImportAttribute> atrybutu, aby zaimportować Win32 `MessageBox` funkcji.  Przykładowy kod wywołuje metodę zaimportowane.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public string EntryPoint;" />
      <MemberSignature Language="ILAsm" Value=".field public string EntryPoint" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public EntryPoint As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ EntryPoint;" />
      <MemberSignature Language="F#" Value="val mutable EntryPoint : string" Usage="System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, nazwa lub porządkowy punkt wejścia biblioteki DLL, który ma zostać wywołana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy określić nazwę punktu wejścia, podając ciąg wskazujący nazwę pliku DLL zawierającego punkt wejścia lub jego numer można rozpoznać punktu wejścia. Liczby porządkowe są poprzedzone znakiem #, na przykład #1. Jeśli to pole zostanie pominięty, środowisko uruchomieniowe języka wspólnego używa nazwy środowiska.NET metody oznaczonej jako <xref:System.Runtime.InteropServices.DllImportAttribute>.  
  
 Aby uzyskać więcej informacji, zobacz [identyfikowanie funkcji w bibliotekach DLL](~/docs/framework/interop/identifying-functions-in-dlls.md). Aby uzyskać przykłady pokazujące, jak używać <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> pola, zobacz [Określanie punktu wejścia](~/docs/framework/interop/specifying-an-entry-point.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Runtime.InteropServices.DllImportAttribute> atrybutu, aby zaimportować Win32 `MessageBox` funkcji.  Przykład kodu wykorzystuje <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> właściwości w celu określenia funkcji do zaimportowania, a następnie zmienia nazwę aby `MyNewMessageBoxMethod`.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ExactSpelling">
      <MemberSignature Language="C#" Value="public bool ExactSpelling;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ExactSpelling" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberSignature Language="VB.NET" Value="Public ExactSpelling As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ExactSpelling;" />
      <MemberSignature Language="F#" Value="val mutable ExactSpelling : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Formanty czy <see cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" /> pola powoduje, że środowisko uruchomieniowe języka wspólnego do wyszukiwania niezarządzaną biblioteką DLL dla punktu wejścia nazw, innym niż ten, który został określony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `false`, nazwy punktu wejścia, które są dołączane za pomocą litery A jest wywoływana po <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> pole jest ustawione na `CharSet.Ansi`, i nazwę punktu wejścia dołączany wraz z literę W jest wywoływana po <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> pole jest ustawione na `CharSet.Unicode`. Zwykle zarządzane kompilatory ustawić tego pola.  
  
 W poniższej tabeli przedstawiono relację między <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet> i <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> pól, na podstawie wartości domyślnej nałożonych przez język programowania. Możesz zmienić ustawienia domyślne, ale to zrobić z ostrożnością.  
  
|Język|ANSI|Unicode|Auto|  
|--------------|----------|-------------|----------|  
|Visual Basic|ExactSpelling:=True|ExactSpelling:=True|ExactSpelling: = False|  
|C#|ExactSpelling=false|ExactSpelling=false|ExactSpelling=false|  
|C++|ExactSpelling=false|ExactSpelling=false|ExactSpelling=false|  
  
   
  
## Examples  
 W niektórych przypadkach użycia deweloperów programu Visual Basic <xref:System.Runtime.InteropServices.DllImportAttribute>, zamiast `Declare` instrukcji, aby zdefiniować funkcję DLL w kodzie zarządzanym. Ustawienie <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> pole jest jednym z tych przypadków.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#4)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#4)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveSig">
      <MemberSignature Language="C#" Value="public bool PreserveSig;" />
      <MemberSignature Language="ILAsm" Value=".field public bool PreserveSig" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberSignature Language="VB.NET" Value="Public PreserveSig As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool PreserveSig;" />
      <MemberSignature Language="F#" Value="val mutable PreserveSig : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy niezarządzanych metod, mieć <see langword="HRESULT" /> lub <see langword="retval" /> zwracają wartości bezpośrednio są tłumaczone czy <see langword="HRESULT" /> lub <see langword="retval" /> zwracają wartości są automatycznie konwertowane na wyjątki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> pole `true` bezpośrednio przełożyć niezarządzanych sygnaturami z `HRESULT` lub `retval` wartości; ustaw ją na `false` Aby dokonać automatycznej konwersji `HRESULT` lub `retval` wartości do wyjątków. Domyślnie <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> pole jest `true`.  
  
 Gdy `true`, wynikowy podpis metody zwraca wartość całkowitą, która zawiera `HRESULT` wartość.  Należy w tym przypadku ręcznie sprawdzić wartość zwracaną i odpowiednio reagować w aplikacji.  
  
 Po ustawieniu <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> pole `false`, wynikowy podpis metody zawiera zwracać typ void nie liczba całkowita (`HRESULT`) typ zwracany.  Gdy metoda niezarządzanego tworzy `HRESULT`, środowisko wykonawcze automatycznie ignoruje wartość zwracaną `S_OK` (lub równa 0) i nie zgłasza wyjątku.  Aby uzyskać `HRESULT`s innych niż `S_OK`, środowisko wykonawcze automatycznie zgłasza wyjątek, który odpowiada `HRESULT`.  Należy pamiętać, że <xref:System.Runtime.InteropServices.DllImportAttribute> atrybut będzie wykonywał tylko tę konwersję do metod, które zwracają `HRESULT`.  
  
 Można zdecydować, aby zmienić błąd domyślny raportowania zachowanie z `HRESULT`s do wyjątków w sytuacjach, gdy wyjątki lepszego dopasowania struktury aplikacji raportowania błędów.  
  
 To pole jest podobne do <xref:System.Runtime.InteropServices.PreserveSigAttribute>; jednak w przeciwieństwie do <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> pola, wartość domyślna dla atrybutu `false`.  
  
 W niektórych przypadkach użycia deweloperów programu Visual Basic <xref:System.Runtime.InteropServices.DllImportAttribute>, zamiast `Declare` instrukcji, aby zdefiniować funkcję DLL w kodzie zarządzanym. Ustawienie <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> pole jest jednym z tych przypadków.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Runtime.InteropServices.DllImportAttribute> do zaimportowania niezarządzaną `SHAutoComplete` raz funkcją <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> pole ustawione na wartość `true` i ponownie, używając <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> pole ustawione na wartość `false`.  Ten przykładowy kod powoduje, że `SHAutoComplete` funkcję generującą wszelkie błędy z powodu wyjątku jeden raz i `HRESULT` następnego.  
  
 [!code-csharp[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.PreserveSigAttribute" />
      </Docs>
    </Member>
    <Member MemberName="SetLastError">
      <MemberSignature Language="C#" Value="public bool SetLastError;" />
      <MemberSignature Language="ILAsm" Value=".field public bool SetLastError" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberSignature Language="VB.NET" Value="Public SetLastError As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool SetLastError;" />
      <MemberSignature Language="F#" Value="val mutable SetLastError : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy obiekt wywoływany wywołuje <see langword="SetLastError" /> funkcji Win32 API przed zwróceniem z atrybutami metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true` Aby wskazać, że obiekt wywoływany wywoła `SetLastError`; w przeciwnym razie `false`. Wartość domyślna to `false`.  
  
 Środowisko uruchomieniowe wywołuje organizatora `GetLastError` i buforuje wartości zwracanej, aby zapobiec nadpisaniu przez inne wywołania interfejsu API. Możesz pobrać kod błędu, wywołując <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>.  
  
   
  
## Examples  
 W niektórych przypadkach użycia deweloperów programu Visual Basic <xref:System.Runtime.InteropServices.DllImportAttribute>, zamiast `Declare` instrukcji, aby zdefiniować funkcję DLL w kodzie zarządzanym. Ustawienie <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> pole jest jednym z tych przypadków.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#5)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#5)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      </Docs>
    </Member>
    <Member MemberName="ThrowOnUnmappableChar">
      <MemberSignature Language="C#" Value="public bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ThrowOnUnmappableChar" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberSignature Language="VB.NET" Value="Public ThrowOnUnmappableChar As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="F#" Value="val mutable ThrowOnUnmappableChar : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Włącza lub wyłącza zgłaszania wyjątku, dla którego nie można zmapować znak Unicode, który jest konwertowany na ANSI "?" znaków.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true` Aby wskazać, że zgłaszany jest wyjątek każdorazowo, organizator międzyoperacyjny konwertuje znak którego nie można zmapować; `false` z informacją, że <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> pole jest wyłączone. To pole jest `false` domyślnie.  
  
 Środowisko uruchomieniowe języka wspólnego konwertuje znaki ANSI, zarządzane dowolne znaki Unicode przekazywany do metody niezarządzanego wykonywania na Windows 98 lub Windows Me. Mapowanie umożliwia Organizator międzyoperacyjny zapewnienie dopasowania w pobliżu znaku, gdy istnieje dokładnego dopasowania. Na przykład Organizator konwertuje znak Unicode o prawach autorskich "c", niezarządzanych metod, które akceptują znaki ANSI. Niektóre znaki nie mają reprezentacji najlepszego dopasowania; następujące znaki są nazywane którego nie można zmapować. Którego nie można zmapować znaki zwykle są konwertowane na wartość domyślna "?" Znaków ANSI.  
  
> [!CAUTION]
>  Niektóre znaki Unicode są konwertowane na niebezpiecznych znaków, takich jak ukośnik odwrotny "\\" znaków, które przypadkowo można zmienić ścieżkę. Ustawiając <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> pole `true`, można sygnał obecności, którego nie można zmapować znaku do obiektu wywołującego, zostanie zgłoszony wyjątek.  
  
> [!CAUTION]
>  Nie można zmienić wartości domyślne, dostarczone przez <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> i <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> pól podczas przekazywania tablicy zarządzanej, której elementy są znaki ANSI lub LPSTRs do bezpiecznej tablicy niezarządzanych. Mapowanie najlepszego dopasowania jest zawsze włączona i jest zgłaszany żaden wyjątek. Należy pamiętać, że ta kombinacja może naruszyć bezpieczeństwo modelu zabezpieczeń.  
  
   
  
## Examples  
 W niektórych przypadkach użycia deweloperów programu Visual Basic <xref:System.Runtime.InteropServices.DllImportAttribute> do definiowania funkcji DLL w kodzie zarządzanym, zamiast `Declare` instrukcji. Ustawienie <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> pole jest jednym z tych przypadków. Poniższy przykład pokazuje, jak zastosować najbardziej rygorystyczne zabezpieczenia mapowanie znaków na platformie wywołania definicje metod Określanie zestawu znaków ANSI, wyłączając najlepsze zachowanie mapowanie i zostanie zgłoszony wyjątek niezamapowane znaków Unicode.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
        <related type="Article" href="https://msdn.microsoft.com/library/115f7a2f-d422-4605-ab36-13a8dd28142a">Marshaling międzyoperacyjny</related>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę pliku DLL, która zawiera punkt wejścia.</summary>
        <value>Nazwa pliku DLL, która zawiera punkt wejścia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz podać pełną lub względną ścieżkę. Jeśli ścieżka nie zostaną podane, biblioteki DLL musi być w bieżącej ścieżce w czasie wykonywania, chyba że biblioteki DLL jest ładowany w inny sposób. Należy jednak pamiętać, że przy użyciu w pełni kwalifikowana ścieżka może prowadzić do wskazać nieścisłość Jeśli biblioteka DLL jest przenoszony.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
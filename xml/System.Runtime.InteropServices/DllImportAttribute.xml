<Type Name="DllImportAttribute" FullName="System.Runtime.InteropServices.DllImportAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1b291b7f17adbbd6bcc7b3b354069112b40071c7" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36538384" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DllImportAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DllImportAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.DllImportAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DllImportAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class DllImportAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type DllImportAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Wskazuje, że metody oparte na atrybutach jest udostępniana przez niezarządzane biblioteki dołączanej (dynamicznie DLL) jako punkt wejścia statycznych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten atrybut można stosować do metody.  
  
 <xref:System.Runtime.InteropServices.DllImportAttribute> Atrybutu zawiera informacje potrzebne do wywołania funkcji wyeksportowanej z niezarządzanej DLL. Jako minimalne wymaganie należy podać nazwę pliku DLL zawierającego punkt wejścia.  
  
 Zastosuj ten atrybut bezpośrednio do języka C# i C++ definicjami metod; Jednak kompilator Visual Basic emituje tego atrybutu, gdy używasz `Declare` instrukcji. Complex — metoda definicji, które obejmują <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping>, <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention>, <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling>, <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>, <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError>, lub <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> pól, zastosuj atrybut bezpośrednio z definicjami metod języka Visual Basic.  
  
 **Uwaga** JScript nie obsługuje tego atrybutu. Dostęp do niezarządzanego metody interfejsu API z programów w języku JScript można użyć języka C# lub Visual Basic klasy otoki.  
  
 Aby uzyskać dodatkowe informacje o korzystaniu z platformy wywoływanie usługi dostępu do funkcji w niezarządzanych bibliotek DLL, zobacz [wykorzystywanie niezarządzanych funkcji DLL](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).  
  
> [!NOTE]
>  <xref:System.Runtime.InteropServices.DllImportAttribute> Nie obsługuje przekazywanie typów ogólnych.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób użycia <xref:System.Runtime.InteropServices.DllImportAttribute> atrybutu, aby zaimportować Win32 `MessageBox` funkcji.  Przykładowy kod wywołuje metodę zaimportowany.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DllImportAttribute (string dllName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.DllImportAttribute.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dllName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DllImportAttribute(System::String ^ dllName);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.DllImportAttribute : string -&gt; System.Runtime.InteropServices.DllImportAttribute" Usage="new System.Runtime.InteropServices.DllImportAttribute dllName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dllName">Nazwa biblioteki DLL zawierającej metodę niezarządzane. Mogą to być nazwa wyświetlana zestawu, jeśli biblioteka DLL jest uwzględniony w zestawie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.InteropServices.DllImportAttribute" /> klasa o nazwie pliku DLL zawierającego metodę do zaimportowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli niezarządzany plik DLL znajduje się w zestawie, na przykład za pomocą konsolidatora lub `/linkresource` — opcja kompilatora, można określić nazwy wyświetlanej zestawu jako część `dllName`. Na przykład, jeśli niezarządzanej DLL o nazwie `unmanaged.dll` jest uwzględniona w nazwie zestawu zarządzanego `MyAssembly`, może być określony atrybut, jak pokazano w poniższym kodzie.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#2)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#2)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#2)]  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób użycia <xref:System.Runtime.InteropServices.DllImportAttribute> atrybutu, aby zaimportować Win32 `MessageBox` funkcji.  Przykładowy kod wywołuje metodę zaimportowany.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BestFitMapping">
      <MemberSignature Language="C#" Value="public bool BestFitMapping;" />
      <MemberSignature Language="ILAsm" Value=".field public bool BestFitMapping" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberSignature Language="VB.NET" Value="Public BestFitMapping As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool BestFitMapping;" />
      <MemberSignature Language="F#" Value="val mutable BestFitMapping : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Włącza lub wyłącza mapowanie najlepszego dopasowania zachowanie podczas konwersji znaków Unicode na ANSI znaków.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `true`, najlepszego dopasowania mapowania zachowanie jest włączone; w przeciwnym razie najlepszego dopasowania mapowania jest wyłączony. <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> Pole jest `true` domyślnie. Dla tego pola zastępują wszelkie ustawienia poziomu dla <xref:System.Runtime.InteropServices.BestFitMappingAttribute?displayProperty=nameWithType> atrybutu.  
  
 Środowisko uruchomieniowe języka wspólnego konwertuje znaków ANSI dowolny zarządzany znaków Unicode, przekazany do metody niezarządzane wykonywanych na Windows 98 lub Windows Me. Mapowanie najlepszego dopasowania umożliwia międzyoperacyjnego organizatora udzielać znak dopasowywanie Zamknij istnieje dokładnego dopasowania. Na przykład organizatora konwertuje znaku Unicode o prawach autorskich "c" dla niezarządzanego metod, które akceptują znaków ANSI. Niektóre znaki braku reprezentację najlepszego dopasowania; następujące znaki są nazywane zmapować. Znaki zmapować zwykle są konwertowane na wartość domyślna "?" Znaków ANSI.  
  
> [!CAUTION]
>  Niektóre znaki Unicode są konwertowane na niebezpiecznych znaków, takich jak kreska ułamkowa odwrócona "\\" znak, który może spowodować niezamierzoną zmianę ścieżki. Przez ustawienie <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> do `true`, sygnalizuje obecności znaku zmapować do obiektu wywołującego, przez Zgłaszanie wyjątku.  
  
> [!CAUTION]
>  Nie można zmienić wartości domyślne, dostarczone przez <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> i <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> pól podczas przekazywania tablicy, której elementy znaków ANSI lub LPSTRs niezarządzanych do bezpiecznej tablicy. Mapowanie najlepszego dopasowania jest zawsze włączona i nie jest wyjątek. Należy pamiętać, że ta kombinacja może naruszyć bezpieczeństwo modelu zabezpieczeń.  
  
   
  
## Examples  
 W niektórych przypadkach użycia deweloperów języka Visual Basic <xref:System.Runtime.InteropServices.DllImportAttribute>, zamiast `Declare` instrukcji, aby zdefiniować funkcję biblioteki DLL w kodzie zarządzanym. Ustawienie <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> pole jest jednym z tych przypadkach. Poniższy przykład przedstawia sposób zastosowania najbardziej rygorystyczne znak mapowania zabezpieczeń do platformy wywołania definicjami metod Określanie zestawu znaków ANSI, wyłączając najlepsze zachowanie mapowanie dopasowania i zgłaszanie wyjątku Niemapowane znaków Unicode.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="T:System.Runtime.InteropServices.BestFitMappingAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CallingConvention CallingConvention;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CallingConvention CallingConvention" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public CallingConvention As CallingConvention " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CallingConvention CallingConvention;" />
      <MemberSignature Language="F#" Value="val mutable CallingConvention : System.Runtime.InteropServices.CallingConvention" Usage="System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CallingConvention</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje konwencja wywołania punktu wejścia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To pole jest ustawione na jedną z <xref:System.Runtime.InteropServices.CallingConvention> elementy członkowskie wyliczenia. Wartość domyślna dla <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> pole jest <xref:System.Runtime.InteropServices.CallingConvention.Winapi>, który z kolei domyślnie <xref:System.Runtime.InteropServices.CallingConvention.StdCall> Konwencji.  
  
 Aby uzyskać więcej informacji zobacz konwencji wywoływania w bibliotece MSDN.  
  
   
  
## Examples  
 W niektórych przypadkach użycia deweloperów języka Visual Basic <xref:System.Runtime.InteropServices.DllImportAttribute>, zamiast `Declare` instrukcji, aby zdefiniować funkcję biblioteki DLL w kodzie zarządzanym. Ustawienie <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> pole jest jednym z tych przypadkach.  
  
 System.Runtime.InteropServices.DllImportAttribute#1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.CallingConvention" />
      </Docs>
    </Member>
    <Member MemberName="CharSet">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CharSet CharSet;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CharSet CharSet" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberSignature Language="VB.NET" Value="Public CharSet As CharSet " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CharSet CharSet;" />
      <MemberSignature Language="F#" Value="val mutable CharSet : System.Runtime.InteropServices.CharSet" Usage="System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CharSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje sposobu zorganizowania parametrów ciągu do metody i przekręcona nazwa kontrolki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego pola z elementem członkowskim o <xref:System.Runtime.InteropServices.CharSet> wyliczenia, aby określić zachowanie marshalingu parametrów typu ciąg oraz określić, która nazwa punktu wejścia do wywołania (dokładną nazwę danego lub nazwy kończą się ciągiem "A" lub "W"). Domyślny element członkowski wyliczenia języka C# i Visual Basic jest `CharSet.Ansi` i jest domyślny element członkowski wyliczenia C++ `CharSet.None`, który jest odpowiednikiem `CharSet.Ansi`. W języku Visual Basic, użyj `Declare` instrukcji, aby określić `CharSet` pola.  
  
 <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> Pole ma wpływ na zachowanie `CharSet` pole w określeniu, która nazwa punktu wejścia do wywołania. Szczegółowy opis i przykłady ciąg organizowanie i nazwą odpowiadającą zachowania związanego z `CharSet` pól, zobacz [określający zestaw znaków](~/docs/framework/interop/specifying-a-character-set.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób użycia <xref:System.Runtime.InteropServices.DllImportAttribute> atrybutu, aby zaimportować Win32 `MessageBox` funkcji.  Przykładowy kod wywołuje metodę zaimportowany.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public string EntryPoint;" />
      <MemberSignature Language="ILAsm" Value=".field public string EntryPoint" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public EntryPoint As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ EntryPoint;" />
      <MemberSignature Language="F#" Value="val mutable EntryPoint : string" Usage="System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje nazwę lub numer punktu wejścia biblioteki DLL do wywołania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy określić nazwę punktu wejścia, podając ciąg wskazujący nazwę pliku DLL zawierającego punkt wejścia lub jego liczby porządkowej można rozpoznać punktu wejścia. Porządkowe mają przedrostek znak #, na przykład #1. W przypadku pominięcia tego pola, środowisko uruchomieniowe języka wspólnego używa nazwy środowiska.NET metody oznaczonej jako <xref:System.Runtime.InteropServices.DllImportAttribute>.  
  
 Aby uzyskać dodatkowe informacje, zobacz [identyfikowanie funkcji w bibliotekach DLL](~/docs/framework/interop/identifying-functions-in-dlls.md). Przykłady przedstawiająca sposób używania <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> pól, zobacz [Określanie punktu wejścia](~/docs/framework/interop/specifying-an-entry-point.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób użycia <xref:System.Runtime.InteropServices.DllImportAttribute> atrybutu, aby zaimportować Win32 `MessageBox` funkcji.  Przykład kodu wykorzystuje <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> właściwości w celu określenia funkcji do zaimportowania, a następnie zmienia nazwę `MyNewMessageBoxMethod`.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ExactSpelling">
      <MemberSignature Language="C#" Value="public bool ExactSpelling;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ExactSpelling" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberSignature Language="VB.NET" Value="Public ExactSpelling As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ExactSpelling;" />
      <MemberSignature Language="F#" Value="val mutable ExactSpelling : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Formanty czy <see cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" /> pola powoduje, że środowisko uruchomieniowe języka wspólnego do wyszukiwania niezarządzanej DLL dla punktu wejścia nazw innych niż określona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `false`, dołączony litera, A nazwy punktu wejścia jest wywoływana po <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> pole jest ustawione na `CharSet.Ansi`, i nazwę punktu wejścia dołączony litera W jest wywoływana po <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> pole jest ustawione na `CharSet.Unicode`. Zwykle zarządzanych kompilatory ustawić tego pola.  
  
 W poniższej tabeli przedstawiono relacje między <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet> i <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> pól na podstawie wartości domyślnych nałożone przez język programowania. Można zmienić ustawienia domyślne, ale zrobić z rozwagą.  
  
|Język|ANSI|Unicode|Auto|  
|--------------|----------|-------------|----------|  
|Visual Basic|ExactSpelling:=True|ExactSpelling:=True|Opcję ExactSpelling: = False|  
|C#|ExactSpelling=false|ExactSpelling=false|ExactSpelling=false|  
|C++|ExactSpelling=false|ExactSpelling=false|ExactSpelling=false|  
  
   
  
## Examples  
 W niektórych przypadkach użycia deweloperów języka Visual Basic <xref:System.Runtime.InteropServices.DllImportAttribute>, zamiast `Declare` instrukcji, aby zdefiniować funkcję biblioteki DLL w kodzie zarządzanym. Ustawienie <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> pole jest jednym z tych przypadkach.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#4)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#4)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveSig">
      <MemberSignature Language="C#" Value="public bool PreserveSig;" />
      <MemberSignature Language="ILAsm" Value=".field public bool PreserveSig" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberSignature Language="VB.NET" Value="Public PreserveSig As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool PreserveSig;" />
      <MemberSignature Language="F#" Value="val mutable PreserveSig : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy niezarządzane metod zawierających <see langword="HRESULT" /> lub <see langword="retval" /> zwracać wartości bezpośrednio są tłumaczone lub czy <see langword="HRESULT" /> lub <see langword="retval" /> zwracać wartości są konwertowane na wyjątki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> do `true` bezpośrednio tłumaczenie niezarządzane sygnatur ze `HRESULT` lub `retval` wartości; ustaw ją na `false` Aby dokonać automatycznej konwersji `HRESULT` lub `retval` wartości do wyjątków. Domyślnie <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> pole jest `true`.  
  
 Gdy `true`, wynikowy podpis metody zwraca wartość całkowitą, która zawiera `HRESULT` wartość.  W takim przypadku należy ręcznie sprawdzić wartość zwrotną i odpowiednio odpowiedzieć w aplikacji.  
  
 Podczas ustawiania <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> do `false`, wynikowy podpis metody zawiera zwrócony typ void zamiast całkowitą (`HRESULT`) typ zwracany.  Gdy tworzy się niezarządzane — metoda `HRESULT`, środowisko uruchomieniowe ignoruje zwracana wartość `S_OK` (lub 0) i nie zgłasza wyjątek.  Aby uzyskać `HRESULT`s innych niż `S_OK`, środowisko uruchomieniowe automatycznie zgłasza wyjątek, który odpowiada `HRESULT`.  Należy pamiętać, że <xref:System.Runtime.InteropServices.DllImportAttribute> atrybutu przeprowadza tylko operacje konwersji do metod, które zwracają `HRESULT`.  
  
 Można zdecydować zmienić zachowanie z raportowania błędów domyślne `HRESULT`s do wyjątków w przypadkach, gdy wyjątki lepszego dopasowania struktury aplikacji raportowania błędów.  
  
 To pole jest podobny do <xref:System.Runtime.InteropServices.PreserveSigAttribute>; jednak contrast do <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> pola, wartością domyślną dla atrybutu jest `false`.  
  
 W niektórych przypadkach użycia deweloperów języka Visual Basic <xref:System.Runtime.InteropServices.DllImportAttribute>, zamiast `Declare` instrukcji, aby zdefiniować funkcję biblioteki DLL w kodzie zarządzanym. Ustawienie <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> pole jest jednym z tych przypadkach.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Runtime.InteropServices.DllImportAttribute> do zaimportowania niezarządzanej `SHAutoComplete` raz działać z <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> pole `true` i ponownie, podając <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> pole `false`.  Powoduje, że w tym przykładzie kodu `SHAutoComplete` funkcji do generowania wszelkie błędy z powodu wyjątku jeden raz i `HRESULT` następnej.  
  
 [!code-csharp[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.PreserveSigAttribute" />
      </Docs>
    </Member>
    <Member MemberName="SetLastError">
      <MemberSignature Language="C#" Value="public bool SetLastError;" />
      <MemberSignature Language="ILAsm" Value=".field public bool SetLastError" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberSignature Language="VB.NET" Value="Public SetLastError As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool SetLastError;" />
      <MemberSignature Language="F#" Value="val mutable SetLastError : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy wywoływany wywołuje <see langword="SetLastError" /> funkcji Win32 API przed powrotem z metody oparte na atrybutach.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true` Aby wskazać, że wywoła wywoływany `SetLastError`; w przeciwnym razie `false`. Wartość domyślna to `false`.  
  
 Wywołania Organizator środowiska wykonawczego `GetLastError` i buforuje wartość zwracana, aby zapobiec nadpisaniu przez inne wywołania interfejsu API. Kod błędu można pobrać przez wywołanie metody <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>.  
  
   
  
## Examples  
 W niektórych przypadkach użycia deweloperów języka Visual Basic <xref:System.Runtime.InteropServices.DllImportAttribute>, zamiast `Declare` instrukcji, aby zdefiniować funkcję biblioteki DLL w kodzie zarządzanym. Ustawienie <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> pole jest jednym z tych przypadkach.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#5)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#5)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      </Docs>
    </Member>
    <Member MemberName="ThrowOnUnmappableChar">
      <MemberSignature Language="C#" Value="public bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ThrowOnUnmappableChar" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberSignature Language="VB.NET" Value="Public ThrowOnUnmappableChar As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="F#" Value="val mutable ThrowOnUnmappableChar : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Włącza lub wyłącza zgłaszanie wyjątków na zmapować znak Unicode, który jest konwertowany na ANSI "?" znaków.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true` Aby wskazać, że zawsze jest zgłaszany wyjątek międzyoperacyjny organizatora konwertuje znak zmapować; `false` z informacją, że <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> pole jest wyłączone. To pole jest `false` domyślnie.  
  
 Środowisko uruchomieniowe języka wspólnego konwertuje znaków ANSI dowolny zarządzany znaków Unicode, przekazany do metody niezarządzane wykonywanych na Windows 98 lub Windows Me. Mapowanie najlepszego dopasowania umożliwia międzyoperacyjnego organizatora udzielać znak dopasowywanie Zamknij istnieje dokładnego dopasowania. Na przykład organizatora konwertuje znaku Unicode o prawach autorskich "c" dla niezarządzanego metod, które akceptują znaków ANSI. Niektóre znaki braku reprezentację najlepszego dopasowania; następujące znaki są nazywane zmapować. Znaki zmapować zwykle są konwertowane na wartość domyślna "?" Znaków ANSI.  
  
> [!CAUTION]
>  Niektóre znaki Unicode są konwertowane na niebezpiecznych znaków, takich jak kreska ułamkowa odwrócona "\\" znak, który może spowodować niezamierzoną zmianę ścieżki. Przez ustawienie <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> do `true`, sygnalizuje obecności znaku zmapować do obiektu wywołującego, przez Zgłaszanie wyjątku.  
  
> [!CAUTION]
>  Nie można zmienić wartości domyślne, dostarczone przez <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> i <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> pól podczas przekazywania tablicy, której elementy znaków ANSI lub LPSTRs niezarządzanych do bezpiecznej tablicy. Mapowanie najlepszego dopasowania jest zawsze włączona i nie jest wyjątek. Należy pamiętać, że ta kombinacja może naruszyć bezpieczeństwo modelu zabezpieczeń.  
  
   
  
## Examples  
 W niektórych przypadkach użycia deweloperów języka Visual Basic <xref:System.Runtime.InteropServices.DllImportAttribute> do definiowania funkcji DLL w kodzie zarządzanym, zamiast `Declare` instrukcji. Ustawienie <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> pole jest jednym z tych przypadkach. Poniższy przykład przedstawia sposób zastosowania najbardziej rygorystyczne znak mapowania zabezpieczeń do platformy wywołania definicjami metod Określanie zestawu znaków ANSI, wyłączając najlepsze zachowanie mapowanie dopasowania i zgłaszanie wyjątku Niemapowane znaków Unicode.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę pliku DLL, która zawiera punkt wejścia.</summary>
        <value>Nazwa pliku biblioteki DLL, który zawiera punkt wejścia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można podać pełną lub względną ścieżkę. Jeżeli określona ścieżka biblioteki DLL musi być w bieżącej ścieżce w czasie wykonywania, chyba, że plik DLL, który jest ładowany w inny sposób. Należy jednak pamiętać, że przy użyciu w pełni kwalifikowaną ścieżkę można wprowadzić niedokładność Jeśli biblioteka DLL jest przenoszony.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="SafeHandle" FullName="System.Runtime.InteropServices.SafeHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6c4334868cde5130ed9da65bfda7e798c24b12cd" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30564724" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SafeHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit SafeHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.SafeHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SafeHandle&#xA;Inherits CriticalFinalizerObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SafeHandle abstract : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje klasę otoki dla systemu operacyjnego. Ta klasa musi być dziedziczone.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle> Klasa udostępnia finalizacji krytyczne dojście zasobów, uniemożliwia uchwytów z zostanie odzyskana przedwcześnie przez wyrzucanie elementów bezużytecznych i odtwarzane przez system Windows, aby odwołać niezamierzone niezarządzane obiekty.  
  
 Ten temat zawiera następujące sekcje:  
  
 [Dlaczego SafeHandle?](#Why)   
 [Element SafeHandle jest](#Does)   
 [Klasy pochodne SafeHandle](#Derived)  
  
<a name="Why"></a>   
## <a name="why-safehandle"></a>Dlaczego SafeHandle?  
 Przed .NET Framework w wersji 2.0, wszystkie systemu operacyjnego dojścia może być tylko hermetyzowane w <xref:System.IntPtr> zarządzany otok obiektów. Gdy to wygodny sposób współdziałanie z kodem natywnym, dojść można przedostawać przez asynchroniczne wyjątki, takie jak nieoczekiwanie przerywanie wątku lub przepełnienie stosu. Te asynchroniczne wyjątki są przeszkodę Oczyszczanie zasobów systemu operacyjnego i może wystąpić niemal z dowolnego miejsca w aplikacji.  
  
 Mimo że zastąpień w celu <xref:System.Object.Finalize%2A?displayProperty=nameWithType> — metoda Zezwalaj Oczyszczanie zasobów niezarządzanych, gdy obiekt jest w trakcie bezużytecznych w pewnych okolicznościach, finalizable obiektów można odzyskać przez odzyskiwanie pamięci podczas wykonywania metody dla platformy wywołania wywołanie. Jeśli finalizator zwalnia dojście przekazane do tej platformy wywołaniem, połączenie może prowadzić do uszkodzenia obsługi. Ponadto można odzyskać dojście, gdy metodę zostanie zablokowane, gdy platforma wywołania wywołania, takich jak podczas odczytywania pliku.  
  
 Więcej wyczerpaniu ponieważ Windows odtwarzana agresywnie dojść, uchwyt można poddana recyklingowi, a wskaż inny zasób, który może zawierać dane poufne. Jest on znany jako atak odtworzenia i może potencjalnie uszkodzić dane i stanowić zagrożenie bezpieczeństwa.  
  
<a name="Does"></a>   
## <a name="what-safehandle-does"></a>Element SafeHandle jest  
 <xref:System.Runtime.InteropServices.SafeHandle> Klasa upraszcza kilka te kwestie okresu istnienia obiektów i jest zintegrowana z platformą wywołania tak, aby nie przedostają zasoby systemu operacyjnego. <xref:System.Runtime.InteropServices.SafeHandle> Klasy rozwiązuje problemy okres istnienia obiektu przypisując i zwalniania uchwytów bez przeszkód. Zawiera on krytyczne finalizatora, który zapewnia, że dojście zostało zamknięte i działanie podczas nieoczekiwany <xref:System.AppDomain> zwalnia, nawet w przypadku wywołania wywołania platformy zakłada, że jest uszkodzony.  
  
 Ponieważ <xref:System.Runtime.InteropServices.SafeHandle> dziedziczy <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, wszystkie niekrytyczne finalizatory są wywoływane przed każdą finalizatory krytyczne. Finalizatory są nazywane na obiektach, które nie są już na żywo podczas przebiegu kolekcji tej samej pamięci. Na przykład <xref:System.IO.FileStream> obiektu można uruchomić normalne finalizator opróżnić istniejące dane buforowane bez ryzyka dojścia jest ujawnione lub poddawane recyklingowi. Ten bardzo słabe kolejności między finalizatory krytyczne i niekrytyczne nie jest przeznaczony do użytku ogólnego. Istnieje głównie w celu pomocy w procesie migracji istniejącej biblioteki zezwalając te biblioteki do użycia <xref:System.Runtime.InteropServices.SafeHandle> bez zmiany ich semantyki. Ponadto krytyczne finalizatora i niczego wywołuje, takich jak <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> metody, musi być w regionie ograniczonego wykonania. To nakłada ograniczenia dotyczące kodu, jakie mogą być zapisywane w obrębie wykresu wywołań finalizatora.  
  
 Wywołanie operacji platformy automatycznie zwiększyć liczebności referencyjnej dojść zamknięte przez <xref:System.Runtime.InteropServices.SafeHandle> i zmniejszyć ich po zakończeniu. Dzięki temu, że dojście nie zostanie poddanych recyklingowi ani został nieoczekiwanie zamknięty.  
  
 Własność dojścia podstawowej można określić podczas tworzenia <xref:System.Runtime.InteropServices.SafeHandle> obiektów, podając wartość `ownsHandle` argument <xref:System.Runtime.InteropServices.SafeHandle> konstruktora klasy. Określa, to czy <xref:System.Runtime.InteropServices.SafeHandle> obiektu będzie zwolnić dojścia po usunięciu obiektu.  Jest to przydatne dla dojść wymagań specyficznych okres istnienia lub służący do konsumowania uchwytu, którego okres istnienia jest kontrolowany przez kogoś innego.  
  
<a name="Derived"></a>   
## <a name="classes-derived-from-safehandle"></a>Klasy pochodne SafeHandle  
 <xref:System.Runtime.InteropServices.SafeHandle> jest to klasa abstrakcyjna otoki dla systemu operacyjnego. Wyprowadzanie z tej klasy jest trudne. Zamiast tego należy użyć klasy pochodnej w <xref:Microsoft.Win32.SafeHandles> przestrzeni nazw, która zapewnienia bezpiecznego dojścia do następujących:  
  
-   Pliki ( <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> klasy).  
  
-   Pliki mapowane do pamięci ( <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> klasy).  
  
-   Potoki ( <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> klasy).  
  
-   Widoki pamięci ( <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> klasy).  
  
-   Konstrukcje kryptografii ( <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, i <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> klasy).  
  
-   Procesy ( <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle> klasy).  
  
-   Klucze rejestru ( <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> klasy).  
  
-   Uchwyty oczekiwania ( <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> klasy).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy niestandardowe bezpieczne dojście dla systemu operacyjnego dojście do pliku, wynikające z <xref:Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid>. Odczytuje bajtów z pliku i wyświetla wartości szesnastkowe. Zawiera także błąd testowania kontroler, która powoduje wątku przerwania, ale wartość uchwytu zostanie zwolniona.  Korzystając z <xref:System.IntPtr> do reprezentowania dojść, dojście jest czasami ujawnione ze względu na przerwanie asynchronicznego wątku.  
  
 Konieczne będzie pliku tekstowego w tym samym folderze co skompilowanej aplikacji. Przy założeniu, że nazwa aplikacji "HexViewer", jest użycie wiersza polecenia:  
  
 `HexViewer <filename> -Fault`  
  
 Opcjonalnie można określić `-Fault` celowo prób wyciek dojście przez przerywanie wątku w niektórych okna. Narzędzie Perform.exe systemu Windows do monitorowania liczby dojścia podczas wstrzyknięcie błędów.  
  
 [!code-csharp[SafeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">aby uzyskać pełne zaufanie dla obiektów dziedziczących. Ten element członkowski nie może być dziedziczona przez kod częściowo zaufany.</permission>
    <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
    <block subset="none" type="overrides">
      <para>Aby utworzyć klasę pochodzącą od <see cref="T:System.Runtime.InteropServices.SafeHandle" />, musisz znać sposób tworzenia i zwolnić dojścia systemu operacyjnego. Ten proces jest inna dojście do różnych typów, ponieważ niektóre używają [CloseHandle](https://msdn.microsoft.com/library/windows/desktop/ms724211.aspx) działanie, a inni korzystają więcej określonych funkcji takich jak [UnmapViewOfFile](https://msdn.microsoft.com/library/windows/desktop/aa366882.aspx) lub [FindClose](https://msdn.microsoft.com/library/windows/desktop/aa364413.aspx). Z tego powodu należy utworzyć klasy pochodnej z <see cref="T:System.Runtime.InteropServices.SafeHandle" /> dla każdego typu dojścia systemu operacyjnego, który ma być zawijany w bezpieczne dojście.  
  
 Przy dziedziczeniu z <see cref="T:System.Runtime.InteropServices.SafeHandle" />, konieczne jest przesłonięcie następujących członków: <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> i <see cref="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />.  
  
 Należy również wprowadzić domyślnego konstruktora, który Konstruktor podstawowej z wartością, która reprezentuje wartości nieprawidłowego dojścia i <see cref="T:System.Boolean" /> wartość wskazującą, czy jest własnością uchwyt macierzysty <see cref="T:System.Runtime.InteropServices.SafeHandle" /> i w związku z tym powinien zostać zwolniony podczas które <see cref="T:System.Runtime.InteropServices.SafeHandle" /> został usunięty.</para>
    </block>
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
    <altmember cref="T:System.Runtime.InteropServices.CriticalHandle" />
    <altmember cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle (IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (invalidHandleValue As IntPtr, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue">Wartość nieprawidłowego dojścia (zazwyczaj 0 lub wartość-1).  Implementacji <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> powinien zwrócić <see langword="true" /> dla tej wartości.</param>
        <param name="ownsHandle">
          <see langword="true" /> Aby umożliwić niezawodnie <see cref="T:System.Runtime.InteropServices.SafeHandle" /> zwolnić dojścia w fazie finalizacji; w przeciwnym razie <see langword="false" /> (niezalecane).</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.InteropServices.SafeHandle" /> klasy z wartością określony nieprawidłowy uchwyt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `ownsHandle` parametr jest `false`, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> nigdy nie jest wywoływana; w związku z tym nie jest zalecane do użycia wartości tego parametru, jak kod wycieku zasobów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeLoadException">Klasa pochodna znajduje się w zestawie bez uprawnienia dostępu do kodu niezarządzanego.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">aby uzyskać pełne zaufanie dla obiektów dziedziczących. Ten element członkowski nie może być dziedziczona przez kod częściowo zaufany.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Oznacza dojście do zwalniania i zwolnić zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> lub <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metoda pozwala zasoby, które ma zostać zwolniony. Może się nie powtórzyła natychmiast inne wątki korzystania z tego samego obiektu bezpieczne dojście, ale odbędzie się, gdy nie jest już wymagane. Mimo że większość klas, które używają <xref:System.Runtime.InteropServices.SafeHandle> klasy nie trzeba podać finalizator, czasami jest to konieczne, (na przykład, aby opróżnić limit buforów plików lub do zapisu niektóre dane z powrotem do pamięci). W takim przypadku klasa może zapewnić finalizatorze działanie przed <xref:System.Runtime.InteropServices.SafeHandle> działa finalizator krytyczne.  
  
 Wywołanie <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> lub <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metody po zakończeniu przy użyciu <xref:System.Runtime.InteropServices.SafeHandle> obiektu.  
  
> [!NOTE]
>  Wywoływanie zawsze <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> lub <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> przed zwolnieniem ostatniego odwołania do <xref:System.Runtime.InteropServices.SafeHandle> obiektu. W przeciwnym razie używa zasobów nie zostanie zwolniona do wywołania modułu zbierającego elementy bezużyteczne <xref:System.Runtime.InteropServices.SafeHandle> obiektu <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> metody.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousAddRef">
      <MemberSignature Language="C#" Value="public void DangerousAddRef (ref bool success);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousAddRef(bool&amp; success) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousAddRef (ByRef success As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousAddRef(bool % success);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="success" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="success">
          <see langword="true" /> Jeśli licznik odwołanie zostało pomyślnie zwiększany; w przeciwnym razie <see langword="false" />.</param>
        <summary>Ręcznie zwiększa licznik odwołania na <see cref="T:System.Runtime.InteropServices.SafeHandle" /> wystąpień.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> Metody uniemożliwia odzyskiwanie pamięci używanej przez dojście środowisko uruchomieniowe języka wspólnego (które występuje, gdy środowisko urchomieniowe wywołuje <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> metody). Można użyć tę metodę, aby ręcznie przyrostu count odwołanie <xref:System.Runtime.InteropServices.SafeHandle> wystąpienia. <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> Zwraca wartość logiczną przy użyciu `ref` parametr (`success`) wskazująca, czy liczba odwołań został pomyślnie zwiększany. Dzięki temu logika program do Wycofaj w razie awarii. Należy ustawić `success` do `false` przed wywołaniem <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. Jeśli `success` jest `true`, uniknąć przecieków zasobów przez dopasowanie wywołanie <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> z odpowiedniego wywołania <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.  
  
> [!CAUTION]
>  Ta metoda jest przeznaczona dla użytkowników zaawansowanych i zawsze należy używać ostrożnie. Aby uniknąć przeciek dojścia zasobów, zawsze należy wywołać tę metodę w regionie ograniczonego wykonania (CER), gdzie przerwania wątku nie może przerwać przetwarzania.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      </Docs>
    </Member>
    <Member MemberName="DangerousGetHandle">
      <MemberSignature Language="C#" Value="public IntPtr DangerousGetHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int DangerousGetHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle" />
      <MemberSignature Language="VB.NET" Value="Public Function DangerousGetHandle () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr DangerousGetHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" /> pola.</summary>
        <returns>
          <see langword="IntPtr" /> Reprezentujący wartość <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" /> pola. Jeśli dojście została oznaczona jako niepoprawna z <see cref="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />, ta metoda zwraca nadal oryginalnej wartości dojścia może być wartością przestarzałe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do pobierania wartości rzeczywistych dojście wystąpienia programu <xref:System.Runtime.InteropServices.SafeHandle> klasy. Ta metoda jest potrzebne do zapewnienia zgodności ponieważ zwraca wiele właściwości w programie .NET Framework `IntPtr` obsługi typów. `IntPtr` typ dojścia są specyficzne dla platformy typy używane do reprezentowania wskaźnika lub dojścia.  
  
> [!CAUTION]
>  Przy użyciu <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> metody może stanowić zagrożenie bezpieczeństwa, ponieważ, jeśli dojście została oznaczona jako niepoprawna z <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> nadal zwraca wartość oryginalne, potencjalnie starych dojścia. Zwracane dojście można także ponownie przetworzony w dowolnym momencie. W najlepszym przypadku oznacza to, że dojście może nagle przestać działać. W najgorszym przypadku dojście lub zasób, który reprezentuje dojście udostępnienia w kodzie niezaufanym, może to prowadzić do odtwarzania ataku zabezpieczeń na dojście ponownie lub zwrócony. Na przykład niezaufanych wywołujący może zapytania na danych w dojściu tylko zwrócił i otrzymywanie informacji dla zasób całości niepowiązanych. Zobacz <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> i <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> metod, aby uzyskać więcej informacji o korzystaniu z <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> methodsafely.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousRelease">
      <MemberSignature Language="C#" Value="public void DangerousRelease ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousRelease() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousRelease ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousRelease();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ręcznie zmniejsza licznika odwołania na <see cref="T:System.Runtime.InteropServices.SafeHandle" /> wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> Metoda jest odpowiednikiem <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. Wywołanie zawsze powinna odpowiadać <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> metody z pomyślnym wywołaniem <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.  
  
> [!CAUTION]
>  Ta metoda jest przeznaczona dla użytkowników zaawansowanych i zawsze należy używać ostrożnie. Aby uniknąć przeciek dojścia zasobów, zawsze należy wywołać tę metodę w regionie ograniczonego wykonania (CER), gdzie przerwania wątku nie może przerwać przetwarzania. W taki sam sposób, że niedopasowane <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> wywołań może spowodować przecieków zasobów, niedopasowanych <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> wywołań może spowodować nieprawidłowe dojście Państwa staną się widoczne dla innych wątków. Nie ujawniaj <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> lub <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> wywołań kodzie niezaufanym.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.Runtime.InteropServices.SafeHandle" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez <see cref="T:System.Runtime.InteropServices.SafeHandle" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> lub <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metoda pozwala zasoby, które ma zostać zwolniony. Może się nie powtórzyła natychmiast inne wątki korzystania z tego samego wystąpienia bezpieczne dojście, ale odbędzie się, gdy nie jest już wymagane. Mimo że większość klas przy użyciu <xref:System.Runtime.InteropServices.SafeHandle> nie trzeba podać finalizator, czasami jest to konieczne, (na przykład można opróżnić limit buforów plików lub zapisania niektóre dane w pamięci). W takim przypadku zapewniają finalizatorze działanie przed <xref:System.Runtime.InteropServices.SafeHandle> działa finalizator krytyczne.  
  
 Wywołanie <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> lub <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metody po zakończeniu przy użyciu <xref:System.Runtime.InteropServices.SafeHandle> obiektu. <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> Pozostawia metody <xref:System.Runtime.InteropServices.SafeHandle> obiektu w stanie uniemożliwiającym jego używanie.  
  
> [!NOTE]
>  Wywoływanie zawsze <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> lub <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metoda przed zwolnieniem ostatniego odwołania do <xref:System.Runtime.InteropServices.SafeHandle> obiektu. W przeciwnym razie używa zasobów nie zostanie zwolniona do wywołania modułu zbierającego elementy bezużyteczne <xref:System.Runtime.InteropServices.SafeHandle> obiektu <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> metody.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> dla zwykłym dispose operacji. <see langword="false" /> celu sfinalizowania dojście.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Runtime.InteropServices.SafeHandle" /> klasa określająca, czy do wykonania zwykłym dispose operacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy nigdy nie jawnie wywołać <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metody z `disposing` ustawiono parametr `false`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SafeHandle ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby skojarzone z dojścia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> Metoda jest destruktor dla elementu <xref:System.Runtime.InteropServices.SafeHandle> klasy. Kod aplikacji nie należy bezpośrednio wywołać tej metody.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberSignature Language="VB.NET" Value="Protected handle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: IntPtr handle;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa dojście w celu jej opakowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie ujawniaj dojście publicznie (to znaczy poza klasy pochodnej).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy dojście jest zamknięty.</summary>
        <value>
          <see langword="true" /> Jeśli zostanie zamknięty dojście; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> Metoda zwraca wartość wskazującą czy <xref:System.Runtime.InteropServices.SafeHandle> obiektu dojście nie jest już skojarzony z zasobem macierzystego. Ta różni się od definicji <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> właściwość, która oblicza, czy podanym dojściu zawsze jest uznawane za nieprawidłowe. <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> Metoda zwraca `true` wartość w następujących przypadkach:  
  
-   <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> Wywołano metodę.  
  
-   <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> Metody lub <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> wywołano metodę i nie żadnych odwołań do <xref:System.Runtime.InteropServices.SafeHandle> obiektu na inne wątki.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsInvalid { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy wartość dojście jest nieprawidłowe.</summary>
        <value>
          <see langword="true" /> Jeśli wartość uchwytu jest nieprawidłowy. w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne muszą implementować <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> właściwości tak, aby środowisko uruchomieniowe języka wspólnego można określić, czy finalizacji krytyczne jest wymagana. Klasa pochodna musi zapewniać implementację pasujące do typu ogólnego uchwytu, które obsługują (0 albo -1 jest nieprawidłowy). Te klasy można następnie dalsze pochodnych typów określonych bezpieczne dojście.  
  
 W odróżnieniu od <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> właściwość, która zgłasza czy <xref:System.Runtime.InteropServices.SafeHandle> obiektu zakończył przy użyciu dojścia podstawowej <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> właściwości oblicza, czy wartość podanym dojściu zawsze jest uznawane za nieprawidłowe. W związku z tym <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> właściwość zawsze zwraca tę samą wartość dowolną wartość z określonego dojścia.  
  
   
  
## Examples  
 Poniższy przykład umożliwia sprawdzenie, czy plik został pomyślnie otwarty. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Runtime.InteropServices.SafeHandle> klasy.  
  
 [!code-csharp[SafeHandle#2](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function ReleaseHandle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool ReleaseHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wykonuje kod wymagany do zwolnienia dojście.</summary>
        <returns>
          <see langword="true" /> Jeśli dojście zwolnieniu pomyślnie; w przeciwnym razie poważnej awarii, <see langword="false" />. W takim przypadku generuje [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Asystent debugowania zarządzanego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> Można wywołać tylko raz i tylko wtedy, gdy uchwyt jest prawidłowy, zgodnie z definicją metody jest gwarancji <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> właściwości. Zaimplementuj tę metodę w Twojej <xref:System.Runtime.InteropServices.SafeHandle> klas do wykonania kodu, który jest wymagany, aby zwolnić dojścia pochodnych. Ponieważ jeden z funkcji <xref:System.Runtime.InteropServices.SafeHandle> jest zapewnienie zapobiegania przecieków zasobów, kod w implementacji <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> musi nigdy się nie powieść. Wywołania modułu zbierającego elementy bezużyteczne <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> po uruchomieniu normalne finalizatory dla obiektów, które były bezużytecznych w tym samym czasie. Moduł zbierający elementy bezużyteczne gwarantuje zasobów, aby wywołać tę metodę i czy metoda nie zostanie przerwana czasie, gdy jest w toku. Ta metoda będzie gotowa jako region ograniczonego wykonania (CER) w czasie tworzenia wystąpienia (wraz ze wszystkich metod jej wykresu wywołań statycznie możliwa do ustalenia). Mimo że zapobiega to przerwania przerwania wątku, nadal należy pamiętać, że żadnych ścieżek błędów w Twojej przesłoniętych <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> metody. W szczególności, zastosuj <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> atrybutu metody należy wywołać z <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>. W większości przypadków należy ten kod:  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 Ponadto w przypadku prostego oczyszczania (na przykład wywołanie interfejsu API Win32 `CloseHandle` na dojście do pliku) można sprawdzić wartość zwrotną dla pojedynczą platformę wywołania wywołania. Złożone oczyszczania może mieć wiele logice programu i wielu wywołań metody, z których część może zakończyć się niepowodzeniem. Należy upewnij się, że logika program ma rezerwowy kod dla każdego z tych przypadkach.  
  
 Jeśli <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> zwraca `false` z jakiejkolwiek przyczyny, generuje [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Asystent debugowania zarządzanego.  Dzięki temu można wykryć przypadkach, gdy nie próba zwolnienia zasobów.  
  
   
  
## Examples  
 Poniższy przykład kodu zwalnia dojście i jest częścią większego przykładu udostępnionego dla <xref:System.Runtime.InteropServices.SafeHandle> klasy.  
  
 [!code-csharp[SafeHandle#3](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetHandle(IntPtr handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Istniejące dojście do użycia.</param>
        <summary>Ustawia określone dojście istniejące dojście.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> metody tylko wtedy, gdy wymaganych do obsługi istniejącego dojścia (na przykład jeśli dojście jest zwracany w strukturze), ponieważ infrastruktury międzyoperacyjnego modelu COM programu .NET Framework nie obsługuje przekazywanie danych wyjściowych dojść w strukturze.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetHandleAsInvalid ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetHandleAsInvalid();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Oznacza dojścia jako nie jest już używana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> metody tylko wtedy, gdy wiesz, że uchwyt nie odwołuje się do zasobu. Dzięki temu nie zmienia wartości <xref:System.Runtime.InteropServices.SafeHandle.handle> pole; tylko program oznacza dojście jako zamknięte. Dojście następnie może zawierać potencjalnie starych wartości. To wywołanie powoduje, że nie są podejmowane próby zwolnienia zasobów.  
  
 Jak <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> metody, użyj <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> tylko wtedy, gdy wymagana jest obsługa istniejące dojście.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>
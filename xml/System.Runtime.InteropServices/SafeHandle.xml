<Type Name="SafeHandle" FullName="System.Runtime.InteropServices.SafeHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9388ac52545afb66815297eef0c8e4a5ae10a715" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69063507" /></Metadata><TypeSignature Language="C#" Value="public abstract class SafeHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit SafeHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.SafeHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SafeHandle&#xA;Inherits CriticalFinalizerObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SafeHandle abstract : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="F#" Value="type SafeHandle = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje klasę otoki dla dojść systemu operacyjnego. Ta klasa musi być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle> Klasa zapewnia krytyczną finalizację zasobów obsługi, uniemożliwiając odzyskiwanie dojść przedwcześnie przez wyrzucanie elementów bezużytecznych i odzyskiwanie ich przez system Windows w celu odwoływania się do niezamierzonych obiektów niezarządzanych.  
  
 Ten temat zawiera następujące sekcje:  
  
 [Dlaczego element SafeHandle?](#Why)   
 [Jakiego elementu SafeHandle robi](#Does)   
 [Klasy pochodzące od elementu SafeHandle](#Derived)  
  
<a name="Why"></a>   
## <a name="why-safehandle"></a>Dlaczego element SafeHandle?  
 Przed .NET Framework w wersji 2,0 wszystkie uchwyty systemu operacyjnego mogą być hermetyzowane tylko w <xref:System.IntPtr> zarządzanym obiekcie otoki. Chociaż jest to wygodny sposób współdziałania z kodem natywnym, uchwyty mogą być przeciekami przez asynchroniczne wyjątki, takie jak nieoczekiwane przerywanie wątku lub przepełnienie stosu. Te wyjątki asynchroniczne są przeszkodą w czyszczeniu zasobów systemu operacyjnego i mogą wystąpić niemal w dowolnym miejscu w aplikacji.  
  
 Chociaż przesłonięcia <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metody Zezwalaj na czyszczenie niezarządzanych zasobów, gdy obiekt jest odzyskiwany, w pewnych okolicznościach można odzyskiwać obiekty przez wyrzucanie elementów bezużytecznych podczas wykonywania metody w wywołaniu platformy połączeń. Jeśli finalizator zwolni dojście do wywołania wywoływanego przez tę platformę, może dojść do obsłużenia uszkodzenia. Dojście może również zostać odczytane, gdy metoda jest blokowana podczas wywołania wywołania platformy, na przykład podczas odczytywania pliku.  
  
 Bardziej krytycznie, ponieważ system Windows agresywnie odtwarza dojścia, dojście może być odtwarzane i wskazywać na inny zasób, który może zawierać poufne dane. Jest to nazywane atakami polegającymi na recyklingu i może potencjalnie uszkodzić dane oraz stanowić zagrożenie bezpieczeństwa.  
  
<a name="Does"></a>   
## <a name="what-safehandle-does"></a>Jakiego elementu SafeHandle robi  
 <xref:System.Runtime.InteropServices.SafeHandle> Klasa upraszcza kilka z tych problemów z okresem istnienia obiektu i jest zintegrowana z wywołaniem platformy, co sprawia, że zasoby systemu operacyjnego nie są wyciekami. <xref:System.Runtime.InteropServices.SafeHandle> Klasa rozwiązuje problemy dotyczące okresu istnienia obiektu przez przypisanie i zwolnienie dojść bez przeszkód. Zawiera krytyczne finalizatory, które gwarantują, że dojście jest zamknięte i jest gwarantowane, że <xref:System.AppDomain> zostanie uruchomione podczas nieoczekiwanego zwalniania, nawet w przypadku, gdy założono, że wywołanie wywołania platformy jest uszkodzone.  
  
 Ponieważ <xref:System.Runtime.InteropServices.SafeHandle> dziedziczy po <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, wszystkie niekrytyczne finalizatory są wywoływane przed którymkolwiek z najważniejszych finalizatorów. Finalizatory są wywoływane na obiektach, które nie są już aktywne podczas tego samego przebiegu elementów bezużytecznych. Na przykład <xref:System.IO.FileStream> obiekt może uruchomić normalne finalizatory, aby opróżnić istniejące dane buforowane bez ryzyka przecieku lub odtwarzania dojścia. To bardzo słabe porządkowanie między najważniejszymi i niekrytycznymi finalizatorami nie jest przeznaczone do użytku ogólnego. Istnieje głównie do ułatwienia migracji istniejących bibliotek, umożliwiając używanie <xref:System.Runtime.InteropServices.SafeHandle> tych bibliotek bez zmiany ich semantyki. Ponadto krytyczny finalizator i wszystkie wywołania, takie jak <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> Metoda, muszą znajdować się w ograniczonym regionie wykonania. Nakłada to ograniczenia dotyczące tego, jaki kod można napisać na grafie wywołań finalizatora.  
  
 Operacje wywołania platformy automatycznie zwiększają liczbę odwołań do dojść hermetyzowanych przez <xref:System.Runtime.InteropServices.SafeHandle> a i zmniejszają je po zakończeniu. Gwarantuje to, że dojście nie będzie odtwarzane ani nieoczekiwanie zamknięte.  
  
 Można określić własność bazowego dojścia podczas konstruowania <xref:System.Runtime.InteropServices.SafeHandle> obiektów, dostarczając wartość `ownsHandle` do argumentu w <xref:System.Runtime.InteropServices.SafeHandle> konstruktorze klasy. Określa, <xref:System.Runtime.InteropServices.SafeHandle> czy obiekt zwolni uchwyt po usunięciu obiektu.  Jest to przydatne w przypadku dojść o szczególnych wymaganiach dotyczących okresu istnienia lub korzystania z dojścia, którego okres istnienia jest kontrolowany przez kogoś innego.  
  
<a name="Derived"></a>   
## <a name="classes-derived-from-safehandle"></a>Klasy pochodzące od elementu SafeHandle  
 <xref:System.Runtime.InteropServices.SafeHandle>jest abstrakcyjną klasą otoki dla dojść systemu operacyjnego. Wyprowadzanie z tej klasy jest trudne. Zamiast tego należy użyć klas pochodnych w <xref:Microsoft.Win32.SafeHandles> przestrzeni nazw, które zapewniają bezpieczne uchwyty dla następujących:  
  
-   Pliki ( <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> Klasa).  
  
-   Pliki mapowane w <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> pamięci (Klasa).  
  
-   Potoki ( <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> Klasa).  
  
-   Widoki pamięci ( <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> Klasa).  
  
-   Konstrukcje kryptografii ( <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>i <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> ).  
  
-   Procesy ( <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle> Klasa).  
  
-   Klucze rejestru ( <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> Klasa).  
  
-   Uchwyty oczekiwania ( <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> Klasa).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy niestandardowe, bezpieczne dojście do pliku systemu operacyjnego, wynikające z programu <xref:Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid>. Odczytuje bajty z pliku i wyświetla ich wartości szesnastkowe. Zawiera również zespół testowania błędów, który powoduje przerwanie wątku, ale wartość dojścia jest zwalniana.  W przypadku użycia <xref:System.IntPtr> do reprezentowania dojść, dojście jest sporadycznie wycieków z powodu asynchronicznego przerwania wątku.  
  
 Potrzebny będzie plik tekstowy w tym samym folderze co skompilowana aplikacja. Przy założeniu, że nazwa aplikacji to "HexViewer", użycie wiersza polecenia to:  
  
 `HexViewer <filename> -Fault`  
  
 Opcjonalnie można `-Fault` określić celową próbę przeciekania dojścia przez przerwanie wątku w określonym oknie. Użyj narzędzia Windows perfmon. exe, aby monitorować liczby dojść podczas wstrzykiwania błędów.  
  
 [!code-csharp[SafeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">aby uzyskać pełne zaufanie dla obiektów dziedziczących. Ten element członkowski nie może być dziedziczony przez częściowo zaufany kod.</permission>
    <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
    <block subset="none" type="overrides"><para>Aby utworzyć klasę pochodną od <see cref="T:System.Runtime.InteropServices.SafeHandle" />, należy znać sposób tworzenia i zwalniania dojścia systemu operacyjnego. Ten proces jest różny dla różnych typów uchwytów, ponieważ niektóre wykorzystują funkcję [CloseHandle](https://msdn.microsoft.com/library/windows/desktop/ms724211.aspx) , podczas gdy inne wykorzystują bardziej specyficzne funkcje, takie jak [Funkcja UnmapViewOfFile](https://msdn.microsoft.com/library/windows/desktop/aa366882.aspx) lub [FindClose](https://msdn.microsoft.com/library/windows/desktop/aa364413.aspx). Z tego powodu należy utworzyć klasę <see cref="T:System.Runtime.InteropServices.SafeHandle" /> pochodną dla każdego typu dojścia systemu operacyjnego, który ma być zawijany w bezpiecznym obsłudze.  
  
W przypadku dziedziczenia <see cref="T:System.Runtime.InteropServices.SafeHandle" />z należy zastąpić następujące elementy członkowskie: <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> i <see cref="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />.  
  
Należy również dostarczyć Konstruktor bez parametrów, który wywołuje konstruktora podstawowego z wartością, która reprezentuje nieprawidłową wartość dojścia, i <see cref="T:System.Boolean" /> wartość wskazującą, czy uchwyt macierzysty należy do, i w <see cref="T:System.Runtime.InteropServices.SafeHandle" /> związku z tym powinien zostać zwolniony <see cref="T:System.Runtime.InteropServices.SafeHandle" /> gdy został usunięty.</para></block>
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
    <altmember cref="T:System.Runtime.InteropServices.CriticalHandle" />
    <altmember cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle (IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (invalidHandleValue As IntPtr, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.SafeHandle : nativeint * bool -&gt; System.Runtime.InteropServices.SafeHandle" Usage="new System.Runtime.InteropServices.SafeHandle (invalidHandleValue, ownsHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue">Wartość nieprawidłowego dojścia (zwykle 0 lub-1).  Twoja implementacja <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> powinna zwracać <see langword="true" /> wartość dla tej wartości.</param>
        <param name="ownsHandle"><see langword="true" />Aby niezawodnie <see cref="T:System.Runtime.InteropServices.SafeHandle" /> zezwolić na wydawanie dojścia w fazie finalizowania; <see langword="false" /> w przeciwnym razie (niezalecane).</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Runtime.InteropServices.SafeHandle" /> klasy z określoną nieprawidłową wartością dojścia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli parametr ma `false`wartość, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> nie jest nigdy wywoływany, dlatego nie zaleca się używania tej wartości parametru, ponieważ kod może wyciekać zasoby. `ownsHandle`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeLoadException">Klasa pochodna znajduje się w zestawie bez uprawnień dostępu do kodu niezarządzanego.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">aby uzyskać pełne zaufanie dla obiektów dziedziczących. Ten element członkowski nie może być dziedziczony przez częściowo zaufany kod.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="safeHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;netstandard-1.5">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Oznacza dojście do zwalniania i zwalniania zasobów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie metody <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> lub umożliwia zwolnienie zasobów. <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> Może to nie nastąpić natychmiast, jeśli inne wątki używają tego samego bezpiecznego obiektu obsługi, ale nastąpi to tak szybko, jak to już się nie dzieje. Chociaż większość klas, które używają <xref:System.Runtime.InteropServices.SafeHandle> klasy nie musi dostarczać finalizatora, jest to czasami konieczne (na przykład w celu opróżnienia buforów plików lub zapisania danych z powrotem do pamięci). W takim przypadku Klasa może zapewnić finalizator, który jest gwarantowany do uruchomienia przed <xref:System.Runtime.InteropServices.SafeHandle> uruchomieniem krytycznego finalizatora.  
  
 Wywoływanie metody <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> <xref:System.Runtime.InteropServices.SafeHandle> lub po zakończeniu korzystania z obiektu. <xref:System.Runtime.InteropServices.SafeHandle.Close%2A>  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> lub <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> przed zwolnieniem ostatniego odwołania do <xref:System.Runtime.InteropServices.SafeHandle> obiektu. W przeciwnym razie używane zasoby nie zostaną zwolnione do momentu wywołania <xref:System.Runtime.InteropServices.SafeHandle> <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> metody obiektu przez moduł zbierający elementy bezużyteczne.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu uzyskania uprawnień do wywoływania kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousAddRef">
      <MemberSignature Language="C#" Value="public void DangerousAddRef (ref bool success);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousAddRef(bool&amp; success) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousAddRef (ByRef success As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousAddRef(bool % success);" />
      <MemberSignature Language="F#" Value="member this.DangerousAddRef :  -&gt; unit" Usage="safeHandle.DangerousAddRef success" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-1.5;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="success" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="success"><see langword="true" />Jeśli licznik odwołań został pomyślnie zwiększony; w przeciwnym razie. <see langword="false" /></param>
        <summary>Ręcznie zwiększa licznik odwołań w <see cref="T:System.Runtime.InteropServices.SafeHandle" /> wystąpieniach.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda uniemożliwia środowisko uruchomieniowe języka wspólnego odzyskiwanie pamięci używanej przez dojście (które występuje, gdy środowisko uruchomieniowe <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> wywołuje metodę). <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> Za pomocą tej metody można ręcznie zwiększyć liczbę <xref:System.Runtime.InteropServices.SafeHandle> odwołań do wystąpienia. <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>Zwraca wartość logiczną przy użyciu `ref` parametru (`success`), który wskazuje, czy licznik odwołań został pomyślnie zwiększony. Dzięki temu logika programu może zostać wycofana w razie awarii. Należy ustawić na `success` `false` wartość przed wywołaniem metody <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. Jeśli `success` <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>tak `true`, unikaj przecieków zasobów, dopasowując wywołanie do z odpowiednim wywołaniem do.  
  
> [!CAUTION]
>  Ta metoda jest przeznaczona dla zaawansowanych użytkowników i zawsze musi być używana ostrożnie. Aby uniknąć przecieków zasobów obsługi, zawsze Wywołaj tę metodę w ograniczonym regionie wykonywania (CER), w którym przerwanie wątku nie może przerwać przetwarzania.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu uzyskania uprawnień do wywoływania kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      </Docs>
    </Member>
    <Member MemberName="DangerousGetHandle">
      <MemberSignature Language="C#" Value="public IntPtr DangerousGetHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int DangerousGetHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle" />
      <MemberSignature Language="VB.NET" Value="Public Function DangerousGetHandle () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr DangerousGetHandle();" />
      <MemberSignature Language="F#" Value="member this.DangerousGetHandle : unit -&gt; nativeint" Usage="safeHandle.DangerousGetHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" /> pola.</summary>
        <returns>Reprezentujący wartość <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />pola. <see langword="IntPtr" /> Jeśli dojście zostało oznaczone jako nieprawidłowe z <see cref="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />, ta metoda nadal zwraca oryginalną wartość dojścia, która może być nieodświeżoną wartością.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody można użyć do pobrania rzeczywistej wartości uchwytu z wystąpienia <xref:System.Runtime.InteropServices.SafeHandle> klasy pochodnej. Ta metoda jest wymagana w celu zapewnienia zgodności z poprzednimi wersjami, ponieważ `IntPtr` wiele właściwości w .NET Framework zwracanych typów dojścia. `IntPtr`typy uchwytów to typy specyficzne dla platformy służące do reprezentowania wskaźnika lub dojścia.  
  
> [!CAUTION]
>  Użycie metody może stanowić zagrożenie bezpieczeństwa, ponieważ, jeśli dojście zostało oznaczone jako nieprawidłowe przy użyciu <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> nadal zwraca oryginalną, potencjalnie nieodświeżoną wartość dojścia. <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> Zwracanego uchwytu można również odtworzyć w dowolnym momencie. Z tego względu, dojście może nagle przestać działać. W najgorszym przypadku, jeśli dojście lub zasób reprezentowane przez dojście jest uwidocznione dla niezaufanego kodu, może to prowadzić do odzyskania zabezpieczeń w przypadku ponownego użycia lub zwrócenia uchwytu. Na przykład niezaufany obiekt wywołujący może wykonywać zapytania dotyczące danych w dojściem i odbierać informacje dla całkowicie niepowiązanego zasobu. <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> Zobacz <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> i metody, aby uzyskać więcej informacji na temat korzystania z methodsafely. <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu uzyskania uprawnień do wywoływania kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousRelease">
      <MemberSignature Language="C#" Value="public void DangerousRelease ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousRelease() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousRelease ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousRelease();" />
      <MemberSignature Language="F#" Value="member this.DangerousRelease : unit -&gt; unit" Usage="safeHandle.DangerousRelease " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-1.5;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ręcznie zmniejsza licznik <see cref="T:System.Runtime.InteropServices.SafeHandle" /> odwołań do wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> Metoda jest odpowiednikiem <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. Należy zawsze dopasować wywołanie <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> metody z powodzeniem wywołaniem do. <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>  
  
> [!CAUTION]
>  Ta metoda jest przeznaczona dla zaawansowanych użytkowników i zawsze musi być używana ostrożnie. Aby uniknąć przecieków zasobów obsługi, zawsze Wywołaj tę metodę w ograniczonym regionie wykonywania (CER), w którym przerwanie wątku nie może przerwać przetwarzania. W taki sam sposób, w jaki niedopasowane <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> wywołania mogą spowodować przecieki zasobów, <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> niedopasowane wywołania mogą spowodować, że nieprawidłowe stany obsługi staną się widoczne dla innych wątków. Nie ujawniaj <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> ani <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> nie wywołują niezaufanego kodu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu uzyskania uprawnień do wywoływania kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.Runtime.InteropServices.SafeHandle" /> klasę.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="safeHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez <see cref="T:System.Runtime.InteropServices.SafeHandle" /> klasę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie metody <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> lub umożliwia zwolnienie zasobów. <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> Może to nie nastąpić natychmiast, jeśli inne wątki używają tego samego wystąpienia bezpiecznego dojścia, ale będą wykonywane zaraz po tym, jak to już się nie dzieje. Chociaż większość klas używających <xref:System.Runtime.InteropServices.SafeHandle> nie musi dostarczać finalizatora, jest to czasami konieczne (na przykład w celu opróżnienia buforów plików lub zapisania danych z powrotem do pamięci). W takim przypadku mogą zapewnić finalizator, który jest gwarantowany do uruchomienia przed <xref:System.Runtime.InteropServices.SafeHandle> uruchomieniem krytycznego finalizatora.  
  
 Wywoływanie metody <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> <xref:System.Runtime.InteropServices.SafeHandle> lub po zakończeniu korzystania z obiektu. <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> Metoda<xref:System.Runtime.InteropServices.SafeHandle> pozostawia obiekt w stanie niezdatnym do użytku.  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> metodę lub <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> przed wydaniem ostatniego odwołania do <xref:System.Runtime.InteropServices.SafeHandle> obiektu. W przeciwnym razie używane zasoby nie zostaną zwolnione do momentu wywołania <xref:System.Runtime.InteropServices.SafeHandle> <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> metody obiektu przez moduł zbierający elementy bezużyteczne.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu uzyskania uprawnień do wywoływania kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="safeHandle.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />dla normalnej operacji Dispose; <see langword="false" /> w celu sfinalizowania dojścia.</param>
        <summary>Zwalnia niezarządzane zasoby używane przez klasę, <see cref="T:System.Runtime.InteropServices.SafeHandle" /> określając, czy należy wykonać normalną operację Dispose.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nigdy nie należy jawnie wywołać <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metody `disposing` z parametrem ustawionym na `false`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu uzyskania uprawnień do wywoływania kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SafeHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="safeHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby skojarzone z dojściem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest destruktorem <xref:System.Runtime.InteropServices.SafeHandle>klasy. <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> Kod aplikacji nie powinien wywoływać tej metody bezpośrednio.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu uzyskania uprawnień do wywoływania kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberSignature Language="VB.NET" Value="Protected handle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: IntPtr handle;" />
      <MemberSignature Language="F#" Value="val mutable handle : nativeint" Usage="System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa uchwyt, który ma być opakowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie ujawniaj dojścia publicznie (czyli poza klasą pochodną).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClosed : bool" Usage="System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy dojście jest zamknięte.</summary>
        <value><see langword="true" />Jeśli dojście jest zamknięte; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zwraca wartość wskazującą, <xref:System.Runtime.InteropServices.SafeHandle> czy uchwyt obiektu nie jest już skojarzony z zasobem macierzystym. <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> Różni się to od definicji <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> właściwości, która oblicza, czy dany uchwyt jest zawsze uznawany za nieprawidłowy. <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> Metoda`true` zwraca wartość w następujących przypadkach:  
  
-   <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> Metoda została wywołana.  
  
-   Metoda lub <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> Metoda została wywołana i nie ma odwołań do <xref:System.Runtime.InteropServices.SafeHandle> obiektu w innych wątkach. <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu uzyskania uprawnień do wywoływania kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsInvalid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInvalid : bool" Usage="System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera wartość wskazującą, czy wartość dojścia jest nieprawidłowa.</summary>
        <value><see langword="true" />Jeśli wartość dojścia jest nieprawidłowa; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne muszą implementować <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> właściwość, aby środowisko uruchomieniowe języka wspólnego mogły ustalić, czy wymagana jest finalizacja krytyczna. Klasy pochodne muszą dostarczać implementację, która odpowiada typowi obsługiwanego uchwytu (0 lub-1 jest nieprawidłowa). Klasy te mogą następnie być bardziej pochodne dla konkretnych bezpiecznych typów uchwytów.  
  
 W przeciwieństwie <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> do właściwości, która raportuje <xref:System.Runtime.InteropServices.SafeHandle> , czy obiekt zakończył korzystanie <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> z bazowego dojścia, właściwość oblicza, czy dana wartość dojścia jest zawsze uznawana za nieprawidłową. W związku z <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> tym właściwość zawsze zwraca tę samą wartość dla każdej wartości dojścia.  
  
   
  
## Examples  
 Poniższy przykład sprawdza, czy plik został pomyślnie otwarty. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Runtime.InteropServices.SafeHandle> klasy.  
  
 [!code-csharp[SafeHandle#2](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu uzyskania uprawnień do wywoływania kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function ReleaseHandle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool ReleaseHandle();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseHandle : unit -&gt; bool" Usage="safeHandle.ReleaseHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, wykonuje kod wymagany do zwolnienia dojścia.</summary>
        <returns><see langword="true" />Jeśli dojście zostało pomyślnie wydane; w przeciwnym razie w przypadku błędu <see langword="false" />krytycznego. W takim przypadku generuje asystenta zarządzanego debugowania <see href="https://docs.microsoft.com/dotnet/framework/debug-trace-profile/releasehandlefailed-mda">releaseHandleFailed</see> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ma być wywoływana tylko raz i tylko wtedy, gdy uchwyt jest prawidłowy jako zdefiniowany <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> przez właściwość. <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> Zaimplementuj tę metodę w <xref:System.Runtime.InteropServices.SafeHandle> klasach pochodnych, aby wykonać dowolny kod, który jest wymagany do zwolnienia dojścia. Ponieważ jedną z funkcji programu <xref:System.Runtime.InteropServices.SafeHandle> jest zagwarantowanie zapobiegania wyciekom zasobów, kod w <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementacji nie może nigdy kończyć się niepowodzeniem. Moduł zbierający elementy <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> bezużyteczne wywołuje się po wykonaniu normalnych finalizatorów dla obiektów, które były zbierane w tym samym czasie. Moduł zbierający elementy bezużyteczne gwarantuje zasoby do wywołania tej metody i że metoda nie zostanie przerwana, gdy jest w toku. Ta metoda zostanie przygotowana jako region ograniczonego wykonania (CER) w czasie konstruowania wystąpienia (wraz ze wszystkimi metodami w grafie niezależnym o statycznym wywoływać). Chociaż uniemożliwia to przerwanie przerywania wątku, nadal należy zachować ostrożność, aby nie wprowadzać żadnych ścieżek błędów w <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> zastąpionej metodzie. W szczególności Zastosuj <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> atrybut do dowolnych metod wywoływanych przez <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>. W większości przypadków ten kod powinien:  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 Ponadto w przypadku prostego oczyszczania (na przykład wywołania interfejsu API `CloseHandle` systemu Windows w dojściu do pliku) można sprawdzić wartość zwracaną dla wywołania wywołania pojedynczej platformy. W przypadku złożonego oczyszczania może istnieć wiele logiki programu i wiele wywołań metod, a niektóre z nich mogą zakończyć się niepowodzeniem. Musisz się upewnić, że logika programu ma kod rezerwowy dla każdego z tych przypadków.  
  
 Jeśli <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> zwraca`false` z jakiegokolwiek powodu, generuje asystenta zarządzanego debugowania [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) .  Pozwala to wykryć przypadki, w których próba zwolnienia zasobów nie powiedzie się.  
  
   
  
## Examples  
 Poniższy przykład kodu zwalnia dojście i jest częścią większego przykładu dostarczonego dla <xref:System.Runtime.InteropServices.SafeHandle> klasy.  
  
 [!code-csharp[SafeHandle#3](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu uzyskania uprawnień do wywoływania kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/76994ee6-9fa9-4059-b813-26578d24427c">Diagnozowanie błędów czasu wykonywania za pomocą asystentów zarządzanego debugowania</related>
        <related type="Article" href="https://msdn.microsoft.com/library/44cd98ba-95e5-40a1-874d-e8e163612c51">ReleaseHandleFailed</related>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="member this.SetHandle : nativeint -&gt; unit" Usage="safeHandle.SetHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Wstępnie istniejący uchwyt do użycia.</param>
        <summary>Ustawia dojście do określonego istniejącego już dojścia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> Użyj metody tylko wtedy, gdy musisz obsługiwać wcześniej istniejące dojście (na przykład, jeśli dojście zostanie zwrócone w strukturze), ponieważ infrastruktura międzyoperacyjna .NET Framework com nie obsługuje organizowania dojść wyjściowych w strukturze.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu uzyskania uprawnień do wywoływania kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetHandleAsInvalid ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetHandleAsInvalid();" />
      <MemberSignature Language="F#" Value="member this.SetHandleAsInvalid : unit -&gt; unit" Usage="safeHandle.SetHandleAsInvalid " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-1.5;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Oznacza dojście, które nie jest już używane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> metodę tylko wtedy, gdy wiesz, że uchwyt nie odwołuje się już do zasobu. Wykonanie tej czynności nie powoduje zmiany wartości <xref:System.Runtime.InteropServices.SafeHandle.handle> pola; oznacza to jedynie, że uchwyt jest zamknięty. Dojście może następnie zawierać potencjalnie nieaktualną wartość. Efekt tego wywołania polega na tym, że nie podjęto próby zwolnienia zasobów.  
  
 Podobnie jak w <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> przypadku metody, <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> należy używać tylko wtedy, gdy musisz obsługiwać wcześniej istniejące dojście.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu uzyskania uprawnień do wywoływania kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>

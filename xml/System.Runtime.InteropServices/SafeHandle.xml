<Type Name="SafeHandle" FullName="System.Runtime.InteropServices.SafeHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d62707b9b460c2a6a8386dd68959d7c9d58100ef" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39782268" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SafeHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit SafeHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.SafeHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SafeHandle&#xA;Inherits CriticalFinalizerObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SafeHandle abstract : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="F#" Value="type SafeHandle = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje klasę otoki dla systemu operacyjnego. Ta klasa musi być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle> Klasa udostępnia krytyczna finalizacja zasobów uchwyt, zapobieganie uchwyty z są odzyskiwane przedwcześnie przez wyrzucanie elementów bezużytecznych i odtwarzaniu przez Windows, aby odwoływać się do niezamierzonych niezarządzane obiekty.  
  
 Ten temat zawiera następujące sekcje:  
  
 [Dlaczego SafeHandle?](#Why)   
 [Jak działa SafeHandle](#Does)   
 [Klasy pochodne klasy SafeHandle](#Derived)  
  
<a name="Why"></a>   
## <a name="why-safehandle"></a>Dlaczego SafeHandle?  
 Przed .NET Framework w wersji 2.0, wszystkie system operacyjny obsługuje tylko może być hermetyzowane w <xref:System.IntPtr> zarządzanych otoka obiektu. Gdy jest to wygodny sposób na potrzeby współdziałania z kodem natywnym, obsługuje można wyciek przez wyjątków asynchronicznych, takich jak wątek nieoczekiwanie zostanie przerwany lub przepełnienie stosu. Te wyjątki asynchroniczne są przeszkody Oczyszczanie zasobów systemu operacyjnego i może wystąpić praktycznie dowolnym miejscu w aplikacji.  
  
 Mimo że zastąpienia <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metoda umożliwia oczyszczania niezarządzanych zasobów, gdy obiekt jest bezużyteczne w pewnych okolicznościach, które można sfinalizować obiektów można odzyskać przez wyrzucanie elementów bezużytecznych podczas wykonywania metody za pomocą platformy wywołania wywołanie. Jeśli finalizator powoduje zwolnienie dojście przekazane do tej platformy wywołaniem, może prowadzić do obsługi uszkodzeń. Ponadto można odzyskać uchwytu, gdy metoda jest zablokowane podczas jej platformy wywołania wywołania, takie jak podczas odczytywania pliku.  
  
 Bardziej krytycznie ponieważ Windows agresywnie jest odtwarzany uchwyty, uchwyt może poddana recyklingowi, a wskaż inny zasób, który może zawierać dane poufne. To jest znany jako atak odtwarzanie i może potencjalnie uszkodzić dane i stanowić zagrożenie dla bezpieczeństwa.  
  
<a name="Does"></a>   
## <a name="what-safehandle-does"></a>Jak działa SafeHandle  
 <xref:System.Runtime.InteropServices.SafeHandle> Klasa upraszcza kilka te kwestie okresu istnienia obiektów i jest zintegrowana z platformą wywołania, tak aby nie wyciek zasobów systemu operacyjnego. <xref:System.Runtime.InteropServices.SafeHandle> Klasy jest rozpoznawana jako kwestie istnienia obiektu i zwalniają dojścia bez zakłóceń. Zawiera krytyczny finalizator, który zapewnia, że uchwyt jest zamknięty, a następnie gwarantuje działanie w trakcie nieoczekiwany <xref:System.AppDomain> zwalnia, nawet w przypadkach, gdy wywołanie platformy wywołanie zakłada, że w stanie uszkodzenia.  
  
 Ponieważ <xref:System.Runtime.InteropServices.SafeHandle> dziedziczy <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, wszystkie niekrytyczne finalizatory są wywoływane przed każdą krytyczne finalizatory. Finalizatory są nazywane dla obiektów, które nie są już na żywo podczas przebiegu tej samej kolekcji wyrzucania elementów. Na przykład <xref:System.IO.FileStream> obiektu można uruchomić normalne finalizator opróżnić się istniejących buforowane dane, bez ryzyka stałego skanowania dojścia jest ujawnione lub poddawane recyklingowi. To bardzo słabe porządkowanie między finalizatory krytyczne i niekrytyczne nie jest przeznaczona do użytku ogólnego. Istnieje przede wszystkim ułatwiają migrację istniejących bibliotek, umożliwiając tych bibliotek do użycia <xref:System.Runtime.InteropServices.SafeHandle> bez zmiany ich semantyki. Ponadto krytyczne finalizatory i nic wywoływanych przez nią, takie jak <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> metody, musi znajdować się w regionie ograniczonego wykonania. To nakłada ograniczenia dotyczące kodu, które mogą być zapisywane w obrębie wykresu wywołań finalizatora.  
  
 Wywołanie operacji platformy automatycznie zwiększyć licznik odwołań uchwytów zamknięte przez <xref:System.Runtime.InteropServices.SafeHandle> i dekrementacyjne je po zakończeniu. Daje to gwarancję, że dojście będą nie odtwarzania lub został nieoczekiwanie zamknięty.  
  
 Można określić własność podstawowego dojścia przy konstruowaniu <xref:System.Runtime.InteropServices.SafeHandle> obiekty podając wartości do `ownsHandle` argument <xref:System.Runtime.InteropServices.SafeHandle> konstruktora klasy. W ten sposób kontroluje czy <xref:System.Runtime.InteropServices.SafeHandle> obiektu spowoduje zwolnienie uchwytu po obiekt został usunięty.  Jest to przydatne, obsługuje istnienia szczególne wymagania lub używania uchwyt, którego okres istnienia jest kontrolowany przez kogoś innego.  
  
<a name="Derived"></a>   
## <a name="classes-derived-from-safehandle"></a>Klasy pochodne klasy SafeHandle  
 <xref:System.Runtime.InteropServices.SafeHandle> jest klasą abstrakcyjna otoki dla systemu operacyjnego. Wyprowadzanie z tej klasy jest trudne. Zamiast tego należy użyć klas pochodnych w <xref:Microsoft.Win32.SafeHandles> przestrzeni nazw, które zapewniają bezpieczne dojścia dla następujących:  
  
-   Pliki ( <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> klasy).  
  
-   Pliki mapowane do pamięci ( <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> klasy).  
  
-   Potoki ( <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> klasy).  
  
-   Widoki pamięci ( <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> klasy).  
  
-   Konstrukcje kryptografii ( <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, i <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> klasy).  
  
-   Procesy ( <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle> klasy).  
  
-   Klucze rejestru ( <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> klasy).  
  
-   Uchwyty oczekiwania ( <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> klasy).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy niestandardowe bezpiecznego dojścia na uchwyt pliku systemu operacyjnego, wynikające z <xref:Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid>. Odczytuje bajtów z pliku i wyświetla ich wartości szesnastkowych. Zawiera również testowanie kontroler pod kątem błędów, dzięki któremu wątku przerwać, ale wartość dojścia jest zwalniana.  Korzystając z <xref:System.IntPtr> do reprezentowania uchwyty, od czasu do czasu przeciek uchwytu ze względu na przerwanie asynchronicznego wątku.  
  
 Konieczne będzie plik tekstowy, w tym samym folderze co skompilowanej aplikacji. Przy założeniu, że nazwy aplikacji "HexViewer" jest użycie wiersza polecenia:  
  
 `HexViewer <filename> -Fault`  
  
 Opcjonalnie można określić `-Fault` próbuje celowo przecieku uchwytu przerywanie wątków niektóre okna. Narzędzie Windows Perform.exe do monitorowania liczby uchwytu podczas wstrzykiwania błędów.  
  
 [!code-csharp[SafeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">aby uzyskać pełne zaufanie dla obiektów dziedziczących. Ten element członkowski nie może być dziedziczona przez częściowo zaufany kod.</permission>
    <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
    <block subset="none" type="overrides">
      <para>Aby utworzyć klasę pochodną <see cref="T:System.Runtime.InteropServices.SafeHandle" />, trzeba wiedzieć, jak utworzyć i bezpłatne dojście systemu operacyjnego. Ten proces różni się dla dojście do różnych typów, ponieważ jest używany przez niektóre [funkcja CloseHandle](https://msdn.microsoft.com/library/windows/desktop/ms724211.aspx) funkcji, a w innych stosuje bardziej szczegółowe funkcje takie jak [UnmapViewOfFile](https://msdn.microsoft.com/library/windows/desktop/aa366882.aspx) lub [FindClose](https://msdn.microsoft.com/library/windows/desktop/aa364413.aspx). Z tego powodu należy utworzyć klasę pochodną z <see cref="T:System.Runtime.InteropServices.SafeHandle" /> dla każdego typu dojście systemu operacyjnego, który ma być zawijany w bezpiecznym dojściu.  Przy dziedziczeniu z <see cref="T:System.Runtime.InteropServices.SafeHandle" />, konieczne jest przesłonięcie następujących składowych: <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> i <see cref="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />.  Należy również podać domyślnego konstruktora, który wywołuje konstruktora podstawowego o wartości, które reprezentują wartości nieprawidłowego dojścia i <see cref="T:System.Boolean" /> wartość wskazującą, czy uchwyt macierzysty jest własnością <see cref="T:System.Runtime.InteropServices.SafeHandle" /> i w związku z tym powinna być zwolniona po które <see cref="T:System.Runtime.InteropServices.SafeHandle" /> został usunięty.</para>
    </block>
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
    <altmember cref="T:System.Runtime.InteropServices.CriticalHandle" />
    <altmember cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle (IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (invalidHandleValue As IntPtr, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.SafeHandle : nativeint * bool -&gt; System.Runtime.InteropServices.SafeHandle" Usage="new System.Runtime.InteropServices.SafeHandle (invalidHandleValue, ownsHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue">Wartość nieprawidłowego dojścia (zazwyczaj 0 lub -1).  Implementacja <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> powinna zwrócić <see langword="true" /> dla tej wartości.</param>
        <param name="ownsHandle">
          <see langword="true" /> Aby umożliwić niezawodnie <see cref="T:System.Runtime.InteropServices.SafeHandle" /> zwolnienie uchwytu podczas fazy finalizacji; w przeciwnym razie <see langword="false" /> (niezalecane).</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.InteropServices.SafeHandle" /> klasy z wartością określoną nieprawidłowego dojścia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `ownsHandle` parametr jest `false`, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> nigdy nie jest wywoływana; w związku z tym, nie zaleca się używać wartości tego parametru, jak Twój kod wycieku zasobów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeLoadException">Klasa pochodna znajduje się w zestawie bez uprawnienia dostępu do kodu niezarządzanego.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">aby uzyskać pełne zaufanie dla obiektów dziedziczących. Ten element członkowski nie może być dziedziczona przez częściowo zaufany kod.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="safeHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Oznacza dojście do zwalniania i zwalnianiu zasobów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> lub <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metoda umożliwia zasoby, które ma zostać zwolniony. Nie może być zmienione od razu, inne wątki korzystania z tego samego obiektu bezpiecznego dojścia, ale będzie miało miejsce, gdy tylko nie są już tak jest. Mimo że większość klas, które używają <xref:System.Runtime.InteropServices.SafeHandle> klasy nie trzeba dostarczyć finalizator, czasami jest to konieczne (na przykład opróżnienia się bufory plików lub zapisać dane z powrotem do pamięci). W tym przypadku klasy potrzeby mogą dostarczyć finalizator, który gwarantuje działanie przed <xref:System.Runtime.InteropServices.SafeHandle> krytyczny finalizator przebiegów.  
  
 Wywołaj <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> lub <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metoda po zakończeniu przy użyciu <xref:System.Runtime.InteropServices.SafeHandle> obiektu.  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> lub <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> przed publikacją swoje ostatnie odwołanie do <xref:System.Runtime.InteropServices.SafeHandle> obiektu. W przeciwnym razie zasobów jest przy użyciu nie zostanie zwolniona, dopóki moduł odśmiecania pamięci wywołuje <xref:System.Runtime.InteropServices.SafeHandle> obiektu <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> metody.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienie wywoływać kod niezarządzany. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousAddRef">
      <MemberSignature Language="C#" Value="public void DangerousAddRef (ref bool success);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousAddRef(bool&amp; success) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousAddRef (ByRef success As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousAddRef(bool % success);" />
      <MemberSignature Language="F#" Value="member this.DangerousAddRef :  -&gt; unit" Usage="safeHandle.DangerousAddRef success" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="success" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="success">
          <see langword="true" /> Jeśli licznik odwołań został pomyślnie zwiększany; w przeciwnym razie <see langword="false" />.</param>
        <summary>Ręcznie zwiększa licznik odwołań na <see cref="T:System.Runtime.InteropServices.SafeHandle" /> wystąpień.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> Metoda uniemożliwia odzyskiwanie pamięci używanej przez dojście środowiska uruchomieniowego języka wspólnego (które występuje, gdy środowisko wykonawcze wywołuje <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> metody). Można użyć tę metodę, aby ręcznie przyrostu odwołania możesz liczyć na <xref:System.Runtime.InteropServices.SafeHandle> wystąpienia. <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> Zwraca wartość logiczną przy użyciu `ref` parametru (`success`) oznacza to, czy licznik odwołań został pomyślnie zwiększany. Dzięki temu logika program wycofać w przypadku awarii. Należy ustawić `success` do `false` przed wywołaniem <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. Jeśli `success` jest `true`, unikaj przeciekom zasobów, dopasowując wywołanie <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> przy użyciu odpowiedniego wywołania <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.  
  
> [!CAUTION]
>  Ta metoda jest przeznaczona dla użytkowników zaawansowanych i zawsze należy używać ostrożnie. Wyciekiem uchwyt zasobów, zawsze wywołać tę metodę wewnątrz regionu ograniczonego wykonania (CER), gdzie przerwanie wątku nie może przerwać przetwarzania.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienie wywoływać kod niezarządzany. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      </Docs>
    </Member>
    <Member MemberName="DangerousGetHandle">
      <MemberSignature Language="C#" Value="public IntPtr DangerousGetHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int DangerousGetHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle" />
      <MemberSignature Language="VB.NET" Value="Public Function DangerousGetHandle () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr DangerousGetHandle();" />
      <MemberSignature Language="F#" Value="member this.DangerousGetHandle : unit -&gt; nativeint" Usage="safeHandle.DangerousGetHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" /> pola.</summary>
        <returns>
          <see langword="IntPtr" /> Reprezentujący wartość <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" /> pola. Jeśli uchwyt został oznaczony nieprawidłowy z <see cref="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />, Metoda ta zwraca nadal oryginalnej wartości uchwyt może być wartością starych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do pobrania wartości rzeczywiste dojście wystąpienia programu <xref:System.Runtime.InteropServices.SafeHandle> klasy pochodnej. Ta metoda jest potrzebne do zapewnienia zgodności ponieważ zwraca wiele właściwości w programie .NET Framework `IntPtr` obsługi typów. `IntPtr` typ dojścia są typy specyficzne dla platformy używanych do reprezentowania wskaźnika lub uchwytu.  
  
> [!CAUTION]
>  Za pomocą <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> metoda może stanowić zagrożenie bezpieczeństwa, ponieważ, jeśli uchwyt została oznaczona jako niepoprawna przy użyciu <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> nadal zwraca wartość oryginalny, potencjalnie nieodświeżoną dojście. Zwracany uchwyt może być również odtworzona w dowolnym momencie. Co najlepsze oznacza to, że dojście może nagle przestać działać. W najgorszym przypadku Jeśli uchwyt lub zasobu, który reprezentuje uchwyt jest uwidaczniany w niezaufanego kodu, może to prowadzić do odtwarzania ataku zabezpieczeń są ponownie wykorzystywane lub zwracany uchwyt. Na przykład niezaufanych wywołujący może wysyłania zapytań dotyczących danych na dojście, po prostu zwracane i otrzymywanie informacji, w przypadku całkowicie niepowiązane zasobów. Zobacz <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> i <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> metody, aby uzyskać więcej informacji o korzystaniu z <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> methodsafely.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienie wywoływać kod niezarządzany. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousRelease">
      <MemberSignature Language="C#" Value="public void DangerousRelease ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousRelease() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousRelease ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousRelease();" />
      <MemberSignature Language="F#" Value="member this.DangerousRelease : unit -&gt; unit" Usage="safeHandle.DangerousRelease " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dekrementuje ręcznie licznik odwołań na <see cref="T:System.Runtime.InteropServices.SafeHandle" /> wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> Metodą jest odpowiednikiem <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. Powinna zawsze być zgodna wywołanie <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> metody z pomyślnym wywołaniem <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.  
  
> [!CAUTION]
>  Ta metoda jest przeznaczona dla użytkowników zaawansowanych i zawsze należy używać ostrożnie. Wyciekiem uchwyt zasobów, zawsze wywołać tę metodę wewnątrz regionu ograniczonego wykonania (CER), gdzie przerwanie wątku nie może przerwać przetwarzania. W taki sam sposób, który niedopasowane <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> wywołań może powodować przecieki zasobów, niedopasowane <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> wywołań może spowodować, że Stany nieprawidłowego dojścia do stają się widoczne dla innych wątków. Nie ujawniaj <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> lub <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> wywołania do niezaufanego kodu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienie wywoływać kod niezarządzany. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.Runtime.InteropServices.SafeHandle" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="safeHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez <see cref="T:System.Runtime.InteropServices.SafeHandle" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> lub <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metoda umożliwia zasoby, które ma zostać zwolniony. Nie może być zmienione od razu, inne wątki korzystania z tego samego wystąpienia bezpiecznego dojścia, ale będzie miało miejsce, gdy tylko nie są już tak jest. Mimo że większość klas przy użyciu <xref:System.Runtime.InteropServices.SafeHandle> nie trzeba dostarczyć finalizator, czasami jest to konieczne (na przykład, aby opróżnić się bufory plików lub do zapisania pewne dane z powrotem do pamięci). W tym przypadku zapewniają finalizator, który jest gwarantowane do uruchomienia przed <xref:System.Runtime.InteropServices.SafeHandle> krytyczny finalizator przebiegów.  
  
 Wywołaj <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> lub <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metoda po zakończeniu przy użyciu <xref:System.Runtime.InteropServices.SafeHandle> obiektu. <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> Pozostawia metoda <xref:System.Runtime.InteropServices.SafeHandle> obiektu w stanie uniemożliwiającym jego używanie.  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> lub <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metoda przed publikacją swoje ostatnie odwołanie do <xref:System.Runtime.InteropServices.SafeHandle> obiektu. W przeciwnym razie zasobów jest przy użyciu nie zostanie zwolniona, dopóki moduł odśmiecania pamięci wywołuje <xref:System.Runtime.InteropServices.SafeHandle> obiektu <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> metody.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienie wywoływać kod niezarządzany. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="safeHandle.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> do normalnego dispose operacji. <see langword="false" /> Aby sfinalizować uchwytu.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Runtime.InteropServices.SafeHandle" /> klasa określająca, czy wykonać normalnego dispose operacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nigdy nie jest jawnie wywołać <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> metody z `disposing` parametr `false`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienie wywoływać kod niezarządzany. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SafeHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="safeHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby skojarzone z uchwytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> Destruktor jest metoda <xref:System.Runtime.InteropServices.SafeHandle> klasy. Kod aplikacji nie powinna bezpośrednio wywołać tę metodę.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienie wywoływać kod niezarządzany. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberSignature Language="VB.NET" Value="Protected handle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: IntPtr handle;" />
      <MemberSignature Language="F#" Value="val mutable handle : nativeint" Usage="System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa dojścia w celu jej opakowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie ujawniaj uchwytu publicznie (czyli poza klasy pochodnej).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClosed : bool" Usage="System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy uchwyt jest zamknięty.</summary>
        <value>
          <see langword="true" /> Jeśli uchwyt zostanie zamknięty; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> Metoda zwraca wartość wskazującą czy <xref:System.Runtime.InteropServices.SafeHandle> dojście do obiektu nie jest już skojarzony z zasobu natywnego. To różni się od definicji <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> właściwość, która oblicza, czy podanym dojściu zawsze jest uznawane za nieprawidłowe. <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> Metoda zwraca `true` wartości w następujących przypadkach:  
  
-   <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> Metoda została wywołana.  
  
-   <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> Metody lub <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> wywołano metodę wiąże się z żadnych odwołań do <xref:System.Runtime.InteropServices.SafeHandle> obiektu na inny wątek.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienie wywoływać kod niezarządzany. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsInvalid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInvalid : bool" Usage="System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy wartość dojścia jest nieprawidłowy.</summary>
        <value>
          <see langword="true" /> Jeśli wartość dojścia jest nieprawidłowa; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne muszą implementować <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> właściwość tak, aby środowisko uruchomieniowe języka wspólnego można określić, czy wymagane jest krytyczna finalizacja. Klasy pochodne musi dostarczyć implementację odpowiadającego ogólny typ dojścia obsługują (0 lub wartość -1 jest nieprawidłowy). Te klasy mogą następnie dodatkowo uzyskane dla typów szczególne bezpiecznego dojścia.  
  
 W odróżnieniu od <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> właściwość, która zgłasza czy <xref:System.Runtime.InteropServices.SafeHandle> obiektu zostało zakończone, przy użyciu podstawowego dojścia <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> właściwość oblicza, czy wartość podanym dojściu zawsze jest uznawane za nieprawidłowe. W związku z tym <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> właściwość zawsze zwraca taką samą wartość dowolną wartość z określonego dojścia.  
  
   
  
## Examples  
 Poniższy przykład sprawdza, jeśli plik został pomyślnie otwarty. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Runtime.InteropServices.SafeHandle> klasy.  
  
 [!code-csharp[SafeHandle#2](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienie wywoływać kod niezarządzany. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function ReleaseHandle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool ReleaseHandle();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseHandle : unit -&gt; bool" Usage="safeHandle.ReleaseHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wykonuje kod wymagane zwolnienie uchwytu.</summary>
        <returns>
          <see langword="true" /> Jeśli uchwyt jest zwalniany pomyślnie; w przeciwnym razie, w przypadku poważnej awarii, <see langword="false" />. W tym przypadku generuje [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Asystent debugowania zarządzanego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> Metody jest gwarantowane, można wywołać tylko raz i tylko wtedy, gdy uchwyt jest prawidłowy, zgodnie z definicją <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> właściwości. Zaimplementować tę metodę w swojej <xref:System.Runtime.InteropServices.SafeHandle> pochodne klasy do wykonywania kodu, który jest wymagany, aby zwolnić uchwytu. Ponieważ jedną z funkcji <xref:System.Runtime.InteropServices.SafeHandle> ma na celu zagwarantowania zapobiegania przeciekom zasobów, kod w danej implementacji <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> musi nigdy się nie powieść. Moduł odśmiecania pamięci wywołuje <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> po uruchomieniu normalne finalizatory dla obiektów, które były bezużyteczne w tym samym czasie. Moduł zbierający elementy bezużyteczne gwarantuje zasobów, aby wywołać tę metodę i że metody nie zostanie przerwana podczas jego jest w toku. Ta metoda będzie gotowa jako region ograniczonego wykonania (CER), podczas tworzenia wystąpienia (oraz wszystkie metody jej wykresu wywołań statycznie możliwa do ustalenia). Mimo że pozwala to uniknąć przerwania przerwanie wątku, nadal należy pamiętać, że wszystkie ścieżki błędów w swojej zastąpione <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> metody. W szczególności należy zastosować <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> atrybutu jakiekolwiek metody wywołania z <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>. W większości przypadków należy ten kod:  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 Ponadto w przypadku prostych oczyszczania (na przykład wywołanie interfejsu API Win32 `CloseHandle` na dojście do pliku) dla pojedynczej platformy wywołania wywołania, można sprawdzić wartość zwracaną. Złożone oczyszczania może mieć wiele logiki programu i wielu wywołań metody, z których część może zakończyć się niepowodzeniem. Należy się upewnić, że logice program ma rezerwowy kod dla każdego z tych przypadków.  
  
 Jeśli <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> zwraca `false` z jakiegokolwiek powodu, generuje [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Asystent debugowania zarządzanego.  Dzięki temu można wykryć przypadki, w którym nie powiedzie się próba zwolnienia zasobów.  
  
   
  
## Examples  
 Poniższy przykładowy kod zwalnia dojścia i jest częścią większego przykładu przewidzianego dla <xref:System.Runtime.InteropServices.SafeHandle> klasy.  
  
 [!code-csharp[SafeHandle#3](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienie wywoływać kod niezarządzany. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="member this.SetHandle : nativeint -&gt; unit" Usage="safeHandle.SetHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Istniejące dojście do użycia.</param>
        <summary>Ustawia określone dojście istniejące uchwytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> metody tylko wtedy, gdy potrzeba do obsługi istniejących uchwyt (na przykład, jeśli uchwyt jest zwracany w strukturze), ponieważ infrastruktury międzyoperacyjnego modelu COM programu .NET Framework nie obsługuje przekazywanie danych wyjściowych uchwytów w strukturze.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienie wywoływać kod niezarządzany. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetHandleAsInvalid ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetHandleAsInvalid();" />
      <MemberSignature Language="F#" Value="member this.SetHandleAsInvalid : unit -&gt; unit" Usage="safeHandle.SetHandleAsInvalid " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Oznacza uchwyt tak nie jest już używana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> metody tylko wtedy, gdy wiesz, że swoje dojście nie jest już odwołuje się do zasobu. Ten sposób nie zmienia wartość <xref:System.Runtime.InteropServices.SafeHandle.handle> pola tylko program oznacza uchwytu jako zamknięte. Dojście następnie może zawierać potencjalnie nieodświeżoną wartość. To wywołanie powoduje, że nie są podejmowane próby zwolnienie zasobów.  
  
 Podobnie jak w przypadku <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> metody, użyj <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> tylko wtedy, gdy potrzeba do obsługi istniejących dojście.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać uprawnienie wywoływać kod niezarządzany. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>
<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="SafeHandle.xml" source-language="en-US" target-language="pl-PL">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac56c4334868cde5130ed9da65bfda7e798c24b12cd.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6c4334868cde5130ed9da65bfda7e798c24b12cd</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>Represents a wrapper class for operating system handles.</source>
          <target state="translated">Reprezentuje klasę otoki dla systemu operacyjnego.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>This class must be inherited.</source>
          <target state="translated">Ta klasa musi być dziedziczone.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class provides critical finalization of handle resources, preventing handles from being reclaimed prematurely by garbage collection and from being recycled by Windows to reference unintended unmanaged objects.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> Klasa udostępnia finalizacji krytyczne dojście zasobów, uniemożliwia uchwytów z zostanie odzyskana przedwcześnie przez wyrzucanie elementów bezużytecznych i odtwarzane przez system Windows, aby odwołać niezamierzone niezarządzane obiekty.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>This topic includes the following sections:</source>
          <target state="translated">Ten temat zawiera następujące sekcje:</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source><bpt id="p1">[</bpt>Why SafeHandle?<ept id="p1">](#Why)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Dlaczego SafeHandle?<ept id="p1">](#Why)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source><bpt id="p1">[</bpt>What SafeHandle does<ept id="p1">](#Does)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Element SafeHandle jest<ept id="p1">](#Does)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source><bpt id="p1">[</bpt>Classes derived from SafeHandle<ept id="p1">](#Derived)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Klasy pochodne SafeHandle<ept id="p1">](#Derived)</ept></target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>Why SafeHandle?</source>
          <target state="translated">Dlaczego SafeHandle?</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>Before the .NET Framework version 2.0, all operating system handles could only be encapsulated in the <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> managed wrapper object.</source>
          <target state="translated">Przed .NET Framework w wersji 2.0, wszystkie systemu operacyjnego dojścia może być tylko hermetyzowane w <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> zarządzany otok obiektów.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>While this was a convenient way to interoperate with native code, handles could be leaked by asynchronous exceptions, such as a thread aborting unexpectedly or a stack overflow.</source>
          <target state="translated">Gdy to wygodny sposób współdziałanie z kodem natywnym, dojść można przedostawać przez asynchroniczne wyjątki, takie jak nieoczekiwanie przerywanie wątku lub przepełnienie stosu.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>These asynchronous exceptions are an obstacle to cleaning up operating system resources, and they can occur almost anywhere in your app.</source>
          <target state="translated">Te asynchroniczne wyjątki są przeszkodę Oczyszczanie zasobów systemu operacyjnego i może wystąpić niemal z dowolnego miejsca w aplikacji.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>Although overrides to the <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method allow cleanup of unmanaged resources when an object is being garbage collected, in some circumstances, finalizable objects can be reclaimed by garbage collection while executing a method within a platform invoke call.</source>
          <target state="translated">Mimo że zastąpień w celu <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> — metoda Zezwalaj Oczyszczanie zasobów niezarządzanych, gdy obiekt jest w trakcie bezużytecznych w pewnych okolicznościach, finalizable obiektów można odzyskać przez odzyskiwanie pamięci podczas wykonywania metody dla platformy wywołania wywołanie.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>If a finalizer frees the handle passed to that platform invoke call, it could lead to handle corruption.</source>
          <target state="translated">Jeśli finalizator zwalnia dojście przekazane do tej platformy wywołaniem, połączenie może prowadzić do uszkodzenia obsługi.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>The handle could also be reclaimed while your method is blocked during a platform invoke call, such as while reading a file.</source>
          <target state="translated">Ponadto można odzyskać dojście, gdy metodę zostanie zablokowane, gdy platforma wywołania wywołania, takich jak podczas odczytywania pliku.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>More critically, because Windows aggressively recycles handles, a handle could be recycled and point to another resource that might contain sensitive data.</source>
          <target state="translated">Więcej wyczerpaniu ponieważ Windows odtwarzana agresywnie dojść, uchwyt można poddana recyklingowi, a wskaż inny zasób, który może zawierać dane poufne.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>This is known as a recycle attack and can potentially corrupt data and be a security threat.</source>
          <target state="translated">Jest on znany jako atak odtworzenia i może potencjalnie uszkodzić dane i stanowić zagrożenie bezpieczeństwa.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>What SafeHandle does</source>
          <target state="translated">Element SafeHandle jest</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class simplifies several of these object lifetime issues, and is integrated with platform invoke so that operating system resources are not leaked.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> Klasa upraszcza kilka te kwestie okresu istnienia obiektów i jest zintegrowana z platformą wywołania tak, aby nie przedostają zasoby systemu operacyjnego.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class resolves object lifetime issues by assigning and releasing handles without interruption.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> Klasy rozwiązuje problemy okres istnienia obiektu przypisując i zwalniania uchwytów bez przeszkód.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>It contains a critical finalizer that ensures that the handle is closed and is guaranteed to run during unexpected <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> unloads, even in cases when the platform invoke call is assumed to be in a corrupted state.</source>
          <target state="translated">Zawiera on krytyczne finalizatora, który zapewnia, że dojście zostało zamknięte i działanie podczas nieoczekiwany <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> zwalnia, nawet w przypadku wywołania wywołania platformy zakłada, że jest uszkodzony.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>Because <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> inherits from <ph id="ph2">&lt;xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject&gt;</ph>, all the noncritical finalizers are called before any of the critical finalizers.</source>
          <target state="translated">Ponieważ <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> dziedziczy <ph id="ph2">&lt;xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject&gt;</ph>, wszystkie niekrytyczne finalizatory są wywoływane przed każdą finalizatory krytyczne.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>The finalizers are called on objects that are no longer live during the same garbage collection pass.</source>
          <target state="translated">Finalizatory są nazywane na obiektach, które nie są już na żywo podczas przebiegu kolekcji tej samej pamięci.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>For example, a <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object can run a normal finalizer to flush out existing buffered data without the risk of the handle being leaked or recycled.</source>
          <target state="translated">Na przykład <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> obiektu można uruchomić normalne finalizator opróżnić istniejące dane buforowane bez ryzyka dojścia jest ujawnione lub poddawane recyklingowi.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>This very weak ordering between critical and noncritical finalizers is not intended for general use.</source>
          <target state="translated">Ten bardzo słabe kolejności między finalizatory krytyczne i niekrytyczne nie jest przeznaczony do użytku ogólnego.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>It exists primarily to assist in the migration of existing libraries by allowing those libraries to use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> without altering their semantics.</source>
          <target state="translated">Istnieje głównie w celu pomocy w procesie migracji istniejącej biblioteki zezwalając te biblioteki do użycia <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> bez zmiany ich semantyki.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>Additionally, the critical finalizer and anything it calls, such as the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType&gt;</ph> method, must be in a constrained execution region.</source>
          <target state="translated">Ponadto krytyczne finalizatora i niczego wywołuje, takich jak <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType&gt;</ph> metody, musi być w regionie ograniczonego wykonania.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>This imposes constraints on what code can be written within the finalizer's call graph.</source>
          <target state="translated">To nakłada ograniczenia dotyczące kodu, jakie mogą być zapisywane w obrębie wykresu wywołań finalizatora.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>Platform invoke operations automatically increment the reference count of handles encapsulated by a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> and decrement them upon completion.</source>
          <target state="translated">Wywołanie operacji platformy automatycznie zwiększyć liczebności referencyjnej dojść zamknięte przez <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> i zmniejszyć ich po zakończeniu.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>This ensures that the handle will not be recycled or closed unexpectedly.</source>
          <target state="translated">Dzięki temu, że dojście nie zostanie poddanych recyklingowi ani został nieoczekiwanie zamknięty.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>You can specify ownership of the underlying handle when constructing <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> objects by supplying a value to the <ph id="ph2">`ownsHandle`</ph> argument in the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class constructor.</source>
          <target state="translated">Własność dojścia podstawowej można określić podczas tworzenia <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> obiektów, podając wartość <ph id="ph2">`ownsHandle`</ph> argument <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> konstruktora klasy.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>This controls whether the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object will release the handle after the object has been disposed.</source>
          <target state="translated">Określa, to czy <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> obiektu będzie zwolnić dojścia po usunięciu obiektu.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>This is useful for handles with peculiar lifetime requirements or for consuming a handle whose lifetime is controlled by someone else.</source>
          <target state="translated">Jest to przydatne dla dojść wymagań specyficznych okres istnienia lub służący do konsumowania uchwytu, którego okres istnienia jest kontrolowany przez kogoś innego.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>Classes derived from SafeHandle</source>
          <target state="translated">Klasy pochodne SafeHandle</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> is an abstract wrapper class for operating system handles.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> jest to klasa abstrakcyjna otoki dla systemu operacyjnego.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>Deriving from this class is difficult.</source>
          <target state="translated">Wyprowadzanie z tej klasy jest trudne.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>Instead, use the derived classes in the <ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles&gt;</ph> namespace that provide safe handles for the following:</source>
          <target state="translated">Zamiast tego należy użyć klasy pochodnej w <ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles&gt;</ph> przestrzeni nazw, która zapewnienia bezpiecznego dojścia do następujących:</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>Files (the <ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeFileHandle&gt;</ph> class).</source>
          <target state="translated">Pliki ( <ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeFileHandle&gt;</ph> klasy).</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>Memory mapped files (the <ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle&gt;</ph> class).</source>
          <target state="translated">Pliki mapowane do pamięci ( <ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle&gt;</ph> klasy).</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>Pipes (the <ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafePipeHandle&gt;</ph> class).</source>
          <target state="translated">Potoki ( <ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafePipeHandle&gt;</ph> klasy).</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>Memory views (the <ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle&gt;</ph> class).</source>
          <target state="translated">Widoki pamięci ( <ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle&gt;</ph> klasy).</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>Cryptography constructs (the <ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle&gt;</ph>, <ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle&gt;</ph>, <ph id="ph3">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle&gt;</ph>, and <ph id="ph4">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle&gt;</ph> classes).</source>
          <target state="translated">Konstrukcje kryptografii ( <ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle&gt;</ph>, <ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle&gt;</ph>, <ph id="ph3">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle&gt;</ph>, i <ph id="ph4">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle&gt;</ph> klasy).</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>Processes (the <ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeProcessHandle&gt;</ph> class).</source>
          <target state="translated">Procesy ( <ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeProcessHandle&gt;</ph> klasy).</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>Registry keys (the <ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> class).</source>
          <target state="translated">Klucze rejestru ( <ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> klasy).</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>Wait handles (the <ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt;</ph> class).</source>
          <target state="translated">Uchwyty oczekiwania ( <ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt;</ph> klasy).</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>The following code example creates a custom safe handle for an operating system file handle, deriving from <ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid&gt;</ph>.</source>
          <target state="translated">Poniższy przykład kodu tworzy niestandardowe bezpieczne dojście dla systemu operacyjnego dojście do pliku, wynikające z <ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>It reads bytes from a file and displays their hexadecimal values.</source>
          <target state="translated">Odczytuje bajtów z pliku i wyświetla wartości szesnastkowe.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>It also contains a fault testing harness that causes the thread to abort, but the handle value is freed.</source>
          <target state="translated">Zawiera także błąd testowania kontroler, która powoduje wątku przerwania, ale wartość uchwytu zostanie zwolniona.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>When using an <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> to represent handles, the handle is occasionally leaked due to the asynchronous thread abort.</source>
          <target state="translated">Korzystając z <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> do reprezentowania dojść, dojście jest czasami ujawnione ze względu na przerwanie asynchronicznego wątku.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>You will need a text file in the same folder as the compiled application.</source>
          <target state="translated">Konieczne będzie pliku tekstowego w tym samym folderze co skompilowanej aplikacji.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>Assuming that you name the application "HexViewer", the command line usage is:</source>
          <target state="translated">Przy założeniu, że nazwa aplikacji "HexViewer", jest użycie wiersza polecenia:</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>Optionally specify <ph id="ph1">`-Fault`</ph> to intentionally attempt to leak the handle by aborting the thread in a certain window.</source>
          <target state="translated">Opcjonalnie można określić <ph id="ph1">`-Fault`</ph> celowo prób wyciek dojście przez przerywanie wątku w niektórych okna.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>Use the Windows Perform.exe tool to monitor handle counts while injecting faults.</source>
          <target state="translated">Narzędzie Perform.exe systemu Windows do monitorowania liczby dojścia podczas wstrzyknięcie błędów.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>for full trust for inheritors.</source>
          <target state="translated">aby uzyskać pełne zaufanie dla obiektów dziedziczących.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>This member cannot be inherited by partially trusted code.</source>
          <target state="translated">Ten element członkowski nie może być dziedziczona przez kod częściowo zaufany.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>To create a class derived from <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.SafeHandle" /&gt;</ph>, you must know how to create and free an operating system handle.</source>
          <target state="translated">Aby utworzyć klasę pochodzącą od <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.SafeHandle" /&gt;</ph>, musisz znać sposób tworzenia i zwolnić dojścia systemu operacyjnego.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>This process is different for different handle types because some use the <bpt id="p1">[</bpt>CloseHandle<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ms724211.aspx)</ept> function, while others use more specific functions such as <bpt id="p2">[</bpt>UnmapViewOfFile<ept id="p2">](https://msdn.microsoft.com/library/windows/desktop/aa366882.aspx)</ept> or <bpt id="p3">[</bpt>FindClose<ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/aa364413.aspx)</ept>.</source>
          <target state="translated">Ten proces jest inna dojście do różnych typów, ponieważ niektóre używają <bpt id="p1">[</bpt>CloseHandle<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ms724211.aspx)</ept> działanie, a inni korzystają więcej określonych funkcji takich jak <bpt id="p2">[</bpt>UnmapViewOfFile<ept id="p2">](https://msdn.microsoft.com/library/windows/desktop/aa366882.aspx)</ept> lub <bpt id="p3">[</bpt>FindClose<ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/aa364413.aspx)</ept>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>For this reason, you must create a derived class of <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.SafeHandle" /&gt;</ph> for each operating system handle type that you want to wrap in a safe handle.</source>
          <target state="translated">Z tego powodu należy utworzyć klasy pochodnej z <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.SafeHandle" /&gt;</ph> dla każdego typu dojścia systemu operacyjnego, który ma być zawijany w bezpieczne dojście.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>When you inherit from <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.SafeHandle" /&gt;</ph>, you must override the following members: <ph id="ph2">&lt;see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /&gt;</ph> and <ph id="ph3">&lt;see cref="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" /&gt;</ph>.</source>
          <target state="translated">Przy dziedziczeniu z <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.SafeHandle" /&gt;</ph>, konieczne jest przesłonięcie następujących członków: <ph id="ph2">&lt;see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /&gt;</ph> i <ph id="ph3">&lt;see cref="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>You should also provide a default constructor that calls the base constructor with a value that represent an invalid handle value, and a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value indicating whether the native handle is owned by the <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.SafeHandle" /&gt;</ph> and consequently should be freed when that <ph id="ph3">&lt;see cref="T:System.Runtime.InteropServices.SafeHandle" /&gt;</ph> has been disposed.</source>
          <target state="translated">Należy również wprowadzić domyślnego konstruktora, który Konstruktor podstawowej z wartością, która reprezentuje wartości nieprawidłowego dojścia i <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> wartość wskazującą, czy jest własnością uchwyt macierzysty <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.SafeHandle" /&gt;</ph> i w związku z tym powinien zostać zwolniony podczas które <ph id="ph3">&lt;see cref="T:System.Runtime.InteropServices.SafeHandle" /&gt;</ph> został usunięty.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)">
          <source>The value of an invalid handle (usually 0 or -1).</source>
          <target state="translated">Wartość nieprawidłowego dojścia (zazwyczaj 0 lub wartość-1).</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)">
          <source>Your implementation of <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /&gt;</ph> should return <ph id="ph2">&lt;see langword="true" /&gt;</ph> for this value.</source>
          <target state="translated">Implementacji <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /&gt;</ph> powinien zwrócić <ph id="ph2">&lt;see langword="true" /&gt;</ph> dla tej wartości.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to reliably let <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.SafeHandle" /&gt;</ph> release the handle during the finalization phase; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph> (not recommended).</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Aby umożliwić niezawodnie <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.SafeHandle" /&gt;</ph> zwolnić dojścia w fazie finalizacji; w przeciwnym razie <ph id="ph3">&lt;see langword="false" /&gt;</ph> (niezalecane).</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.SafeHandle" /&gt;</ph> class with the specified invalid handle value.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.SafeHandle" /&gt;</ph> klasy z wartością określony nieprawidłowy uchwyt.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)">
          <source>If the <ph id="ph1">`ownsHandle`</ph> parameter is <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> is never called; thus, it is not recommended to use this parameter value as your code may leak resources.</source>
          <target state="translated">Jeśli <ph id="ph1">`ownsHandle`</ph> parametr jest <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> nigdy nie jest wywoływana; w związku z tym nie jest zalecane do użycia wartości tego parametru, jak kod wycieku zasobów.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)">
          <source>The derived class resides in an assembly without unmanaged code access permission.</source>
          <target state="translated">Klasa pochodna znajduje się w zestawie bez uprawnienia dostępu do kodu niezarządzanego.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)">
          <source>for full trust for inheritors.</source>
          <target state="translated">aby uzyskać pełne zaufanie dla obiektów dziedziczących.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)">
          <source>This member cannot be inherited by partially trusted code.</source>
          <target state="translated">Ten element członkowski nie może być dziedziczona przez kod częściowo zaufany.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.SafeHandle.Close">
          <source>Marks the handle for releasing and freeing resources.</source>
          <target state="translated">Oznacza dojście do zwalniania i zwolnić zasoby.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Close">
          <source>Calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> method allows the resources to be freed.</source>
          <target state="translated">Wywoływanie <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> lub <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> metoda pozwala zasoby, które ma zostać zwolniony.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Close">
          <source>This might not happen immediately if other threads are using the same safe handle object, but will happen as soon as that is no longer the case.</source>
          <target state="translated">Może się nie powtórzyła natychmiast inne wątki korzystania z tego samego obiektu bezpieczne dojście, ale odbędzie się, gdy nie jest już wymagane.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Close">
          <source>Although most classes that use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</source>
          <target state="translated">Mimo że większość klas, które używają <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> klasy nie trzeba podać finalizator, czasami jest to konieczne, (na przykład, aby opróżnić limit buforów plików lub do zapisu niektóre dane z powrotem do pamięci).</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Close">
          <source>In this case, the class can provide a finalizer that is guaranteed to run before the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> critical finalizer runs.</source>
          <target state="translated">W takim przypadku klasa może zapewnić finalizatorze działanie przed <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> działa finalizator krytyczne.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Close">
          <source>Call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> method when you are finished using the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object.</source>
          <target state="translated">Wywołanie <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> lub <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> metody po zakończeniu przy użyciu <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Close">
          <source>Always call <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> before you release your last reference to the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object.</source>
          <target state="translated">Wywoływanie zawsze <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> lub <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> przed zwolnieniem ostatniego odwołania do <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Close">
          <source>Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object's <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">W przeciwnym razie używa zasobów nie zostanie zwolniona do wywołania modułu zbierającego elementy bezużyteczne <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> obiektu <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Close">
          <source>for permission to call unmanaged code.</source>
          <target state="translated">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Close">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Akcja zabezpieczeń: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Close">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Wyliczenie skojarzone: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the reference counter was successfully incremented; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli licznik odwołanie zostało pomyślnie zwiększany; w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)">
          <source>Manually increments the reference counter on <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.SafeHandle" /&gt;</ph> instances.</source>
          <target state="translated">Ręcznie zwiększa licznik odwołania na <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.SafeHandle" /&gt;</ph> wystąpień.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph> method prevents the common language runtime from reclaiming memory used by a handle (which occurs when the runtime calls the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> method).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph> Metody uniemożliwia odzyskiwanie pamięci używanej przez dojście środowisko uruchomieniowe języka wspólnego (które występuje, gdy środowisko urchomieniowe wywołuje <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> metody).</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)">
          <source>You can use this method to manually increment the reference count on a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> instance.</source>
          <target state="translated">Można użyć tę metodę, aby ręcznie przyrostu count odwołanie <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> wystąpienia.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph> returns a Boolean value using a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`success`</ph>) that indicates whether the reference count was incremented successfully.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph> Zwraca wartość logiczną przy użyciu <ph id="ph2">`ref`</ph> parametr (<ph id="ph3">`success`</ph>) wskazująca, czy liczba odwołań został pomyślnie zwiększany.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)">
          <source>This allows your program logic to back out in case of failure.</source>
          <target state="translated">Dzięki temu logika program do Wycofaj w razie awarii.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)">
          <source>You should set <ph id="ph1">`success`</ph> to <ph id="ph2">`false`</ph> before calling <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph>.</source>
          <target state="translated">Należy ustawić <ph id="ph1">`success`</ph> do <ph id="ph2">`false`</ph> przed wywołaniem <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)">
          <source>If <ph id="ph1">`success`</ph> is <ph id="ph2">`true`</ph>, avoid resource leaks by matching the call to <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph> with a corresponding call to <ph id="ph4">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A&gt;</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">`success`</ph> jest <ph id="ph2">`true`</ph>, uniknąć przecieków zasobów przez dopasowanie wywołanie <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph> z odpowiedniego wywołania <ph id="ph4">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)">
          <source>This method is intended for advanced users and must always be used carefully.</source>
          <target state="translated">Ta metoda jest przeznaczona dla użytkowników zaawansowanych i zawsze należy używać ostrożnie.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)">
          <source>To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing.</source>
          <target state="translated">Aby uniknąć przeciek dojścia zasobów, zawsze należy wywołać tę metodę w regionie ograniczonego wykonania (CER), gdzie przerwania wątku nie może przerwać przetwarzania.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)">
          <source>for permission to call unmanaged code.</source>
          <target state="translated">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Akcja zabezpieczeń: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Wyliczenie skojarzone: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle">
          <source>Returns the value of the <ph id="ph1">&lt;see cref="F:System.Runtime.InteropServices.SafeHandle.handle" /&gt;</ph> field.</source>
          <target state="translated">Zwraca wartość <ph id="ph1">&lt;see cref="F:System.Runtime.InteropServices.SafeHandle.handle" /&gt;</ph> pola.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle">
          <source>An <ph id="ph1">&lt;see langword="IntPtr" /&gt;</ph> representing the value of the <ph id="ph2">&lt;see cref="F:System.Runtime.InteropServices.SafeHandle.handle" /&gt;</ph> field.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="IntPtr" /&gt;</ph> Reprezentujący wartość <ph id="ph2">&lt;see cref="F:System.Runtime.InteropServices.SafeHandle.handle" /&gt;</ph> pola.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle">
          <source>If the handle has been marked invalid with <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" /&gt;</ph>, this method still returns the original handle value, which can be a stale value.</source>
          <target state="translated">Jeśli dojście została oznaczona jako niepoprawna z <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" /&gt;</ph>, ta metoda zwraca nadal oryginalnej wartości dojścia może być wartością przestarzałe.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle">
          <source>You can use this method to retrieve the actual handle value from an instance of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> derived class.</source>
          <target state="translated">Ta metoda służy do pobierania wartości rzeczywistych dojście wystąpienia programu <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle">
          <source>This method is needed for backwards compatibility because many properties in the .NET Framework return <ph id="ph1">`IntPtr`</ph> handle types.</source>
          <target state="translated">Ta metoda jest potrzebne do zapewnienia zgodności ponieważ zwraca wiele właściwości w programie .NET Framework <ph id="ph1">`IntPtr`</ph> obsługi typów.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle">
          <source><ph id="ph1">`IntPtr`</ph> handle types are platform-specific types used to represent a pointer or a handle.</source>
          <target state="translated"><ph id="ph1">`IntPtr`</ph> typ dojścia są specyficzne dla platformy typy używane do reprezentowania wskaźnika lub dojścia.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle">
          <source>Using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A&gt;</ph> method can pose security risks because, if the handle has been marked as invalid with <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A&gt;</ph> still returns the original, potentially stale handle value.</source>
          <target state="translated">Przy użyciu <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A&gt;</ph> metody może stanowić zagrożenie bezpieczeństwa, ponieważ, jeśli dojście została oznaczona jako niepoprawna z <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A&gt;</ph> nadal zwraca wartość oryginalne, potencjalnie starych dojścia.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle">
          <source>The returned handle can also be recycled at any point.</source>
          <target state="translated">Zwracane dojście można także ponownie przetworzony w dowolnym momencie.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle">
          <source>At best, this means the handle might suddenly stop working.</source>
          <target state="translated">W najlepszym przypadku oznacza to, że dojście może nagle przestać działać.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle">
          <source>At worst, if the handle or the resource that the handle represents is exposed to untrusted code, this can lead to a recycling security attack on the reused or returned handle.</source>
          <target state="translated">W najgorszym przypadku dojście lub zasób, który reprezentuje dojście udostępnienia w kodzie niezaufanym, może to prowadzić do odtwarzania ataku zabezpieczeń na dojście ponownie lub zwrócony.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle">
          <source>For example, an untrusted caller can query data on the handle just returned and receive information for an entirely unrelated resource.</source>
          <target state="translated">Na przykład niezaufanych wywołujący może zapytania na danych w dojściu tylko zwrócił i otrzymywanie informacji dla zasób całości niepowiązanych.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle">
          <source>See the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph> and the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A&gt;</ph> methods for more information about using the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A&gt;</ph> methodsafely.</source>
          <target state="translated">Zobacz <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A&gt;</ph> metod, aby uzyskać więcej informacji o korzystaniu z <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A&gt;</ph> methodsafely.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle">
          <source>for permission to call unmanaged code.</source>
          <target state="translated">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Akcja zabezpieczeń: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Wyliczenie skojarzone: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease">
          <source>Manually decrements the reference counter on a <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.SafeHandle" /&gt;</ph> instance.</source>
          <target state="translated">Ręcznie zmniejsza licznika odwołania na <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.SafeHandle" /&gt;</ph> wystąpienia.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A&gt;</ph> method is the counterpart to <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A&gt;</ph> Metoda jest odpowiednikiem <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease">
          <source>You should always match a call to the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A&gt;</ph> method with a successful call to <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph>.</source>
          <target state="translated">Wywołanie zawsze powinna odpowiadać <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A&gt;</ph> metody z pomyślnym wywołaniem <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease">
          <source>This method is intended for advanced users and must always be used carefully.</source>
          <target state="translated">Ta metoda jest przeznaczona dla użytkowników zaawansowanych i zawsze należy używać ostrożnie.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease">
          <source>To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing.</source>
          <target state="translated">Aby uniknąć przeciek dojścia zasobów, zawsze należy wywołać tę metodę w regionie ograniczonego wykonania (CER), gdzie przerwania wątku nie może przerwać przetwarzania.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease">
          <source>In the same way that unmatched <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph> calls can cause resource leaks, unmatched <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A&gt;</ph> calls can cause invalid handle states to become visible to other threads.</source>
          <target state="translated">W taki sam sposób, że niedopasowane <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph> wywołań może spowodować przecieków zasobów, niedopasowanych <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A&gt;</ph> wywołań może spowodować nieprawidłowe dojście Państwa staną się widoczne dla innych wątków.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease">
          <source>Do not expose <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A&gt;</ph> calls to untrusted code.</source>
          <target state="translated">Nie ujawniaj <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph> lub <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A&gt;</ph> wywołań kodzie niezaufanym.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease">
          <source>for permission to call unmanaged code.</source>
          <target state="translated">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Akcja zabezpieczeń: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Wyliczenie skojarzone: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.SafeHandle">
          <source>Releases the resources used by the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.SafeHandle" /&gt;</ph> class.</source>
          <target state="translated">Zwalnia zasoby używane przez <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.SafeHandle" /&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.SafeHandle.Dispose">
          <source>Releases all resources used by the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.SafeHandle" /&gt;</ph> class.</source>
          <target state="translated">Zwalnia wszelkie zasoby używane przez <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.SafeHandle" /&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Dispose">
          <source>Calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> method allows the resources to be freed.</source>
          <target state="translated">Wywoływanie <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> lub <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> metoda pozwala zasoby, które ma zostać zwolniony.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Dispose">
          <source>This might not happen immediately if other threads are using the same instance of the safe handle, but will happen as soon as that is no longer the case.</source>
          <target state="translated">Może się nie powtórzyła natychmiast inne wątki korzystania z tego samego wystąpienia bezpieczne dojście, ale odbędzie się, gdy nie jest już wymagane.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Dispose">
          <source>Although most classes using <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</source>
          <target state="translated">Mimo że większość klas przy użyciu <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> nie trzeba podać finalizator, czasami jest to konieczne, (na przykład można opróżnić limit buforów plików lub zapisania niektóre dane w pamięci).</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Dispose">
          <source>In this case, they can provide a finalizer that is guaranteed to run before the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> critical finalizer runs.</source>
          <target state="translated">W takim przypadku zapewniają finalizatorze działanie przed <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> działa finalizator krytyczne.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Dispose">
          <source>Call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> method when you are finished using the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object.</source>
          <target state="translated">Wywołanie <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> lub <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> metody po zakończeniu przy użyciu <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> method leaves the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object in an unusable state.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> Pozostawia metody <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> obiektu w stanie uniemożliwiającym jego używanie.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Dispose">
          <source>Always call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> method before you release your last reference to the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object.</source>
          <target state="translated">Wywoływanie zawsze <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> lub <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> metoda przed zwolnieniem ostatniego odwołania do <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Dispose">
          <source>Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object's <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">W przeciwnym razie używa zasobów nie zostanie zwolniona do wywołania modułu zbierającego elementy bezużyteczne <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> obiektu <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Dispose">
          <source>for permission to call unmanaged code.</source>
          <target state="translated">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Dispose">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Akcja zabezpieczeń: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Dispose">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Wyliczenie skojarzone: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> for a normal dispose operation; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to finalize the handle.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> dla zwykłym dispose operacji. <ph id="ph2">&lt;see langword="false" /&gt;</ph> celu sfinalizowania dojście.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.SafeHandle" /&gt;</ph> class specifying whether to perform a normal dispose operation.</source>
          <target state="translated">Zwalnia zasoby niezarządzane używane przez <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.SafeHandle" /&gt;</ph> klasa określająca, czy do wykonania zwykłym dispose operacji.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)">
          <source>You should never explicitly call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> method with the <ph id="ph2">`disposing`</ph> parameter set to <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Należy nigdy nie jawnie wywołać <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> metody z <ph id="ph2">`disposing`</ph> ustawiono parametr <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)">
          <source>for permission to call unmanaged code.</source>
          <target state="translated">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Akcja zabezpieczeń: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Wyliczenie skojarzone: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.SafeHandle.Finalize">
          <source>Frees all resources associated with the handle.</source>
          <target state="translated">Zwalnia wszystkie zasoby skojarzone z dojścia.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A&gt;</ph> method is the destructor for the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A&gt;</ph> Metoda jest destruktor dla elementu <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Finalize">
          <source>Application code should not call this method directly.</source>
          <target state="translated">Kod aplikacji nie należy bezpośrednio wywołać tej metody.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Finalize">
          <source>for permission to call unmanaged code.</source>
          <target state="translated">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Finalize">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Akcja zabezpieczeń: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.Finalize">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Wyliczenie skojarzone: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.SafeHandle.handle">
          <source>Specifies the handle to be wrapped.</source>
          <target state="translated">Określa dojście w celu jej opakowania.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.SafeHandle.handle">
          <source>Do not expose the handle publicly (that is, outside of the derived class).</source>
          <target state="translated">Nie ujawniaj dojście publicznie (to znaczy poza klasy pochodnej).</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="P:System.Runtime.InteropServices.SafeHandle.IsClosed">
          <source>Gets a value indicating whether the handle is closed.</source>
          <target state="translated">Pobiera wartość wskazującą, czy dojście jest zamknięty.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.SafeHandle.IsClosed">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the handle is closed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli zostanie zamknięty dojście; w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.SafeHandle.IsClosed">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A&gt;</ph> method returns a value indicating whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object's handle is no longer associated with a native resource.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A&gt;</ph> Metoda zwraca wartość wskazującą czy <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> obiektu dojście nie jest już skojarzony z zasobem macierzystego.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.SafeHandle.IsClosed">
          <source>This differs from the definition of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A&gt;</ph> property, which computes whether a given handle is always considered invalid.</source>
          <target state="translated">Ta różni się od definicji <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A&gt;</ph> właściwość, która oblicza, czy podanym dojściu zawsze jest uznawane za nieprawidłowe.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.SafeHandle.IsClosed">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A&gt;</ph> method returns a <ph id="ph2">`true`</ph> value in the following cases:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A&gt;</ph> Metoda zwraca <ph id="ph2">`true`</ph> wartość w następujących przypadkach:</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.SafeHandle.IsClosed">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A&gt;</ph> method was called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A&gt;</ph> Wywołano metodę.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.SafeHandle.IsClosed">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> method or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> method was called and there are no references to the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object on other threads.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> Metody lub <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> wywołano metodę i nie żadnych odwołań do <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> obiektu na inne wątki.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.SafeHandle.IsClosed">
          <source>for permission to call unmanaged code.</source>
          <target state="translated">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.SafeHandle.IsClosed">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Akcja zabezpieczeń: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.SafeHandle.IsClosed">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Wyliczenie skojarzone: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="P:System.Runtime.InteropServices.SafeHandle.IsInvalid">
          <source>When overridden in a derived class, gets a value indicating whether the handle value is invalid.</source>
          <target state="translated">W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy wartość dojście jest nieprawidłowe.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.SafeHandle.IsInvalid">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the handle value is invalid; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli wartość uchwytu jest nieprawidłowy. w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.SafeHandle.IsInvalid">
          <source>Derived classes must implement the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A&gt;</ph> property so that the common language runtime can determine whether critical finalization is required.</source>
          <target state="translated">Klasy pochodne muszą implementować <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A&gt;</ph> właściwości tak, aby środowisko uruchomieniowe języka wspólnego można określić, czy finalizacji krytyczne jest wymagana.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.SafeHandle.IsInvalid">
          <source>Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid).</source>
          <target state="translated">Klasa pochodna musi zapewniać implementację pasujące do typu ogólnego uchwytu, które obsługują (0 albo -1 jest nieprawidłowy).</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.SafeHandle.IsInvalid">
          <source>These classes can then be further derived for specific safe handle types.</source>
          <target state="translated">Te klasy można następnie dalsze pochodnych typów określonych bezpieczne dojście.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.SafeHandle.IsInvalid">
          <source>Unlike the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A&gt;</ph> property, which reports whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object has finished using the underlying handle, the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A&gt;</ph> property calculates whether the given handle value is always considered invalid.</source>
          <target state="translated">W odróżnieniu od <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A&gt;</ph> właściwość, która zgłasza czy <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> obiektu zakończył przy użyciu dojścia podstawowej <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A&gt;</ph> właściwości oblicza, czy wartość podanym dojściu zawsze jest uznawane za nieprawidłowe.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.SafeHandle.IsInvalid">
          <source>Therefore, the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A&gt;</ph> property always returns the same value for any one handle value.</source>
          <target state="translated">W związku z tym <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A&gt;</ph> właściwość zawsze zwraca tę samą wartość dowolną wartość z określonego dojścia.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.SafeHandle.IsInvalid">
          <source>The following example checks if a file was opened successfully.</source>
          <target state="translated">Poniższy przykład umożliwia sprawdzenie, czy plik został pomyślnie otwarty.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.SafeHandle.IsInvalid">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class.</source>
          <target state="translated">Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.SafeHandle.IsInvalid">
          <source>for permission to call unmanaged code.</source>
          <target state="translated">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.SafeHandle.IsInvalid">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Akcja zabezpieczeń: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.SafeHandle.IsInvalid">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Wyliczenie skojarzone: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle">
          <source>When overridden in a derived class, executes the code required to free the handle.</source>
          <target state="translated">W przypadku przesłonięcia w klasie pochodnej, wykonuje kod wymagany do zwolnienia dojście.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the handle is released successfully; otherwise, in the event of a catastrophic failure, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli dojście zwolnieniu pomyślnie; w przeciwnym razie poważnej awarii, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle">
          <source>In this case, it generates a <bpt id="p1">[</bpt>releaseHandleFailed<ept id="p1">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept> Managed Debugging Assistant.</source>
          <target state="translated">W takim przypadku generuje <bpt id="p1">[</bpt>releaseHandleFailed<ept id="p1">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept> Asystent debugowania zarządzanego.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> method is guaranteed to be called only once and only if the handle is valid as defined by the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> Można wywołać tylko raz i tylko wtedy, gdy uchwyt jest prawidłowy, zgodnie z definicją metody jest gwarancji <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A&gt;</ph> właściwości.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle">
          <source>Implement this method in your <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> derived classes to execute any code that is required to free the handle.</source>
          <target state="translated">Zaimplementuj tę metodę w Twojej <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> klas do wykonania kodu, który jest wymagany, aby zwolnić dojścia pochodnych.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle">
          <source>Because one of the functions of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> is to guarantee prevention of resource leaks, the code in your implementation of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> must never fail.</source>
          <target state="translated">Ponieważ jeden z funkcji <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> jest zapewnienie zapobiegania przecieków zasobów, kod w implementacji <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> musi nigdy się nie powieść.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle">
          <source>The garbage collector calls <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> after normal finalizers have been run for objects that were garbage collected at the same time.</source>
          <target state="translated">Wywołania modułu zbierającego elementy bezużyteczne <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> po uruchomieniu normalne finalizatory dla obiektów, które były bezużytecznych w tym samym czasie.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle">
          <source>The garbage collector guarantees the resources to invoke this method and that the method will not be interrupted while it is in progress.</source>
          <target state="translated">Moduł zbierający elementy bezużyteczne gwarantuje zasobów, aby wywołać tę metodę i czy metoda nie zostanie przerwana czasie, gdy jest w toku.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle">
          <source>This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph).</source>
          <target state="translated">Ta metoda będzie gotowa jako region ograniczonego wykonania (CER) w czasie tworzenia wystąpienia (wraz ze wszystkich metod jej wykresu wywołań statycznie możliwa do ustalenia).</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle">
          <source>Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> method.</source>
          <target state="translated">Mimo że zapobiega to przerwania przerwania wątku, nadal należy pamiętać, że żadnych ścieżek błędów w Twojej przesłoniętych <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle">
          <source>In particular, apply the <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> attribute to any methods you call from <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph>.</source>
          <target state="translated">W szczególności, zastosuj <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> atrybutu metody należy wywołać z <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle">
          <source>In most cases this code should be:</source>
          <target state="translated">W większości przypadków należy ten kod:</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle">
          <source>Additionally, for simple cleanup (for example, calling the Win32 API <ph id="ph1">`CloseHandle`</ph> on a file handle) you can check the return value for the single platform invoke call.</source>
          <target state="translated">Ponadto w przypadku prostego oczyszczania (na przykład wywołanie interfejsu API Win32 <ph id="ph1">`CloseHandle`</ph> na dojście do pliku) można sprawdzić wartość zwrotną dla pojedynczą platformę wywołania wywołania.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle">
          <source>For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail.</source>
          <target state="translated">Złożone oczyszczania może mieć wiele logice programu i wielu wywołań metody, z których część może zakończyć się niepowodzeniem.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle">
          <source>You must ensure that your program logic has fallback code for each of those cases.</source>
          <target state="translated">Należy upewnij się, że logika program ma rezerwowy kod dla każdego z tych przypadkach.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle">
          <source>If <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> returns <ph id="ph2">`false`</ph> for any reason, it generates a <bpt id="p1">[</bpt>releaseHandleFailed<ept id="p1">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept> Managed Debugging Assistant.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> zwraca <ph id="ph2">`false`</ph> z jakiejkolwiek przyczyny, generuje <bpt id="p1">[</bpt>releaseHandleFailed<ept id="p1">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept> Asystent debugowania zarządzanego.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle">
          <source>This helps you detect cases where your attempt to release resources fails.</source>
          <target state="translated">Dzięki temu można wykryć przypadkach, gdy nie próba zwolnienia zasobów.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle">
          <source>The following code example releases the handle and is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class.</source>
          <target state="translated">Poniższy przykład kodu zwalnia dojście i jest częścią większego przykładu udostępnionego dla <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle">
          <source>for permission to call unmanaged code.</source>
          <target state="translated">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Akcja zabezpieczeń: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Wyliczenie skojarzone: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)">
          <source>The pre-existing handle to use.</source>
          <target state="translated">Istniejące dojście do użycia.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)">
          <source>Sets the handle to the specified pre-existing handle.</source>
          <target state="translated">Ustawia określone dojście istniejące dojście.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)">
          <source>Use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A&gt;</ph> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling output handles in a structure.</source>
          <target state="translated">Użyj <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A&gt;</ph> metody tylko wtedy, gdy wymaganych do obsługi istniejącego dojścia (na przykład jeśli dojście jest zwracany w strukturze), ponieważ infrastruktury międzyoperacyjnego modelu COM programu .NET Framework nie obsługuje przekazywanie danych wyjściowych dojść w strukturze.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)">
          <source>for permission to call unmanaged code.</source>
          <target state="translated">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Akcja zabezpieczeń: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Wyliczenie skojarzone: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid">
          <source>Marks a handle as no longer used.</source>
          <target state="translated">Oznacza dojścia jako nie jest już używana.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid">
          <source>Call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A&gt;</ph> method only when you know that your handle no longer references a resource.</source>
          <target state="translated">Wywołanie <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A&gt;</ph> metody tylko wtedy, gdy wiesz, że uchwyt nie odwołuje się do zasobu.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid">
          <source>Doing so does not change the value of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.handle&gt;</ph> field; it only marks the handle as closed.</source>
          <target state="translated">Dzięki temu nie zmienia wartości <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.handle&gt;</ph> pole; tylko program oznacza dojście jako zamknięte.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid">
          <source>The handle might then contain a potentially stale value.</source>
          <target state="translated">Dojście następnie może zawierać potencjalnie starych wartości.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid">
          <source>The effect of this call is that no attempt is made to free the resources.</source>
          <target state="translated">To wywołanie powoduje, że nie są podejmowane próby zwolnienia zasobów.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid">
          <source>As with the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A&gt;</ph> only if you need to support a pre-existing handle.</source>
          <target state="translated">Jak <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A&gt;</ph> metody, użyj <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A&gt;</ph> tylko wtedy, gdy wymagana jest obsługa istniejące dojście.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid">
          <source>for permission to call unmanaged code.</source>
          <target state="translated">Aby uzyskać uprawnienia do wywoływania kodu niezarządzanego.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Akcja zabezpieczeń: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Wyliczenie skojarzone: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>
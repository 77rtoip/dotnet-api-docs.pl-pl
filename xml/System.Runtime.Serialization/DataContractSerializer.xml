<Type Name="DataContractSerializer" FullName="System.Runtime.Serialization.DataContractSerializer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="53e74201cf982de62be84d374fdcec4b4d421aef" />
    <Meta Name="ms.sourcegitcommit" Value="9dda17222b9f7d3edf130133bfb1370d5b410a4b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="09/22/2018" />
    <Meta Name="ms.locfileid" Value="46690647" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DataContractSerializer : System.Runtime.Serialization.XmlObjectSerializer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DataContractSerializer extends System.Runtime.Serialization.XmlObjectSerializer" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Serialization.DataContractSerializer" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DataContractSerializer&#xA;Inherits XmlObjectSerializer" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataContractSerializer sealed : System::Runtime::Serialization::XmlObjectSerializer" />
  <TypeSignature Language="F#" Value="type DataContractSerializer = class&#xA;    inherit XmlObjectSerializer" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.3.0</AssemblyVersion>
    <AssemblyVersion>4.1.4.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Serialization</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.Serialization.XmlObjectSerializer</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Serializuje i deserializuje wystąpienia typu do strumień XML lub dokumentu za pomocą kontraktu danych. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Serialization.DataContractSerializer> klasy do serializacji i deserializacji wystąpienia typu do strumień XML lub dokumentu. Na przykład można utworzyć typu o nazwie `Person` z właściwościami, które zawierają istotne dane, takie jak nazwa i adres. Można tworzyć i modyfikować wystąpienie `Person` klasy i zapisywanie wszystkich wartości właściwości, w dokumencie XML do pobierania nowszych lub w strumień XML do natychmiastowego transportu. Najważniejszą <xref:System.Runtime.Serialization.DataContractSerializer> służy do serializacji i deserializacji danych przesyłanych w komunikatach usługi Windows Communication Foundation (WCF). Zastosuj <xref:System.Runtime.Serialization.DataContractAttribute> atrybutu klasy, a <xref:System.Runtime.Serialization.DataMemberAttribute> atrybutu do składowych klasy, aby określić właściwości i pola, które są serializowane.  
  
 Aby uzyskać listę typów, które może być Zserializowany, zobacz [typy obsługiwane przez serializator kontraktu danych](~/docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).  
  
 Aby użyć <xref:System.Runtime.Serialization.DataContractSerializer>, najpierw utwórz wystąpienie klasy i obiekt odpowiednie wpisywanie lub odczytywanie formatu; na przykład wystąpienie <xref:System.Xml.XmlDictionaryWriter>. Następnie wywołaj <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> metodę, aby zachować dane. Do pobierania danych, Utwórz obiekt odpowiednie do odczytywania format danych (takich jak <xref:System.Xml.XmlDictionaryReader> dokumentu XML) i wywołać <xref:System.Runtime.Serialization.DataContractSerializer.ReadObject%2A> metody.  
  
 Aby uzyskać więcej informacji o korzystaniu z <xref:System.Runtime.Serialization.DataContractSerializer>, zobacz [serializacji i deserializacji](~/docs/framework/wcf/feature-details/serialization-and-deserialization.md).  
  
 Możesz ustawić typ serializator kontraktu danych za pomocą [ &lt;dataContractSerializer&gt; ](~/docs/framework/configure-apps/file-schema/wcf/datacontractserializer-element.md) elementu w pliku konfiguracji aplikacji klienta.  
  
## <a name="preparing-classes-for-serialization-or-deserialization"></a>Przygotowywanie do serializacji lub deserializacji klas  
 <xref:System.Runtime.Serialization.DataContractSerializer> Jest używany w połączeniu z <xref:System.Runtime.Serialization.DataContractAttribute> i <xref:System.Runtime.Serialization.DataMemberAttribute> klasy. Aby przygotować klasę do serializacji, zastosuj <xref:System.Runtime.Serialization.DataContractAttribute> do klasy.  Dla każdego elementu członkowskiego klasy, która zwraca dane przeznaczone do serializacji, zastosuj <xref:System.Runtime.Serialization.DataMemberAttribute>. Może wykonywać serializację pola i właściwości, niezależnie od tego, w ułatwienia dostępu: prywatnych, chronionych wewnętrznych chronione wewnętrznego lub publicznego.  
  
 Na przykład określa schematu `Customer` z `ID` właściwości, ale masz już istniejącą aplikację, która korzysta z typu o nazwie `Person` z `Name` właściwości. Aby utworzyć typ, który jest zgodny z umowy, należy najpierw zastosować <xref:System.Runtime.Serialization.DataContractAttribute> do klasy.  Następnie Zastosuj <xref:System.Runtime.Serialization.DataMemberAttribute> do każdego pola lub właściwości przewidzianej do serializacji.  
  
> [!NOTE]
>  Można zastosować <xref:System.Runtime.Serialization.DataMemberAttribute> do publicznych i prywatnych elementów członkowskich.  
  
 Ostateczny format XML nie musi być tekstu. Zamiast tego <xref:System.Runtime.Serialization.DataContractSerializer> zapisuje dane w postaci zestaw informacji XML, dzięki czemu można zapisywać dane w dowolnym formacie rozpoznawanym przez <xref:System.Xml.XmlReader> i <xref:System.Xml.XmlWriter>. Zaleca się, że używasz <xref:System.Xml.XmlDictionaryReader> i <xref:System.Xml.XmlDictionaryWriter> klasy do odczytu i zapisu, ponieważ oba są zoptymalizowane do pracy z <xref:System.Runtime.Serialization.DataContractSerializer>.  
  
 Jeśli tworzysz klasę, która ma pola lub właściwości, które muszą być wypełnione przed serializacji lub deserializacji wystąpienia, należy użyć atrybutów wywołania zwrotnego, zgodnie z opisem w [wywołania zwrotne serializacji z tolerancją dla wersji](~/docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md).  
  
## <a name="adding-to-the-collection-of-known-types"></a>Dodawanie do kolekcji znanych typów  
 Podczas serializacji lub deserializacji obiektu, jest wymagany, typ to "znane" do <xref:System.Runtime.Serialization.DataContractSerializer>. Rozpocznij od utworzenia wystąpienia klasy, która implementuje <xref:System.Collections.Generic.IEnumerable%601> (takie jak <xref:System.Collections.Generic.List%601>) i dodawanie znanych typów do kolekcji. Następnie utwórz wystąpienie obiektu <xref:System.Runtime.Serialization.DataContractSerializer> przy użyciu jednego z przeciążeń, które przyjmuje <xref:System.Collections.Generic.IEnumerable%601> (na przykład <xref:System.Runtime.Serialization.DataContractSerializer.%23ctor%28System.Type%2CSystem.Collections.Generic.IEnumerable%7BSystem.Type%7D%29>.  
  
> [!NOTE]
>  W przeciwieństwie do innych typów pierwotnych <xref:System.DateTimeOffset> struktura nie jest znany typ domyślnie, dlatego należy ręcznie dodać do listy znanych typów (zobacz [znane typy kontraktu danych](~/docs/framework/wcf/feature-details/data-contract-known-types.md)).  
  
## <a name="forward-compatibility"></a>Zgodność z nowszymi wersjami  
 <xref:System.Runtime.Serialization.DataContractSerializer> Rozumie kontraktów danych, które zostały zaprojektowane, aby był zgodny z przyszłych wersji kontraktu. Takie typy implementują <xref:System.Runtime.Serialization.IExtensibleDataObject> interfejsu. Funkcje interfejsu <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> właściwość, która zwraca <xref:System.Runtime.Serialization.ExtensionDataObject> obiektu. Aby uzyskać więcej informacji, zobacz [kontrakty danych zgodne](~/docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).  
  
## <a name="running-under-partial-trust"></a>Uruchamianie w częściowej relacji zaufania  
 Podczas tworzenia wystąpienia obiektu docelowego podczas deserializacji <xref:System.Runtime.Serialization.DataContractSerializer> nie wywołać konstruktora obiektu docelowego. Jeśli tworzysz *[DataContract]* typu, który jest dostępny w częściowej relacji zaufania (oznacza to, nie jest publiczny, a w zestawie, który ma `AllowPartiallyTrustedCallers` zastosowany) i który wykonuje określone akcje związane z zabezpieczeniami, należy pamiętać, Konstruktor nie jest wywoływana. W szczególności następujące techniki nie działają:  
  
-   Jeśli zostanie podjęta próba ograniczać częściowej relacji zaufania, wprowadzając konstruktora wewnętrznego lub prywatnego lub dodając `LinkDemand` do konstruktora — oba te zostały uwzględnione podczas deserializacji w częściowej relacji zaufania.  
  
-   Jeśli kod jest klasa, która przyjęto założenie, że uruchomieniu konstruktora, klasa może wystąpić w nieprawidłowy stan wewnętrzny, który jest kończona.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje typ o nazwie `Person` , jest serializowany przez <xref:System.Runtime.Serialization.DataContractSerializer>. <xref:System.Runtime.Serialization.DataContractAttribute> Atrybut jest stosowany do klasy, a <xref:System.Runtime.Serialization.DataMemberAttribute> jest stosowany do elementów członkowskich w celu poinstruowania <xref:System.Runtime.Serialization.DataContractSerializer> co do serializacji.  
  
 [!code-csharp[DataContractSerializer#0](~/samples/snippets/csharp/VS_Snippets_CFX/datacontractserializer/cs/source.cs#0)]
 [!code-vb[DataContractSerializer#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/datacontractserializer/vb/source.vb#0)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Wystąpienia tej klasy są bezpieczne wątkowo, z wyjątkiem sytuacji, gdy wystąpienie jest używany z implementacją <see cref="T:System.Runtime.Serialization.IDataContractSurrogate" /> lub <see cref="T:System.Runtime.Serialization.DataContractResolver" />.</threadsafe>
    <altmember cref="T:System.Runtime.Serialization.DataMemberAttribute" />
    <altmember cref="T:System.Runtime.Serialization.DataContractAttribute" />
    <altmember cref="T:System.Runtime.Serialization.IExtensibleDataObject" />
    <altmember cref="T:System.Runtime.Serialization.ExtensionDataObject" />
    <related type="Article" href="~/docs/framework/wcf/feature-details/using-data-contracts.md">Używanie kontraktów danych</related>
    <related type="Article" href="~/docs/framework/wcf/feature-details/serialization-and-deserialization.md">Serializacja i deserializacja</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.Runtime.Serialization.InvalidDataContractException">Typ poddawany serializacji nie jest zgodny z regułami kontraktu danych. Na przykład <see cref="T:System.Runtime.Serialization.DataContractAttribute" /> nie zastosowano atrybut do typu.</exception>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.Serialization.DataContractSerializer" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContractSerializer (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.#ctor(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContractSerializer(Type ^ type);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Serialization.DataContractSerializer : Type -&gt; System.Runtime.Serialization.DataContractSerializer" Usage="new System.Runtime.Serialization.DataContractSerializer type" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Typ wystąpienia, które serializowany lub deserializowany.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.Serialization.DataContractSerializer" /> klasy do serializacji lub deserializacji obiektu określonego typu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Runtime.Serialization.DataContractSerializer> , który określa typ do serializacji lub deserializacji.  
  
 [!code-csharp[DataContractSerializer#8](~/samples/snippets/csharp/VS_Snippets_CFX/datacontractserializer/cs/source.cs#8)]
 [!code-vb[DataContractSerializer#8](~/samples/snippets/visualbasic/VS_Snippets_CFX/datacontractserializer/vb/source.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContractSerializer (Type type, System.Collections.Generic.IEnumerable&lt;Type&gt; knownTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; knownTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.#ctor(System.Type,System.Collections.Generic.IEnumerable{System.Type})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContractSerializer(Type ^ type, System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ knownTypes);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Serialization.DataContractSerializer : Type * seq&lt;Type&gt; -&gt; System.Runtime.Serialization.DataContractSerializer" Usage="new System.Runtime.Serialization.DataContractSerializer (type, knownTypes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="knownTypes" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="type">Typ wystąpienia, które serializowany lub deserializowany.</param>
        <param name="knownTypes">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Type" /> zawiera typy, które mogą być obecne na grafie obiektu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.Serialization.DataContractSerializer" /> klasy do serializacji lub deserializacji obiektu określonego typu i kolekcji znanych typów, które mogą być obecne na grafie obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Runtime.Serialization.DataContractSerializer> , który określa typ do serializacji lub deserializacji i kolekcji znanych typów, których można użyć w wykresu obiektu.  
  
 [!code-csharp[DataContractSerializer#9](~/samples/snippets/csharp/VS_Snippets_CFX/datacontractserializer/cs/source.cs#9)]
 [!code-vb[DataContractSerializer#9](~/samples/snippets/visualbasic/VS_Snippets_CFX/datacontractserializer/vb/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Runtime.Serialization.DataContractSerializer.KnownTypes" />
        <altmember cref="T:System.Runtime.Serialization.KnownTypeAttribute" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContractSerializer (Type type, System.Runtime.Serialization.DataContractSerializerSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, class System.Runtime.Serialization.DataContractSerializerSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.#ctor(System.Type,System.Runtime.Serialization.DataContractSerializerSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContractSerializer(Type ^ type, System::Runtime::Serialization::DataContractSerializerSettings ^ settings);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Serialization.DataContractSerializer : Type * System.Runtime.Serialization.DataContractSerializerSettings -&gt; System.Runtime.Serialization.DataContractSerializer" Usage="new System.Runtime.Serialization.DataContractSerializer (type, settings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="settings" Type="System.Runtime.Serialization.DataContractSerializerSettings" />
      </Parameters>
      <Docs>
        <param name="type">Typ wystąpienia do serializacji lub deserializacji.</param>
        <param name="settings">Ustawienia serializatora.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.Serialization.DataContractSerializer" /> klasy do serializacji lub deserializacji obiektu określonego typu i ustawień.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContractSerializer (Type type, string rootName, string rootNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, string rootName, string rootNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.#ctor(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContractSerializer(Type ^ type, System::String ^ rootName, System::String ^ rootNamespace);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Serialization.DataContractSerializer : Type * string * string -&gt; System.Runtime.Serialization.DataContractSerializer" Usage="new System.Runtime.Serialization.DataContractSerializer (type, rootName, rootNamespace)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="rootName" Type="System.String" />
        <Parameter Name="rootNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ wystąpienia, które serializowany lub deserializowany.</param>
        <param name="rootName">Nazwa elementu XML, który otacza zawartości do serializacji lub deserializacji.</param>
        <param name="rootNamespace">Przestrzeń nazw elementu XML, który otacza zawartości do serializacji lub deserializacji.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.Serialization.DataContractSerializer" /> klasy do serializacji lub deserializacji obiektu określonego typu przy użyciu podanych element główny XML i przestrzeni nazw.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Runtime.Serialization.DataContractSerializer> , który określa typ do serializacji lub deserializacji, a także nazwa XML i przestrzeni nazw do odczytu lub zapisu w dokumencie XML.  
  
 [!code-csharp[DataContractSerializer#10](~/samples/snippets/csharp/VS_Snippets_CFX/datacontractserializer/cs/source.cs#10)]
 [!code-vb[DataContractSerializer#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/datacontractserializer/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContractSerializer (Type type, System.Xml.XmlDictionaryString rootName, System.Xml.XmlDictionaryString rootNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, class System.Xml.XmlDictionaryString rootName, class System.Xml.XmlDictionaryString rootNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.#ctor(System.Type,System.Xml.XmlDictionaryString,System.Xml.XmlDictionaryString)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContractSerializer(Type ^ type, System::Xml::XmlDictionaryString ^ rootName, System::Xml::XmlDictionaryString ^ rootNamespace);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Serialization.DataContractSerializer : Type * System.Xml.XmlDictionaryString * System.Xml.XmlDictionaryString -&gt; System.Runtime.Serialization.DataContractSerializer" Usage="new System.Runtime.Serialization.DataContractSerializer (type, rootName, rootNamespace)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="rootName" Type="System.Xml.XmlDictionaryString" />
        <Parameter Name="rootNamespace" Type="System.Xml.XmlDictionaryString" />
      </Parameters>
      <Docs>
        <param name="type">Typ wystąpienia, które serializowany lub deserializowany.</param>
        <param name="rootName">
          <see cref="T:System.Xml.XmlDictionaryString" /> Zawierającą nazwę elementu głównego zawartości.</param>
        <param name="rootNamespace">
          <see cref="T:System.Xml.XmlDictionaryString" /> Zawierającą przestrzeń nazw głównego elementu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.Serialization.DataContractSerializer" /> klasy do serializacji lub deserializacji obiektu określonego typu przy użyciu elementu głównego XML i przestrzeń nazw określona przez parametry typu <see cref="T:System.Xml.XmlDictionaryString" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Runtime.Serialization.DataContractSerializer> , który określa typ do serializacji lub deserializacji, a także nazwa XML i przestrzeni nazw (jako <xref:System.Xml.XmlDictionaryString> obiektów) do odczytu lub zapisu w dokumencie XML.  
  
 [!code-csharp[DataContractSerializer#11](~/samples/snippets/csharp/VS_Snippets_CFX/datacontractserializer/cs/source.cs#11)]
 [!code-vb[DataContractSerializer#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/datacontractserializer/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContractSerializer (Type type, string rootName, string rootNamespace, System.Collections.Generic.IEnumerable&lt;Type&gt; knownTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, string rootName, string rootNamespace, class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; knownTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.#ctor(System.Type,System.String,System.String,System.Collections.Generic.IEnumerable{System.Type})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContractSerializer(Type ^ type, System::String ^ rootName, System::String ^ rootNamespace, System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ knownTypes);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Serialization.DataContractSerializer : Type * string * string * seq&lt;Type&gt; -&gt; System.Runtime.Serialization.DataContractSerializer" Usage="new System.Runtime.Serialization.DataContractSerializer (type, rootName, rootNamespace, knownTypes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="rootName" Type="System.String" />
        <Parameter Name="rootNamespace" Type="System.String" />
        <Parameter Name="knownTypes" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="type">Typ wystąpienia, które serializowany lub deserializowany.</param>
        <param name="rootName">Nazwa elementu głównego zawartości.</param>
        <param name="rootNamespace">Przestrzeń nazw elementu głównego.</param>
        <param name="knownTypes">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Type" /> zawiera typy, które mogą być obecne na grafie obiektu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.Serialization.DataContractSerializer" /> klasy do serializacji lub deserializacji obiektu określonego typu. Ta metoda określa również element główny XML i przestrzeni nazw w dwoma parametrami, a także listę znanych typów, które mogą być obecne na grafie obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Runtime.Serialization.DataContractSerializer> , który określa typ do serializacji lub deserializacji, a także nazwa XML i przestrzeni nazw do odczytu lub zapisu w dokumencie XML. Wystąpienie tworzy również kod <xref:System.Collections.Generic.IEnumerable%601> zawiera znane typy, które są używane podczas serializacji lub deserializacji.  
  
 [!code-csharp[DataContractSerializer#12](~/samples/snippets/csharp/VS_Snippets_CFX/datacontractserializer/cs/source.cs#12)]
 [!code-vb[DataContractSerializer#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/datacontractserializer/vb/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Runtime.Serialization.DataContractSerializer.KnownTypes" />
        <altmember cref="T:System.Runtime.Serialization.KnownTypeAttribute" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContractSerializer (Type type, System.Xml.XmlDictionaryString rootName, System.Xml.XmlDictionaryString rootNamespace, System.Collections.Generic.IEnumerable&lt;Type&gt; knownTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, class System.Xml.XmlDictionaryString rootName, class System.Xml.XmlDictionaryString rootNamespace, class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; knownTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.#ctor(System.Type,System.Xml.XmlDictionaryString,System.Xml.XmlDictionaryString,System.Collections.Generic.IEnumerable{System.Type})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContractSerializer(Type ^ type, System::Xml::XmlDictionaryString ^ rootName, System::Xml::XmlDictionaryString ^ rootNamespace, System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ knownTypes);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Serialization.DataContractSerializer : Type * System.Xml.XmlDictionaryString * System.Xml.XmlDictionaryString * seq&lt;Type&gt; -&gt; System.Runtime.Serialization.DataContractSerializer" Usage="new System.Runtime.Serialization.DataContractSerializer (type, rootName, rootNamespace, knownTypes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="rootName" Type="System.Xml.XmlDictionaryString" />
        <Parameter Name="rootNamespace" Type="System.Xml.XmlDictionaryString" />
        <Parameter Name="knownTypes" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="type">Typ wystąpienia, które serializowany lub deserializowany.</param>
        <param name="rootName">
          <see cref="T:System.Xml.XmlDictionaryString" /> Zawierającą nazwę elementu głównego zawartości.</param>
        <param name="rootNamespace">
          <see cref="T:System.Xml.XmlDictionaryString" /> Zawierającą przestrzeń nazw głównego elementu.</param>
        <param name="knownTypes">A <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Type" /> zawierający znane typy, które mogą być obecne na grafie obiektu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.Serialization.DataContractSerializer" /> klasy do serializacji lub deserializacji obiektu określonego typu. Ta metoda określa również element główny XML i przestrzeni nazw w dwóch <see cref="T:System.Xml.XmlDictionaryString" /> parametrów, a także listę znanych typów, które mogą być obecne na grafie obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Runtime.Serialization.DataContractSerializer> , który określa typ do serializacji lub deserializacji, a także nazwa XML i przestrzeni nazw (jako <xref:System.Xml.XmlDictionaryString> obiektów) do odczytu lub zapisu w dokumencie XML. Wystąpienie tworzy również kod <xref:System.Collections.Generic.IEnumerable%601> zawiera znane typy, które są używane podczas serializacji lub deserializacji.  
  
 [!code-csharp[DataContractSerializer#13](~/samples/snippets/csharp/VS_Snippets_CFX/datacontractserializer/cs/source.cs#13)]
 [!code-vb[DataContractSerializer#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/datacontractserializer/vb/source.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Runtime.Serialization.DataContractSerializer.KnownTypes" />
        <altmember cref="T:System.Runtime.Serialization.KnownTypeAttribute" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContractSerializer (Type type, System.Collections.Generic.IEnumerable&lt;Type&gt; knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, System.Runtime.Serialization.IDataContractSurrogate dataContractSurrogate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; knownTypes, int32 maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, class System.Runtime.Serialization.IDataContractSurrogate dataContractSurrogate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.#ctor(System.Type,System.Collections.Generic.IEnumerable{System.Type},System.Int32,System.Boolean,System.Boolean,System.Runtime.Serialization.IDataContractSurrogate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContractSerializer(Type ^ type, System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, System::Runtime::Serialization::IDataContractSurrogate ^ dataContractSurrogate);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Serialization.DataContractSerializer : Type * seq&lt;Type&gt; * int * bool * bool * System.Runtime.Serialization.IDataContractSurrogate -&gt; System.Runtime.Serialization.DataContractSerializer" Usage="new System.Runtime.Serialization.DataContractSerializer (type, knownTypes, maxItemsInObjectGraph, ignoreExtensionDataObject, preserveObjectReferences, dataContractSurrogate)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="knownTypes" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
        <Parameter Name="maxItemsInObjectGraph" Type="System.Int32" />
        <Parameter Name="ignoreExtensionDataObject" Type="System.Boolean" />
        <Parameter Name="preserveObjectReferences" Type="System.Boolean" />
        <Parameter Name="dataContractSurrogate" Type="System.Runtime.Serialization.IDataContractSurrogate" />
      </Parameters>
      <Docs>
        <param name="type">Typ wystąpienia, które serializowany lub deserializowany.</param>
        <param name="knownTypes">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Type" /> zawierający znane typy, które mogą być obecne na grafie obiektu.</param>
        <param name="maxItemsInObjectGraph">Maksymalna liczba elementów na wykresie do serializacji lub deserializacji. Wartość domyślna to wartość zwrócona przez obiekt <see cref="F:System.Int32.MaxValue" /> właściwości.</param>
        <param name="ignoreExtensionDataObject">
          <see langword="true" /> Aby zignorować dane dostarczane przez rozszerzenie typu podczas serializacji i deserializacji; w przeciwnym razie <see langword="false" />.</param>
        <param name="preserveObjectReferences">
          <see langword="true" /> Aby użyć niestandardowego kodu XML konstrukcji, aby zachować dane odwołanie do obiektu; w przeciwnym razie <see langword="false" />.</param>
        <param name="dataContractSurrogate">Implementacja <see cref="T:System.Runtime.Serialization.IDataContractSurrogate" /> dostosowywania procesu serializacji.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.Serialization.DataContractSerializer" /> klasy do serializacji lub deserializacji obiektu określonego typu. Ta metoda określa również listę znanych typów, które mogą być obecne na grafie obiektu maksymalną liczbę elementów wykresu, można serializować parametrów, aby zignorować nieoczekiwane dane, czy można użyć niestandardowego kodu XML konstrukcji, aby zachować dane odwołanie do obiektu na wykresie i substytut dla niestandardowej serializacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Runtime.Serialization.DataContractSerializer> , który określa typ do serializacji lub deserializacji i wystąpienie <xref:System.Collections.Generic.IEnumerable%601> zawiera znane typy, które są używane podczas serializacji lub deserializacji. Ten kod ustawia również `ignoreExtensionDataObject` i `preserveObjectReferences` parametry `true`i określa implementację <xref:System.Runtime.Serialization.IDataContractSurrogate> interfejsu do obsługi starszych typów (typy, które nie mają <xref:System.Runtime.Serialization.DataContractAttribute> zastosowany). Aby uzyskać więcej informacji, zobacz <xref:System.Runtime.Serialization.IDataContractSurrogate> dokumentacji.  
  
 [!code-csharp[DataContractSerializer#14](~/samples/snippets/csharp/VS_Snippets_CFX/datacontractserializer/cs/source.cs#14)]
 [!code-vb[DataContractSerializer#14](~/samples/snippets/visualbasic/VS_Snippets_CFX/datacontractserializer/vb/source.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Liczba elementów przekracza wartość maksymalną.</exception>
        <altmember cref="P:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph" />
        <altmember cref="P:System.Runtime.Serialization.DataContractSerializer.PreserveObjectReferences" />
        <altmember cref="P:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject" />
        <altmember cref="T:System.Runtime.Serialization.IExtensibleDataObject" />
        <altmember cref="T:System.Runtime.Serialization.ExtensionDataObject" />
        <altmember cref="T:System.Runtime.Serialization.KnownTypeAttribute" />
        <altmember cref="T:System.Runtime.Serialization.IDataContractSurrogate" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContractSerializer (Type type, System.Collections.Generic.IEnumerable&lt;Type&gt; knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, System.Runtime.Serialization.IDataContractSurrogate dataContractSurrogate, System.Runtime.Serialization.DataContractResolver dataContractResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; knownTypes, int32 maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, class System.Runtime.Serialization.IDataContractSurrogate dataContractSurrogate, class System.Runtime.Serialization.DataContractResolver dataContractResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.#ctor(System.Type,System.Collections.Generic.IEnumerable{System.Type},System.Int32,System.Boolean,System.Boolean,System.Runtime.Serialization.IDataContractSurrogate,System.Runtime.Serialization.DataContractResolver)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContractSerializer(Type ^ type, System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, System::Runtime::Serialization::IDataContractSurrogate ^ dataContractSurrogate, System::Runtime::Serialization::DataContractResolver ^ dataContractResolver);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Serialization.DataContractSerializer : Type * seq&lt;Type&gt; * int * bool * bool * System.Runtime.Serialization.IDataContractSurrogate * System.Runtime.Serialization.DataContractResolver -&gt; System.Runtime.Serialization.DataContractSerializer" Usage="new System.Runtime.Serialization.DataContractSerializer (type, knownTypes, maxItemsInObjectGraph, ignoreExtensionDataObject, preserveObjectReferences, dataContractSurrogate, dataContractResolver)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="knownTypes" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
        <Parameter Name="maxItemsInObjectGraph" Type="System.Int32" />
        <Parameter Name="ignoreExtensionDataObject" Type="System.Boolean" />
        <Parameter Name="preserveObjectReferences" Type="System.Boolean" />
        <Parameter Name="dataContractSurrogate" Type="System.Runtime.Serialization.IDataContractSurrogate" />
        <Parameter Name="dataContractResolver" Type="System.Runtime.Serialization.DataContractResolver" />
      </Parameters>
      <Docs>
        <param name="type">Typ wystąpienia, które serializowany lub deserializowany.</param>
        <param name="knownTypes">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Type" /> zawierający znane typy, które mogą być obecne na grafie obiektu.</param>
        <param name="maxItemsInObjectGraph">Maksymalna liczba elementów na wykresie do serializacji lub deserializacji. Wartość domyślna to wartość zwrócona przez obiekt <see cref="F:System.Int32.MaxValue" /> właściwości.</param>
        <param name="ignoreExtensionDataObject">
          <see langword="true" /> Aby zignorować dane dostarczane przez rozszerzenie typu podczas serializacji i deserializacji; w przeciwnym razie <see langword="false" />.</param>
        <param name="preserveObjectReferences">
          <see langword="true" /> Aby użyć niestandardowego kodu XML konstrukcji, aby zachować dane odwołanie do obiektu; w przeciwnym razie <see langword="false" />.</param>
        <param name="dataContractSurrogate">Implementacja <see cref="T:System.Runtime.Serialization.IDataContractSurrogate" /> dostosowywania procesu serializacji.</param>
        <param name="dataContractResolver">Implementacja <see cref="T:System.Runtime.Serialization.DataContractResolver" /> do mapowania <see langword="xsi:type" /> typy kontraktów deklaracje do danych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.Serialization.DataContractSerializer" /> klasy do serializacji lub deserializacji obiektu określonego typu. Ta metoda określa również listę znanych typów, które mogą być obecne na grafie obiektu maksymalną liczbę elementów wykresu, można serializować parametrów, aby zignorować nieoczekiwane dane, czy można użyć niestandardowego kodu XML konstrukcji, aby zachować dane odwołanie do obiektu na wykresie zastępcze dla niestandardowej serializacji i alternatywę dla mapowania <see langword="xsi:type" /> deklaracje w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Ta metoda nie jest dostępna w aplikacjach Windows Store.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContractSerializer (Type type, string rootName, string rootNamespace, System.Collections.Generic.IEnumerable&lt;Type&gt; knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, System.Runtime.Serialization.IDataContractSurrogate dataContractSurrogate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, string rootName, string rootNamespace, class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; knownTypes, int32 maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, class System.Runtime.Serialization.IDataContractSurrogate dataContractSurrogate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.#ctor(System.Type,System.String,System.String,System.Collections.Generic.IEnumerable{System.Type},System.Int32,System.Boolean,System.Boolean,System.Runtime.Serialization.IDataContractSurrogate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContractSerializer(Type ^ type, System::String ^ rootName, System::String ^ rootNamespace, System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, System::Runtime::Serialization::IDataContractSurrogate ^ dataContractSurrogate);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Serialization.DataContractSerializer : Type * string * string * seq&lt;Type&gt; * int * bool * bool * System.Runtime.Serialization.IDataContractSurrogate -&gt; System.Runtime.Serialization.DataContractSerializer" Usage="new System.Runtime.Serialization.DataContractSerializer (type, rootName, rootNamespace, knownTypes, maxItemsInObjectGraph, ignoreExtensionDataObject, preserveObjectReferences, dataContractSurrogate)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="rootName" Type="System.String" />
        <Parameter Name="rootNamespace" Type="System.String" />
        <Parameter Name="knownTypes" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
        <Parameter Name="maxItemsInObjectGraph" Type="System.Int32" />
        <Parameter Name="ignoreExtensionDataObject" Type="System.Boolean" />
        <Parameter Name="preserveObjectReferences" Type="System.Boolean" />
        <Parameter Name="dataContractSurrogate" Type="System.Runtime.Serialization.IDataContractSurrogate" />
      </Parameters>
      <Docs>
        <param name="type">Typ wystąpienia, które serializowany lub deserializowany.</param>
        <param name="rootName">Element XML, który otacza zawartości do serializacji lub deserializacji.</param>
        <param name="rootNamespace">Przestrzeń nazw elementu XML, który otacza zawartości do serializacji lub deserializacji.</param>
        <param name="knownTypes">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Type" /> zawierający znane typy, które mogą być obecne na grafie obiektu.</param>
        <param name="maxItemsInObjectGraph">Maksymalna liczba elementów na wykresie do serializacji lub deserializacji.</param>
        <param name="ignoreExtensionDataObject">
          <see langword="true" /> Aby zignorować dane dostarczane przez rozszerzenie typu podczas serializacji i deserializacji; w przeciwnym razie <see langword="false" />.</param>
        <param name="preserveObjectReferences">
          <see langword="true" /> Aby użyć niestandardowego kodu XML konstrukcji, aby zachować dane odwołanie do obiektu; w przeciwnym razie <see langword="false" />.</param>
        <param name="dataContractSurrogate">Implementacja <see cref="T:System.Runtime.Serialization.IDataContractSurrogate" /> dostosowywania procesu serializacji.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.Serialization.DataContractSerializer" /> klasy do serializacji lub deserializacji obiektu określonego typu. Ta metoda określa również listę znanych typów, które mogą być obecne na grafie obiektu maksymalną liczbę elementów wykresu, można serializować parametrów, aby zignorować nieoczekiwane dane, czy można użyć niestandardowego kodu XML konstrukcji, aby zachować dane odwołanie do obiektu na wykresie zastępczy dla niestandardowej serializacji oraz — element XML i przestrzeni nazw, które zawierają zawartość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Runtime.Serialization.DataContractSerializer> , który określa typ do serializacji lub deserializacji, element główny XML i przestrzeni nazw i wystąpienie <xref:System.Collections.Generic.IEnumerable%601> zawiera typy używane podczas deserializacji. Ten kod ustawia również `ignoreExtensionDataObject` i `preserveObjectReferences` parametry `true`i określa implementację <xref:System.Runtime.Serialization.IDataContractSurrogate> interfejsu do obsługi starszych typów (typy, które nie mają <xref:System.Runtime.Serialization.DataContractAttribute> zastosowany). Aby uzyskać więcej informacji, zobacz <xref:System.Runtime.Serialization.IDataContractSurrogate> dokumentacji.  
  
 [!code-csharp[DataContractSerializer#15](~/samples/snippets/csharp/VS_Snippets_CFX/datacontractserializer/cs/source.cs#15)]
 [!code-vb[DataContractSerializer#15](~/samples/snippets/visualbasic/VS_Snippets_CFX/datacontractserializer/vb/source.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Liczba elementów przekracza wartość maksymalną.</exception>
        <altmember cref="P:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph" />
        <altmember cref="P:System.Runtime.Serialization.DataContractSerializer.PreserveObjectReferences" />
        <altmember cref="P:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject" />
        <altmember cref="T:System.Runtime.Serialization.IExtensibleDataObject" />
        <altmember cref="T:System.Runtime.Serialization.ExtensionDataObject" />
        <altmember cref="T:System.Runtime.Serialization.KnownTypeAttribute" />
        <altmember cref="T:System.Runtime.Serialization.IDataContractSurrogate" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContractSerializer (Type type, System.Xml.XmlDictionaryString rootName, System.Xml.XmlDictionaryString rootNamespace, System.Collections.Generic.IEnumerable&lt;Type&gt; knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, System.Runtime.Serialization.IDataContractSurrogate dataContractSurrogate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, class System.Xml.XmlDictionaryString rootName, class System.Xml.XmlDictionaryString rootNamespace, class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; knownTypes, int32 maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, class System.Runtime.Serialization.IDataContractSurrogate dataContractSurrogate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.#ctor(System.Type,System.Xml.XmlDictionaryString,System.Xml.XmlDictionaryString,System.Collections.Generic.IEnumerable{System.Type},System.Int32,System.Boolean,System.Boolean,System.Runtime.Serialization.IDataContractSurrogate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContractSerializer(Type ^ type, System::Xml::XmlDictionaryString ^ rootName, System::Xml::XmlDictionaryString ^ rootNamespace, System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, System::Runtime::Serialization::IDataContractSurrogate ^ dataContractSurrogate);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Serialization.DataContractSerializer : Type * System.Xml.XmlDictionaryString * System.Xml.XmlDictionaryString * seq&lt;Type&gt; * int * bool * bool * System.Runtime.Serialization.IDataContractSurrogate -&gt; System.Runtime.Serialization.DataContractSerializer" Usage="new System.Runtime.Serialization.DataContractSerializer (type, rootName, rootNamespace, knownTypes, maxItemsInObjectGraph, ignoreExtensionDataObject, preserveObjectReferences, dataContractSurrogate)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="rootName" Type="System.Xml.XmlDictionaryString" />
        <Parameter Name="rootNamespace" Type="System.Xml.XmlDictionaryString" />
        <Parameter Name="knownTypes" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
        <Parameter Name="maxItemsInObjectGraph" Type="System.Int32" />
        <Parameter Name="ignoreExtensionDataObject" Type="System.Boolean" />
        <Parameter Name="preserveObjectReferences" Type="System.Boolean" />
        <Parameter Name="dataContractSurrogate" Type="System.Runtime.Serialization.IDataContractSurrogate" />
      </Parameters>
      <Docs>
        <param name="type">Typ wystąpienia, które serializowany lub deserializowany.</param>
        <param name="rootName">
          <see cref="T:System.Xml.XmlDictionaryString" /> , Który określa element XML, który otacza zawartości do serializacji lub deserializacji.</param>
        <param name="rootNamespace">
          <see cref="T:System.Xml.XmlDictionaryString" /> , Który określa obszar nazw XML w folderze głównym.</param>
        <param name="knownTypes">A <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Type" /> zawierający znane typy, które mogą być obecne na grafie obiektu.</param>
        <param name="maxItemsInObjectGraph">Maksymalna liczba elementów na wykresie do serializacji lub deserializacji.</param>
        <param name="ignoreExtensionDataObject">
          <see langword="true" /> Aby zignorować dane dostarczane przez rozszerzenie typu podczas serializacji i deserializacji; w przeciwnym razie <see langword="false" />.</param>
        <param name="preserveObjectReferences">
          <see langword="true" /> Aby użyć niestandardowego kodu XML konstrukcji, aby zachować dane odwołanie do obiektu; w przeciwnym razie <see langword="false" />.</param>
        <param name="dataContractSurrogate">Implementacja <see cref="T:System.Runtime.Serialization.IDataContractSurrogate" /> dostosowywania procesu serializacji.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.Serialization.DataContractSerializer" /> klasy do serializacji lub deserializacji obiektu określonego typu. Ta metoda określa również listę znanych typów, które mogą być obecne na grafie obiektu maksymalną liczbę elementów wykresu, można serializować parametrów, aby zignorować nieoczekiwane dane, czy można użyć niestandardowego kodu XML konstrukcji, aby zachować dane odwołanie do obiektu na wykresie zastępcze dla niestandardowej serializacji i parametry <see cref="T:System.Xml.XmlDictionaryString" /> określające — element XML i przestrzeni nazw, która zawiera zawartość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Runtime.Serialization.DataContractSerializer> , który określa typ do serializacji lub deserializacji element główny XML i przestrzeni nazw (jako <xref:System.Xml.XmlDictionaryString> parametrów) i wystąpieniem programu <xref:System.Collections.Generic.IEnumerable%601> zawiera typy używane podczas deserializacji. Ten kod ustawia również `ignoreExtensionDataObject` i `preserveObjectReferences` parametry `true`i określa implementację <xref:System.Runtime.Serialization.IDataContractSurrogate> interfejsu do obsługi starszych typów (typy, które nie mają <xref:System.Runtime.Serialization.DataContractAttribute> zastosowany). Aby uzyskać więcej informacji, zobacz <xref:System.Runtime.Serialization.IDataContractSurrogate> dokumentacji.  
  
 [!code-csharp[DataContractSerializer#16](~/samples/snippets/csharp/VS_Snippets_CFX/datacontractserializer/cs/source.cs#16)]
 [!code-vb[DataContractSerializer#16](~/samples/snippets/visualbasic/VS_Snippets_CFX/datacontractserializer/vb/source.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Liczba elementów przekracza wartość maksymalną.</exception>
        <altmember cref="P:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph" />
        <altmember cref="P:System.Runtime.Serialization.DataContractSerializer.PreserveObjectReferences" />
        <altmember cref="P:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject" />
        <altmember cref="T:System.Runtime.Serialization.IExtensibleDataObject" />
        <altmember cref="T:System.Runtime.Serialization.ExtensionDataObject" />
        <altmember cref="T:System.Runtime.Serialization.IDataContractSurrogate" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContractSerializer (Type type, string rootName, string rootNamespace, System.Collections.Generic.IEnumerable&lt;Type&gt; knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, System.Runtime.Serialization.IDataContractSurrogate dataContractSurrogate, System.Runtime.Serialization.DataContractResolver dataContractResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, string rootName, string rootNamespace, class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; knownTypes, int32 maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, class System.Runtime.Serialization.IDataContractSurrogate dataContractSurrogate, class System.Runtime.Serialization.DataContractResolver dataContractResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.#ctor(System.Type,System.String,System.String,System.Collections.Generic.IEnumerable{System.Type},System.Int32,System.Boolean,System.Boolean,System.Runtime.Serialization.IDataContractSurrogate,System.Runtime.Serialization.DataContractResolver)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContractSerializer(Type ^ type, System::String ^ rootName, System::String ^ rootNamespace, System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, System::Runtime::Serialization::IDataContractSurrogate ^ dataContractSurrogate, System::Runtime::Serialization::DataContractResolver ^ dataContractResolver);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Serialization.DataContractSerializer : Type * string * string * seq&lt;Type&gt; * int * bool * bool * System.Runtime.Serialization.IDataContractSurrogate * System.Runtime.Serialization.DataContractResolver -&gt; System.Runtime.Serialization.DataContractSerializer" Usage="new System.Runtime.Serialization.DataContractSerializer (type, rootName, rootNamespace, knownTypes, maxItemsInObjectGraph, ignoreExtensionDataObject, preserveObjectReferences, dataContractSurrogate, dataContractResolver)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="rootName" Type="System.String" />
        <Parameter Name="rootNamespace" Type="System.String" />
        <Parameter Name="knownTypes" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
        <Parameter Name="maxItemsInObjectGraph" Type="System.Int32" />
        <Parameter Name="ignoreExtensionDataObject" Type="System.Boolean" />
        <Parameter Name="preserveObjectReferences" Type="System.Boolean" />
        <Parameter Name="dataContractSurrogate" Type="System.Runtime.Serialization.IDataContractSurrogate" />
        <Parameter Name="dataContractResolver" Type="System.Runtime.Serialization.DataContractResolver" />
      </Parameters>
      <Docs>
        <param name="type">Typ wystąpienia, które serializowany lub deserializowany.</param>
        <param name="rootName">Element XML, który otacza zawartości do serializacji lub deserializacji.</param>
        <param name="rootNamespace">Przestrzeń nazw elementu XML, który otacza zawartości do serializacji lub deserializacji.</param>
        <param name="knownTypes">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Type" /> zawierający znane typy, które mogą być obecne na grafie obiektu.</param>
        <param name="maxItemsInObjectGraph">Maksymalna liczba elementów na wykresie do serializacji lub deserializacji.</param>
        <param name="ignoreExtensionDataObject">
          <see langword="true" /> Aby zignorować dane dostarczane przez rozszerzenie typu podczas serializacji i deserializacji; w przeciwnym razie <see langword="false" />.</param>
        <param name="preserveObjectReferences">
          <see langword="true" /> Aby użyć niestandardowego kodu XML konstrukcji, aby zachować dane odwołanie do obiektu; w przeciwnym razie <see langword="false" />.</param>
        <param name="dataContractSurrogate">Implementacja <see cref="T:System.Runtime.Serialization.IDataContractSurrogate" /> dostosowywania procesu serializacji.</param>
        <param name="dataContractResolver">Implementacja <see cref="T:System.Runtime.Serialization.DataContractResolver" /> do mapowania <see langword="xsi:type" /> typy kontraktów deklaracje do danych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.Serialization.DataContractSerializer" /> klasy do serializacji lub deserializacji obiektu określonego typu. Ta metoda określa również listę znanych typów, które mogą być obecne na grafie obiektu maksymalną liczbę elementów wykresu, można serializować parametrów, aby zignorować nieoczekiwane dane, czy można użyć niestandardowego kodu XML konstrukcji, aby zachować dane odwołanie do obiektu na wykresie zastępcze dla niestandardowej serializacji, — element XML i przestrzeń nazw zawierająca zawartość i alternatywę dla mapowania <see langword="xsi:type" /> deklaracje w czasie wykonywania.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContractSerializer (Type type, System.Xml.XmlDictionaryString rootName, System.Xml.XmlDictionaryString rootNamespace, System.Collections.Generic.IEnumerable&lt;Type&gt; knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, System.Runtime.Serialization.IDataContractSurrogate dataContractSurrogate, System.Runtime.Serialization.DataContractResolver dataContractResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, class System.Xml.XmlDictionaryString rootName, class System.Xml.XmlDictionaryString rootNamespace, class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; knownTypes, int32 maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, class System.Runtime.Serialization.IDataContractSurrogate dataContractSurrogate, class System.Runtime.Serialization.DataContractResolver dataContractResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.#ctor(System.Type,System.Xml.XmlDictionaryString,System.Xml.XmlDictionaryString,System.Collections.Generic.IEnumerable{System.Type},System.Int32,System.Boolean,System.Boolean,System.Runtime.Serialization.IDataContractSurrogate,System.Runtime.Serialization.DataContractResolver)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContractSerializer(Type ^ type, System::Xml::XmlDictionaryString ^ rootName, System::Xml::XmlDictionaryString ^ rootNamespace, System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, System::Runtime::Serialization::IDataContractSurrogate ^ dataContractSurrogate, System::Runtime::Serialization::DataContractResolver ^ dataContractResolver);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Serialization.DataContractSerializer : Type * System.Xml.XmlDictionaryString * System.Xml.XmlDictionaryString * seq&lt;Type&gt; * int * bool * bool * System.Runtime.Serialization.IDataContractSurrogate * System.Runtime.Serialization.DataContractResolver -&gt; System.Runtime.Serialization.DataContractSerializer" Usage="new System.Runtime.Serialization.DataContractSerializer (type, rootName, rootNamespace, knownTypes, maxItemsInObjectGraph, ignoreExtensionDataObject, preserveObjectReferences, dataContractSurrogate, dataContractResolver)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="rootName" Type="System.Xml.XmlDictionaryString" />
        <Parameter Name="rootNamespace" Type="System.Xml.XmlDictionaryString" />
        <Parameter Name="knownTypes" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
        <Parameter Name="maxItemsInObjectGraph" Type="System.Int32" />
        <Parameter Name="ignoreExtensionDataObject" Type="System.Boolean" />
        <Parameter Name="preserveObjectReferences" Type="System.Boolean" />
        <Parameter Name="dataContractSurrogate" Type="System.Runtime.Serialization.IDataContractSurrogate" />
        <Parameter Name="dataContractResolver" Type="System.Runtime.Serialization.DataContractResolver" />
      </Parameters>
      <Docs>
        <param name="type">Typ wystąpienia, które serializowany lub deserializowany.</param>
        <param name="rootName">Element XML, który otacza zawartości do serializacji lub deserializacji.</param>
        <param name="rootNamespace">Przestrzeń nazw elementu XML, który otacza zawartości do serializacji lub deserializacji.</param>
        <param name="knownTypes">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Type" /> zawierający znane typy, które mogą być obecne na grafie obiektu.</param>
        <param name="maxItemsInObjectGraph">Maksymalna liczba elementów na wykresie do serializacji lub deserializacji.</param>
        <param name="ignoreExtensionDataObject">
          <see langword="true" /> Aby zignorować dane dostarczane przez rozszerzenie typu podczas serializacji i deserializacji; w przeciwnym razie <see langword="false" />.</param>
        <param name="preserveObjectReferences">
          <see langword="true" /> Aby użyć niestandardowego kodu XML konstrukcji, aby zachować dane odwołanie do obiektu; w przeciwnym razie <see langword="false" />.</param>
        <param name="dataContractSurrogate">Implementacja <see cref="T:System.Runtime.Serialization.IDataContractSurrogate" /> dostosowywania procesu serializacji.</param>
        <param name="dataContractResolver">Implementacja <see cref="T:System.Runtime.Serialization.DataContractResolver" /> do mapowania <see langword="xsi:type" /> typy kontraktów deklaracje do danych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.Serialization.DataContractSerializer" /> klasy do serializacji lub deserializacji obiektu określonego typu. Ta metoda określa również listę znanych typów, które mogą być obecne na grafie obiektu maksymalną liczbę elementów wykresu, można serializować parametrów, aby zignorować nieoczekiwane dane, czy można użyć niestandardowego kodu XML konstrukcji, aby zachować dane odwołanie do obiektu na wykresie zastępcze dla niestandardowej serializacji, parametry <see cref="T:System.Xml.XmlDictionaryString" /> określające — element XML i przestrzeń nazw zawierająca zawartość i alternatywę dla mapowania <see langword="xsi:type" /> deklaracje w czasie wykonywania.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContractResolver">
      <MemberSignature Language="C#" Value="public System.Runtime.Serialization.DataContractResolver DataContractResolver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Serialization.DataContractResolver DataContractResolver" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Serialization.DataContractSerializer.DataContractResolver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataContractResolver As DataContractResolver" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Serialization::DataContractResolver ^ DataContractResolver { System::Runtime::Serialization::DataContractResolver ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataContractResolver : System.Runtime.Serialization.DataContractResolver" Usage="System.Runtime.Serialization.DataContractSerializer.DataContractResolver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Serialization.DataContractResolver</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik służy do mapowania dynamicznie <see langword="xsi:type" /> deklaracje typów znanego kontraktu.</summary>
        <value>Implementacja <see cref="T:System.Runtime.Serialization.DataContractResolver" /> klasy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Serialization.DataContractResolver> Można ustawić przy użyciu <xref:System.Runtime.Serialization.DataContractSerializer> konstruktora.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContractSurrogate">
      <MemberSignature Language="C#" Value="public System.Runtime.Serialization.IDataContractSurrogate DataContractSurrogate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Serialization.IDataContractSurrogate DataContractSurrogate" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Serialization.DataContractSerializer.DataContractSurrogate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataContractSurrogate As IDataContractSurrogate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Serialization::IDataContractSurrogate ^ DataContractSurrogate { System::Runtime::Serialization::IDataContractSurrogate ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataContractSurrogate : System.Runtime.Serialization.IDataContractSurrogate" Usage="System.Runtime.Serialization.DataContractSerializer.DataContractSurrogate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Serialization.IDataContractSurrogate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ zastępczy, który można rozszerzyć proces serializacji lub deserializacji.</summary>
        <value>Implementacja <see cref="T:System.Runtime.Serialization.IDataContractSurrogate" /> klasy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Serialization.IDataContractSurrogate> Można dostosować sposób serializacji i deserializacji wystąpienia typu. Na przykład może służyć do serializacji typów starszej wersji, które nie są możliwe do serializacji, oznacza to, typów, do którego Włącz <xref:System.Runtime.Serialization.DataContractAttribute> atrybutu nie zostały zastosowane.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Serialization.IDataContractSurrogate" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreExtensionDataObject">
      <MemberSignature Language="C#" Value="public bool IgnoreExtensionDataObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreExtensionDataObject" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IgnoreExtensionDataObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreExtensionDataObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreExtensionDataObject : bool" Usage="System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą, czy chcesz zignorować dane dostarczane przez rozszerzenie klasy, gdy klasa jest serializowany lub deserializowany.</summary>
        <value>
          <see langword="true" /> Aby pominąć dane rozszerzenie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> Właściwość jest używana podczas klasy, do którego <xref:System.Runtime.Serialization.DataContractAttribute> została również zastosować implementuje <xref:System.Runtime.Serialization.IExtensibleDataObject> interfejsu. W tym przypadku dane dodane w przyszłych wersjach kontrakt jest ignorowana na odczyt i zapis. Aby uzyskać więcej informacji, zobacz [kontrakty danych zgodne](~/docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject" />
        <altmember cref="T:System.Runtime.Serialization.DataContractAttribute" />
        <altmember cref="T:System.Runtime.Serialization.IExtensibleDataObject" />
        <altmember cref="T:System.Runtime.Serialization.ExtensionDataObject" />
        <related type="Article" href="http://msdn.microsoft.com/library/413c9044-26f8-4ecb-968c-18495ea52cd9">Kontrakty danych zgodne do przodu</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartObject">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy czytnik jest umieszczony na obiekcie, który może być zdeserializowany.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartObject">
      <MemberSignature Language="C#" Value="public override bool IsStartObject (System.Xml.XmlDictionaryReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsStartObject(class System.Xml.XmlDictionaryReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.IsStartObject(System.Xml.XmlDictionaryReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsStartObject (reader As XmlDictionaryReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsStartObject(System::Xml::XmlDictionaryReader ^ reader);" />
      <MemberSignature Language="F#" Value="override this.IsStartObject : System.Xml.XmlDictionaryReader -&gt; bool" Usage="dataContractSerializer.IsStartObject reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlDictionaryReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlDictionaryReader" /> Używane do odczytywania strumienia XML.</param>
        <summary>Określa, czy <see cref="T:System.Xml.XmlDictionaryReader" /> jest umieszczony na obiekcie, który może być zdeserializowany.</summary>
        <returns>
          <see langword="true" /> Jeśli czytnik znajduje się na początku elementu strumień do odczytu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Serialization.DataContractSerializer.IsStartObject%2A> Określa, czy obiekt może odczytywać, sprawdzając, czy jest umieszczony w elemencie XML. Również sprawdza, czy nazwa i nazw elementu XML, że czytnik znajduje się w i porównuje wartości oczekiwanej nazwy i przestrzeni nazw. Można ustawić oczekiwanej nazwy i przestrzeni nazw następującym kodem: kontraktu danych, nazwę i przestrzeń nazw typu przekazany do konstruktora, lub `rootName` i `rootNamespace` wartości przekazywane do konstruktora (jeśli istnieje).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Runtime.Serialization.DataContractSerializer.IsStartObject%2A> właściwości w celu określenia, czy wykryto początek danych.  
  
 [!code-csharp[DataContractSerializer#6](~/samples/snippets/csharp/VS_Snippets_CFX/datacontractserializer/cs/source.cs#6)]
 [!code-vb[DataContractSerializer#6](~/samples/snippets/visualbasic/VS_Snippets_CFX/datacontractserializer/vb/source.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStartObject">
      <MemberSignature Language="C#" Value="public override bool IsStartObject (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsStartObject(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.IsStartObject(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsStartObject (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsStartObject(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="override this.IsStartObject : System.Xml.XmlReader -&gt; bool" Usage="dataContractSerializer.IsStartObject reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> Używane do odczytywania strumienia XML.</param>
        <summary>Określa, czy <see cref="T:System.Xml.XmlReader" /> jest umieszczony na obiekcie, który może być zdeserializowany.</summary>
        <returns>
          <see langword="true" /> Jeśli czytnik znajduje się na początku elementu strumień do odczytu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KnownTypes">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;Type&gt; KnownTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Type&gt; KnownTypes" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Serialization.DataContractSerializer.KnownTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KnownTypes As ReadOnlyCollection(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;Type ^&gt; ^ KnownTypes { System::Collections::ObjectModel::ReadOnlyCollection&lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.KnownTypes : System.Collections.ObjectModel.ReadOnlyCollection&lt;Type&gt;" Usage="System.Runtime.Serialization.DataContractSerializer.KnownTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję typów, które mogą być obecne na grafie obiektu zserializowanym przy użyciu tego wystąpienia <see cref="T:System.Runtime.Serialization.DataContractSerializer" />.</summary>
        <value>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> zawierający oczekiwanych typów przekazany jako znanych typów do <see cref="T:System.Runtime.Serialization.DataContractSerializer" /> konstruktora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Serialization.DataContractSerializer.KnownTypes%2A> Właściwość udostępnia zestaw znane typy, które są używane do serializacji i deserializacji. Na przykład, jeśli wystąpienie <xref:System.Collections.Hashtable> klasy zawiera wystąpienia `Person` klasy, Dodaj `Person` typu wystąpienia <xref:System.Collections.Generic.List%601> klasy i użyj wystąpienia, aby skonstruować wystąpienia <xref:System.Runtime.Serialization.DataContractSerializer>. Jeśli znasz innych typów do dodania do <xref:System.Collections.Hashtable>, następnie dodać te typy do kolekcji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Serialization.KnownTypeAttribute" />
      </Docs>
    </Member>
    <Member MemberName="MaxItemsInObjectGraph">
      <MemberSignature Language="C#" Value="public int MaxItemsInObjectGraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxItemsInObjectGraph" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxItemsInObjectGraph As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxItemsInObjectGraph { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxItemsInObjectGraph : int" Usage="System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalną liczbę elementów do serializacji lub deserializacji wykresu obiektu.</summary>
        <value>Maksymalna liczba elementów do serializacji lub deserializacji. Wartość domyślna to <see cref="F:System.Int32.MaxValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tę właściwość można ustawić w konfiguracji lub obowiązkowo w kodzie. Aby ustawić jej konfigurację, Dodawanie niestandardowego zachowania do sekcji zachowania i dodaj następujące ustawienie.  
  
```  
<behaviors>    <behavior name="MyServiceBehavior">        <dataContractSerializer maxItemsInObjectGraph="3" />    </behavior></behaviors>  
```  
  
 Aby ustawić tę właściwość obowiązkowo w kodzie Znajdź opis działania usługi, następnie uzyskać zachowanie operacji, na koniec ustaw właściwość, jak pokazano w poniższym kodzie.  
  
```  
OperationDescription operation = host.Description.Endpoints[0].Contract.Operations.Find("MyOperationName");operation.Behaviors.Find<DataContractSerializerOperationBehavior>().MaxItemsInObjectGraph = 3;  
```  
  
 <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> Właściwość określa maksymalną liczbę obiektów, które serializator serializuje i deserializuje w jednym <xref:System.Runtime.Serialization.DataContractSerializer.ReadObject%2A> wywołania metody. (Metoda ma zawsze wartość jeden główny obiekt, ale ten obiekt może mieć inne obiekty w składowych danych. Te obiekty mogą mieć inne obiekty itd.) Wartość domyślna to <xref:System.Int32.MaxValue>. Należy pamiętać, że podczas serializacji lub deserializacji tablic, każdy wpis tablicy jest liczona jako oddzielny obiekt. Należy również zauważyć, że niektóre obiekty mogą mieć reprezentację dużej ilości pamięci i dlatego tego samego przydziału nie może być wystarczające, aby zapobiegać atakom typu odmowa usługi. Aby uzyskać więcej informacji, zobacz [zagadnienia dotyczące zabezpieczeń dla danych](~/docs/framework/wcf/feature-details/security-considerations-for-data.md). Jeśli chcesz zwiększyć ten limit przydziału poza jego wartość domyślną, należy to zrobić na wysyłanie (serializacji) i odbieranie (deserializacji) stron. Dotyczy zarówno podczas odczytywania i zapisywania danych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Liczba elementów przekracza wartość maksymalną.</exception>
      </Docs>
    </Member>
    <Member MemberName="PreserveObjectReferences">
      <MemberSignature Language="C#" Value="public bool PreserveObjectReferences { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreserveObjectReferences" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Serialization.DataContractSerializer.PreserveObjectReferences" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreserveObjectReferences As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PreserveObjectReferences { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.PreserveObjectReferences : bool" Usage="System.Runtime.Serialization.DataContractSerializer.PreserveObjectReferences" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą, czy można użyć niestandardowego kodu XML konstrukcji, aby zachować dane odwołanie do obiektu.</summary>
        <value>
          <see langword="true" /> Aby zachować references; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadObject">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje strumień XML i zwraca po deserializacji obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadObject">
      <MemberSignature Language="C#" Value="public override object ReadObject (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object ReadObject(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.ReadObject(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadObject (reader As XmlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ ReadObject(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="override this.ReadObject : System.Xml.XmlReader -&gt; obj" Usage="dataContractSerializer.ReadObject reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> Używane do odczytywania strumienia XML.</param>
        <summary>Odczytuje strumień XML z <see cref="T:System.Xml.XmlReader" /> i zwraca po deserializacji obiektu.</summary>
        <returns>Obiekt po deserializacji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadObject">
      <MemberSignature Language="C#" Value="public override object ReadObject (System.Xml.XmlDictionaryReader reader, bool verifyObjectName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object ReadObject(class System.Xml.XmlDictionaryReader reader, bool verifyObjectName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.ReadObject(System.Xml.XmlDictionaryReader,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadObject (reader As XmlDictionaryReader, verifyObjectName As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ ReadObject(System::Xml::XmlDictionaryReader ^ reader, bool verifyObjectName);" />
      <MemberSignature Language="F#" Value="override this.ReadObject : System.Xml.XmlDictionaryReader * bool -&gt; obj" Usage="dataContractSerializer.ReadObject (reader, verifyObjectName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlDictionaryReader" />
        <Parameter Name="verifyObjectName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlDictionaryReader" /> Używane do odczytywania strumienia XML.</param>
        <param name="verifyObjectName">
          <see langword="true" /> Aby sprawdzić, czy nazwa obiektu odpowiada wartości Nazwa głównego dostarczone w Konstruktorze; w przeciwnym razie <see langword="false" />.</param>
        <summary>Odczytuje strumień XML z <see cref="T:System.Xml.XmlDictionaryReader" /> i zwraca obiekt po deserializacji oraz określa, czy dokonuje Aby sprawdzić nazwę obiektu przed odczytaniem wartości.</summary>
        <returns>Obiekt po deserializacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład odczytuje dokument XML i deserializuje wystąpienia obiektu.  
  
 [!code-csharp[DataContractSerializer#2](~/samples/snippets/csharp/VS_Snippets_CFX/datacontractserializer/cs/source.cs#2)]
 [!code-vb[DataContractSerializer#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/datacontractserializer/vb/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">
          <paramref name="verifyObjectName" /> Parametr ma wartość <see langword="true" />, a nazwy elementu i przestrzeni nazw nie odpowiadają wartościom w konstruktorze.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadObject">
      <MemberSignature Language="C#" Value="public override object ReadObject (System.Xml.XmlReader reader, bool verifyObjectName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object ReadObject(class System.Xml.XmlReader reader, bool verifyObjectName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.ReadObject(System.Xml.XmlReader,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadObject (reader As XmlReader, verifyObjectName As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ ReadObject(System::Xml::XmlReader ^ reader, bool verifyObjectName);" />
      <MemberSignature Language="F#" Value="override this.ReadObject : System.Xml.XmlReader * bool -&gt; obj" Usage="dataContractSerializer.ReadObject (reader, verifyObjectName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="verifyObjectName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> Używane do odczytywania strumienia XML.</param>
        <param name="verifyObjectName">
          <see langword="true" /> Aby sprawdzić, czy nazwa obiektu odpowiada wartości Nazwa głównego dostarczone w Konstruktorze; w przeciwnym razie <see langword="false" />.</param>
        <summary>Odczytuje strumień XML z <see cref="T:System.Xml.XmlReader" /> i zwraca obiekt po deserializacji oraz określa, czy dokonuje Aby sprawdzić nazwę obiektu przed odczytaniem wartości.</summary>
        <returns>Obiekt po deserializacji.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">
          <paramref name="verifyObjectName" /> Parametr ma wartość <see langword="true" />, a nazwy elementu i przestrzeni nazw nie odpowiadają wartościom w konstruktorze.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadObject">
      <MemberSignature Language="C#" Value="public object ReadObject (System.Xml.XmlDictionaryReader reader, bool verifyObjectName, System.Runtime.Serialization.DataContractResolver dataContractResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadObject(class System.Xml.XmlDictionaryReader reader, bool verifyObjectName, class System.Runtime.Serialization.DataContractResolver dataContractResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.ReadObject(System.Xml.XmlDictionaryReader,System.Boolean,System.Runtime.Serialization.DataContractResolver)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ReadObject(System::Xml::XmlDictionaryReader ^ reader, bool verifyObjectName, System::Runtime::Serialization::DataContractResolver ^ dataContractResolver);" />
      <MemberSignature Language="F#" Value="override this.ReadObject : System.Xml.XmlDictionaryReader * bool * System.Runtime.Serialization.DataContractResolver -&gt; obj" Usage="dataContractSerializer.ReadObject (reader, verifyObjectName, dataContractResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlDictionaryReader" />
        <Parameter Name="verifyObjectName" Type="System.Boolean" />
        <Parameter Name="dataContractResolver" Type="System.Runtime.Serialization.DataContractResolver" />
      </Parameters>
      <Docs>
        <param name="reader">Czytnik XML użyty do odczytu zawartości.</param>
        <param name="verifyObjectName">
          <see langword="true" /> Aby sprawdzić nazwę obiektu; w przeciwnym razie <see langword="false" />.</param>
        <param name="dataContractResolver">Implementacja <see cref="T:System.Runtime.Serialization.DataContractResolver" /> do mapowania <see langword="xsi:type" /> typy kontraktów deklaracje do danych.</param>
        <summary>Odczytuje dokument XML lub strumienia dokumentu i zwraca po deserializacji obiektu.  Metoda zawiera parametru do określenia, czy nazwa obiektu jest weryfikowany jest weryfikowana, a program rozpoznawania nazw dla mapowania <see langword="xsi:type" /> deklaracje w czasie wykonywania.</summary>
        <returns>Obiekt po deserializacji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SerializeReadOnlyTypes">
      <MemberSignature Language="C#" Value="public bool SerializeReadOnlyTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SerializeReadOnlyTypes" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Serialization.DataContractSerializer.SerializeReadOnlyTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SerializeReadOnlyTypes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SerializeReadOnlyTypes { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SerializeReadOnlyTypes : bool" Usage="System.Runtime.Serialization.DataContractSerializer.SerializeReadOnlyTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą, czy typy tylko do odczytu są serializowane.</summary>
        <value>
          <see langword="true" /> Jeśli typy tylko do odczytu są serializowane; <see langword="false" /> Jeśli wszystkie typy są serializowane.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEndObject">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje zamykającego elementu XML przy użyciu określonego składnika zapisywania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEndObject">
      <MemberSignature Language="C#" Value="public override void WriteEndObject (System.Xml.XmlDictionaryWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteEndObject(class System.Xml.XmlDictionaryWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.WriteEndObject(System.Xml.XmlDictionaryWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteEndObject (writer As XmlDictionaryWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteEndObject(System::Xml::XmlDictionaryWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.WriteEndObject : System.Xml.XmlDictionaryWriter -&gt; unit" Usage="dataContractSerializer.WriteEndObject writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlDictionaryWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlDictionaryWriter" /> Używany do zapisywania w strumieniu.</param>
        <summary>Zapisuje zamykający elementu XML za pomocą <see cref="T:System.Xml.XmlDictionaryWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy obiekt do serializacji wystąpienia <xref:System.Runtime.Serialization.DataContractSerializer>, a wystąpienie <xref:System.Xml.XmlDictionaryWriter> klasy.  W przykładzie użyto <xref:System.Runtime.Serialization.DataContractSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.DataContractSerializer.WriteObjectContent%2A>, i <xref:System.Runtime.Serialization.DataContractSerializer.WriteObjectContent%2A> metod, zapis danych obiektu do dokumentu XML. Wykonanie tych wywołań jest odpowiednikiem wywołania jednej z <xref:System.Runtime.Serialization.DataContractSerializer.WriteObject%2A> metody. Na przykład użytkownik może uniemożliwić wywołania oddzielnie, aby wstawić dodatkowe atrybuty XML do pliku XML, po wywołaniu <xref:System.Runtime.Serialization.DataContractSerializer.WriteStartObject%2A> metody.  
  
 [!code-csharp[DataContractSerializer#7](~/samples/snippets/csharp/VS_Snippets_CFX/datacontractserializer/cs/source.cs#7)]
 [!code-vb[DataContractSerializer#7](~/samples/snippets/visualbasic/VS_Snippets_CFX/datacontractserializer/vb/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.InvalidDataContractException">Typ poddawany serializacji nie jest zgodny z regułami kontraktu danych. Na przykład <see cref="T:System.Runtime.Serialization.DataContractAttribute" /> nie zastosowano atrybut do typu.</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">Występuje problem z wystąpieniem zapisywana.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEndObject">
      <MemberSignature Language="C#" Value="public override void WriteEndObject (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteEndObject(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.WriteEndObject(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteEndObject (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteEndObject(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.WriteEndObject : System.Xml.XmlWriter -&gt; unit" Usage="dataContractSerializer.WriteEndObject writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> Używany do zapisywania w strumieniu.</param>
        <summary>Zapisuje zamykający elementu XML za pomocą <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Runtime.Serialization.InvalidDataContractException">Typ poddawany serializacji nie jest zgodny z regułami kontraktu danych. Na przykład <see cref="T:System.Runtime.Serialization.DataContractAttribute" /> nie zastosowano atrybut do typu.</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">Występuje problem z wystąpieniem zapisywana.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteObject">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje wszystkie dane obiektów (od — element XML, zawartość i elementu zamykającego) do dokumentu XML lub strumienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteObject">
      <MemberSignature Language="C#" Value="public override void WriteObject (System.Xml.XmlWriter writer, object graph);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteObject(class System.Xml.XmlWriter writer, object graph) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.WriteObject(System.Xml.XmlWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteObject (writer As XmlWriter, graph As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteObject(System::Xml::XmlWriter ^ writer, System::Object ^ graph);" />
      <MemberSignature Language="F#" Value="override this.WriteObject : System.Xml.XmlWriter * obj -&gt; unit" Usage="dataContractSerializer.WriteObject (writer, graph)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="graph" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> Używany do zapisywania dokumentu XML lub strumienia.</param>
        <param name="graph">Obiekt, który zawiera dane do zapisania w strumieniu.</param>
        <summary>Zapisuje wszystkie dane obiektów (od elementu XML, zawartość i elementu zamykającego) do dokumentu XML lub przesyłanie strumieniowe przy użyciu <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Runtime.Serialization.InvalidDataContractException">Typ poddawany serializacji nie jest zgodny z regułami kontraktu danych. Na przykład <see cref="T:System.Runtime.Serialization.DataContractAttribute" /> nie zastosowano atrybut do typu.</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">Występuje problem z wystąpieniem zapisywana.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteObject">
      <MemberSignature Language="C#" Value="public void WriteObject (System.Xml.XmlDictionaryWriter writer, object graph, System.Runtime.Serialization.DataContractResolver dataContractResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteObject(class System.Xml.XmlDictionaryWriter writer, object graph, class System.Runtime.Serialization.DataContractResolver dataContractResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.WriteObject(System.Xml.XmlDictionaryWriter,System.Object,System.Runtime.Serialization.DataContractResolver)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteObject(System::Xml::XmlDictionaryWriter ^ writer, System::Object ^ graph, System::Runtime::Serialization::DataContractResolver ^ dataContractResolver);" />
      <MemberSignature Language="F#" Value="override this.WriteObject : System.Xml.XmlDictionaryWriter * obj * System.Runtime.Serialization.DataContractResolver -&gt; unit" Usage="dataContractSerializer.WriteObject (writer, graph, dataContractResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlDictionaryWriter" />
        <Parameter Name="graph" Type="System.Object" />
        <Parameter Name="dataContractResolver" Type="System.Runtime.Serialization.DataContractResolver" />
      </Parameters>
      <Docs>
        <param name="writer">Obiektu XmlDictionaryWriter używany do zapisywania zawartości do dokumentu XML lub strumienia.</param>
        <param name="graph">Obiekt, który zawiera zawartość do zapisania.</param>
        <param name="dataContractResolver">Implementacja <see cref="T:System.Runtime.Serialization.DataContractResolver" /> służy do mapowania <see langword="xsi:type" /> deklaracje do znanych danych zamówień.</param>
        <summary>Zapisuje wszystkie dane obiektów (począwszy od elementu XML, zawartość i otaczającego element) do dokumentu XML lub przy użyciu określonego obiektu XmlDictionaryWriter strumienia. Metoda obejmuje program rozpoznawania nazw dla mapowania <see langword="xsi:type" /> deklaracje w czasie wykonywania.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteObjectContent">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje zawartość XML bez elementu opakowywanie przy użyciu określonego składnika zapisywania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteObjectContent">
      <MemberSignature Language="C#" Value="public override void WriteObjectContent (System.Xml.XmlDictionaryWriter writer, object graph);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteObjectContent(class System.Xml.XmlDictionaryWriter writer, object graph) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.WriteObjectContent(System.Xml.XmlDictionaryWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteObjectContent (writer As XmlDictionaryWriter, graph As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteObjectContent(System::Xml::XmlDictionaryWriter ^ writer, System::Object ^ graph);" />
      <MemberSignature Language="F#" Value="override this.WriteObjectContent : System.Xml.XmlDictionaryWriter * obj -&gt; unit" Usage="dataContractSerializer.WriteObjectContent (writer, graph)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlDictionaryWriter" />
        <Parameter Name="graph" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlDictionaryWriter" /> Używany do zapisywania w strumieniu.</param>
        <param name="graph">Obiekt, który można zapisać do strumienia.</param>
        <summary>Zapisuje XML zawartości przy użyciu <see cref="T:System.Xml.XmlDictionaryWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy obiekt do serializacji wystąpienia <xref:System.Runtime.Serialization.DataContractSerializer>, a wystąpienie <xref:System.Xml.XmlDictionaryWriter> klasy.  W przykładzie użyto <xref:System.Runtime.Serialization.DataContractSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.DataContractSerializer.WriteObjectContent%2A>, i <xref:System.Runtime.Serialization.DataContractSerializer.WriteObjectContent%2A> metod, zapis danych obiektu do dokumentu XML.  
  
 [!code-csharp[DataContractSerializer#7](~/samples/snippets/csharp/VS_Snippets_CFX/datacontractserializer/cs/source.cs#7)]
 [!code-vb[DataContractSerializer#7](~/samples/snippets/visualbasic/VS_Snippets_CFX/datacontractserializer/vb/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.InvalidDataContractException">Typ poddawany serializacji nie jest zgodny z regułami kontraktu danych. Na przykład <see cref="T:System.Runtime.Serialization.DataContractAttribute" /> nie zastosowano atrybut do typu.</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">Występuje problem z wystąpieniem zapisywana.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteObjectContent">
      <MemberSignature Language="C#" Value="public override void WriteObjectContent (System.Xml.XmlWriter writer, object graph);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteObjectContent(class System.Xml.XmlWriter writer, object graph) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.WriteObjectContent(System.Xml.XmlWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteObjectContent (writer As XmlWriter, graph As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteObjectContent(System::Xml::XmlWriter ^ writer, System::Object ^ graph);" />
      <MemberSignature Language="F#" Value="override this.WriteObjectContent : System.Xml.XmlWriter * obj -&gt; unit" Usage="dataContractSerializer.WriteObjectContent (writer, graph)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="graph" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> Używany do zapisywania w strumieniu.</param>
        <param name="graph">Obiekt, który można zapisać do strumienia.</param>
        <summary>Zapisuje XML zawartości przy użyciu <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Runtime.Serialization.InvalidDataContractException">Typ poddawany serializacji nie jest zgodny z regułami kontraktu danych. Na przykład <see cref="T:System.Runtime.Serialization.DataContractAttribute" /> nie zastosowano atrybut do typu.</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">Występuje problem z wystąpieniem zapisywana.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteStartObject">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje otwierający — element XML przy użyciu określonego składnika zapisywania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteStartObject">
      <MemberSignature Language="C#" Value="public override void WriteStartObject (System.Xml.XmlDictionaryWriter writer, object graph);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteStartObject(class System.Xml.XmlDictionaryWriter writer, object graph) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.WriteStartObject(System.Xml.XmlDictionaryWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteStartObject (writer As XmlDictionaryWriter, graph As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteStartObject(System::Xml::XmlDictionaryWriter ^ writer, System::Object ^ graph);" />
      <MemberSignature Language="F#" Value="override this.WriteStartObject : System.Xml.XmlDictionaryWriter * obj -&gt; unit" Usage="dataContractSerializer.WriteStartObject (writer, graph)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlDictionaryWriter" />
        <Parameter Name="graph" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlDictionaryWriter" /> Użyty do zapisu elementu początkowego XML.</param>
        <param name="graph">Obiekt do zapisania.</param>
        <summary>Zapisuje otwierający elementu XML za pomocą <see cref="T:System.Xml.XmlDictionaryWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy obiekt do serializacji wystąpienia <xref:System.Runtime.Serialization.DataContractSerializer>, a wystąpienie <xref:System.Xml.XmlDictionaryWriter> klasy.  W przykładzie użyto <xref:System.Runtime.Serialization.DataContractSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.DataContractSerializer.WriteObjectContent%2A>, i <xref:System.Runtime.Serialization.DataContractSerializer.WriteObjectContent%2A> metod, zapis danych obiektu do dokumentu XML.  
  
 [!code-csharp[DataContractSerializer#7](~/samples/snippets/csharp/VS_Snippets_CFX/datacontractserializer/cs/source.cs#7)]
 [!code-vb[DataContractSerializer#7](~/samples/snippets/visualbasic/VS_Snippets_CFX/datacontractserializer/vb/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteStartObject">
      <MemberSignature Language="C#" Value="public override void WriteStartObject (System.Xml.XmlWriter writer, object graph);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteStartObject(class System.Xml.XmlWriter writer, object graph) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractSerializer.WriteStartObject(System.Xml.XmlWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteStartObject (writer As XmlWriter, graph As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteStartObject(System::Xml::XmlWriter ^ writer, System::Object ^ graph);" />
      <MemberSignature Language="F#" Value="override this.WriteStartObject : System.Xml.XmlWriter * obj -&gt; unit" Usage="dataContractSerializer.WriteStartObject (writer, graph)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Xml</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="graph" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> Użyty do zapisu elementu początkowego XML.</param>
        <param name="graph">Obiekt do zapisania.</param>
        <summary>Zapisuje otwierający elementu XML za pomocą <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
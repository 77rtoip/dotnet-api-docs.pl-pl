<Type Name="DataContractAttribute" FullName="System.Runtime.Serialization.DataContractAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="24efcecc4e2e14dfc6c4496732d0b78d086f5feb" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36533798" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DataContractAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DataContractAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Serialization.DataContractAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DataContractAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataContractAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type DataContractAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Serialization.Primitives</AssemblyName>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Serialization</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Enum | System.AttributeTargets.Struct, AllowMultiple=false, Inherited=false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Określa, że typ definiuje lub implementuje kontraktu danych i jest możliwy do serializacji przez serializator, takich jak <see cref="T:System.Runtime.Serialization.DataContractSerializer" />. Aby ich typ możliwy do serializacji, autorzy typ musi definiować ich typu kontraktu danych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastosuj <xref:System.Runtime.Serialization.DataContractAttribute> do typów (klasy, struktury lub wyliczenia), które są używane podczas operacji serializacji i deserializacji przez atrybut <xref:System.Runtime.Serialization.DataContractSerializer>. Jeśli wysyłać lub odbierać wiadomości przy użyciu infrastruktury usługi Windows Communication Foundation (WCF), należy również zastosować <xref:System.Runtime.Serialization.DataContractAttribute> do dowolnej klasy, które przechowywania i manipulowania dane przesłane w wiadomości. Aby uzyskać więcej informacji na temat kontraktów danych, zobacz [za pomocą kontraktów danych](~/docs/framework/wcf/feature-details/using-data-contracts.md).  
  
 Należy także zastosować <xref:System.Runtime.Serialization.DataMemberAttribute> do dowolnego pola, właściwości lub zdarzeń, który przechowuje wartości mają do serializacji. Stosując <xref:System.Runtime.Serialization.DataContractAttribute>, jawnie włączyć <xref:System.Runtime.Serialization.DataContractSerializer> do serializowania i deserializowania danych.  
  
> [!CAUTION]
>  Możesz zastosować <xref:System.Runtime.Serialization.DataMemberAttribute> do pól prywatnych. Należy pamiętać, że jest serializowany danych zwróconych przez pole (nawet jeśli jest to element prywatny) i deserializacji i w związku z tym można wyświetlić lub przechwycony przez złośliwy użytkownik lub proces.  
  
 Aby uzyskać więcej informacji na temat kontraktów danych, zobacz tematy wymienione w [za pomocą kontraktów danych](~/docs/framework/wcf/feature-details/using-data-contracts.md).  
  
## <a name="data-contracts"></a>Kontrakty danych  
 A *kontraktu danych* jest abstrakcyjny opis zestawu pól z typem danych dla każdego pola. Kontrakt danych istnieje poza jednym implementacji do usług na różnych platformach współdziałanie. Jak długo dane przekazywane między usługami spełnia ten sam kontrakt, wszystkie usługi może przetwarzać danych. To przetwarzanie jest także znana jako *luźno systemu*. Kontrakt danych również jest podobny do interfejsu, w tym kontrakt Określa, jak dane muszą być dostarczone tak, aby mogą być przetwarzane przez aplikację. Na przykład kontraktu danych może wywołać dla typu danych o nazwie "Osoba", która ma dwa pola tekstowe, o nazwie "Imię" i "Nazwisko". Aby utworzyć kontrakt danych, należy zastosować <xref:System.Runtime.Serialization.DataContractAttribute> do klasy i zastosować <xref:System.Runtime.Serialization.DataMemberAttribute> pola lub właściwości, które muszą być serializowane. Podczas serializacji, danych jest zgodna z niejawnie wbudowany w typie kontraktu danych.  
  
> [!NOTE]
>  Kontrakt danych różni się znacząco od rzeczywistej interfejsu w jego zachowanie dziedziczenia. Interfejsy są dziedziczone przez wszystkie typy pochodne. Po zastosowaniu <xref:System.Runtime.Serialization.DataContractAttribute> do klasy podstawowej, typy pochodne dziedziczy atrybut lub zachowanie. Jednak jeśli typ pochodny ma kontraktu danych, elementy członkowskie danych klasy podstawowej są serializowane. Jednak należy zastosować <xref:System.Runtime.Serialization.DataMemberAttribute> do nowych elementów członkowskich w klasie pochodnej aby je do serializacji.  
  
## <a name="xml-schema-documents-and-the-svcutil-tool"></a>Narzędzia SvcUtil i dokumentach schematów XML.  
 Jeśli są wymiana danych z innych usług, musi opisywać kontraktu danych. Dla bieżącej wersji <xref:System.Runtime.Serialization.DataContractSerializer>, schemat XML może służyć do definiowania kontraktów danych. (Inne rodzaje metadanych/opis mogą służyć do tych samych celów.) Aby utworzyć schemat XML z aplikacji, użyj [narzędzie narzędzia metadanych elementu ServiceModel (Svcutil.exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) z **/dconly** opcji wiersza polecenia. Gdy dane wejściowe do narzędzia jest zestawem, domyślnie narzędzie generuje zestaw schematów XML, które definiują wszystkie typy kontraktu danych, w tym zestawie. Z kolei umożliwia także z narzędzia Svcutil.exe do tworzenia definicji klasy Visual Basic lub C#, które odpowiadają wymaganiom schematów XML, korzystających z konstrukcji, których można wyrazić za kontraktów danych. W takim przypadku **/dconly** opcji wiersza polecenia nie jest wymagana.  
  
 Jeśli w danych wejściowych z narzędzia Svcutil.exe schematu XML Domyślnie narzędzie tworzy zestaw klas. Podczas badania tych klas, stwierdzisz, że <xref:System.Runtime.Serialization.DataContractAttribute> została zastosowana. Te klasy można użyć do utworzenia nowej aplikacji do przetwarzania danych, które muszą być wymieniane z innymi usługami.  
  
 Można również uruchomić narzędzie względem punktu końcowego, który zwraca dokumentu Web Services Description Language (WSDL) w celu automatycznego generowania kodu i konfigurację, aby utworzyć klienta usługi Windows Communication Foundation (WCF). Wygenerowany kod zawiera typy, które są oznaczone ikoną z <xref:System.Runtime.Serialization.DataContractAttribute>.  
  
## <a name="reusing-existing-types"></a>Ponowne wykorzystywanie istniejących typów  
 Kontrakt danych ma dwa podstawowe wymagania: nazwy stabilny i listy elementów członkowskich. Stabilna nazwa składa się z identyfikator przestrzeni nazw uniform resource identifier (URI) i nazwa lokalna kontraktu. Domyślnie, po zastosowaniu <xref:System.Runtime.Serialization.DataContractAttribute> do klasy, używa nazwy klasy jako nazwę lokalną i przestrzeni nazw klasy (prefiksem "http://schemas.datacontract.org/2004/07/") jako identyfikator URI przestrzeni nazw. Można zastąpić wartości domyślne ustawienie <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> i <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A> właściwości. Możesz również zmienić przestrzeni nazw, stosując <xref:System.Runtime.Serialization.ContractNamespaceAttribute> do przestrzeni nazw. Użyj tej funkcji, jeśli masz istniejący typ, który przetwarza dane, dokładnie tak, jak wymagają, ale ma inną przestrzeń nazw i nazwę klasy z kontraktu danych. Przez zastąpienie wartości domyślne, można użyć ponownie z istniejącym typem i dane serializowane są zgodne z kontraktu danych.  
  
> [!NOTE]
>  W każdy kod, można użyć słowa `DataContract` zamiast dłuższy <xref:System.Runtime.Serialization.DataContractAttribute>.  
  
## <a name="versioning"></a>Przechowywanie wersji  
 Kontrakt danych również może obsłużyć nowszy siebie samego. Oznacza to kiedy nowsza wersja kontraktu obejmuje dodatkowe dane, dane są przechowywane i zwrócony do nadawcy bez zmian. Aby to zrobić, należy zaimplementować <xref:System.Runtime.Serialization.IExtensibleDataObject> interfejsu.  
  
 Aby uzyskać więcej informacji o wersji, zobacz [przechowywanie wersji kontraktów danych](~/docs/framework/wcf/feature-details/data-contract-versioning.md).  
  
   
  
## Examples  
 W poniższym przykładzie serializuje i deserializuje klasy o nazwie `Person` do której <xref:System.Runtime.Serialization.DataContractAttribute> została zastosowana. Należy pamiętać, że <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A> i <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> właściwości zostały ustawione na wartości, które zastępują ustawienia domyślne.  
  
 [!code-csharp[DataContractAttribute#1](~/samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#1)]
 [!code-vb[DataContractAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.Serialization.IExtensibleDataObject" />
    <altmember cref="T:System.Runtime.Serialization.ExtensionDataObject" />
    <altmember cref="T:System.Runtime.Serialization.DataContractSerializer" />
    <altmember cref="T:System.Runtime.Serialization.DataMemberAttribute" />
    <altmember cref="T:System.Runtime.Serialization.ISerializable" />
    <altmember cref="T:System.Runtime.Serialization.KnownTypeAttribute" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContractAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.DataContractAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContractAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.Serialization.DataContractAttribute" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameSetExplicitly">
      <MemberSignature Language="C#" Value="public bool IsNameSetExplicitly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameSetExplicitly" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Serialization.DataContractAttribute.IsNameSetExplicitly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameSetExplicitly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameSetExplicitly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameSetExplicitly : bool" Usage="System.Runtime.Serialization.DataContractAttribute.IsNameSetExplicitly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy <see cref="P:System.Runtime.Serialization.DataContractAttribute.Name" /> została jawnie ustawiona.</summary>
        <value>Zwraca <see langword="true" /> Jeśli nazwa została jawnie ustawione; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNamespaceSetExplicitly">
      <MemberSignature Language="C#" Value="public bool IsNamespaceSetExplicitly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNamespaceSetExplicitly" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Serialization.DataContractAttribute.IsNamespaceSetExplicitly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNamespaceSetExplicitly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNamespaceSetExplicitly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNamespaceSetExplicitly : bool" Usage="System.Runtime.Serialization.DataContractAttribute.IsNamespaceSetExplicitly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy <see cref="P:System.Runtime.Serialization.DataContractAttribute.Namespace" /> została jawnie ustawiona.</summary>
        <value>Zwraca <see langword="true" /> Jeśli przestrzeń nazw została jawnie ustawione; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReference">
      <MemberSignature Language="C#" Value="public bool IsReference { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReference" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Serialization.DataContractAttribute.IsReference" />
      <MemberSignature Language="VB.NET" Value="Public Property IsReference As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReference { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsReference : bool with get, set" Usage="System.Runtime.Serialization.DataContractAttribute.IsReference" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy chcesz zachować dane odwołanie do obiektu.</summary>
        <value>
          <see langword="true" /> Aby zachować dane odwołanie do obiektu przy użyciu standardowych XML; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `IsReference` właściwości nakazać programowi <xref:System.Runtime.Serialization.DataContractSerializer> do wstawienia konstrukcje XML, które zachowują informacje o odwołaniu obiekt.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Runtime.Serialization.DataContractSerializer.PreserveObjectReferences" />
      </Docs>
    </Member>
    <Member MemberName="IsReferenceSetExplicitly">
      <MemberSignature Language="C#" Value="public bool IsReferenceSetExplicitly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReferenceSetExplicitly" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Serialization.DataContractAttribute.IsReferenceSetExplicitly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReferenceSetExplicitly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReferenceSetExplicitly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReferenceSetExplicitly : bool" Usage="System.Runtime.Serialization.DataContractAttribute.IsReferenceSetExplicitly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy <see cref="P:System.Runtime.Serialization.DataContractAttribute.IsReference" /> została jawnie ustawiona.</summary>
        <value>
          <see langword="true" /> Jeśli odwołanie ma jawnie ustawionej; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Serialization.DataContractAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Runtime.Serialization.DataContractAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę kontraktu danych dla typu.</summary>
        <value>Lokalna nazwa kontraktu danych. Wartością domyślną jest nazwa klasy, która dotyczy atrybut.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> Właściwość jest używana do nadaj nazwę kontraktu danych, która jest nazwa typu w schemacie XML. Aby uzyskać więcej informacji, zobacz [nazwy kontraktów danych](~/docs/framework/wcf/feature-details/data-contract-names.md).  
  
 Domyślnie nazwa kontraktu danych jest nazwa typu który <xref:System.Runtime.Serialization.DataContractAttribute> jest stosowany do. Jednak może być powodów, aby zmienić tę nazwę domyślną. Jedną z przyczyn jest umożliwienie istniejącego typu do przetwarzania danych, która musi być zgodna z istniejącego kontraktu danych. Na przykład istnieje typu o nazwie `Person` , ale kontrakt danych zawartych w schemacie XML wymaga, aby nazwa `Customer`. Kontrakt można spełnić przez ustawienie wartości właściwości `Customer`.  
  
 Drugi przyczyna jest umożliwienie generowania nazw, które nie są prawidłowe jako nazwy typu. Na przykład jeśli kontraktu danych wymaga nazwy, który nie jest dozwolony jako nazwę typu, należy ustawić wartość właściwości tej nazwy certyfikatów niedozwolonych. Na przykład ciąg "$value" jest niedozwolone jako nazwę typu, ale jest dozwolona jako <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> wartości właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Serialization.DataContractAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Runtime.Serialization.DataContractAttribute.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia przestrzeń nazw kontraktu danych dla typu.</summary>
        <value>Przestrzeń nazw kontraktu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia określenie określonego obszaru nazw, jeśli z danym typem musi zwracać danych, który jest zgodny z kontraktem określonych danych.  
  
> [!TIP]
>  Aby pomyślnie przesyłane dane Nazwa danych w kontraktu danych musi być takie same, zarówno klient, jak i serwera. Projekty Visual Basic, domyślnie, Dodaj prefiks do przestrzeń nazw zdefiniowana w każdym pliku (nazywanego "głównej przestrzeni nazw," o nazwie po projektu). Dodawanie tego prefiksu powoduje, że klient i serwer przestrzeni nazw maja być inne dla tego samego typu. Rozwiązanie to ustawić <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A> dla właściwości "", lub jawnie ustaw przestrzeń nazw kontraktu danych w tej właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
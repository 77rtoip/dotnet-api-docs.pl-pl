<Type Name="FieldInfo" FullName="System.Reflection.FieldInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="eaf3da8149c7beea481d56464ce8b739bcbe0488" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30564862" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class FieldInfo : System.Reflection.MemberInfo, System.Runtime.InteropServices._FieldInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit FieldInfo extends System.Reflection.MemberInfo implements class System.Runtime.InteropServices._FieldInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.FieldInfo" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class FieldInfo&#xA;Inherits MemberInfo&#xA;Implements _FieldInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class FieldInfo abstract : System::Reflection::MemberInfo, System::Runtime::InteropServices::_FieldInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._FieldInfo</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._FieldInfo))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Umożliwia odnalezienie atrybutów pola i udostępnia metadane.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informacje zawarte w polu są uzyskiwane z metadanych. <xref:System.Reflection.FieldInfo> Klasa nie ma on publicznego konstruktora. <xref:System.Reflection.FieldInfo> obiekty są uzyskiwane przez wywołanie albo <xref:System.Type.GetFields%2A> lub <xref:System.Type.GetField%2A> metody `Type` obiektu.  
  
 Pola są zmienne zdefiniowane w klasie. <xref:System.Reflection.FieldInfo> zapewnia dostęp do metadanych dla pola w obrębie klasy i zapewnia zestawu dynamicznego i funkcje get dla pola. Klasa nie została załadowana do pamięci do invoke lub get jest wywoływana dla obiektu.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Type.GetFields%2A?displayProperty=nameWithType> metody, aby uzyskać informacje dotyczące pola z <xref:System.Reflection.FieldInfo> klasy, a następnie wyświetla atrybuty pól.  
  
 [!code-cpp[FieldInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo/CPP/fieldinfo.cpp#1)]
 [!code-csharp[FieldInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo/CS/fieldinfo.cs#1)]
 [!code-vb[FieldInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo/VB/fieldinfo.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">aby uzyskać pełne zaufanie dla obiektów dziedziczących. Klasa ta nie może być dziedziczona przez kod częściowo zaufany.</permission>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <block subset="none" type="overrides">
      <para>Przy dziedziczeniu z <see cref="T:System.Reflection.FieldInfo" />, konieczne jest przesłonięcie następujących członków: <see cref="M:System.Reflection.FieldInfo.GetValue(System.Object)" /> i <see cref="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)" />.</para>
    </block>
    <altmember cref="T:System.Type" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected FieldInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; FieldInfo();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see langword="FieldInfo" /> klasy.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.FieldAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Attributes As FieldAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::FieldAttributes Attributes { System::Reflection::FieldAttributes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera atrybuty skojarzone z tym polem.</summary>
        <value>
          <see langword="FieldAttributes" /> Dla tego pola.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszyscy członkowie mają zestaw atrybutów, które są zdefiniowane w odniesieniu do określonego typu elementu członkowskiego. `FieldAttributes` informuje użytkownika, czy to pole jest pole prywatne, pola statycznego i tak dalej.  
  
 Aby uzyskać `Attributes` właściwość, najpierw uzyskać klasy `Type`. Z `Type`, Pobierz `FieldInfo`. Z `FieldInfo`, Pobierz `Attributes`.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy trzy pola i wyświetla ich atrybuty pól. A `FieldAttributes` wartość może zawierać więcej niż jeden atrybut, taki jak zarówno `Public` i `Literal`, jak pokazano w trzecim polu.  
  
 [!code-cpp[Classic FieldAttributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldAttributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldAttributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldAttributes Example/CS/source.cs#1)]
 [!code-vb[Classic FieldAttributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldAttributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania z tym wystąpieniem lub <see langword="null" />.</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest równe podanemu obiektowi.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="obj" /> equals, typ i wartość tego wystąpienia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FieldHandle">
      <MemberSignature Language="C#" Value="public abstract RuntimeFieldHandle FieldHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeFieldHandle FieldHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.FieldHandle" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FieldHandle As RuntimeFieldHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property RuntimeFieldHandle FieldHandle { RuntimeFieldHandle get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.FieldHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeFieldHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see langword="RuntimeFieldHandle" />, która jest dojścia do reprezentacji wewnętrznej metadanych pola.</summary>
        <value>Dojście do reprezentacji wewnętrznej metadanych pola.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uchwyty są prawidłowe tylko w domenie aplikacji, w którym zostały uzyskane.  
  
   
  
## Examples  
 Poniższy przykład powoduje pobranie informacji o polu MyClass.MyField i wyświetla pole skojarzone z dojścia pola.  
  
 [!code-cpp[FieldInfo_FieldHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_FieldHandle/CPP/fieldinfo_fieldhandle.cpp#1)]
 [!code-csharp[FieldInfo_FieldHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_FieldHandle/CS/fieldinfo_fieldhandle.cs#1)]
 [!code-vb[FieldInfo_FieldHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_FieldHandle/VB/fieldinfo_fieldhandle.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FieldType">
      <MemberSignature Language="C#" Value="public abstract Type FieldType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type FieldType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.FieldType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FieldType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ FieldType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.FieldType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ obiektu to pole.</summary>
        <value>Typ obiektu to pole.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ jest pewien typ danych pierwotnych `String`, `Boolean`, lub `GUID`.  
  
 Aby uzyskać `FieldType` właściwość, najpierw uzyskać klasy `Type`. Z `Type`, Pobierz `FieldInfo`. Z `FieldInfo`, Pobierz `FieldType` wartość.  
  
   
  
## Examples  
 Poniższy przykład tworzy pole, pobiera jej typu i <xref:System.Reflection.FieldInfo>i wyświetla jego <xref:System.Reflection.FieldInfo.FieldType%2A>.  
  
 [!code-cpp[Classic FieldInfo.FieldType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.FieldType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.FieldType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.FieldType Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.FieldType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.FieldType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFieldFromHandle">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera <see cref="T:System.Reflection.FieldInfo" /> pola reprezentowany przez dojście.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFieldFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.FieldInfo GetFieldFromHandle (RuntimeFieldHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.FieldInfo GetFieldFromHandle(valuetype System.RuntimeFieldHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFieldFromHandle (handle As RuntimeFieldHandle) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::FieldInfo ^ GetFieldFromHandle(RuntimeFieldHandle handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeFieldHandle" />
      </Parameters>
      <Docs>
        <param name="handle">A <see cref="T:System.RuntimeFieldHandle" /> strukturę, która zawiera dojście do reprezentacji wewnętrznej metadanych pola.</param>
        <summary>Pobiera <see cref="T:System.Reflection.FieldInfo" /> pola reprezentowanego przez określone dojście.</summary>
        <returns>A <see cref="T:System.Reflection.FieldInfo" /> obiekt reprezentujący określone przez pole <paramref name="handle" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uchwyty są prawidłowe tylko w domenie aplikacji, w którym zostały uzyskane.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Type.GetFields%2A?displayProperty=nameWithType> metodę, aby pobrać <xref:System.Reflection.FieldInfo> obiektów dla pól typu, pobiera <xref:System.RuntimeFieldHandle> struktury dla każdego pola, a następnie pobiera <xref:System.Reflection.FieldInfo> obiektów z dojść przy użyciu tego przeciążenia <xref:System.Reflection.FieldInfo.GetFieldFromHandle%2A>metody.  
  
 [!code-cpp[FieldInfo_GetFieldFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_GetFieldFromHandle/CPP/fieldinfo_getfieldfromhandle.cpp#1)]
 [!code-csharp[FieldInfo_GetFieldFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_GetFieldFromHandle/CS/fieldinfo_getfieldfromhandle.cs#1)]
 [!code-vb[FieldInfo_GetFieldFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_GetFieldFromHandle/VB/fieldinfo_getfieldfromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetFieldFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.FieldInfo GetFieldFromHandle (RuntimeFieldHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.FieldInfo GetFieldFromHandle(valuetype System.RuntimeFieldHandle handle, valuetype System.RuntimeTypeHandle declaringType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFieldFromHandle (handle As RuntimeFieldHandle, declaringType As RuntimeTypeHandle) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::FieldInfo ^ GetFieldFromHandle(RuntimeFieldHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeFieldHandle" />
        <Parameter Name="declaringType" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">A <see cref="T:System.RuntimeFieldHandle" /> strukturę, która zawiera dojście do reprezentacji wewnętrznej metadanych pola.</param>
        <param name="declaringType">A <see cref="T:System.RuntimeTypeHandle" /> strukturę, która zawiera dojście do typu ogólnego, który definiuje pole.</param>
        <summary>Pobiera <see cref="T:System.Reflection.FieldInfo" /> pola reprezentowanego przez określone dojście dla określonego typu ogólnego.</summary>
        <returns>A <see cref="T:System.Reflection.FieldInfo" /> obiekt reprezentujący określone przez pole <paramref name="handle" />, w typu ogólnego określonego przez <paramref name="declaringType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uchwyty są prawidłowe tylko w domenie aplikacji, w którym zostały uzyskane.  
  
 Zalecaną praktyką jest to, że `declaringType` zawsze należy wpisać dojście typu środowiska uruchomieniowego zbudowany `handle` należy. Oznacza to, że jeśli `handle` jest środowiska uruchomieniowego dojścia pola dla pola należącego do `MyType<int>` (`MyType(Of Integer)` w języku Visual Basic), `declaringType` jest dojście typu środowiska uruchomieniowego dla `MyType<int>`. Dojście pola środowiska wykonawczego reprezentuje pole w definicji typu ogólnego, nie używaj dojścia typu środowiska uruchomieniowego definicji typu ogólnego.  
  
 Implementacje są zgodne w niektórych przypadkach. Na przykład pojedynczej implementacji jest współużytkowana przez wszystkie typy, które są tworzone na podstawie definicji typu ogólnego określonego za pomocą typy referencyjne dla argumentów typu ogólnego. Na przykład `MyType<string>`, `MyType<object>`, i `MyType<ArrayList>` wszystkie mają tego samego wykonania. W takiej sytuacji <xref:System.Reflection.FieldInfo> obiekt, który jest zwracany reprezentuje pole w typie który `declaringType` określa niezależnie od oryginalne źródło `handle`. Takie rozwiązanie nie jest zalecane, ponieważ działa tylko wtedy, gdy argumentów typu ogólnego typu skonstruowane są typy referencyjne.  
  
 Jeśli argument ogólny jest typem wartości, dojście typu środowiska uruchomieniowego skonstruowanego typu nie jest zgodny z dojścia pola środowiska wykonawczego z konstrukcji, które mają odwołania, wpisz w tym samym miejscu parametru ogólnego, lub inną wartość, wpisz w tym miejscu . W takim przypadku jedynym sposobem, aby użyć <xref:System.Reflection.FieldInfo.GetFieldFromHandle%28System.RuntimeFieldHandle%2CSystem.RuntimeTypeHandle%29?displayProperty=nameWithType> przeciążenia jest zapewnienie, że `declaringType` jest dojście typu środowiska uruchomieniowego dla typu zbudowany `handle` należy.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób pobrać <xref:System.Reflection.FieldInfo> obiektów dla pola skonstruowane klas rodzajowych. W przykładzie zdefiniowano typ ogólny `Test<T>` (`Test(Of T)` w języku Visual Basic) z jednym polem o nazwie `TestField`, typu `T`. Pobiera przykładzie <xref:System.RuntimeFieldHandle> i <xref:System.RuntimeTypeHandle> w przypadku których `T` jest <xref:System.String>oraz przedstawiono następujące:  
  
-   Jeśli jest zgłaszany wyjątek <xref:System.Reflection.FieldInfo.GetFieldFromHandle%28System.RuntimeFieldHandle%29> używane jest przeciążenie metody. Dotyczy to nawet, jeśli pole nie jest typu `T`.  
  
-   A <xref:System.Reflection.FieldInfo> jest pomyślnie pobrane, jeśli jest w tym przypadku z tego samego konstrukcji jako dojścia pola środowiska wykonawczego, dojście typu środowiska uruchomieniowego `Test<string>`.  
  
-   Jeśli dojście typu środowiska uruchomieniowego z konstrukcji zgodne, w tym przypadku jest `Test<object>`, <xref:System.Reflection.FieldInfo> dla pola w konstrukcji zgodne są pobierane.  
  
-   Jeśli dojście typu środowiska uruchomieniowego nie pochodzi z konstrukcji zgodny, jest zwracany wyjątek. W takim przypadku określono typ wartości dla `T`.  
  
 [!code-csharp[FieldInfo_GetFieldFromHandle2#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_GetFieldFromHandle2/cs/source.cs#1)]
 [!code-vb[FieldInfo_GetFieldFromHandle2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_GetFieldFromHandle2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> jest nieprawidłowy.  
  
 —lub—  
  
 <paramref name="declaringType" /> nie jest zgodny z <paramref name="handle" />. Na przykład <paramref name="declaringType" /> jest dojście typu środowiska uruchomieniowego definicji typu ogólnego i <paramref name="handle" /> pochodzi z typu skonstruowane.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla tego wystąpienia.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOptionalCustomModifiers">
      <MemberSignature Language="C#" Value="public virtual Type[] GetOptionalCustomModifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetOptionalCustomModifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetOptionalCustomModifiers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOptionalCustomModifiers () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetOptionalCustomModifiers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera tablicę typów określających opcjonalne Modyfikatory niestandardowego pola.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiektów, które zidentyfikować opcjonalne Modyfikatory niestandardowe bieżącego pola, takie jak <see cref="T:System.Runtime.CompilerServices.IsConst" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.FieldInfo.GetOptionalCustomModifiers%2A> i <xref:System.Reflection.FieldInfo.GetRequiredCustomModifiers%2A> metody są udostępniane dla projektantów kompilatory zarządzanych. Aby uzyskać więcej informacji na Modyfikatory niestandardowych, zobacz <xref:System.Runtime.CompilerServices.IsBoxed> i powiązanych klas w <xref:System.Runtime.CompilerServices> przestrzeni nazw i specyfikacja metadanych w dokumentacji ECMA II partycji. Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRawConstantValue">
      <MemberSignature Language="C#" Value="public virtual object GetRawConstantValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetRawConstantValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetRawConstantValue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRawConstantValue () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetRawConstantValue();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość literału skojarzony z polem przez kompilator.</summary>
        <returns>
          <see cref="T:System.Object" /> Zawiera wartość literału skojarzony z polem. Jeśli wartość literału jest typ klasy z wartością elementu o wartości zero, jest zwracana wartość <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla projektantów kompilatory zarządzanych i analizatorów kodu.  
  
 Tej metody można użyć zarówno kontekstu wykonywania i kontekstu reflection-only.  
  
 W metadanych niezarządzane stałej tabela jest używana do przechowywania wartości stałych pól, parametrów i właściwości. Informacje o stałej nie wpływają bezpośrednio zachowania w czasie wykonywania. Kompilatory sprawdzić te informacje w czasie kompilacji podczas importowania metadanych. Jeśli używany, wartość stałą jest osadzony w strumieniu język pośredni (MSIL) firmy Microsoft, które kompilator emituje. Nie ma żadnych instrukcji MSIL, które mogą służyć do dostępu do tabeli stałej w czasie wykonywania.  
  
> [!NOTE]
>  Więcej informacji o stałej tabeli i wartości stałych znajduje się w dokumentacji ECMA II partycji. Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Stałe tabeli w niezarządzanych metadanych nie zawiera wartości stałej dla bieżącego pola.</exception>
        <exception cref="T:System.FormatException">Typ wartości nie jest jednym z typów dopuszczonych wspólnej specyfikacji języka (CLS). Zobacz specyfikację ECMA II partycji logicznej Format metadanych: inne struktury, używane w podpisach typów elementów.</exception>
        <exception cref="T:System.NotSupportedException">Nie ustawiono wartości stałej dla pola.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRequiredCustomModifiers">
      <MemberSignature Language="C#" Value="public virtual Type[] GetRequiredCustomModifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetRequiredCustomModifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetRequiredCustomModifiers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRequiredCustomModifiers () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetRequiredCustomModifiers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera tablicę typów określających wymagane Modyfikatory niestandardowe właściwości.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiektów, które takie jak zidentyfikować wymagane Modyfikatory niestandardowych bieżącej właściwości <see cref="T:System.Runtime.CompilerServices.IsConst" /> lub <see cref="T:System.Runtime.CompilerServices.IsImplicitlyDereferenced" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.FieldInfo.GetOptionalCustomModifiers%2A> i <xref:System.Reflection.FieldInfo.GetRequiredCustomModifiers%2A> metody są udostępniane dla projektantów kompilatory zarządzanych. Aby uzyskać więcej informacji na Modyfikatory niestandardowych, zobacz <xref:System.Runtime.CompilerServices.IsBoxed> i powiązanych klas w <xref:System.Runtime.CompilerServices> przestrzeni nazw i specyfikacja metadanych w dokumentacji ECMA II partycji. Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public abstract object GetValue (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetValue(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetValue (obj As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ GetValue(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.GetValue(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, w których wartość pola zostaną zwrócone.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej zwraca wartość pola obsługiwany przez dany obiekt.</summary>
        <returns>Obiekt zawierający wartości pola dostarczanej przez to wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli pole jest statyczny, `obj` jest ignorowana. Dla niestatycznego pola `obj` powinien być wystąpieniem klasy, która dziedziczy lub deklaruje pole. Należy pamiętać, że zwracany typ funkcji `GetValue` jest `Object`. Na przykład, jeśli pole zawiera wartość typu Boolean pierwotne wartości wystąpienia `Object` z odpowiednią wartość logiczna jest zwracana wartość. Zanim zwróci wartość, `GetValue` sprawdza, czy użytkownik ma uprawnienia dostępu.  
  
> [!NOTE]
>  Ograniczenia dostępu są ignorowane w przypadku całkowicie zaufanego kodu. Oznacza to konstruktory prywatne, pola, metody i właściwości można uzyskać dostępu do się wywołana przez odbicie w każdym przypadku, gdy kod jest w pełni zaufany.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda umożliwia dostęp do elementów członkowskich niepubliczne, jeśli element wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga i jeśli zestaw grant niepublicznych elementów członkowskich jest ograniczone do obiektu wywołującego udzielić zestawu lub być podzbiorem jej. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Reflection.FieldInfo.GetValue%2A> metody do pobierania wartości pola statycznego. Należy pamiętać, że wartość `obj` argument jest `null`.  
  
 [!code-cpp[getfldval#1](~/samples/snippets/cpp/VS_Snippets_CLR/GetFldVal/CPP/getfldval.cpp#1)]
 [!code-csharp[getfldval#1](~/samples/snippets/csharp/VS_Snippets_CLR/GetFldVal/CS/getfldval.cs#1)]
 [!code-vb[getfldval#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/GetFldVal/VB/getfldval.vb#1)]  
  
 Poniższy przykład pobiera tablicę <xref:System.Reflection.FieldInfo> obiektów, które reprezentuje pola `FieldsClass` typu, a następnie wywołania <xref:System.Reflection.FieldInfo.GetValue%2A> do wyświetlania wartości każdego pola dla `fieldsInst` obiektu.  
  
 [!code-cpp[FieldInfo_GetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_GetValue/CPP/fieldinfo_getvalue.cpp#1)]
 [!code-csharp[FieldInfo_GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_GetValue/CS/fieldinfo_getvalue.cs#1)]
 [!code-vb[FieldInfo_GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_GetValue/VB/fieldinfo_getvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">
          <block subset="none" type="note">
            <para>  
 W [.NET dla Sklepu Windows apps](http://go.microsoft.com/fwlink/?LinkID=247912) lub przenośnej biblioteki klas, catch <see cref="T:System.Exception" /> zamiast tego.  
  
</para>
          </block>  
  
 To pole jest statyczna i <paramref name="obj" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Pole jest oznaczone jako literal, ale pole ma jeden z typów literału zaakceptowane.</exception>
        <exception cref="T:System.FieldAccessException">
          <block subset="none" type="note">
            <para>  
 W [.NET dla Sklepu Windows apps](http://go.microsoft.com/fwlink/?LinkID=247912) lub przenośnej biblioteki klas, catch wyjątku klasy podstawowej <see cref="T:System.MemberAccessException" />, zamiast tego.  
  
</para>
          </block>  
  
 Obiekt wywołujący nie ma uprawnień dostępu do tego pola.</exception>
        <exception cref="T:System.ArgumentException">Metoda nie jest zadeklarowana ani dziedziczone przez klasy <paramref name="obj" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetValueDirect">
      <MemberSignature Language="C#" Value="public virtual object GetValueDirect (TypedReference obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetValueDirect(valuetype System.TypedReference obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetValueDirect(System.TypedReference)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueDirect (obj As TypedReference) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetValueDirect(TypedReference obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.GetValueDirect(System.TypedReference)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.TypedReference" />
      </Parameters>
      <Docs>
        <param name="obj">A <see cref="T:System.TypedReference" /> strukturę, która hermetyzuje zarządzanych wskaźnik do lokalizacji i środowiska uruchomieniowego reprezentację typu, które mogą być przechowywane w tej lokalizacji.</param>
        <summary>Zwraca wartość pola obsługiwany przez dany obiekt.</summary>
        <returns>
          <see langword="Object" /> Zawierający wartość pola.</returns>
        <remarks>To be added.</remarks>
        <altCompliant cref="M:System.Reflection.FieldInfo.GetValue(System.Object)" />
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący wymaga alternatywnej specyfikacja języka wspólnego (CLS), ale zamiast tego wywołać tę metodę.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsAssembly">
      <MemberSignature Language="C#" Value="public bool IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy potencjalne widoczność to pole jest opisane przez <see cref="F:System.Reflection.FieldAttributes.Assembly" />; oznacza to, że pole jest widoczne co najwyżej na inne typy w tym samym zestawie i nie są widoczne dla pochodzi typów poza zestaw.</summary>
        <value>
          <see langword="true" /> Jeśli widoczność to pole jest dokładnie opisanego przez <see cref="F:System.Reflection.FieldAttributes.Assembly" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rzeczywiste widoczność pola jest ograniczona widoczność jego typu. <xref:System.Reflection.FieldInfo.IsAssembly%2A> Właściwość może być `true` pola, ale jeśli jest to pole prywatne typu zagnieżdżonego, a następnie pole nie jest widoczna na zewnątrz typu zawierającego.  
  
 Widoczność pola jest dokładnie opisanego przez <xref:System.Reflection.FieldAttributes.Assembly?displayProperty=nameWithType> w przypadku widoczności tylko modyfikator `internal` (`Friend` w języku Visual Basic). Ta właściwość jest `false` dla pól, które są `protected internal` w języku C# (`Protected Friend` w języku Visual Basic `protected public` w języku C++); użyj <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A> właściwość do identyfikacji tych pól.  
  
   
  
## Examples  
 Poniższy przykładowy kod definiuje pola o różnej widoczności i wyświetla wartości z ich <xref:System.Reflection.FieldInfo.IsAssembly%2A>, <xref:System.Reflection.FieldInfo.IsFamily%2A>, <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>, i <xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A> właściwości.  
  
> [!NOTE]
>  Języki Visual Basic i C# nie można zdefiniować pól z <xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType> widoczność; czy poziom dostępu jest wyświetlany tylko w przykładzie C++.  
  
 [!code-cpp[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="P:System.Reflection.FieldInfo.IsFamily" />
        <altmember cref="P:System.Reflection.FieldInfo.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.FieldInfo.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFamily">
      <MemberSignature Language="C#" Value="public bool IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamily { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy widoczność to pole jest opisane przez <see cref="F:System.Reflection.FieldAttributes.Family" />; pole jest widoczne tylko w ramach jego klasa i klasy pochodne.</summary>
        <value>
          <see langword="true" /> Jeśli dostęp do tego pola jest dokładnie opisanego przez <see cref="F:System.Reflection.FieldAttributes.Family" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Widoczność pola jest dokładnie opisanego przez <xref:System.Reflection.FieldAttributes.Family?displayProperty=nameWithType> w przypadku widoczności tylko modyfikator `protected`. Ta właściwość jest `false` dla pól, które są `protected internal` w języku C# (`Protected Friend` w języku Visual Basic `protected public` w języku C++); użyj <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A> właściwość do identyfikacji tych pól.  
  
   
  
## Examples  
 Poniższy przykładowy kod definiuje pola o różnej widoczności i wyświetla wartości z ich <xref:System.Reflection.FieldInfo.IsAssembly%2A>, <xref:System.Reflection.FieldInfo.IsFamily%2A>, <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>, i <xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A> właściwości.  
  
> [!NOTE]
>  Języki Visual Basic i C# nie można zdefiniować pól z <xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType> widoczność; czy poziom dostępu jest wyświetlany tylko w przykładzie C++.  
  
 [!code-cpp[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="T:System.Type" />
        <altmember cref="P:System.Reflection.FieldInfo.IsAssembly" />
        <altmember cref="P:System.Reflection.FieldInfo.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.FieldInfo.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyAndAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyAndAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy widoczność to pole jest opisane przez <see cref="F:System.Reflection.FieldAttributes.FamANDAssem" />; oznacza to pole może być używane z klasy pochodnej, ale tylko wtedy, gdy znajdują się w tym samym zestawie.</summary>
        <value>
          <see langword="true" /> Jeśli dostęp do tego pola jest dokładnie opisanego przez <see cref="F:System.Reflection.FieldAttributes.FamANDAssem" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli pole ma <xref:System.Reflection.FieldAttributes.FamANDAssem> poziomu widoczność, może ona zostać wywołana z dowolnego elementu członkowskiego w klasie pochodnej, który jest również w tym samym zestawie, ale nie z innego typu.  
  
 Widoczność pola jest dokładnie opisanego przez <xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType> przypadku modyfikator widoczności `protected private` w języku C++. Nie można zdefiniować pól to wgląd w języku Visual Basic lub C#.  
  
   
  
## Examples  
 Poniższy przykładowy kod definiuje pola o różnej widoczności i wyświetla wartości z ich <xref:System.Reflection.FieldInfo.IsAssembly%2A>, <xref:System.Reflection.FieldInfo.IsFamily%2A>, <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>, i <xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A> właściwości.  
  
> [!NOTE]
>  Języki Visual Basic i C# nie można zdefiniować pól z <xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType> widoczność; czy poziom dostępu jest wyświetlany tylko w przykładzie C++.  
  
 [!code-cpp[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.FieldInfo.IsFamilyOrAssembly" />
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="P:System.Reflection.FieldInfo.IsAssembly" />
        <altmember cref="P:System.Reflection.FieldInfo.IsFamily" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyOrAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyOrAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy potencjalne widoczność to pole jest opisane przez <see cref="F:System.Reflection.FieldAttributes.FamORAssem" />; oznacza to, że pole mogą być dostępne klasy pochodne wszędzie tam, gdzie są one i przez klasy w tym samym zestawie.</summary>
        <value>
          <see langword="true" /> Jeśli dostęp do tego pola jest dokładnie opisanego przez <see cref="F:System.Reflection.FieldAttributes.FamORAssem" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli pole ma <xref:System.Reflection.FieldAttributes.FamORAssem> poziomu widoczność, może ona zostać wywołana z dowolnego elementu członkowskiego w klasie pochodnej lub dowolnego elementu członkowskiego w tym samym zestawie, ale nie z innego typu.  
  
 Rzeczywiste widoczność pola jest ograniczona widoczność jego typu. <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A> Właściwość może być `true` pola, ale jeśli jest to pole prywatne typu zagnieżdżonego, a następnie pole nie jest widoczna na zewnątrz typu zawierającego.  
  
 Widoczność pola jest dokładnie opisanego przez <xref:System.Reflection.FieldAttributes.FamORAssem?displayProperty=nameWithType> przypadku modyfikator widoczności `protected internal` w języku C# (`Protected Friend` w języku Visual Basic `protected public` w języku C++).  
  
   
  
## Examples  
 Poniższy przykładowy kod definiuje pola o różnej widoczności i wyświetla wartości z ich <xref:System.Reflection.FieldInfo.IsAssembly%2A>, <xref:System.Reflection.FieldInfo.IsFamily%2A>, <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>, i <xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A> właściwości.  
  
> [!NOTE]
>  Języki Visual Basic i C# nie można zdefiniować pól z <xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType> widoczność; czy poziom dostępu jest wyświetlany tylko w przykładzie C++.  
  
 [!code-cpp[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="P:System.Reflection.FieldInfo.IsAssembly" />
        <altmember cref="P:System.Reflection.FieldInfo.IsFamily" />
      </Docs>
    </Member>
    <Member MemberName="IsInitOnly">
      <MemberSignature Language="C#" Value="public bool IsInitOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsInitOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsInitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy pole można ustawić tylko w treści konstruktora.</summary>
        <value>
          <see langword="true" /> Jeśli pole ma <see langword="InitOnly" /> atrybutu ustawione; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli jest zwracana wartość `true`, pole mogą być inicjowane tylko, a następnie jest tylko do odczytu.  
  
 Aby uzyskać `IsInitOnly` właściwość, najpierw uzyskać klasy `Type`. Z `Type`, Pobierz `FieldInfo`. Z `FieldInfo`, Pobierz `IsInitOnly` właściwości. Aby uzyskać dostęp do pole niepubliczne, łączenia <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> z jednego lub obu <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> i <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> w `GetField` metody.  
  
 `IsInitOnly` Właściwości jest ustawiana podczas <xref:System.Reflection.FieldAttributes.InitOnly?displayProperty=nameWithType> ustawiono atrybut.  
  
   
  
## Examples  
 W poniższym przykładzie są tworzone dwa pola. Drugie pole jest tylko do odczytu, o nie metody dostępu set i `IsInitOnly` ma ustawioną wartość `true`.  
  
 [!code-cpp[Classic FieldInfo.IsInitOnly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.IsInitOnly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.IsInitOnly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.IsInitOnly Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.IsInitOnly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.IsInitOnly Example/VB/source.vb#1)]  
  
 Ten kod generuje następujące dane wyjściowe:  
  
 Reflection.FieldInfo  
  
 Zmodyfikowane Myfielda - A - IsInitOnly = False  
  
 Myfieldb - B pola tylko do odczytu, IsInitOnly = True  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="IsLiteral">
      <MemberSignature Language="C#" Value="public bool IsLiteral { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLiteral" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsLiteral" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLiteral As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLiteral { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsLiteral</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wartość jest zapisywana na czas kompilacji i nie można zmienić.</summary>
        <value>
          <see langword="true" /> Jeśli pole ma <see langword="Literal" /> atrybutu ustawione; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `IsLiteral` Właściwości jest ustawiana podczas `FieldAttributes.Literal` ustawiono atrybut. Jeśli ten atrybut jest ustawiona, to pole nie można zmienić i jest stały.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotSerialized">
      <MemberSignature Language="C#" Value="public bool IsNotSerialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotSerialized" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsNotSerialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotSerialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotSerialized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsNotSerialized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to pole ma <see langword="NotSerialized" /> atrybutu.</summary>
        <value>
          <see langword="true" /> Jeśli pole ma <see langword="NotSerialized" /> atrybutu ustawione; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `IsNotSerialized` Zwraca `true` Jeśli pole jest oznaczony atrybutem `FieldAttributes.NotSerialized` flagi. Ta flaga jest ustawiona na pole, wskazuje, czy pole nie ma go serializować, gdy typ jest zdalny.  
  
   
  
## Examples  
 Poniższy przykład pobiera informacje o polu pól MyClass, określa, czy pola może być Zserializowany i wyświetla wyniki.  
  
 [!code-cpp[FieldInfo_IsNotSerialized#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsNotSerialized/CPP/fieldinfo_isnotserialized.cpp#1)]
 [!code-csharp[FieldInfo_IsNotSerialized#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsNotSerialized/CS/fieldinfo_isnotserialized.cs#1)]
 [!code-vb[FieldInfo_IsNotSerialized#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsNotSerialized/VB/fieldinfo_isnotserialized.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPinvokeImpl">
      <MemberSignature Language="C#" Value="public bool IsPinvokeImpl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPinvokeImpl" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsPinvokeImpl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPinvokeImpl As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPinvokeImpl { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsPinvokeImpl</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy odpowiadającego <see langword="PinvokeImpl" /> atrybut jest ustawiony w <see cref="T:System.Reflection.FieldAttributes" />.</summary>
        <value>
          <see langword="true" /> Jeśli <see langword="PinvokeImpl" /> atrybut jest ustawiony w <see cref="T:System.Reflection.FieldAttributes" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy klasą i wyświetla nazwę pola i <xref:System.Reflection.FieldInfo.IsPinvokeImpl%2A> wartość właściwości pola.  
  
 [!code-cpp[FieldInfo_IsPInvokeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsPInvokeImpl/CPP/fieldinfo_ispinvokeimpl.cpp#1)]
 [!code-csharp[FieldInfo_IsPInvokeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsPInvokeImpl/CS/fieldinfo_ispinvokeimpl.cs#1)]
 [!code-vb[FieldInfo_IsPInvokeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsPInvokeImpl/VB/fieldinfo_ispinvokeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPrivate">
      <MemberSignature Language="C#" Value="public bool IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrivate { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy pole jest prywatny.</summary>
        <value>
          <see langword="true" /> Jeśli pole jest prywatny; w przeciwnym razie; <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pola private jest dostępny tylko w funkcji elementów członkowskich.  
  
 `IsPrivate` Właściwości jest ustawiana podczas `FieldAttributes.Private` ustawiono atrybut.  
  
 Aby uzyskać `IsPrivate` właściwość, najpierw uzyskać klasy `Type`. Z `Type`, Pobierz `FieldInfo`. Z `FieldInfo`, Pobierz `IsPrivate` właściwości. Aby uzyskać dostęp do pole niepubliczne, ustaw `BindingFlags` do `NonPublic`oraz `Static` lub `Instance` w `GetField` metody.  
  
   
  
## Examples  
 Poniższy przykład zwraca wartość wskazującą, czy pole klasy jest prywatny.  
  
 [!code-cpp[FieldInfo_IsPrivate#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsPrivate/CPP/fieldinfo_isprivate.cpp#1)]
 [!code-csharp[FieldInfo_IsPrivate#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsPrivate/CS/fieldinfo_isprivate.cs#1)]
 [!code-vb[FieldInfo_IsPrivate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsPrivate/VB/fieldinfo_isprivate.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy pole jest publiczny.</summary>
        <value>
          <see langword="true" /> Jeśli to pole nie jest publiczny; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pola publiczne są dostępne wszędzie ich odpowiednich grup są widoczne.  
  
 `IsPublic` Właściwości jest ustawiana podczas `FieldAttributes.Public` ustawiono atrybut.  
  
 Aby uzyskać `IsPublic` właściwość, najpierw uzyskać klasy `Type`. Z `Type`, Pobierz `FieldInfo`. Z `FieldInfo`, Pobierz `IsPublic` właściwości. Jeśli pole jest inne niż publicznego, jest chroniona i nie są łatwo dostępne. Aby uzyskać dostęp do pole niepubliczne, ustaw `BindingFlags` do `NonPublic`, określ `BindingFlags.Instance` lub `BindingFlags.Static`i użyj go dla `GetField` — metoda.  
  
   
  
## Examples  
 Poniższy przykład zwraca wartość wskazującą, czy pole klasy jest publicznych lub prywatnych.  
  
 [!code-cpp[Classic FieldInfo.IsPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.IsPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.IsPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.IsPublic Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.IsPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.IsPublic Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżące pole jest krytyczny dla zabezpieczeń lub bezpieczny krytyczny dla zabezpieczeń na bieżącym poziomie zaufania.</summary>
        <value>
          <see langword="true" /> Jeśli bieżące pole jest krytyczny dla zabezpieczeń lub bezpieczny krytyczny dla zabezpieczeń na bieżącym poziomie zaufania; <see langword="false" /> Jeśli jest niewidoczne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.FieldInfo.IsSecurityCritical%2A>, <xref:System.Reflection.FieldInfo.IsSecuritySafeCritical%2A>, I <xref:System.Reflection.FieldInfo.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości pola na bieżącym poziomie zaufania określone przez środowisko uruchomieniowe języka wspólnego (CLR). W poniższej tabeli przedstawiono kombinacje tych właściwości:  
  
|Poziom zabezpieczeń|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Krytyczny|`true`|`false`|`false`|  
|Bezpieczne krytyczne|`true`|`true`|`false`|  
|Przezroczyste|`false`|`false`|`true`|  
  
 Przy użyciu tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu typów i członków, sprawdzania na bieżącym poziomie zaufania i próby zduplikowane reguły środowiska uruchomieniowego.  
  
> [!IMPORTANT]
>  Dla zestawów częściowego zaufania wartość tej właściwości zależy od bieżącego poziomu zaufania dla zestawu. Jeżeli zestaw jest ładowany do domeny aplikacji częściowo zaufanej (na przykład w domenie aplikacji w trybie piaskownicy), środowisko wykonawcze ignoruje adnotacje zabezpieczeń zestawu. Zestaw i wszystkie jego typy są traktowane jako przezroczyste. Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń zestawu częściowego zaufania tylko wtedy, gdy zestaw ten jest ładowany do w pełni zaufanej domeny aplikacji (na przykład, do domyślnej domeny aplikacji z aplikacji pulpitu). Z drugiej strony zaufany zestaw (czyli zestaw z silną nazwą zainstalowaną w globalnej pamięci podręcznej zestawów) zawsze jest ładowany z pełnym zaufaniem, bez względu na poziom zaufania domeny aplikacji, więc jego bieżący poziom zaufania zawsze jest w pełni zaufany. Można określić bieżącego poziomy zaufania zestawów i domen aplikacji przy użyciu <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> i <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości.  
  
 Aby uzyskać więcej informacji na temat odbicia i przejrzystości, zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Informacje o przejrzystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.FieldInfo.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.FieldInfo.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżące pole jest bezpieczny krytyczny dla zabezpieczeń na bieżącym poziomie zaufania.</summary>
        <value>
          <see langword="true" /> Jeśli bieżące pole jest bezpieczny krytyczny dla zabezpieczeń na bieżącym poziomie zaufania; <see langword="false" /> przypadku zabezpieczeń krytyczny ani przezroczysty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.FieldInfo.IsSecurityCritical%2A>, <xref:System.Reflection.FieldInfo.IsSecuritySafeCritical%2A>, I <xref:System.Reflection.FieldInfo.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości pola na bieżącym poziomie zaufania określone przez środowisko uruchomieniowe języka wspólnego (CLR). W poniższej tabeli przedstawiono kombinacje tych właściwości:  
  
|Poziom zabezpieczeń|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Krytyczny|`true`|`false`|`false`|  
|Bezpieczne krytyczne|`true`|`true`|`false`|  
|Przezroczyste|`false`|`false`|`true`|  
  
 Przy użyciu tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu typów i członków, sprawdzania na bieżącym poziomie zaufania i próby zduplikowane reguły środowiska uruchomieniowego.  
  
> [!IMPORTANT]
>  Dla zestawów częściowego zaufania wartość tej właściwości zależy od bieżącego poziomu zaufania dla zestawu. Jeżeli zestaw jest ładowany do domeny aplikacji częściowo zaufanej (na przykład w domenie aplikacji w trybie piaskownicy), środowisko wykonawcze ignoruje adnotacje zabezpieczeń zestawu. Zestaw i wszystkie jego typy są traktowane jako przezroczyste. Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń zestawu częściowego zaufania tylko wtedy, gdy zestaw ten jest ładowany do w pełni zaufanej domeny aplikacji (na przykład, do domyślnej domeny aplikacji z aplikacji pulpitu). Z drugiej strony zaufany zestaw (czyli zestaw z silną nazwą zainstalowaną w globalnej pamięci podręcznej zestawów) zawsze jest ładowany z pełnym zaufaniem, bez względu na poziom zaufania domeny aplikacji, więc jego bieżący poziom zaufania zawsze jest w pełni zaufany. Można określić bieżącego poziomy zaufania zestawów i domen aplikacji przy użyciu <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> i <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości.  
  
 Aby uzyskać więcej informacji na temat odbicia i przejrzystości, zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Informacje o przejrzystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.FieldInfo.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.FieldInfo.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżące pole jest przezroczysty na bieżącym poziomie zaufania.</summary>
        <value>
          <see langword="true" /> Jeśli pole jest przezroczystym poziomie bezpieczeństwa na bieżącym poziomie zaufania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.FieldInfo.IsSecurityCritical%2A>, <xref:System.Reflection.FieldInfo.IsSecuritySafeCritical%2A>, I <xref:System.Reflection.FieldInfo.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości pola na bieżącym poziomie zaufania określone przez środowisko uruchomieniowe języka wspólnego (CLR). W poniższej tabeli przedstawiono kombinacje tych właściwości:  
  
|Poziom zabezpieczeń|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Krytyczny|`true`|`false`|`false`|  
|Bezpieczne krytyczne|`true`|`true`|`false`|  
|Przezroczyste|`false`|`false`|`true`|  
  
 Przy użyciu tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu typów i członków, sprawdzania na bieżącym poziomie zaufania i próby zduplikowane reguły środowiska uruchomieniowego.  
  
> [!IMPORTANT]
>  Dla zestawów częściowego zaufania wartość tej właściwości zależy od bieżącego poziomu zaufania dla zestawu. Jeżeli zestaw jest ładowany do domeny aplikacji częściowo zaufanej (na przykład w domenie aplikacji w trybie piaskownicy), środowisko wykonawcze ignoruje adnotacje zabezpieczeń zestawu. Zestaw i wszystkie jego typy są traktowane jako przezroczyste. Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń zestawu częściowego zaufania tylko wtedy, gdy zestaw ten jest ładowany do w pełni zaufanej domeny aplikacji (na przykład, do domyślnej domeny aplikacji z aplikacji pulpitu). Z drugiej strony zaufany zestaw (czyli zestaw z silną nazwą zainstalowaną w globalnej pamięci podręcznej zestawów) zawsze jest ładowany z pełnym zaufaniem, bez względu na poziom zaufania domeny aplikacji, więc jego bieżący poziom zaufania zawsze jest w pełni zaufany. Można określić bieżącego poziomy zaufania zestawów i domen aplikacji przy użyciu <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> i <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości.  
  
 Aby uzyskać więcej informacji na temat odbicia i przejrzystości, zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Informacje o przejrzystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.FieldInfo.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.FieldInfo.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy odpowiadającego <see langword="SpecialName" /> atrybut jest ustawiony w <see cref="T:System.Reflection.FieldAttributes" /> modułu wyliczającego.</summary>
        <value>
          <see langword="true" /> Jeśli <see langword="SpecialName" /> atrybut jest ustawiony w <see cref="T:System.Reflection.FieldAttributes" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwy zaczynać ani zawierać znaku podkreślenia (_), metod dostępu do właściwości i metod przeładowanie operatora są przykłady nazw, które mogą wymagać specjalnego przetwarzania przez niektóre kompilatory.  
  
   
  
## Examples  
 Poniższy przykład zwraca wartość wskazującą, czy pola w klasie zawierają atrybut jako SpecialName.  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsStatic">
      <MemberSignature Language="C#" Value="public bool IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsStatic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStatic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStatic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy pole jest statyczne.</summary>
        <value>
          <see langword="true" /> Jeśli to pole ma statycznej; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli pole jest statyczny, jedną kopię pole jest współużytkowana przez wszystkie wystąpienia typu.  
  
 `IsStatic` Właściwości jest ustawiana podczas `FieldAttributes.Static` ustawiono atrybut.  
  
 Aby uzyskać `IsStatic` właściwość, najpierw uzyskać klasy `Type`. Z `Type`, Pobierz `FieldInfo`. Z `FieldInfo`, Pobierz `IsStatic` właściwości. Aby uzyskać dostęp do pole niepubliczne, ustaw `BindingFlags` do `NonPublic` w `GetField` — metoda i ustawić dostępności `Instance` lub `Static`.  
  
   
  
## Examples  
 Poniższy przykład określa, czy określone pole jest statyczna i wyświetla wyniki.  
  
 [!code-cpp[Classic FieldInfo.IsStatic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.IsStatic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.IsStatic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.IsStatic Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.IsStatic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.IsStatic Example/VB/source.vb#1)]  
  
 Ten kod generuje następujące dane wyjściowe:  
  
 Reflection.FieldInfo  
  
 Myfielda — pole prywatne; IsStatic — FAŁSZ  
  
 Myfieldb - B pola statycznego; IsStatic — PRAWDA  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Reflection.MemberTypes" /> wartość wskazującą, czy ten element członkowski jest polem.</summary>
        <value>A <see cref="T:System.Reflection.MemberTypes" /> wartość wskazującą, czy ten element członkowski jest polem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zastępuje <xref:System.Reflection.MemberInfo.MemberType%2A>. W związku z tym podczas badania zestawu <xref:System.Reflection.MemberInfo> obiektów — na przykład tablicy zwracanej przez <xref:System.Type.GetMembers%2A> — <xref:System.Reflection.MemberInfo.MemberType%2A> zwraca <xref:System.Reflection.MemberTypes.Field?displayProperty=nameWithType> tylko wtedy, gdy dany element jest polem.  
  
   
  
## Examples  
 Poniższy przykład określa, czy określony element członkowski jest polem i wyświetla wyniki.  
  
 [!code-cpp[Classic FieldInfo.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.MemberType Example/VB/source.vb#1)]  
  
 Ten kod generuje następujące dane wyjściowe:  
  
 Reflection.FieldInfo  
  
 Myfield.Field — pole prywatne; MemberType jest polem  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.FieldInfo left, System.Reflection.FieldInfo right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.FieldInfo left, class System.Reflection.FieldInfo right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.op_Equality(System.Reflection.FieldInfo,System.Reflection.FieldInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As FieldInfo, right As FieldInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::FieldInfo ^ left, System::Reflection::FieldInfo ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.FieldInfo" />
        <Parameter Name="right" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="right">Drugi obiekt, który będzie porównywany.</param>
        <summary>Wskazuje, czy dwa <see cref="T:System.Reflection.FieldInfo" /> obiekty są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.FieldInfo left, System.Reflection.FieldInfo right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.FieldInfo left, class System.Reflection.FieldInfo right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.op_Inequality(System.Reflection.FieldInfo,System.Reflection.FieldInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As FieldInfo, right As FieldInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::FieldInfo ^ left, System::Reflection::FieldInfo ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.FieldInfo" />
        <Parameter Name="right" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="right">Drugi obiekt, który będzie porównywany.</param>
        <summary>Wskazuje, czy dwa <see cref="T:System.Reflection.FieldInfo" /> obiekty nie są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> nie jest równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia wartość pola dla danego obiektu do danej wartości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object obj, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValue(object obj, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (obj As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetValue(System::Object ^ obj, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.SetValue(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, w których wartość pola zostanie ustawiona.</param>
        <param name="value">Wartość do przypisania do tego pola.</param>
        <summary>Ustawia wartość pola obsługiwany przez dany obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przypisze `value` do pola, sprawdzając tego wystąpienia obiektu `obj`. Jeśli pole jest statyczny, `obj` zostaną zignorowane. Dla niestatycznego pola `obj` powinien być wystąpieniem klasy, która dziedziczy lub deklaruje pole. Nowa wartość jest przekazywany jako `Object`. Na przykład, jeśli typ pola jest wartość logiczna, wystąpienie `Object` z odpowiednią wartość logiczna została przekazana wartość. Przed ustawieniem wartości, `SetValue` sprawdza, czy użytkownik ma uprawnienia dostępu. Końcowy jest metoda wygody, wywoływania następujące `SetValue` metody.  
  
> [!NOTE]
>  Całkowicie zaufanego kodu ma uprawnienia wymagane do uzyskiwania dostępu i wywoływanie konstruktory prywatne, metody, pól i właściwości, za pomocą odbicia.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda umożliwia dostęp do elementów członkowskich niepubliczne, jeśli element wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga i jeśli zestaw grant niepublicznych elementów członkowskich jest ograniczone do obiektu wywołującego udzielić zestawu lub być podzbiorem jej. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
   
  
## Examples  
 Poniższy przykład ustawia wartość pola, pobiera i wyświetla wartość modyfikuje pole i wyświetla wyniki.  
  
 [!code-cpp[FieldInfo_SetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_SetValue/CPP/fieldinfo_setvalue.cpp#1)]
 [!code-csharp[FieldInfo_SetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_SetValue/CS/fieldinfo_setvalue.cs#1)]
 [!code-vb[FieldInfo_SetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_SetValue/VB/fieldinfo_setvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FieldAccessException">
          <block subset="none" type="note">
            <para>  
 W [.NET dla Sklepu Windows apps](http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośnej biblioteki klas](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch wyjątku klasy podstawowej <see cref="T:System.MemberAccessException" />, zamiast tego.  
  
</para>
          </block>  
  
 Obiekt wywołujący nie ma uprawnień dostępu do tego pola.</exception>
        <exception cref="T:System.Reflection.TargetException">
          <block subset="none" type="note">
            <para>  
 W [.NET dla Sklepu Windows apps](http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośnej biblioteki klas](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch <see cref="T:System.Exception" /> zamiast tego.  
  
</para>
          </block>
          <paramref name="obj" /> Parametr jest <see langword="null" /> i pole jest polem wystąpienia.</exception>
        <exception cref="T:System.ArgumentException">Pole nie istnieje w obiekcie.  
  
 —lub—  
  
 <paramref name="value" /> Parametr nie może przekonwertować i przechowywać w polu.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do aktualizowania pola tylko do inicjowania. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public abstract void SetValue (object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValue(object obj, object value, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void SetValue(System::Object ^ obj, System::Object ^ value, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, w których wartość pola zostanie ustawiona.</param>
        <param name="value">Wartość do przypisania do tego pola.</param>
        <param name="invokeAttr">Pola <see langword="Binder" /> określający typ powiązania, które jest pożądany (na przykład <see langword="Binder.CreateInstance" /> lub <see langword="Binder.ExactBinding" />).</param>
        <param name="binder">Zestaw właściwości, który umożliwia powiązanie koercja typy argumentów i wywoływania elementów członkowskich w drodze odbicia. Jeśli <c>integratora</c> jest <see langword="null" />, następnie <see langword="Binder.DefaultBinding" /> jest używany.</param>
        <param name="culture">Preferencje oprogramowania określonej kultury.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, ustawia wartość pola obsługiwany przez dany obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przypisze `value` do pola odzwierciedlone przez to wystąpienie na `obj`. Jeśli pole jest statyczny, `obj` zostaną zignorowane. Dla niestatycznego pola `obj` powinien być wystąpieniem klasy, która dziedziczy lub deklaruje pole. Nowa wartość jest przekazywany jako `Object`. Na przykład, jeśli typ pola jest `Boolean`, wystąpienie `Object` z odpowiednią wartość logiczna została przekazana wartość. Przed ustawieniem wartości, `SetValue` sprawdza, czy użytkownik ma uprawnienia dostępu.  
  
> [!NOTE]
>  Całkowicie zaufanego kodu ma uprawnienia wymagane do uzyskiwania dostępu i wywoływanie konstruktory prywatne, metody, pól i właściwości, za pomocą odbicia.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda umożliwia dostęp do elementów członkowskich niepubliczne, jeśli element wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga i jeśli zestaw grant niepublicznych elementów członkowskich jest ograniczone do obiektu wywołującego udzielić zestawu lub być podzbiorem jej. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FieldAccessException">Obiekt wywołujący nie ma uprawnień dostępu do tego pola.</exception>
        <exception cref="T:System.Reflection.TargetException">
          <paramref name="obj" /> Parametr jest <see langword="null" /> i pole jest polem wystąpienia.</exception>
        <exception cref="T:System.ArgumentException">Pole nie istnieje w obiekcie.  
  
 —lub—  
  
 <paramref name="value" /> Parametr nie może przekonwertować i przechowywać w polu.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do aktualizowania pola tylko do inicjowania. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetValueDirect">
      <MemberSignature Language="C#" Value="public virtual void SetValueDirect (TypedReference obj, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValueDirect(valuetype System.TypedReference obj, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.SetValueDirect(System.TypedReference,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetValueDirect (obj As TypedReference, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetValueDirect(TypedReference obj, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.SetValueDirect(System.TypedReference,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.TypedReference" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">A <see cref="T:System.TypedReference" /> strukturę, która hermetyzuje zarządzanych wskaźnik do lokalizacji i środowiska uruchomieniowego reprezentację typu, które mogą być przechowywane w tej lokalizacji.</param>
        <param name="value">Wartość do przypisania do tego pola.</param>
        <summary>Ustawia wartość pola obsługiwany przez dany obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda umożliwia dostęp do elementów członkowskich niepubliczne, jeśli element wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga i jeśli zestaw grant niepublicznych elementów członkowskich jest ograniczone do obiektu wywołującego udzielić zestawu lub być podzbiorem jej. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)" />
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący wymaga alternatywnej specyfikacja języka wspólnego (CLS), ale zamiast tego wywołać tę metodę.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._FieldInfo.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _FieldInfo.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._FieldInfo.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _FieldInfo.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._FieldInfo.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_FieldInfo::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="rgszNames">Przekazana tablica nazw ma być mapowana.</param>
        <param name="cNames">Liczba nazw, które mają być mapowane.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</param>
        <param name="rgDispId">Tablica przydzielana przez obiekt wywołujący, który otrzymuje numery identyfikacyjne odpowiadających nazw.</param>
        <summary>Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetIDsOfNames`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._FieldInfo.GetType">
      <MemberSignature Language="C#" Value="Type _FieldInfo.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._FieldInfo.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _FieldInfo.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._FieldInfo.GetType() = System::Runtime::InteropServices::_FieldInfo::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.Type" /> reprezentujący obiekt <see cref="T:System.Reflection.FieldInfo" /> typu.</summary>
        <returns>A <see cref="T:System.Type" /> reprezentujący obiekt <see cref="T:System.Reflection.FieldInfo" /> typu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._FieldInfo.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _FieldInfo.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._FieldInfo.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _FieldInfo.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._FieldInfo.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_FieldInfo::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informacje o typie, który będzie zwracany.</param>
        <param name="lcid">Identyfikator regionalny dla informacji o typie.</param>
        <param name="ppTInfo">Otrzymuje wskaźnik do obiektu informacji żądanego typu.</param>
        <summary>Pobiera informacje o typie dla obiektu, których następnie można użyć do uzyskania informacji o typie interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfo`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._FieldInfo.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _FieldInfo.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._FieldInfo.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _FieldInfo.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._FieldInfo.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_FieldInfo::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Wskazuje lokalizację, która odbiera informację o liczbie typów dostarczanych przez obiekt.</param>
        <summary>Pobiera informację o liczbie typów interfejsów, jakie zawiera obiekt (0 lub 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfoCount`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._FieldInfo.Invoke">
      <MemberSignature Language="C#" Value="void _FieldInfo.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._FieldInfo.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _FieldInfo.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._FieldInfo.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_FieldInfo::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Określa element członkowski.</param>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</param>
        <param name="wFlags">Flagi opisujące kontekst wywołania.</param>
        <param name="pDispParams">Wskaźnik do struktury zawiera tablicę argumentów, tablicę identyfikatorów DISPID argumentu dla nazwanych argumentów i zlicza liczbę elementów w tablicach.</param>
        <param name="pVarResult">Wskaźnik miejsca, gdzie ma być przechowywany wynik.</param>
        <param name="pExcepInfo">Wskaźnik do struktury, która zawiera informacje o wyjątku.</param>
        <param name="puArgErr">Indeks pierwszego argumentu, który zawiera błąd.</param>
        <summary>Umożliwia dostęp do właściwości i metod udostępnianych przez obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::Invoke`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="MethodInfo" FullName="System.Reflection.MethodInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1db341516e40895b598e4179337fa6c67cfc445c" />
    <Meta Name="ms.sourcegitcommit" Value="1465f1a9bce3970cd9e95769eaa641b92a0a22d5" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/18/2018" />
    <Meta Name="ms.locfileid" Value="31481557" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class MethodInfo : System.Reflection.MethodBase, System.Runtime.InteropServices._MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit MethodInfo extends System.Reflection.MethodBase implements class System.Runtime.InteropServices._MethodInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.MethodInfo" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MethodInfo&#xA;Inherits MethodBase&#xA;Implements _MethodInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodInfo abstract : System::Reflection::MethodBase, System::Runtime::InteropServices::_MethodInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodInfo</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodInfo))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="befcc-101">Umożliwia odnalezienie atrybuty metody i zapewnia dostęp do metody metadanych.</span>
      <span class="sxs-lookup">
        <span data-stu-id="befcc-101">Discovers the attributes of a method and provides access to method metadata.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="befcc-102"><xref:System.Reflection.MethodInfo> Klasa reprezentuje metod typu.</span><span class="sxs-lookup"><span data-stu-id="befcc-102">The <xref:System.Reflection.MethodInfo> class represents a method of a type.</span></span> <span data-ttu-id="befcc-103">Można użyć <xref:System.Reflection.MethodInfo> obiektu, aby uzyskać informacje na temat metody, który reprezentuje obiekt i można wywołać metody.</span><span class="sxs-lookup"><span data-stu-id="befcc-103">You can use a <xref:System.Reflection.MethodInfo> object to obtain information about the method that the object represents and to invoke the method.</span></span> <span data-ttu-id="befcc-104">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="befcc-104">For example:</span></span>  
  
-   <span data-ttu-id="befcc-105">Można określić metody widoczność przez pobieranie wartości z <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, <xref:System.Reflection.MethodBase.IsPrivate%2A>, i <xref:System.Reflection.MethodBase.IsPublic%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="befcc-105">You can determine the method's visibility by retrieving the values of the <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, <xref:System.Reflection.MethodBase.IsPrivate%2A>, and <xref:System.Reflection.MethodBase.IsPublic%2A> properties.</span></span>  
  
-   <span data-ttu-id="befcc-106">Użytkownik stwierdzi, jakie atrybuty są stosowane do metody pobierając zaletą <xref:System.Reflection.MethodBase.Attributes%2A> właściwość lub wywołanie <xref:System.Reflection.Assembly.GetCustomAttributes%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="befcc-106">You can discover what attributes are applied to the method by retrieving the value of the <xref:System.Reflection.MethodBase.Attributes%2A> property or calling the <xref:System.Reflection.Assembly.GetCustomAttributes%2A> method.</span></span>  
  
-   <span data-ttu-id="befcc-107">Można określić, czy metody jest rodzajowy — metoda, otwórz skonstruowany metody ogólnej lub zamkniętej metody ogólnej tworzony przez pobieranie wartości z <xref:System.Reflection.MethodBase.IsGenericMethod%2A> i <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="befcc-107">You can determine whether the method is a generic method, an open constructed generic method, or a closed constructed generic method, by retrieving the values of the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> and <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> properties.</span></span>  
  
-   <span data-ttu-id="befcc-108">Możesz uzyskać informacje na temat parametrów metod i zwracany typ z <xref:System.Reflection.MethodBase.GetParameters%2A> — metoda i <xref:System.Reflection.MethodInfo.ReturnParameter%2A>, <xref:System.Reflection.MethodInfo.ReturnType%2A>, i <xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="befcc-108">You can get information about the method's parameters and return type from the <xref:System.Reflection.MethodBase.GetParameters%2A> method and the <xref:System.Reflection.MethodInfo.ReturnParameter%2A>, <xref:System.Reflection.MethodInfo.ReturnType%2A>, and <xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A> properties.</span></span>  
  
-   <span data-ttu-id="befcc-109">Można wykonać metody w wystąpieniu klasy przez wywołanie metody <xref:System.Reflection.MethodBase.Invoke%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="befcc-109">You can execute a method on a class instance by calling the <xref:System.Reflection.MethodBase.Invoke%2A> method.</span></span>  
  
-   <span data-ttu-id="befcc-110">Można utworzyć wystąpienia <xref:System.Reflection.MethodInfo> obiekt, który reprezentuje skonstruowane Metoda ogólna z odpowiadającą definicję metody rodzajowej przez wywołanie metody <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="befcc-110">You can instantiate a <xref:System.Reflection.MethodInfo> object that represents a constructed generic method from one that represents a generic method definition by calling the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method.</span></span>  
  
 <span data-ttu-id="befcc-111">Można utworzyć wystąpienia <xref:System.Reflection.MethodInfo> wystąpień przez wywołanie metody <xref:System.Type.GetMethods%2A?displayProperty=nameWithType> lub <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> metody, lub przez wywołanie metody <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> metody <xref:System.Reflection.MethodInfo> obiekt, który reprezentuje definicję metody rodzajowej.</span><span class="sxs-lookup"><span data-stu-id="befcc-111">You can instantiate a <xref:System.Reflection.MethodInfo> instances by calling the <xref:System.Type.GetMethods%2A?displayProperty=nameWithType> or <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> method, or by calling the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> method of a <xref:System.Reflection.MethodInfo> object that represents a generic method definition.</span></span>  
  
 <span data-ttu-id="befcc-112">Lista niezmiennej warunki postanowienia związane z metody ogólne, zobacz <xref:System.Reflection.MethodBase.IsGenericMethod%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="befcc-112">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="befcc-113">Lista niezmiennej warunki dla innych terminów używanych w ogólnym odbicia, zobacz <xref:System.Type.IsGenericType%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="befcc-113">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property.</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="befcc-114">aby uzyskać pełne zaufanie dla obiektów dziedziczących.</span>
      <span class="sxs-lookup">
        <span data-stu-id="befcc-114">for full trust for inheritors.</span>
      </span>
      <span data-ttu-id="befcc-115">Klasa ta nie może być dziedziczona przez kod częściowo zaufany.</span>
      <span class="sxs-lookup">
        <span data-stu-id="befcc-115">This class cannot be inherited by partially trusted code.</span>
      </span>
    </permission>
    <threadsafe>
      <span data-ttu-id="befcc-116">Ten typ jest bezpieczny wątkowo.</span>
      <span class="sxs-lookup">
        <span data-stu-id="befcc-116">This type is thread safe.</span>
      </span>
    </threadsafe>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="befcc-117">Przy dziedziczeniu z <see cref="T:System.Reflection.MethodInfo" />, konieczne jest przesłonięcie <see cref="M:System.Reflection.MethodInfo.GetBaseDefinition" />, <see cref="P:System.Reflection.MethodInfo.ReturnType" />, <see cref="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes" />, <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, i <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />.</span>
        <span class="sxs-lookup">
          <span data-stu-id="befcc-117">When you inherit from <see cref="T:System.Reflection.MethodInfo" />, you must override <see cref="M:System.Reflection.MethodInfo.GetBaseDefinition" />, <see cref="P:System.Reflection.MethodInfo.ReturnType" />, <see cref="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes" />, <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, and <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />.</span>
        </span>
      </para>
    </block>
    <altmember cref="Overload:System.Type.GetMethods" />
    <altmember cref="Overload:System.Type.GetMethod" />
    <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodInfo();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="befcc-118">Inicjuje nowe wystąpienie klasy <see cref="T:System.Reflection.MethodInfo" /> klasy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-118">Initializes a new instance of the <see cref="T:System.Reflection.MethodInfo" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="befcc-119">Tworzy delegata z tej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-119">Creates a delegate from this method.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public virtual Delegate CreateDelegate (Type delegateType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.CreateDelegate(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDelegate (delegateType As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Delegate ^ CreateDelegate(Type ^ delegateType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="befcc-120">Typ delegata do utworzenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-120">The type of the delegate to create.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="befcc-121">Tworzy określonego typu delegata z tej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-121">Creates a delegate of the specified type from this method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="befcc-122">Delegat dla tej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-122">The delegate for this method.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public virtual Delegate CreateDelegate (Type delegateType, object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.CreateDelegate(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDelegate (delegateType As Type, target As Object) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="befcc-123">Typ delegata do utworzenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-123">The type of the delegate to create.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="befcc-124">Obiekt będący celem delegata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-124">The object targeted by the delegate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="befcc-125">Tworzy określonego typu delegata określonego obiektu docelowego z tej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-125">Creates a delegate of the specified type with the specified target from this method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="befcc-126">Delegat dla tej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-126">The delegate for this method.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="befcc-127">Obiekt do porównania z tym wystąpieniem lub <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-127">An object to compare with this instance, or <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="befcc-128">Zwraca wartość wskazującą, czy to wystąpienie jest równe podanemu obiektowi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-128">Returns a value that indicates whether this instance is equal to a specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="befcc-129">
            <see langword="true" /> Jeśli <paramref name="obj" /> equals, typ i wartość tego wystąpienia; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-129">
              <see langword="true" /> if <paramref name="obj" /> equals the type and value of this instance; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetBaseDefinition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="befcc-130">Po przesłonięciu w klasie pochodnej zwraca <see cref="T:System.Reflection.MethodInfo" /> obiekt zadeklarować metody w klasie podstawowej bezpośrednio lub pośrednio w których był pierwszy metodę reprezentowaną przez to wystąpienie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-130">When overridden in a derived class, returns the <see cref="T:System.Reflection.MethodInfo" /> object for the method on the direct or indirect base class in which the method represented by this instance was first declared.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="befcc-131">A <see cref="T:System.Reflection.MethodInfo" /> obiektu dla pierwszego implementacja tej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-131">A <see cref="T:System.Reflection.MethodInfo" /> object for the first implementation of this method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="befcc-132"><xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> Metoda zwraca pierwsza definicja metody określonej w hierarchii klasy.</span><span class="sxs-lookup"><span data-stu-id="befcc-132">The <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns the first definition of the specified method in the class hierarchy.</span></span> <span data-ttu-id="befcc-133">Można określić typu znaleziono pobierając zaletą pierwsza definicja metody <xref:System.Reflection.MemberInfo.DeclaringType%2A> zwrócona właściwość <xref:System.Reflection.MethodInfo> obiektu.</span><span class="sxs-lookup"><span data-stu-id="befcc-133">You can determine the type on which the first definition of the method is found by retrieving the value of the <xref:System.Reflection.MemberInfo.DeclaringType%2A> property on the returned <xref:System.Reflection.MethodInfo> object.</span></span>  
  
 <span data-ttu-id="befcc-134"><xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> Metoda działa w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="befcc-134">The <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method behaves as follows:</span></span>  
  
-   <span data-ttu-id="befcc-135">Jeśli bieżący <xref:System.Reflection.MethodInfo> obiekt reprezentuje implementację interfejsu <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> metoda zwraca bieżącą <xref:System.Reflection.MethodInfo> obiektu.</span><span class="sxs-lookup"><span data-stu-id="befcc-135">If the current <xref:System.Reflection.MethodInfo> object represents an interface implementation, the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns the current <xref:System.Reflection.MethodInfo> object.</span></span>  
  
-   <span data-ttu-id="befcc-136">Jeśli bieżący <xref:System.Reflection.MethodInfo> obiekt reprezentuje metodę, która zastępuje wirtualnego definicji w klasie podstawowej, <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> metoda zwraca <xref:System.Reflection.MethodInfo> obiekt, który reprezentuje definicję wirtualnego.</span><span class="sxs-lookup"><span data-stu-id="befcc-136">If the current <xref:System.Reflection.MethodInfo> object represents a method that overrides a virtual definition in a base class, the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns a <xref:System.Reflection.MethodInfo> object that represents the virtual definition.</span></span>  
  
-   <span data-ttu-id="befcc-137">Jeśli bieżący <xref:System.Reflection.MethodInfo> obiekt reprezentuje metodę, która zostanie określony z `new` — słowo kluczowe języka C# lub `Shadows` słów kluczowych w języku Visual Basic (podobnie jak w `newslot`, zgodnie z opisem w [Wspólny System typów](~/docs/standard/base-types/common-type-system.md)), <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> metoda zwraca bieżącą <xref:System.Reflection.MethodInfo> obiektu.</span><span class="sxs-lookup"><span data-stu-id="befcc-137">If the current <xref:System.Reflection.MethodInfo> object represents a method that is specified with the `new` keyword in C# or the `Shadows` keyword in Visual Basic (as in `newslot`, as described in [Common Type System](~/docs/standard/base-types/common-type-system.md)), the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns the current <xref:System.Reflection.MethodInfo> object.</span></span>  
  
-   <span data-ttu-id="befcc-138">Jeśli bieżący <xref:System.Reflection.MethodInfo> obiekt reprezentuje dziedziczonej metody (to znaczy bieżącej metody nie ma własną implementację), <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> metoda zwraca <xref:System.Reflection.MethodInfo> obiekt, który reprezentuje najniższą metody w hierarchii klasy.</span><span class="sxs-lookup"><span data-stu-id="befcc-138">If the current <xref:System.Reflection.MethodInfo> object represents an inherited method (that is, the current method does not provide its own implementation), the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns a <xref:System.Reflection.MethodInfo> object that represents the lowest method in the class hierarchy.</span></span> <span data-ttu-id="befcc-139">Na przykład jeśli `Base.ToString` zastępuje `Object.ToString`, i `Derived.ToString` zastępuje `Base.ToString`, wywoływania <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> metoda <xref:System.Reflection.MethodInfo> obiekt, który reprezentuje `Derived.ToString` zwraca <xref:System.Reflection.MethodInfo> obiekt, który reprezentuje `Object.ToString`.</span><span class="sxs-lookup"><span data-stu-id="befcc-139">For example, if `Base.ToString` overrides `Object.ToString`, and `Derived.ToString` overrides `Base.ToString`, calling the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method on a <xref:System.Reflection.MethodInfo> object that represents `Derived.ToString` returns a <xref:System.Reflection.MethodInfo> object that represents `Object.ToString`.</span></span>  
  
-   <span data-ttu-id="befcc-140">Jeśli bieżący <xref:System.Reflection.MethodInfo> obiekt reprezentuje metodę, która nie znajduje się w dowolnej klasy podstawowej <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> metoda zwraca bieżącą <xref:System.Reflection.MethodInfo> obiektu.</span><span class="sxs-lookup"><span data-stu-id="befcc-140">If the current <xref:System.Reflection.MethodInfo> object represents a method that is not present in any base class, the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns the current <xref:System.Reflection.MethodInfo> object.</span></span>  
  
 <span data-ttu-id="befcc-141">Można określić, czy bieżąca metoda zastępuje metodę w klasie podstawowej przez wywołanie metody <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="befcc-141">You can determine whether the current method overrides a method in a base class by calling the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method.</span></span> <span data-ttu-id="befcc-142">Poniższy przykład implementuje `IsOverride` metody, w tym.</span><span class="sxs-lookup"><span data-stu-id="befcc-142">The following example implements an `IsOverride` method that does this.</span></span>  
  
 [!code-csharp[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/IsOverride1.cs#2)]
 [!code-vb[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/IsOverride1.vb#2)]  
  
 <span data-ttu-id="befcc-143">Aby wywołać `GetBaseDefinition` metody:</span><span class="sxs-lookup"><span data-stu-id="befcc-143">To call the `GetBaseDefinition` method:</span></span>  
  
1.  <span data-ttu-id="befcc-144">Pobierz <xref:System.Type> obiekt, który reprezentuje typ (klasy lub struktury), który zawiera właściwości.</span><span class="sxs-lookup"><span data-stu-id="befcc-144">Get a <xref:System.Type> object that represents the type (the class or structure) that contains the property.</span></span> <span data-ttu-id="befcc-145">Jeśli pracujesz z obiektem (wystąpienia typu), można wywołać jej <xref:System.Object.GetType%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="befcc-145">If you are working with an object (an instance of a type), you can call its <xref:System.Object.GetType%2A> method.</span></span> <span data-ttu-id="befcc-146">W przeciwnym razie można używać operatora C# lub operator języka Visual Basic, co w przykładzie przedstawiono.</span><span class="sxs-lookup"><span data-stu-id="befcc-146">Otherwise, you can use the C#  operator or the Visual Basic  operator, as the example illustrates.</span></span>  
  
2.  <span data-ttu-id="befcc-147">Pobierz <xref:System.Reflection.MethodInfo> obiekt, który reprezentuje metodę, w którym Cię.</span><span class="sxs-lookup"><span data-stu-id="befcc-147">Get a <xref:System.Reflection.MethodInfo> object that represents the method in which you're interested.</span></span> <span data-ttu-id="befcc-148">Aby to zrobić, uzyskiwanie tablicę wszystkich metod z <xref:System.Type.GetMethods%2A?displayProperty=nameWithType> metody, a następnie iteracja elementów w tablicy, lub można pobrać <xref:System.Reflection.MethodInfo> obiekt, który reprezentuje bezpośrednio przez wywołanie metody <xref:System.Type.GetMethod%28System.String%29?displayProperty=nameWithType> — metoda i określając Nazwa metody.</span><span class="sxs-lookup"><span data-stu-id="befcc-148">You can do this by getting an array of all methods from the <xref:System.Type.GetMethods%2A?displayProperty=nameWithType> method and then iterating the elements in the array, or you can retrieve the <xref:System.Reflection.MethodInfo> object that represents the method directly by calling the <xref:System.Type.GetMethod%28System.String%29?displayProperty=nameWithType> method and specifying the method name.</span></span>  
  
3.  <span data-ttu-id="befcc-149">Wywołanie <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> metodę, aby uzyskać wartość <xref:System.Reflection.MethodInfo> obiekt, który reprezentuje definicję metody podstawowej.</span><span class="sxs-lookup"><span data-stu-id="befcc-149">Call the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method to get the value of the <xref:System.Reflection.MethodInfo> object that represents the base method definition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="befcc-150">W poniższym przykładzie pokazano zachowanie <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="befcc-150">The following example demonstrates the behavior of the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method.</span></span>  
  
 [!code-csharp[System.Reflection.MethodInfo.GetBaseDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/getbasedefinition1.cs#1)]
 [!code-vb[System.Reflection.MethodInfo.GetBaseDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/getbasedefinition1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="befcc-151">Zwraca tablicę <see cref="T:System.Type" /> obiekty reprezentujące argumenty typu metody ogólnej lub parametrów typu definicję metody rodzajowej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-151">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="befcc-152">Tablica <see cref="T:System.Type" /> obiekty reprezentujące argumenty typu metody ogólnej lub parametrów typu definicję metody rodzajowej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-152">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span>
          </span>
          <span data-ttu-id="befcc-153">Zwraca pustą tablicę, jeśli bieżąca metoda nie jest metody rodzajowej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-153">Returns an empty array if the current method is not a generic method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="befcc-154">Elementy tablicy zwracane są w kolejności, w którym są wyświetlane na liście parametrów typu dla metody ogólnej.</span><span class="sxs-lookup"><span data-stu-id="befcc-154">The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</span></span>  
  
-   <span data-ttu-id="befcc-155">Jeśli bieżąca metoda jest metodą skonstruowane zamkniętego (oznacza to, <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> zwraca `false`), tablica zwrócona przez <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> metoda zawiera typy, które zostały przypisane do parametrów typu ogólnego Metoda ogólna Definicja.</span><span class="sxs-lookup"><span data-stu-id="befcc-155">If the current method is a closed constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic method definition.</span></span>  
  
-   <span data-ttu-id="befcc-156">Jeśli bieżąca metoda jest ogólną definicją metody, tablica zawiera parametry typu.</span><span class="sxs-lookup"><span data-stu-id="befcc-156">If the current method is a generic method definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="befcc-157">Jeśli bieżąca metoda jest metodą skonstruowane Otwórz (oznacza to, <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> zwraca `true`), w których określone typy zostały przypisane do niektórych parametrów typu i typu parametry otaczającej typów ogólnych zostały przypisane do innego typu Parametry, tablica zawiera typy i typ parametrów.</span><span class="sxs-lookup"><span data-stu-id="befcc-157">If the current method is an open constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</span></span> <span data-ttu-id="befcc-158">Użyj <xref:System.Type.IsGenericParameter%2A> właściwości, aby wiedzieli, od siebie.</span><span class="sxs-lookup"><span data-stu-id="befcc-158">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="befcc-159">Do pokazania w tym scenariuszu, zobacz przykład kodu <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="befcc-159">For a demonstration of this scenario, see the code example for the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="befcc-160">Lista niezmiennej warunki postanowienia związane z metody ogólne, zobacz <xref:System.Reflection.MethodBase.IsGenericMethod%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="befcc-160">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="befcc-161">Lista niezmiennej warunki dla innych terminów używanych w ogólnym odbicia, zobacz <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="befcc-161">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
## Examples  
 <span data-ttu-id="befcc-162">Poniższy przykład kodu pokazuje, jak uzyskać argumentów typu ogólnego metody i wyświetlić je.</span><span class="sxs-lookup"><span data-stu-id="befcc-162">The following code example shows how to get the type arguments of a generic method and display them.</span></span>  
  
 <span data-ttu-id="befcc-163">Ten przykład jest częścią większego przykładu udostępnionego dla <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="befcc-163">This example is part of a larger example provided for the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#8](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#8)]
 [!code-csharp[MethodInfo.Generics#8](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#8)]
 [!code-vb[MethodInfo.Generics#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="befcc-164">Ta metoda nie jest obsługiwana.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-164">This method is not supported.</span>
          </span>
        </exception>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="M:System.Reflection.MethodInfo.GetGenericMethodDefinition" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo GetGenericMethodDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetGenericMethodDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.GetGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericMethodDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetGenericMethodDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="befcc-165">Zwraca <see cref="T:System.Reflection.MethodInfo" /> obiekt, który reprezentuje definicję metody rodzajowej, z którego można skonstruować bieżącej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-165">Returns a <see cref="T:System.Reflection.MethodInfo" /> object that represents a generic method definition from which the current method can be constructed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="befcc-166">A <see cref="T:System.Reflection.MethodInfo" /> obiekt reprezentujący definicję metody rodzajowej, z którego można skonstruować bieżącej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-166">A <see cref="T:System.Reflection.MethodInfo" /> object representing a generic method definition from which the current method can be constructed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="befcc-167">Definicję metody rodzajowej jest szablonem, z którego można utworzyć metody.</span><span class="sxs-lookup"><span data-stu-id="befcc-167">A generic method definition is a template from which methods can be constructed.</span></span> <span data-ttu-id="befcc-168">Na przykład z ogólną definicją metody `T M<T>(T t)` (wyrażony w języku C# składni; `Function M(Of T)(ByVal tVal As T) As T` w języku Visual Basic) można utworzyć i wywołanie metody `int M<int>(int t)` (`Function M(Of Integer)(ByVal tVal As Integer) As Integer` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="befcc-168">For example, from the generic method definition `T M<T>(T t)` (expressed in C# syntax; `Function M(Of T)(ByVal tVal As T) As T` in Visual Basic) you can construct and invoke the method `int M<int>(int t)` (`Function M(Of Integer)(ByVal tVal As Integer) As Integer` in Visual Basic).</span></span> <span data-ttu-id="befcc-169">Podane <xref:System.Reflection.MethodInfo> metody skonstruowany obiekt reprezentujący to <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> metoda zwraca definicję metody rodzajowej.</span><span class="sxs-lookup"><span data-stu-id="befcc-169">Given a <xref:System.Reflection.MethodInfo> object representing this constructed method, the <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> method returns the generic method definition.</span></span>  
  
 <span data-ttu-id="befcc-170">Jeśli dwie metody skonstruowane są tworzone na podstawie tę samą definicję metody rodzajowej <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> metoda zwraca takie same <xref:System.Reflection.MethodInfo> obiektu dla obu metod.</span><span class="sxs-lookup"><span data-stu-id="befcc-170">If two constructed methods are created from the same generic method definition, the <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> method returns the same <xref:System.Reflection.MethodInfo> object for both methods.</span></span>  
  
 <span data-ttu-id="befcc-171">Jeśli należy wywołać <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> na <xref:System.Reflection.MethodInfo> reprezentujący definicję metody rodzajowej, zwraca bieżącą <xref:System.Reflection.MethodInfo>.</span><span class="sxs-lookup"><span data-stu-id="befcc-171">If you call <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> on a <xref:System.Reflection.MethodInfo> that already represents a generic method definition, it returns the current <xref:System.Reflection.MethodInfo>.</span></span>  
  
 <span data-ttu-id="befcc-172">Jeśli definicję metody rodzajowej zawiera parametry ogólne typu deklarującego, będzie definicję metody rodzajowej specyficzne dla poszczególnych typów skonstruowane.</span><span class="sxs-lookup"><span data-stu-id="befcc-172">If a generic method definition includes generic parameters of the declaring type, there will be a generic method definition specific to each constructed type.</span></span> <span data-ttu-id="befcc-173">Rozważmy na przykład następujący kod w języku C#, Visual Basic i C++:</span><span class="sxs-lookup"><span data-stu-id="befcc-173">For example, consider the following C#, Visual Basic, and C++ code:</span></span>  
  
```  
class B<U,V> {}  
class C<T> { public B<T,S> M<S>() {...}}  
  
Class B(Of U, V)  
End Class  
Class C(Of T)  
    Public Function M(Of S)() As B(Of T, S)  
        ...  
    End Function  
End Class   
  
generic <typename U, typename V> ref class B {};  
generic <typename T> ref class C  
{  
public:  
    generic <typename S> B<T,S>^ M() {...};  
};  
```  
  
 <span data-ttu-id="befcc-174">W typie skonstruowane `C<int>` (`C(Of Integer)` w języku Visual Basic), Metoda ogólna `M` zwraca `B<int, S>`.</span><span class="sxs-lookup"><span data-stu-id="befcc-174">In the constructed type `C<int>` (`C(Of Integer)` in Visual Basic), the generic method `M` returns `B<int, S>`.</span></span> <span data-ttu-id="befcc-175">W otwartym typem `C<T>`, `M` zwraca `B<T, S>`.</span><span class="sxs-lookup"><span data-stu-id="befcc-175">In the open type `C<T>`, `M` returns `B<T, S>`.</span></span> <span data-ttu-id="befcc-176">W obu przypadkach <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> zwraca `true` dla <xref:System.Reflection.MethodInfo> reprezentujący `M`, więc <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> można wywołać w obu <xref:System.Reflection.MethodInfo> obiektów.</span><span class="sxs-lookup"><span data-stu-id="befcc-176">In both cases, the <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> property returns `true` for the <xref:System.Reflection.MethodInfo> that represents `M`, so <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> can be called on both <xref:System.Reflection.MethodInfo> objects.</span></span> <span data-ttu-id="befcc-177">W przypadku utworzony typ wyniku wywołania metody <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> jest <xref:System.Reflection.MethodInfo> może być wywołany.</span><span class="sxs-lookup"><span data-stu-id="befcc-177">In the case of the constructed type, the result of calling <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> is a <xref:System.Reflection.MethodInfo> that can be invoked.</span></span> <span data-ttu-id="befcc-178">W przypadku typu otwartego <xref:System.Reflection.MethodInfo> zwrócony przez <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> nie można wywołać.</span><span class="sxs-lookup"><span data-stu-id="befcc-178">In the case of the open type, the <xref:System.Reflection.MethodInfo> returned by <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> cannot be invoked.</span></span>  
  
 <span data-ttu-id="befcc-179">Lista niezmiennej warunki postanowienia związane z metody ogólne, zobacz <xref:System.Reflection.MethodBase.IsGenericMethod%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="befcc-179">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="befcc-180">Lista niezmiennej warunki dla innych terminów używanych w ogólnym odbicia, zobacz <xref:System.Type.IsGenericType%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="befcc-180">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="befcc-181">Poniższy przykład kodu pokazuje klasy z metody rodzajowej i kod wymagany do uzyskania <xref:System.Reflection.MethodInfo> w przypadku metody powiązać metodę argumentów typu, a wrócić oryginalnej definicji typu ogólnego z powiązanej metody.</span><span class="sxs-lookup"><span data-stu-id="befcc-181">The following code example shows a class with a generic method and the code required to obtain a <xref:System.Reflection.MethodInfo> for the method, bind the method to type arguments, and get the original generic type definition back from the bound method.</span></span>  
  
 <span data-ttu-id="befcc-182">Ten przykład jest częścią większego przykładu udostępnionego dla <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="befcc-182">This example is part of a larger example provided for the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#2](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#2)]
 [!code-csharp[MethodInfo.Generics#2](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#2)]
 [!code-vb[MethodInfo.Generics#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#2)]  
[!code-cpp[MethodInfo.Generics#3](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#3)]
[!code-csharp[MethodInfo.Generics#3](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#3)]
[!code-vb[MethodInfo.Generics#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#3)]  
[!code-cpp[MethodInfo.Generics#4](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#4)]
[!code-csharp[MethodInfo.Generics#4](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#4)]
[!code-vb[MethodInfo.Generics#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="befcc-183">Bieżąca metoda nie jest metody rodzajowej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-183">The current method is not a generic method.</span>
          </span>
          <span data-ttu-id="befcc-184">Oznacza to <see cref="P:System.Reflection.MethodBase.IsGenericMethod" /> zwraca <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-184">That is, <see cref="P:System.Reflection.MethodBase.IsGenericMethod" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="befcc-185">Ta metoda nie jest obsługiwana.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-185">This method is not supported.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="befcc-186">Zwraca kod skrótu dla tego wystąpienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-186">Returns the hash code for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="befcc-187">Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-187">A 32-bit signed integer hash code.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo MakeGenericMethod (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo MakeGenericMethod(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericMethod (ParamArray typeArguments As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ MakeGenericMethod(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">
          <span data-ttu-id="befcc-188">Tablica typów mają być zastępowane dla parametrów typu w bieżącej definicji metody ogólnej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-188">An array of types to be substituted for the type parameters of the current generic method definition.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="befcc-189">Zastępuje elementy tablicą typów parametrów typu bieżącej definicji metody rodzajowej i zwraca <see cref="T:System.Reflection.MethodInfo" /> obiekt reprezentujący powstałe w ten sposób skonstruowany — metoda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-189">Substitutes the elements of an array of types for the type parameters of the current generic method definition, and returns a <see cref="T:System.Reflection.MethodInfo" /> object representing the resulting constructed method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="befcc-190">A <see cref="T:System.Reflection.MethodInfo" /> obiekt, który reprezentuje metodę skonstruowane sformułowany, zastępując elementy <paramref name="typeArguments" /> dla parametrów typu w bieżącej definicji metody rodzajowej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-190">A <see cref="T:System.Reflection.MethodInfo" /> object that represents the constructed method formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic method definition.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="befcc-191"><xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> Metoda służy do pisania kodu, który przypisuje określone typy parametrów typu definicję metody rodzajowej, co powoduje utworzenie <xref:System.Reflection.MethodInfo> obiekt, który reprezentuje konkretnej metody skonstruowane.</span><span class="sxs-lookup"><span data-stu-id="befcc-191">The <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method allows you to write code that assigns specific types to the type parameters of a generic method definition, thus creating a <xref:System.Reflection.MethodInfo> object that represents a particular constructed method.</span></span> <span data-ttu-id="befcc-192">Jeśli <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> właściwości tego <xref:System.Reflection.MethodInfo> zwraca obiekt `true`, można go było wywołanie metody lub do utworzenia delegata można wywołać metody.</span><span class="sxs-lookup"><span data-stu-id="befcc-192">If the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property of this <xref:System.Reflection.MethodInfo> object returns `true`, you can use it to invoke the method or to create a delegate to invoke the method.</span></span>  
  
 <span data-ttu-id="befcc-193">Metody skonstruowany przy <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> metoda może być otwarty, oznacza to, że niektóre z jego argumentów typu można otaczającej typów ogólnych parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="befcc-193">Methods constructed with the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method can be open, that is, some of their type arguments can be type parameters of enclosing generic types.</span></span> <span data-ttu-id="befcc-194">Można użyć tych metod skonstruowane otwarte podczas generowania zestawów dynamicznych.</span><span class="sxs-lookup"><span data-stu-id="befcc-194">You might use such open constructed methods when you generate dynamic assemblies.</span></span> <span data-ttu-id="befcc-195">Rozważmy na przykład następujący kod w języku C#, Visual Basic i C++.</span><span class="sxs-lookup"><span data-stu-id="befcc-195">For example, consider the following C#, Visual Basic, and C++ code.</span></span>  
  
```  
class C  
{  
    T N<T,U>(T t, U u) {...}  
    public V M<V>(V v)  
    {  
        return N<V,int>(v, 42);  
    }  
}  
  
Class C  
    Public Function N(Of T,U)(ByVal ta As T, ByVal ua As U) As T  
        ...  
    End Function  
    Public Function M(Of V)(ByVal va As V ) As V  
        Return N(Of V, Integer)(va, 42)  
    End Function  
End Class  
  
ref class C  
{  
private:  
    generic <typename T, typename U> T N(T t, U u) {...}  
public:  
    generic <typename V> V M(V v)  
    {  
        return N<V, int>(v, 42);  
    }  
};  
```  
  
 <span data-ttu-id="befcc-196">Treść metody `M` zawiera wywołanie metody `N`, określając parametr typu `M` i typ <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="befcc-196">The method body of `M` contains a call to method `N`, specifying the type parameter of `M` and the type <xref:System.Int32>.</span></span> <span data-ttu-id="befcc-197"><xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> Zwraca `false` dla metody `N<V,int>`.</span><span class="sxs-lookup"><span data-stu-id="befcc-197">The <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> property returns `false` for method `N<V,int>`.</span></span> <span data-ttu-id="befcc-198"><xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> Zwraca `true`, metoda tak `N<V,int>` nie można wywołać.</span><span class="sxs-lookup"><span data-stu-id="befcc-198">The <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`, so method `N<V,int>` cannot be invoked.</span></span>  
  
 <span data-ttu-id="befcc-199">Lista niezmiennej warunki postanowienia związane z metody ogólne, zobacz <xref:System.Reflection.MethodBase.IsGenericMethod%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="befcc-199">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="befcc-200">Lista niezmiennej warunki dla innych terminów używanych w ogólnym odbicia, zobacz <xref:System.Type.IsGenericType%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="befcc-200">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="befcc-201">Poniższy przykład kodu pokazuje właściwości i metod <xref:System.Reflection.MethodInfo> obsługujących badania metody ogólne.</span><span class="sxs-lookup"><span data-stu-id="befcc-201">The following code example demonstrates the properties and methods of <xref:System.Reflection.MethodInfo> that support the examination of generic methods.</span></span> <span data-ttu-id="befcc-202">Przykład wykonuje następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="befcc-202">The example does the following:</span></span>  
  
-   <span data-ttu-id="befcc-203">Definiuje klasę, która ma metody rodzajowej.</span><span class="sxs-lookup"><span data-stu-id="befcc-203">Defines a class that has a generic method.</span></span>  
  
-   <span data-ttu-id="befcc-204">Tworzy <xref:System.Reflection.MethodInfo> reprezentujący metody ogólnej.</span><span class="sxs-lookup"><span data-stu-id="befcc-204">Creates a <xref:System.Reflection.MethodInfo> that represents the generic method.</span></span>  
  
-   <span data-ttu-id="befcc-205">Wyświetla właściwości definicję metody rodzajowej.</span><span class="sxs-lookup"><span data-stu-id="befcc-205">Displays properties of the generic method definition.</span></span>  
  
-   <span data-ttu-id="befcc-206">Argumenty z parametrami typu z typu przypisuje <xref:System.Reflection.MethodInfo>i wywołuje wynikowy skonstruowane metoda rodzajowa.</span><span class="sxs-lookup"><span data-stu-id="befcc-206">Assigns type arguments to the type parameters of the <xref:System.Reflection.MethodInfo>, and invokes the resulting constructed generic method.</span></span>  
  
-   <span data-ttu-id="befcc-207">Wyświetla właściwości skonstruowane metoda rodzajowa.</span><span class="sxs-lookup"><span data-stu-id="befcc-207">Displays properties of the constructed generic method.</span></span>  
  
-   <span data-ttu-id="befcc-208">Pobiera definicję metody rodzajowej z metody skonstruowane i porównuje go do oryginalnej definicji.</span><span class="sxs-lookup"><span data-stu-id="befcc-208">Retrieves the generic method definition from the constructed method and compares it to the original definition.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="befcc-209">Bieżące <see cref="T:System.Reflection.MethodInfo" /> nie reprezentuje definicję metody rodzajowej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-209">The current <see cref="T:System.Reflection.MethodInfo" /> does not represent a generic method definition.</span>
          </span>
          <span data-ttu-id="befcc-210">Oznacza to <see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /> zwraca <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-210">That is, <see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="befcc-211">
            <paramref name="typeArguments" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-211">
              <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="befcc-212">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-212">-or-</span>
          </span>
          <span data-ttu-id="befcc-213">Każdy z elementów <paramref name="typeArguments" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-213">Any element of <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="befcc-214">Liczba elementów w <paramref name="typeArguments" /> nie jest taka sama jak liczba parametrów typu w bieżącej definicji metody rodzajowej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-214">The number of elements in <paramref name="typeArguments" /> is not the same as the number of type parameters of the current generic method definition.</span>
          </span>
          <span data-ttu-id="befcc-215">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-215">-or-</span>
          </span>
          <span data-ttu-id="befcc-216">Element <paramref name="typeArguments" /> nie spełnia ograniczenia odpowiedniego parametru typu bieżącej definicji metody rodzajowej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-216">An element of <paramref name="typeArguments" /> does not satisfy the constraints specified for the corresponding type parameter of the current generic method definition.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="befcc-217">Ta metoda nie jest obsługiwana.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-217">This method is not supported.</span>
          </span>
        </exception>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="M:System.Reflection.MethodInfo.GetGenericMethodDefinition" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodInfo.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="befcc-218">Pobiera <see cref="T:System.Reflection.MemberTypes" /> wartość wskazującą, czy ten element członkowski jest metodą.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-218">Gets a <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="befcc-219">A <see cref="T:System.Reflection.MemberTypes" /> wartość wskazującą, czy ten element członkowski jest metodą.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-219">A <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a method.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="befcc-220">Ta właściwość zastępuje <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="befcc-220">This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="befcc-221">W związku z tym podczas badania zestawu <xref:System.Reflection.MemberInfo> obiektów — na przykład tablicy zwracanej przez <xref:System.Type.GetMembers%2A> — <xref:System.Reflection.MemberInfo.MemberType%2A> zwraca <xref:System.Reflection.MemberTypes.Method?displayProperty=nameWithType> tylko wtedy, gdy dany element jest metoda.</span><span class="sxs-lookup"><span data-stu-id="befcc-221">Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objects — for example, the array returned by <xref:System.Type.GetMembers%2A> — the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes.Method?displayProperty=nameWithType> only when a given member is a method.</span></span>  
  
 <span data-ttu-id="befcc-222">Aby uzyskać `MemberType` właściwość, najpierw uzyskać klasy `Type`.</span><span class="sxs-lookup"><span data-stu-id="befcc-222">To get the `MemberType` property, first get the class `Type`.</span></span> <span data-ttu-id="befcc-223">Z `Type`, Pobierz `MethodInfo`.</span><span class="sxs-lookup"><span data-stu-id="befcc-223">From the `Type`, get the `MethodInfo`.</span></span> <span data-ttu-id="befcc-224">Z `MethodInfo`, Pobierz `MemberType`.</span><span class="sxs-lookup"><span data-stu-id="befcc-224">From the `MethodInfo`, get the `MemberType`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="befcc-225">W poniższym przykładzie przedstawiono typ określonego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="befcc-225">The following example displays the type of the specified member.</span></span>  
  
 [!code-cpp[Classic MethodInfo.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodInfo.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodInfo.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodInfo.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic MethodInfo.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodInfo.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.MethodInfo left, System.Reflection.MethodInfo right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.MethodInfo left, class System.Reflection.MethodInfo right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As MethodInfo, right As MethodInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::MethodInfo ^ left, System::Reflection::MethodInfo ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodInfo" />
        <Parameter Name="right" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="befcc-226">Pierwszy obiekt, który ma zostać porównany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-226">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="befcc-227">Drugi obiekt, który będzie porównywany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-227">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="befcc-228">Wskazuje, czy dwa <see cref="T:System.Reflection.MethodInfo" /> obiekty są takie same.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-228">Indicates whether two <see cref="T:System.Reflection.MethodInfo" /> objects are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="befcc-229">
            <see langword="true" /> Jeśli <paramref name="left" /> jest równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-229">
              <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.MethodInfo left, System.Reflection.MethodInfo right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.MethodInfo left, class System.Reflection.MethodInfo right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.op_Inequality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As MethodInfo, right As MethodInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::MethodInfo ^ left, System::Reflection::MethodInfo ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodInfo" />
        <Parameter Name="right" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="befcc-230">Pierwszy obiekt, który ma zostać porównany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-230">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="befcc-231">Drugi obiekt, który będzie porównywany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-231">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="befcc-232">Wskazuje, czy dwa <see cref="T:System.Reflection.MethodInfo" /> obiekty nie są takie same.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-232">Indicates whether two <see cref="T:System.Reflection.MethodInfo" /> objects are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="befcc-233">
            <see langword="true" /> Jeśli <paramref name="left" /> nie jest równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-233">
              <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="befcc-234">Pobiera <see cref="T:System.Reflection.ParameterInfo" /> obiekt, który zawiera informacje o zwracany typ metody, takie jak czy zwracany typ ma niestandardowy modyfikatorów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-234">Gets a <see cref="T:System.Reflection.ParameterInfo" /> object that contains information about the return type of the method, such as whether the return type has custom modifiers.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="befcc-235">A <see cref="T:System.Reflection.ParameterInfo" /> obiekt, który zawiera informacje o typie zwracanym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-235">A <see cref="T:System.Reflection.ParameterInfo" /> object that contains information about the return type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="befcc-236">Projektanci kompilatora mogą używać <xref:System.Reflection.ParameterInfo> obiektu zwróconego przez tę właściwość, aby dowiedzieć się, czy niestandardowe modyfikatory, takich jak <xref:Microsoft.VisualC.IsConstModifier>, zostały zastosowane do zwracanego typu.</span><span class="sxs-lookup"><span data-stu-id="befcc-236">Compiler designers can use the <xref:System.Reflection.ParameterInfo> object returned by this property to discover whether custom modifiers, such as <xref:Microsoft.VisualC.IsConstModifier>, have been applied to the return type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="befcc-237">Ta metoda nie jest zaimplementowana.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-237">This method is not implemented.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.ParameterInfo.GetOptionalCustomModifiers" />
        <altmember cref="M:System.Reflection.ParameterInfo.GetRequiredCustomModifiers" />
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public virtual Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodInfo.ReturnType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="befcc-238">Pobiera typ zwrotny tej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-238">Gets the return type of this method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="befcc-239">Typ zwrotny tej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-239">The return type of this method.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="befcc-240">Do pobrania właściwości zwracanego typu, należy najpierw pobrać klasę `Type`.</span><span class="sxs-lookup"><span data-stu-id="befcc-240">To get the return type property, first get the class `Type`.</span></span> <span data-ttu-id="befcc-241">Z `Type`, Pobierz `MethodInfo`.</span><span class="sxs-lookup"><span data-stu-id="befcc-241">From the `Type`, get the `MethodInfo`.</span></span> <span data-ttu-id="befcc-242">Z `MethodInfo`, Pobierz `ReturnType`.</span><span class="sxs-lookup"><span data-stu-id="befcc-242">From the `MethodInfo`, get the `ReturnType`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="befcc-243">W poniższym przykładzie przedstawiono zwracany typ określonej metody.</span><span class="sxs-lookup"><span data-stu-id="befcc-243">The following example displays the return type of the specified method.</span></span>  
  
 [!code-cpp[Classic MethodInfo.ReturnType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodInfo.ReturnType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodInfo.ReturnType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodInfo.ReturnType Example/CS/source.cs#1)]
 [!code-vb[Classic MethodInfo.ReturnType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodInfo.ReturnType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodInfo.ReturnTypeCustomAttributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="befcc-244">Pobiera atrybuty niestandardowe dla zwracanego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-244">Gets the custom attributes for the return type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="befcc-245">
            <see langword="ICustomAttributeProvider" /> Obiekt reprezentujący atrybuty niestandardowe dla zwracanego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-245">An <see langword="ICustomAttributeProvider" /> object representing the custom attributes for the return type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodInfo.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodInfo.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodInfo.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodInfo.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodInfo::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="befcc-246">Zarezerwowane do użytku w przyszłości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-246">Reserved for future use.</span>
          </span>
          <span data-ttu-id="befcc-247">Musi być wartością IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-247">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="befcc-248">Przekazana tablica nazw ma być mapowana.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-248">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="befcc-249">Liczba nazw, które mają być mapowane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-249">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="befcc-250">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-250">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="befcc-251">Tablica przydzielone przez obiekt wywołujący, która odbiera identyfikatory, odpowiadających nazwy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-251">Caller-allocated array that receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="befcc-252">Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-252">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="befcc-253">Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="befcc-253">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="befcc-254">Aby uzyskać więcej informacji na temat `IDispatch::GetIDsOfNames`, zobacz bibliotece MSDN.</span><span class="sxs-lookup"><span data-stu-id="befcc-254">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="befcc-255">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-255">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.GetType">
      <MemberSignature Language="C#" Value="Type _MethodInfo.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._MethodInfo.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _MethodInfo.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._MethodInfo.GetType() = System::Runtime::InteropServices::_MethodInfo::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="befcc-256">Zapewnia dostęp do <see cref="M:System.Object.GetType" /> metody z modelu COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-256">Provides access to the <see cref="M:System.Object.GetType" /> method from COM.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="befcc-257">A <see cref="T:System.Type" /> reprezentujący obiekt <see cref="T:System.Reflection.MethodInfo" /> typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-257">A <see cref="T:System.Type" /> object representing the <see cref="T:System.Reflection.MethodInfo" /> type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodInfo.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodInfo.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodInfo.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodInfo.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodInfo::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="befcc-258">Informacje o typie, który będzie zwracany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-258">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="befcc-259">Identyfikator regionalny dla informacji o typie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-259">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="befcc-260">Otrzymuje wskaźnik do obiektu informacji żądanego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-260">Receives a pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="befcc-261">Pobiera informacje o typie dla obiekt, który można uzyskać informacji o typie dla interfejsu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-261">Retrieves the type information for an object, which can be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="befcc-262">Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="befcc-262">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="befcc-263">Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfo`, zobacz bibliotece MSDN.</span><span class="sxs-lookup"><span data-stu-id="befcc-263">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="befcc-264">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-264">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodInfo.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodInfo.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodInfo::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="befcc-265">Wskazuje lokalizację, która odbiera informację o liczbie typów dostarczanych przez obiekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-265">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="befcc-266">Pobiera informację o liczbie typów interfejsów, jakie zawiera obiekt (0 lub 1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-266">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="befcc-267">Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="befcc-267">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="befcc-268">Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfoCount`, zobacz bibliotece MSDN.</span><span class="sxs-lookup"><span data-stu-id="befcc-268">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="befcc-269">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-269">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.Invoke">
      <MemberSignature Language="C#" Value="void _MethodInfo.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodInfo.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodInfo.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodInfo.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodInfo::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="befcc-270">Określa element członkowski.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-270">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="befcc-271">Zarezerwowane do użytku w przyszłości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-271">Reserved for future use.</span>
          </span>
          <span data-ttu-id="befcc-272">Musi być wartością IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-272">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="befcc-273">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-273">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="befcc-274">Flagi opisujące kontekst wywołania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-274">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="befcc-275">Wskaźnik do struktury zawiera tablicę argumentów, tablicę identyfikatorów DISPID argumentu dla nazwanych argumentów i zlicza liczbę elementów w tablicach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-275">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="befcc-276">Wskaźnik miejsca, gdzie ma być przechowywany wynik.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-276">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="befcc-277">Wskaźnik do struktury, która zawiera informacje o wyjątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-277">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="befcc-278">Indeks pierwszego argumentu, który zawiera błąd.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-278">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="befcc-279">Umożliwia dostęp do właściwości i metod udostępnianych przez obiekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-279">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="befcc-280">Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="befcc-280">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="befcc-281">Aby uzyskać więcej informacji na temat `IDispatch::Invoke`, zobacz bibliotece MSDN.</span><span class="sxs-lookup"><span data-stu-id="befcc-281">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="befcc-282">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="befcc-282">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>
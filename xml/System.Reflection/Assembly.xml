<Type Name="Assembly" FullName="System.Reflection.Assembly">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d35fad0399a60bc1bb00006517d4d911156a2fb1" />
    <Meta Name="ms.sourcegitcommit" Value="41742a1055cefdeaf2f9d76364f4bad3c9f83126" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="10/16/2018" />
    <Meta Name="ms.locfileid" Value="48712929" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Assembly, System.Runtime.Serialization.ISerializable, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Assembly extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Assembly, class System.Runtime.Serialization.ISerializable, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Assembly" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Assembly&#xA;Implements _Assembly, ICustomAttributeProvider, IEvidenceFactory, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Assembly abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Assembly, System::Runtime::Serialization::ISerializable, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type Assembly = class&#xA;    interface ICustomAttributeProvider&#xA;    interface _Assembly&#xA;    interface IEvidenceFactory&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Assembly</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Assembly))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje zestaw, który jest wielokrotnego użytku, obsługą wersji i samoopisujące blokiem konstrukcyjnym typowych aplikacji środowiska wykonawczego języka.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Reflection.Assembly> klasy ładować zestawy, aby zapoznać się z części metadanych i podzieloną na występujące zestawów, aby wykryć typy zawarte w zestawach, a także tworzenie wystąpień tych typów.  
  
 Aby uzyskać tablicę <xref:System.Reflection.Assembly> obiektów reprezentująca zestawy obecnie załadowane do domeny aplikacji (na przykład domyślnej domeny aplikacji prostego projektu), użyj <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> metody.  
  
 Dynamicznie, ładować zestawy <xref:System.Reflection.Assembly> klasa udostępnia następujące metody statyczne (`Shared` metod w języku Visual Basic). Zestawy są ładowane do domeny aplikacji, w którym występuje operacja ładowania.  
  
-   Ładować zestawy zalecaną metodą jest użycie <xref:System.AppDomain.Load%2A> metody, która identyfikuje zestawie, który ma być ładowane przez jego nazwę wyświetlaną (na przykład, "przestrzeń nazw System.Windows.Forms, wersja = 2.0.0.0 lub nowszej, Culture = neutral, PublicKeyToken = b77a5c561934e089"). Wyszukiwanie zestawu zgodna z zasadami opisanymi w [jak środowisko uruchomieniowe lokalizuje zestawy](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md).  
  
-   <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> i <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metody umożliwiają załadowania zestawu w celu odbicia, ale nie do wykonania. Na przykład zestaw, który jest przeznaczony dla platformy 64-bitowych można sprawdzić przez kod, który działa na platformie 32-bitowej.  
  
-   <xref:System.Reflection.Assembly.LoadFile%2A> i <xref:System.Reflection.Assembly.LoadFrom%2A> metody są dostarczane dla rzadkich scenariuszach, w których zestaw musi być identyfikowany przy użyciu ścieżki.  
  
 Aby uzyskać <xref:System.Reflection.Assembly> obiekt zawierający obecnie wykonywany zestaw, użyj <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> metody.  
  
 Wiele elementów członkowskich z <xref:System.Reflection.Assembly> klasy zawierają informacje o zestawie. Na przykład:  
  
-   <xref:System.Reflection.Assembly.GetName%2A> Metoda zwraca <xref:System.Reflection.AssemblyName> obiektu, który zapewnia dostęp do części nazwy wyświetlanej zestawu.  
  
-   <xref:System.Reflection.Assembly.GetCustomAttributes%2A> Metoda Wyświetla atrybuty stosowane do zestawu.  
  
-   <xref:System.Reflection.Assembly.GetFiles%2A> Metoda zapewnia dostęp do plików w manifeście zestawu.  
  
-   <xref:System.Reflection.Assembly.GetManifestResourceNames%2A> Metoda zapewnia nazw zasobów w manifeście zestawu.  
  
 <xref:System.Reflection.Assembly.GetTypes%2A> Metoda Wyświetla listę wszystkich typów w zestawie. <xref:System.Reflection.Assembly.GetExportedTypes%2A> Metoda Wyświetla listę typów, które są widoczne dla wywołań spoza zestawu. <xref:System.Reflection.Assembly.GetType%2A> Metoda może służyć do wyszukiwania określonego typu w zestawie. <xref:System.Reflection.Assembly.CreateInstance%2A> Metoda może służyć do wyszukiwania i tworzenia wystąpień typów w zestawie.  
  
 Aby uzyskać więcej informacji na temat zestawów, zobacz sekcję "Domen i zestawów aplikacji" w [domen aplikacji](~/docs/framework/app-domains/application-domains.md) tematu.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano, jak uzyskać zawierający obecnie wykonywany zestaw, utworzyć wystąpienia typu zawarte w tym zestawie i wywołać za pomocą jednego typu metody z późnym wiązaniem. W tym celu przykładowy kod definiuje klasę o nazwie `Example`, za pomocą metody o nazwie `SampleMethod`. Konstruktor klasy akceptuje liczbę całkowitą, który jest używany do obliczania wartość zwracaną metody.  
  
 W przykładzie kodu pokazano również użycie <xref:System.Reflection.Assembly.GetName%2A> metodę, aby uzyskać <xref:System.Reflection.AssemblyName> obiektu, który może służyć do analizowania pełną nazwę zestawu. Przykład wyświetla numer wersji zestawu, <xref:System.Reflection.Assembly.CodeBase%2A> właściwości i <xref:System.Reflection.Assembly.EntryPoint%2A> właściwości.  
  
 [!code-cpp[AssemblyClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyClass/cpp/source.cpp#1)]
 [!code-csharp[AssemblyClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyClass/cs/source.cs#1)]
 [!code-vb[AssemblyClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyClass/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">aby uzyskać pełne zaufanie dla obiektów dziedziczących. Klasa ta nie może być dziedziczona przez kod częściowo zaufany.</permission>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <altmember cref="T:System.AppDomain" />
    <altmember cref="T:System.Reflection.AssemblyName" />
    <related type="Article" href="~/docs/framework/app-domains/application-domains.md">Domeny aplikacji</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Assembly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Assembly();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Reflection.Assembly" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest wywoływany przez klasy pochodne podczas konstruowania <xref:System.Reflection.Assembly> obiektów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public virtual string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeBase : string" Usage="System.Reflection.Assembly.CodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.CodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lokalizację zestawu początkowo określonych, na przykład w <see cref="T:System.Reflection.AssemblyName" /> obiektu.</summary>
        <value>Lokalizacja zestawu oryginalnie określony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać ścieżkę bezwzględną do załadowanego pliku zawierającego manifest, użyj <xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType> właściwości zamiast tego.  
  
 Jeśli zestaw został załadowany jako tablicę bajtów, za pomocą przeciążenia <xref:System.Reflection.Assembly.Load%2A> metody, która przyjmuje tablicę bajtów, właściwość ta zwraca lokalizację obiektu wywołującego metody, a nie lokalizacja załadowany zestaw.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Reflection.Assembly.CodeBase%2A> właściwości.  
  
 [!code-cpp[System.Reflection.Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/codebase1.cpp#1)]
 [!code-csharp[System.Reflection.Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/codebase1.cs#1)]
 [!code-vb[System.Reflection.Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/codebase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do ścieżki. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lokalizuje typu z tego zestawu i tworzy jego wystąpienie przy użyciu aktywatora systemu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string -&gt; obj&#xA;override this.CreateInstance : string -&gt; obj" Usage="assembly.CreateInstance typeName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> Typu do zlokalizowania.</param>
        <summary>Lokalizuje określonego typu z tego zestawu i tworzy jego wystąpienie przy użyciu aktywatora systemu, korzystania z wyszukiwania z uwzględnieniem wielkości liter.</summary>
        <returns>Wystąpienie określonego typu, które są tworzone przy użyciu domyślnego konstruktora; lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie zostanie znaleziony. Typ został rozwiązany za pomocą domyślnego integratora bez określania atrybutów kultury lub aktywacji i za pomocą <see cref="T:System.Reflection.BindingFlags" /> równa <see langword="Public" /> lub <see langword="Instance" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli środowisko wykonawcze nie może znaleźć `typeName` w <xref:System.Reflection.Assembly> wystąpienie, zwraca `null` zamiast zgłaszać wyjątek. Może się to zdarzyć, ponieważ:  
  
-   Nie określono w pełni kwalifikowaną nazwę typu.  
  
-   Został określony w pełni kwalifikowana nazwa typu, ale jego przypadek nie odpowiadać wielkości liter typu <xref:System.Type.FullName%2A?displayProperty=nameWithType> właściwości. Dla porównania bez uwzględniania wielkości liter `typeName` przy użyciu typu imię i nazwisko, wywołaj <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> przeciążenia, a następnie określ `true` dla `ignoreCase` argumentu.  
  
-   Typ nie istnieje w bieżącym <xref:System.Reflection.Assembly> wystąpienia.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `Person` klasy i wywołania <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> metody tworzenia jego instancji.  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance1.cs#1)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> jest pustym ciągiem ("") lub na początku ciągu znakiem null.  
  
—lub— 
Bieżący zestaw został załadowany do kontekstu reflection-only.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> wymaga zależnego zestawu, który nie został odnaleziony.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> wymaga zależnego zestawu, który został znaleziony, ale nie można go załadować.  
  
—lub— 
Bieżący zestaw został załadowany do kontekstu reflection-only i <paramref name="typeName" /> wymaga zależnego zestawu, który nie jest załadowany.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> wymaga zależnego zestawu, ale plik nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="typeName" /> wymaga wersji środowiska uruchomieniowego, która jest nowsza niż wersja aktualnie załadowanych zależnego zestawu, który został skompilowany.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String, ignoreCase As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool -&gt; obj&#xA;override this.CreateInstance : string * bool -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> Typu do zlokalizowania.</param>
        <param name="ignoreCase">
          <see langword="true" /> ignorowanie wielkości liter nazwy typu; w przeciwnym razie <see langword="false" />.</param>
        <summary>Lokalizuje określonego typu z tego zestawu i tworzy wystąpienie klasy przy użyciu aktywatora systemu za pomocą opcjonalnych wyszukiwania uwzględniana wielkość liter.</summary>
        <returns>Wystąpienie określonego typu, które są tworzone przy użyciu domyślnego konstruktora; lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie zostanie znaleziony. Typ został rozwiązany za pomocą domyślnego integratora bez określania atrybutów kultury lub aktywacji i za pomocą <see cref="T:System.Reflection.BindingFlags" /> równa <see langword="Public" /> lub <see langword="Instance" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli środowisko wykonawcze nie może znaleźć `typeName` w <xref:System.Reflection.Assembly> wystąpienie, zwraca `null` zamiast zgłaszać wyjątek. Może się to zdarzyć, ponieważ:  
  
-   Nie określono w pełni kwalifikowaną nazwę typu.  
  
-   Typ nie istnieje w bieżącym <xref:System.Reflection.Assembly> wystąpienia.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `Person` klasy. Następnie wywołuje <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> metodę wystąpienia, ale ponieważ wielkość liter w wyrazie `typeName` argument nie jest zgodna z typem <xref:System.Type.FullName%2A> właściwości, metoda zwraca `null`. Kiedy przykład przekazuje te same parametry do <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> przeciążenie i określa, że porównanie powinno być bez uwzględniania wielkości liter, `Person` klasy zostanie znaleziony, a `Person` pomyślnie tworzone jest wystąpienie obiektu.  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance2.cs#2)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> jest pustym ciągiem ("") lub na początku ciągu znakiem null.  
  
—lub— 
Bieżący zestaw został załadowany do kontekstu reflection-only.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> wymaga zależnego zestawu, który nie został odnaleziony.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> wymaga zależnego zestawu, który został znaleziony, ale nie można go załadować.  
  
—lub— 
Bieżący zestaw został załadowany do kontekstu reflection-only i <paramref name="typeName" /> wymaga zależnego zestawu, który nie jest załadowany.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> wymaga zależnego zestawu, ale plik nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="typeName" /> wymaga wersji środowiska uruchomieniowego, która jest nowsza niż wersja aktualnie załadowanych zależnego zestawu, który został skompilowany.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj&#xA;override this.CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> Typu do zlokalizowania.</param>
        <param name="ignoreCase">
          <see langword="true" /> ignorowanie wielkości liter nazwy typu; w przeciwnym razie <see langword="false" />.</param>
        <param name="bindingAttr">Maska bitów, które ma wpływ na sposób, w którym jest prowadzone wyszukiwanie. Wartość jest kombinacja flag bitowych z <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="binder">Typy obiektu, który umożliwia wiązanie, wymuszanie argumentów, wywoływania członków i pobieranie <see langword="MemberInfo" /> obiektów przy użyciu odbicia. Jeśli <c>integratora</c> jest <see langword="null" />, jest używany domyślny integrator.</param>
        <param name="args">Tablica, która zawiera argumenty do przekazania do konstruktora. Ta tablica argumentów musi być zgodny z liczby, kolejności i wpisz parametry konstruktora do wywołania. W razie potrzeby konstruktora domyślnego <c>args</c> musi być pustą tablicą lub <see langword="null" />.</param>
        <param name="culture">Wystąpienie <see langword="CultureInfo" /> używane do sterowania wymuszanie typów. Jeśli jest to <see langword="null" />, <see langword="CultureInfo" /> dla bieżącego wątku jest używana. (Jest to konieczne przekonwertować <see langword="String" /> reprezentujący 1000- <see langword="Double" /> wartość, na przykład, ponieważ 1000 jest reprezentowany w inny sposób przez różnych kultur.)</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest tablica, która zawiera pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu, który określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.  Ten parametr jest powiązany z obiektów aktywacji klienta. Aktywacja klienta jest technologią starszą, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Lokalizuje określonego typu z tego zestawu i tworzy jego wystąpienie, przy użyciu aktywatora systemu za pomocą opcjonalnych wyszukiwania uwzględniana wielkość liter i o określonej kultury, argumentów i atrybutów powiązania i aktywacji.</summary>
        <returns>Wystąpienie określonego typu lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie zostanie znaleziony. Podane argumenty są używane do rozpoznania typu i utworzyć powiązanie Konstruktor, który jest używany do tworzenia wystąpienia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> jest pustym ciągiem ("") lub na początku ciągu znakiem null.  
  
—lub— 
Bieżący zestaw został załadowany do kontekstu reflection-only.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.NotSupportedException">Tablica atrybutów aktywacji niepuste jest przekazywany do typu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> wymaga zależnego zestawu, który nie został odnaleziony.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> wymaga zależnego zestawu, który został znaleziony, ale nie można go załadować.  
  
—lub— 
Bieżący zestaw został załadowany do kontekstu reflection-only i <paramref name="typeName" /> wymaga zależnego zestawu, który nie jest załadowany.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> wymaga zależnego zestawu, ale plik nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="typeName" /> wymaga wersji środowiska uruchomieniowego, która jest nowsza niż wersja aktualnie załadowanych zależnego zestawu, który, który został skompilowany.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby utworzyć wystąpienie obiektu delegowanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateQualifiedName">
      <MemberSignature Language="C#" Value="public static string CreateQualifiedName (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateQualifiedName(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateQualifiedName (assemblyName As String, typeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CreateQualifiedName(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateQualifiedName : string * string -&gt; string" Usage="System.Reflection.Assembly.CreateQualifiedName (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa wyświetlana zestawu.</param>
        <param name="typeName">Pełna nazwa typu.</param>
        <summary>Tworzy nazwę typu kwalifikowana przez nazwę wyświetlaną własnego zestawu.</summary>
        <returns>Pełna nazwa typu kwalifikowana przez nazwę wyświetlaną zestawu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Format zwracanego ciągu jest następujący:  
  
 \<FullTypeName >, \<AssemblyDisplayName >  
  
 Zobacz <xref:System.Reflection.AssemblyName> opis w formacie nazwy wyświetlanej zestawu.  
  
 Aby uwzględnić zmiany w wersji środowiska uruchomieniowego języka wspólnego, należy użyć tej metody, a nie konstruowanie kwalifikowana nazwa samodzielnie.  Aby uzyskać informacje o kwalifikowane nazwy zestawów, zobacz <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CustomAttributes : seq&lt;System.Reflection.CustomAttributeData&gt;" Usage="System.Reflection.Assembly.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję zawierającą ten zestaw atrybutów niestandardowych.</summary>
        <value>Kolekcja, która zawiera atrybuty niestandardowe dla tego zestawu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.DefinedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefinedTypes As IEnumerable(Of TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ DefinedTypes { System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefinedTypes : seq&lt;System.Reflection.TypeInfo&gt;" Usage="System.Reflection.Assembly.DefinedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję typów zdefiniowanych w tym zestawie.</summary>
        <value>Kolekcja typów zdefiniowanych w tym zestawie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.DefinedTypes%2A> Właściwość jest porównywalna do <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> metody, chyba że <xref:System.Reflection.Assembly.DefinedTypes%2A> właściwość zwraca kolekcję <xref:System.Reflection.TypeInfo> obiektów, a <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> metoda zwraca tablicę <xref:System.Type> obiektów.  
  
 Zwracana tablica zawiera zagnieżdżone typy.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Assembly.GetTypes" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntryPoint As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ EntryPoint { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EntryPoint : System.Reflection.MethodInfo" Usage="System.Reflection.Assembly.EntryPoint" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EntryPoint</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera punkt wejścia tego zestawu.</summary>
        <value>Obiekt, który reprezentuje punkt wejścia tego zestawu. Jeśli zostanie znaleziony żaden punkt wejścia (na przykład, zestaw jest biblioteki DLL), <see langword="null" /> jest zwracana.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="assembly.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Obiekt, który ma zostać porównany z tym wystąpieniem.</param>
        <summary>Określa, czy ten zestaw i określony obiekt są równe.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="o" /> jest taki sam jak to wystąpienie w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.Equals%2A> Metoda polega na przeprowadzeniu testu równości odwołań określić, czy bieżące wystąpienie i `o` są takie same.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public virtual string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EscapedCodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EscapedCodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EscapedCodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EscapedCodeBase : string" Usage="System.Reflection.Assembly.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EscapedCodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator URI, w tym znaki ucieczki, który reprezentuje bazy kodu.</summary>
        <value>Identyfikator URI ze znakami ucieczki.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do ścieżki. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.Reflection.Assembly.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Evidence</InterfaceMember>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dowodów dla tego zestawu.</summary>
        <value>Dowód dla tego zestawu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dowód jest zestaw informacji stanowi danych wejściowych do decyzji dotyczących zasad zabezpieczeń, takie jak uprawnienia, jakie może otrzymać kodu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExportedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; ExportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; ExportedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ExportedTypes As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ ExportedTypes { System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExportedTypes : seq&lt;Type&gt;" Usage="System.Reflection.Assembly.ExportedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję typy publiczne zdefiniowane w tym zestawie, które są widoczne poza zestawem.</summary>
        <value>Zbiór typów publicznych określonych w tym zestawie, które są widoczne poza zestawem.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.Assembly.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę wyświetlaną zestawu.</summary>
        <value>Wyświetlana nazwa zestawu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zobacz <xref:System.Reflection.AssemblyName> opis w formacie nazwy wyświetlanej zestawu.  
  
> [!NOTE]
>  Pisanie kodu można przeanalizować nazwy wyświetlane nie jest zalecane. Zamiast tego przekaż nazwę wyświetlaną, aby <xref:System.Reflection.AssemblyName.%23ctor%2A> konstruktora, który analizuje je i wypełnienie odpowiednich pól nowej <xref:System.Reflection.AssemblyName>.  
  
 W wersji 2.0 środowiska .NET Framework architektura procesora jest dodawana do tożsamości zestawu i może być określona jako część zestawu ciągu nazw. Jednak nie są uwzględnione w ciągu zwracanego przez <xref:System.Reflection.Assembly.FullName%2A> właściwość ze względu na zgodność. Zobacz <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład pobiera nazwę wyświetlaną zawierający obecnie wykonywany zestaw i nazwę wyświetlaną zestawu, który zawiera <xref:System.Int32> typu (`int` w języku C# `Integer` w języku Visual Basic).  
  
 [!code-cpp[Assembly.FullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.FullName/CPP/Example.cpp#1)]
 [!code-csharp[Assembly.FullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.FullName/CS/Example.cs#1)]
 [!code-vb[Assembly.FullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.FullName/VB/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Określanie w pełni kwalifikowanych nazw typów</related>
      </Docs>
    </Member>
    <Member MemberName="GetAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetAssembly (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetAssembly(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetAssembly(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetAssembly : Type -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetAssembly type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Obiekt reprezentujący typ w zestawie, który zostanie zwrócony.</param>
        <summary>Pobiera aktualnie załadowanych zestawu, w którym zdefiniowano określonego typu.</summary>
        <returns>Zestaw, w którym zdefiniowano określonego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody jest odpowiednikiem pobierania wartości <xref:System.Type.Assembly?displayProperty=nameWithType> właściwości. Jednak <xref:System.Type.Assembly?displayProperty=nameWithType> właściwość zazwyczaj zapewnia najlepszą wydajność.  
  
 Aby wywołać tę metodę, musisz mieć <xref:System.Type> obiektu, co oznacza, że zestaw, w którym zdefiniowano klasy musi już być załadowany.  
  
   
  
## Examples  
 Poniższy przykład pobiera zestaw, który zawiera <xref:System.Int32> wpisz i wyświetla jego nazwę i lokalizację pliku.  
  
 [!code-cpp[System.Reflection.Assembly#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/GetAssembly1.cpp#12)]
 [!code-csharp[System.Reflection.Assembly#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/GetAssembly1.cs#12)]
 [!code-vb[System.Reflection.Assembly#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/GetAssembly1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCallingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCallingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCallingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCallingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCallingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCallingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetCallingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetCallingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Reflection.Assembly" /> metody, który wywołał metodę aktualnie wykonywany.</summary>
        <returns>
          <see langword="Assembly" /> Obiektu, który wywołał metodę aktualnie wykonywanej metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli metoda wywołująca <xref:System.Reflection.Assembly.GetCallingAssembly%2A> metody jest rozwinięty w tekście przez kompilator just-in-time (JIT), lub jeżeli jego element wywołujący jest rozwinięty w tekście, zestaw, który jest zwracany przez <xref:System.Reflection.Assembly.GetCallingAssembly%2A> może różnić się nieoczekiwanie. Na przykład należy wziąć pod uwagę następujące metod i zestawów:  
  
-   Metoda `M1` w zestawie `A1` wywołania <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.  
  
-   Metoda `M2` w zestawie `A2` wywołania `M1`.  
  
-   Metoda `M3` w zestawie `A3` wywołania `M2`.  
  
 Gdy `M1` nie jest śródwierszowa, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> zwraca `A2`. Gdy `M1` jest śródwierszowa, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> zwraca `A3`. Podobnie, gdy `M2` nie jest śródwierszowa, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> zwraca `A2`. Gdy `M2` jest śródwierszowa, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> zwraca `A3`.  
  
 Występuje także w tym celu po `M1` wykonuje jako wywołania tail `M2`, lub gdy `M2` wykonuje jako wywołania tail `M3`. Może uniemożliwić kompilator JIT wbudowanie metodę, która wywołuje <xref:System.Reflection.Assembly.GetCallingAssembly%2A>, stosując <xref:System.Runtime.CompilerServices.MethodImplAttribute> atrybutem <xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType> flagi, ale nie ma podobnych mechanizmu w celu zapobiegania wywołania zakończenia.  
  
   
  
## Examples  
 Poniższy przykład pobiera wywołującym zestawem bieżącej metody.  
  
 [!code-cpp[System.Reflection.Assembly#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/getcallingassembly1.cpp#4)]
 [!code-csharp[System.Reflection.Assembly#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/getcallingassembly1.cs#4)]
 [!code-vb[System.Reflection.Assembly#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/getcallingassembly1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera atrybuty niestandardowe dla tego zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : bool -&gt; obj[]&#xA;override this.GetCustomAttributes : bool -&gt; obj[]" Usage="assembly.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">Ten argument jest ignorowany dla obiektów typu <see cref="T:System.Reflection.Assembly" />.</param>
        <summary>Pobiera atrybuty niestandardowe dla tego zestawu.</summary>
        <returns>Tablica, która zawiera atrybuty niestandardowe dla tego zestawu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda implementuje odpowiednich <xref:System.Reflection.ICustomAttributeProvider> metody interfejsu. W związku z tym `inherit` musi zostać określony parametr, nawet jeśli jest on ignorowany.  
  
 Pseudo-atrybut wskazuje bity metadane podstawowe, które musi zostać ustawione, gdy obecny jest atrybut. W odróżnieniu od niestandardowy atrybut, który rozszerza metadanych dla typu, który jest zapisywany wraz z typu pseudo-atrybutu modyfikuje metadanych dla typu, a następnie jest odrzucany. Niektóre uzyskane bity nie są dostępne przy użyciu odbicia istniejących interfejsów API.  
  
 Poniższa tabela zawiera podsumowanie różnych pseudo-atrybuty i metody dostępu dla usługi bits, które są dostępne w odbiciu.  
  
|Pseudo-atrybut|Metadane usługi Bits|Akcesor odbicia|  
|-----------------------|-------------------|-------------------------|  
|DllImportAttribute|Corpinvokemap —<br /><br /> Nazwa biblioteki DLL|Brak akcesora dla PInvokeMap dla zwykłej metody/globalne atrybuty metody.<br /><br /> Brak akcesora dla nazwy biblioteki DLL.|  
|GuidAttribute|Przechowywane jako atrybut niestandardowy liczby rzeczywistej.|Dostępne jako atrybut niestandardowy rzeczywistego.|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|Cormethodimpl —|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|Różne usługi bits.|Brak akcesora.|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags().OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags().OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|Structlayoutattribute —|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> Klasa pakowania.|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> Brak akcesora.|  
|FieldOffsetAttribute|Przesunięcie pola.|Brak akcesora.|  
|AssemblyLoadAttribute|Corassemblyflags —|Brak metody dostępu lub modułu wyliczającego.|  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : Type * bool -&gt; obj[]&#xA;override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="assembly.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Typ, dla którego mają zostać zwrócone atrybutów niestandardowych.</param>
        <param name="inherit">Ten argument jest ignorowany dla obiektów typu <see cref="T:System.Reflection.Assembly" />.</param>
        <summary>Pobiera atrybuty niestandardowe dla tego zestawu jako określonego typu.</summary>
        <returns>Tablica zawiera atrybuty niestandardowe dla tego zestawu, określony przez <paramref name="attributeType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda implementuje odpowiednich <xref:System.Reflection.ICustomAttributeProvider> metody interfejsu. W związku z tym `inherit` musi zostać określony parametr, nawet jeśli jest on ignorowany.  
  
 Pseudo-atrybut wskazuje bity metadane podstawowe, które musi zostać ustawione, gdy obecny jest atrybut. W odróżnieniu od niestandardowy atrybut, który rozszerza metadanych dla typu, który jest zapisywany wraz z typu pseudo-atrybutu modyfikuje metadanych dla typu, a następnie jest odrzucany. Niektóre uzyskane bity nie są dostępne przy użyciu odbicia istniejących interfejsów API.  
  
 Poniższa tabela zawiera podsumowanie różnych pseudo-atrybuty i metody dostępu dla usługi bits, które są dostępne w odbiciu.  
  
|Pseudo-atrybut|Metadane usługi Bits|Akcesor odbicia|  
|-----------------------|-------------------|-------------------------|  
|DllImportAttribute|Corpinvokemap —<br /><br /> Nazwa biblioteki DLL|Brak akcesora dla PInvokeMap dla zwykłej metody/globalne atrybuty metody.<br /><br /> Brak akcesora dla nazwy biblioteki DLL.|  
|GuidAttribute|Przechowywane jako atrybut niestandardowy liczby rzeczywistej.|Dostępne jako atrybut niestandardowy rzeczywistego.|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|Cormethodimpl —|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|Różne usługi bits.|Brak akcesora.|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags().OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags().OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|Structlayoutattribute —|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> Klasa pakowania.|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> Brak akcesora.|  
|FieldOffsetAttribute|Przesunięcie pola.|Brak akcesora.|  
|AssemblyLoadAttribute|Corassemblyflags —|Brak metody dostępu lub modułu wyliczającego.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> nie jest typem środowiska uruchomieniowego.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;&#xA;override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="assembly.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca informacje na temat atrybutów, które zostały zastosowane do bieżącego <see cref="T:System.Reflection.Assembly" />, wyrażona jako <see cref="T:System.Reflection.CustomAttributeData" /> obiektów.</summary>
        <returns>Z listy ogólnej <see cref="T:System.Reflection.CustomAttributeData" /> obiekty reprezentujące dane dotyczące atrybutów, które zostały zastosowane do bieżącego zestawu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby sprawdzić kod w kontekstu reflection-only, w przypadkach, gdzie atrybutów niestandardowych, samodzielnie są zdefiniowane w kodzie, który jest ładowany do kontekstu reflection-only atrybutów niestandardowych. Metody, takie jak <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> i <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> nie można użyć w takich przypadkach, ponieważ mogą one tworzyć wystąpienia atrybutów. Nie można wykonać kod w kontekstu reflection-only. Aby uzyskać więcej informacji i przykład kodu, zobacz <xref:System.Reflection.CustomAttributeData> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetEntryAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetEntryAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEntryAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetEntryAssembly();" />
      <MemberSignature Language="F#" Value="static member GetEntryAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetEntryAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera pliku wykonywalnego procesu w domyślnej domeny aplikacji. W innych domenach aplikacji, jest to pierwszy plik wykonywalny, który został wykonany przez <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</summary>
        <returns>Zestaw, który jest pliku wykonywalnego procesu w domyślnej domeny aplikacji lub pierwszy plik wykonywalny, który został wykonany przez <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />. Może zwracać <see langword="null" /> gdy wywoływana z kodu niezarządzanego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> Metoda może zwracać `null` gdy zarządzany zestaw został załadowany z niezarządzanej aplikacji. Na przykład, jeśli Niezarządzana aplikacja tworzy instancję składnika COM napisanych w języku C#, wywołanie <xref:System.Reflection.Assembly.GetEntryAssembly%2A> metody z składnika języka C# zwraca wartość null, ponieważ kod niezarządzany, a nie zestaw zarządzany punkt wejścia dla procesu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExecutingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetExecutingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetExecutingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExecutingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExecutingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetExecutingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetExecutingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetExecutingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera zestaw, który zawiera kod, który jest w trakcie wykonywania.</summary>
        <returns>Zestaw, który zawiera kod, który jest w trakcie wykonywania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ze względu na wydajność należy wywołać tej metody tylko wtedy, gdy nie wiadomo, w czasie projektowania jakie zestawu jest w trakcie wykonywania. Zalecanym sposobem pobrania <xref:System.Reflection.Assembly> obiekt, który reprezentuje bieżący zestaw jest użycie <xref:System.Type.Assembly%2A?displayProperty=nameWithType> właściwości typu można odnaleźć w zestawie, tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/assembly1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/assembly1.vb#1)]  
  
 Aby uzyskać zestaw, który zawiera metody, która wywołała kodem wykonywanym, użyj <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Type.Assembly%2A?displayProperty=nameWithType> właściwości do pobrania zawierający obecnie wykonywany zestaw na podstawie typu zawarte w tym zestawie. Wzywa także <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> metodę, aby pokazać, że zwraca <xref:System.Reflection.Assembly> obiekt, który reprezentuje tego samego zestawu.  
  
 [!code-cpp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cpp/getexecutingassembly1.cpp#5)]
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/getexecutingassembly1.cs#5)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/getexecutingassembly1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetExportedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetExportedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetExportedTypes : unit -&gt; Type[]&#xA;override this.GetExportedTypes : unit -&gt; Type[]" Usage="assembly.GetExportedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetExportedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera typy publiczne zdefiniowane w tym zestawie, które są widoczne poza zestawem.</summary>
        <returns>Tablica, która reprezentuje typy zdefiniowane w tym zestawie, które są widoczne poza zestawem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedyne typy widoczna spoza zestawu są typy publiczne i typy publiczne zagnieżdżone w innych typów publicznych.  
  
   
  
## Examples  
 Poniższy przykładowy kod definiuje kilka klas z różnymi poziomami dostępu i wywołania <xref:System.Reflection.Assembly.GetExportedTypes%2A> do wyświetlania tych, które są widoczny spoza zestawu.  
  
 [!code-cpp[Assembly.GetExportedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.GetExportedTypes/CPP/source.cpp#1)]
 [!code-csharp[Assembly.GetExportedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.GetExportedTypes/CS/source.cs#1)]
 [!code-vb[Assembly.GetExportedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.GetExportedTypes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Zestaw jest zestawu dynamicznego.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można załadować zestawu zależnego.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFile (name As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::FileStream ^ GetFile(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetFile : string -&gt; System.IO.FileStream&#xA;override this.GetFile : string -&gt; System.IO.FileStream" Usage="assembly.GetFile name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFile(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa określonego pliku. Nie należy dołączać ścieżkę do pliku.</param>
        <summary>Pobiera <see cref="T:System.IO.FileStream" /> dla określonego pliku w tabeli plików manifestu zestawu.</summary>
        <returns>Strumień, który zawiera określonego pliku lub <see langword="null" /> Jeśli plik nie zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda działa w obu plikach zasobów publicznych i prywatnych.  
  
 `name` Nie powinien zawierać ścieżkę do pliku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> Parametr jest pustym ciągiem ("").</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> nie jest prawidłowym zestawem.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do ścieżki i odczytywania określonego pliku. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera pliki znajdujące się w tabeli plików manifestu zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles () As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : unit -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : unit -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera pliki znajdujące się w tabeli plików manifestu zestawu.</summary>
        <returns>Tablica strumienie, które zawierają pliki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda działa na plikach zasobów publicznych i prywatnych.  
  
 To przeciążenie jest równoważne z wywoływaniem <xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29> przeciążenia i określając `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.BadImageFormatException">Plik nie jest prawidłowym zestawem.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles (getResourceModules As Boolean) As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : bool -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : bool -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <see langword="true" /> w tym moduły zasobów; w przeciwnym razie <see langword="false" />.</param>
        <summary>Pobiera pliki znajdujące się w tabeli plików manifestu zestawu, określania, czy mają zostać dołączone moduły zasobów.</summary>
        <returns>Tablica strumienie, które zawierają pliki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda działa na plikach zasobów publicznych i prywatnych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.BadImageFormatException">Plik nie jest prawidłowym zestawem.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetForwardedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetForwardedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetForwardedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetForwardedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetForwardedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetForwardedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetForwardedTypes : unit -&gt; Type[]&#xA;override this.GetForwardedTypes : unit -&gt; Type[]" Usage="assembly.GetForwardedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="assembly.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla tego wystąpienia.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLoadedModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wszystkie załadowane moduły, które są częścią tego zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLoadedModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules();" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wszystkie załadowane moduły, które są częścią tego zestawu.</summary>
        <returns>Tablica modułów.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLoadedModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <see langword="true" /> w tym moduły zasobów; w przeciwnym razie <see langword="false" />.</param>
        <summary>Pobiera wszystkie załadowane moduły, które są częścią tego zestawu, określania, czy mają zostać dołączone moduły zasobów.</summary>
        <returns>Tablica modułów.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceInfo (resourceName As String) As ManifestResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ManifestResourceInfo ^ GetManifestResourceInfo(System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo&#xA;override this.GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo" Usage="assembly.GetManifestResourceInfo resourceName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceInfo(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName">Wielkość liter nazwy zasobu.</param>
        <summary>Zwraca informacje dotyczące sposobu danego zasobu zostały utrwalone.</summary>
        <returns>Obiekt, który są wypełniane informacjami o topologii zasobu lub <see langword="null" /> Jeśli zasób nie zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informacje o zasobach jest zwracany tylko wtedy, gdy zasób jest widoczny do obiektu wywołującego lub obiekt wywołujący ma <xref:System.Security.Permissions.ReflectionPermission>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceName" /> Parametr jest pustym ciągiem ("").</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetManifestResourceNames();" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceNames : unit -&gt; string[]&#xA;override this.GetManifestResourceNames : unit -&gt; string[]" Usage="assembly.GetManifestResourceNames " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceNames</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca nazwy wszystkich zasobów, w tym zestawie.</summary>
        <returns>Tablica, która zawiera nazwy wszystkich zasobów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć nazwy każdego zasobu w tablicy zwracanej przez tę metodę w następujący sposób:  
  
-   Można przekazać nazwę zasobu, aby <xref:System.Reflection.Assembly.GetManifestResourceInfo%2A> metodę, aby uzyskać dodatkowe informacje o tym zasobie.  
  
-   Jeśli nazwa identyfikuje plik binarny Resources, można usunąć rozszerzenie pliku Resources i przekazać go do <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType> Konstruktor do tworzenia wystąpienia usługi resource manager.  
  
-   Można przekazać nazwę zasobu, aby <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> metodę, która pobierze <xref:System.IO.Stream> obiekt, który można następnie przekazać do <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> konstruktora.  
  
-   Można przekazać nazwę zasobu, aby <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> metodę, która pobierze <xref:System.IO.Stream> obiekt, który można następnie przekazać do <xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> konstruktora.  
  
 Informacje o zasobach jest zwracany tylko wtedy, gdy zasób jest widoczny do obiektu wywołującego lub obiekt wywołujący ma <xref:System.Security.Permissions.ReflectionPermission>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetManifestResourceStream">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładuje określony zasób manifestu z tego zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceStream (name As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Wielkość liter nazwa manifestu żądanych zasobów.</param>
        <summary>Ładuje określony zasób manifestu z tego zestawu.</summary>
        <returns>Zasobu manifestu. lub <see langword="null" /> Jeśli nie określono żadnych zasobów podczas kompilacji lub zasób nie jest widoczny dla elementu wywołującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Manifestu zasób jest zasobem (na przykład plikiem obrazu), który jest wbudowany w zestaw w czasie kompilacji. Aby uzyskać więcej informacji na temat zasobów manifestu, zobacz [podstawowe informacje dotyczące programu Microsoft .NET Framework zasobów](http://go.microsoft.com/fwlink/?LinkId=204554) w bibliotece MSDN.  
  
 Informacje o zasobach jest zwracany tylko wtedy, gdy zasób jest widoczny do obiektu wywołującego lub obiekt wywołujący ma <xref:System.Security.Permissions.ReflectionPermission>.  
  
> [!NOTE]
>  Ta metoda zwraca `null` Jeśli dostępu do prywatnego zasobu w innym zestawie, a obiekt wywołujący nie ma <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flagi.  
  
 Jeśli manifest zestawu zawiera plik zasobów <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> zwraca <xref:System.IO.Stream> obiektu nawet wtedy, gdy plik zasobu nie można odnaleźć na dysku w czasie. Jeśli plik zasobów nie zostanie znaleziony, przekazując wartość wynikowa <xref:System.IO.Stream> obiekt <xref:System.Resources.ResourceReader> powoduje, że Konstruktor <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> Parametr jest pustym ciągiem ("").</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.IO.IOException" />, a zamiast tego.  
  
</para>
          </block>  
  
 Nie można załadować pliku, który został znaleziony.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> nie jest prawidłowym zestawem.</exception>
        <exception cref="T:System.NotImplementedException">Zasób długość jest większa niż <see cref="F:System.Int64.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md">Manifest zestawu</related>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : Type * string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : Type * string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream (type, name)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ, w których przestrzeń nazw jest używana do określania zakresu nazwę zasobu manifestu.</param>
        <param name="name">Wielkość liter nazwa manifestu żądanych zasobów.</param>
        <summary>Ładuje określony zasobu manifestu w zakresie przestrzeni nazw określonego typu, w tym zestawie.</summary>
        <returns>Zasobu manifestu. lub <see langword="null" /> Jeśli nie określono żadnych zasobów podczas kompilacji lub zasób nie jest widoczny dla elementu wywołującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład jeśli Pełna nazwa określona dla `type` jest "MyNameSpace.MyClasses" i `name` jest "Net", ta metoda przeciążenia wyszukuje zasób o nazwie "MyNameSpace.Net".  
  
 Manifestu zasób jest zasobem (na przykład plikiem obrazu), który jest wbudowany w zestaw w czasie kompilacji. Aby uzyskać więcej informacji na temat zasobów manifestu, zobacz [podstawowe informacje dotyczące programu Microsoft .NET Framework zasobów](http://go.microsoft.com/fwlink/?LinkId=204554) w bibliotece MSDN.  
  
 Informacje o zasobach jest zwracany tylko wtedy, gdy zasób jest widoczny do obiektu wywołującego lub obiekt wywołujący ma <xref:System.Security.Permissions.ReflectionPermission>.  
  
> [!NOTE]
>  Ta metoda zwraca `null` Jeśli dostępu do prywatnego zasobu w innym zestawie, a obiekt wywołujący nie ma <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flagi.  
  
 Jeśli manifest zestawu zawiera plik zasobów <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> zwraca <xref:System.IO.Stream> obiektu nawet wtedy, gdy plik zasobu nie można odnaleźć na dysku w czasie. Jeśli plik zasobów nie zostanie znaleziony, przekazując wartość wynikowa <xref:System.IO.Stream> obiekt <xref:System.Resources.ResourceReader> powoduje, że Konstruktor <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> Parametr jest pustym ciągiem ("").</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> nie jest prawidłowym zestawem.</exception>
        <exception cref="T:System.NotImplementedException">Zasób długość jest większa niż <see cref="F:System.Int64.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md">Manifest zestawu</related>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModule(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModule (name As String) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ GetModule(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetModule : string -&gt; System.Reflection.Module&#xA;override this.GetModule : string -&gt; System.Reflection.Module" Usage="assembly.GetModule name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModule(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa modułu żądanej.</param>
        <summary>Pobiera określonego modułu, w tym zestawie.</summary>
        <returns>Moduł zażądano, lub <see langword="null" /> Jeśli moduł nie zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda działa na nazwy plików.  
  
 Klasy w `Reflection.Emit` przestrzeni nazw emisji nazwa zakresu dla modułu dynamicznego. Nazwa zakresu można określić przy <xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType> właściwości. Typ modułu chcesz przekazać `Assembly.GetModule`. Na przykład, jeśli chcesz, aby moduł, który zawiera manifest zestawu, przekazać nazwę zakresu modułu do `GetModule`. W przeciwnym razie należy przekazać nazwę pliku modułu. Zestawy są ładowane za pomocą jednej z `Load` metody, które mają parametr byte [] mają tylko jeden moduł i dlatego manifestu modułu. Zawsze należy dążyć tych modułów przy użyciu nazwy zakresu.  
  
 Można pobrać typu z określonego modułu przy użyciu <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>. Wywoływanie `Module.GetType` modułu zawierającego manifest nie będzie inicjował wyszukiwania całego zestawu. Można pobrać typu z zestawu, niezależnie od tego, który moduł znajduje się w lokalizacji, należy wywołać <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> Parametr jest pustym ciągiem ("").</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> nie jest prawidłowym zestawem.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wszystkie moduły, które są częścią tego zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules();" />
      <MemberSignature Language="F#" Value="abstract member GetModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wszystkie moduły, które są częścią tego zestawu.</summary>
        <returns>Tablica modułów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda działa na plikach zasobów publicznych i prywatnych.  
  
> [!NOTE]
>  Moduły muszą emitowane przy użyciu rozszerzeń nazw plików.  
  
   
  
## Examples  
 Poniższy przykład wyświetla nazwę modułu w zwróconej tablicy, który zawiera manifest zestawu.  
  
 [!code-cpp[Classic Assembly.GetModules Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Assembly.GetModules Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CS/source.cs#1)]
 [!code-vb[Classic Assembly.GetModules Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Moduł do załadowania nie określa rozszerzenie nazwy pliku.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <see langword="true" /> w tym moduły zasobów; w przeciwnym razie <see langword="false" />.</param>
        <summary>Pobiera wszystkie moduły, które są częścią tego zestawu, określania, czy mają zostać dołączone moduły zasobów.</summary>
        <returns>Tablica modułów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda działa na plikach zasobów publicznych i prywatnych.  
  
> [!NOTE]
>  Moduły muszą emitowane przy użyciu rozszerzeń nazw plików.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetName">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera <see cref="T:System.Reflection.AssemblyName" /> dla tego zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName () As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName();" />
      <MemberSignature Language="F#" Value="abstract member GetName : unit -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : unit -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.Reflection.AssemblyName" /> dla tego zestawu.</summary>
        <returns>Obiekt, który zawiera nazwę wyświetlaną w pełni przeanalizowany dla tego zestawu.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do ścieżki zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName (copiedName As Boolean) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName(bool copiedName);" />
      <MemberSignature Language="F#" Value="abstract member GetName : bool -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : bool -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName copiedName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="copiedName">
          <see langword="true" /> Aby ustawić <see cref="P:System.Reflection.Assembly.CodeBase" /> do lokalizacji zestawów po kopie w tle woluminów; <see langword="false" /> można ustawić <see cref="P:System.Reflection.Assembly.CodeBase" /> do oryginalnej lokalizacji.</param>
        <summary>Pobiera <see cref="T:System.Reflection.AssemblyName" /> dla tego zestawu, określony przez ustawienie kodu <paramref name="copiedName" />.</summary>
        <returns>Obiekt, który zawiera nazwę wyświetlaną w pełni przeanalizowany dla tego zestawu.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do ścieżki zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="assembly.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Obiekt, który ma zostać wypełniony informacjami o serializacji.</param>
        <param name="context">Kontekst docelowego serializacji.</param>
        <summary>Pobiera informacje o serializacji wszystkie dane potrzebne do reinstantiate tego zestawu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReferencedAssemblies () As AssemblyName()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::AssemblyName ^&gt; ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]&#xA;override this.GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]" Usage="assembly.GetReferencedAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetReferencedAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.Reflection.AssemblyName" /> obiektów dla wszystkich zestawów, które są przywoływane przez ten zestaw.</summary>
        <returns>Tablica, która zawiera nazwy wyświetlane pełni przeanalizowana wszystkich zestawów, które są przywoływane przez ten zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> właściwość <xref:System.Reflection.AssemblyName> obiekt, który jest zwracany przez tę metodę jest <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> przypadku nie algorytmu wyznaczania wartości skrótu dla przywoływanego zestawu, czy nie jest algorytm wyznaczania wartości skrótu przywoływanego zestawu identyfikowane za pomocą <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> wyliczenia. W poprzednich wersjach programu .NET Framework <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> właściwości zwróconej <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType> w takiej sytuacji.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wywołanie <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> metody. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Reflection.Assembly> klasy.  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSatelliteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera zestawu satelickiego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSatelliteAssembly (culture As CultureInfo) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly culture" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Określonej kultury.</param>
        <summary>Pobiera zestawu satelickiego dla określonej kultury.</summary>
        <returns>Zestawu satelickiego określony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestawy satelickie zawierają zlokalizowane zasoby, jak różniący się od głównej aplikacji zestawy, które zawierają niemożliwe do zlokalizowania kodu wykonywalnego i zasoby dla pojedynczej kultury, które służą jako domyślne lub kultury neutralnej.  
  
 Wywołaj tę metodę, aby użyć bieżącej wersji zestawu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć zestawu.</exception>
        <exception cref="T:System.IO.FileLoadException">Znaleziono zestawie satelickim o takiej samej nazwie pliku, ale <see langword="CultureInfo" /> nie był zgodny ten, który został określony.</exception>
        <exception cref="T:System.BadImageFormatException">Zestawu satelickiego nie jest prawidłowym zestawem.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture, Version ^ version);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly (culture, version)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <param name="culture">Określonej kultury.</param>
        <param name="version">Wersja zestawu satelickiego.</param>
        <summary>Pobiera określoną wersję zestawu satelickiego dla określonej kultury.</summary>
        <returns>Zestawu satelickiego określony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestawy satelickie zawierają zlokalizowane zasoby, jak różniący się od głównej aplikacji zestawy, które zawierają niemożliwe do zlokalizowania kodu wykonywalnego i zasoby dla pojedynczej kultury, które służą jako domyślne lub kultury neutralnej.  
  
 Wywołaj <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> przeciążenie, można użyć bieżącej wersji zestawu.  
  
 Jeśli `version` jest `null`, bieżąca wersja zestawu jest używana, gdy są podpisane zasób oraz głównych zestawów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileLoadException">Znaleziono zestawie satelickim o takiej samej nazwie pliku, ale <see langword="CultureInfo" /> lub wersji nie był zgodny ten, który został określony.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć zestawu.</exception>
        <exception cref="T:System.BadImageFormatException">Zestawu satelickiego nie jest prawidłowym zestawem.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera <see cref="T:System.Type" /> obiekt, który reprezentuje określonego typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="assembly.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="assembly.GetType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Pełna nazwa typu.</param>
        <summary>Pobiera <see cref="T:System.Type" /> obiektu o określonej nazwie w wystąpieniu zestawu.</summary>
        <returns>Obiekt, który reprezentuje określoną klasę lub <see langword="null" /> Jeśli klasa nie zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta wyszukuje tylko bieżące wystąpienie zestawu. `name` Parametr zawiera przestrzeń nazw, ale nie zestaw. Aby wyszukać innych zestawów dla typu, należy użyć <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> przeciążenia metody, które można opcjonalnie uwzględnić nazwę wyświetlaną zestawu jako część nazwy typu.  
  
> [!NOTE]
>  Jeśli typ został przesłany dalej do innego zestawu, nadal jest zwracany przez tę metodę. Aby uzyskać informacje dotyczące typu przesyłania dalej, zobacz [Type Forwarding in środowiska uruchomieniowego języka wspólnego](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano abstrakcyjną `MeansOfTransportation` klasy w `Transportation` przestrzeni nazw. Wywołuje <xref:System.Reflection.Assembly.GetType%28System.String%29> metodę, aby pobrać jego <xref:System.Type> obiektu, wywołuje <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> metodę, aby uzyskać tablicę <xref:System.Reflection.PropertyInfo> obiektów, które reprezentują właściwości typu, a następnie wyświetla informacje od typu abstrakcji właściwości. Należy pamiętać, że wywołanie <xref:System.Reflection.Assembly.GetType%28System.String%29> metoda wykorzystuje w pełni kwalifikowana nazwa typu (czyli jego przestrzeń nazw wraz z jego nazwą typu).  
  
 [!code-csharp[System.Reflection.Assembly.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.gettype/vb/gettype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> wymaga zależnego zestawu, który nie został odnaleziony.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.IO.IOException" />, a zamiast tego.  
  
</para>
          </block>
          <paramref name="name" /> wymaga zależnego zestawu, który został znaleziony, ale nie można go załadować.  
  
—lub— 
Bieżący zestaw został załadowany do kontekstu reflection-only i <paramref name="name" /> wymaga zależnego zestawu, który nie jest załadowany.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> wymaga zależnego zestawu, ale plik nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="name" /> wymaga wersji środowiska uruchomieniowego nowszej niż aktualnie załadowanych zależnego zestawu, który został skompilowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Pełna nazwa typu.</param>
        <param name="throwOnError">
          <see langword="true" /> Aby zgłosić wyjątek, jeśli typ nie zostanie odnaleziony; <see langword="false" /> do zwrócenia <see langword="null" />.</param>
        <summary>Pobiera <see cref="T:System.Type" /> obiektu o określonej nazwie w wystąpieniu zestawu i opcjonalnie zgłasza wyjątek, jeśli typ nie zostanie znaleziony.</summary>
        <returns>Obiekt, który reprezentuje określonej klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta wyszukuje tylko bieżące wystąpienie zestawu. `name` Parametr zawiera przestrzeń nazw, ale nie zestaw. Aby wyszukać innych zestawów dla typu, należy użyć <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> przeciążenia metody, które można opcjonalnie uwzględnić nazwę wyświetlaną zestawu jako część nazwy typu.  
  
> [!NOTE]
>  Jeśli typ został przesłany dalej do innego zestawu, nadal jest zwracany przez tę metodę. Aby uzyskać informacje dotyczące typu przesyłania dalej, zobacz [Type Forwarding in środowiska uruchomieniowego języka wspólnego](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 `throwOnError` Parametr dotyczy tylko, co się stanie, gdy typ nie zostanie znaleziony. Nie ma wpływu na inne wyjątki, które mogą być generowane. W szczególności, jeśli typ zostanie znaleziony, ale nie może zostać załadowany <xref:System.TypeLoadException> mogą być generowane nawet wtedy, gdy `throwOnError` jest `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest nieprawidłowy.  
  
—lub— 
Długość <paramref name="name" /> dłuższa niż 1024 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> jest <see langword="true" />, i nie można odnaleźć typu.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> wymaga zależnego zestawu, który nie został odnaleziony.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="name" /> wymaga zależnego zestawu, który został znaleziony, ale nie można go załadować.  
  
—lub— 
Bieżący zestaw został załadowany do kontekstu reflection-only i <paramref name="name" /> wymaga zależnego zestawu, który nie jest załadowany.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> wymaga zależnego zestawu, ale plik nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="name" /> wymaga wersji środowiska uruchomieniowego nowszej niż aktualnie załadowanych zależnego zestawu, który został skompilowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Pełna nazwa typu.</param>
        <param name="throwOnError">
          <see langword="true" /> Aby zgłosić wyjątek, jeśli typ nie zostanie odnaleziony; <see langword="false" /> do zwrócenia <see langword="null" />.</param>
        <param name="ignoreCase">
          <see langword="true" /> ignorowanie wielkości liter nazwy typu; w przeciwnym razie <see langword="false" />.</param>
        <summary>Pobiera <see cref="T:System.Type" /> obiektu o określonej nazwie w wystąpieniu zestawu, z opcjami ignoruje wielkość liter i zostanie zgłoszony wyjątek, jeśli typ nie zostanie znaleziony.</summary>
        <returns>Obiekt, który reprezentuje określonej klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta wyszukuje tylko bieżące wystąpienie zestawu. `name` Parametr zawiera przestrzeń nazw, ale nie zestaw. Aby wyszukać innych zestawów dla typu, należy użyć <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> przeciążenia metody, które można opcjonalnie uwzględnić nazwę wyświetlaną zestawu jako część nazwy typu.  
  
> [!NOTE]
>  Jeśli typ został przesłany dalej do innego zestawu, nadal jest zwracany przez tę metodę. Aby uzyskać informacje dotyczące typu przesyłania dalej, zobacz [Type Forwarding in środowiska uruchomieniowego języka wspólnego](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 `throwOnError` Parametr dotyczy tylko, co się stanie, gdy typ nie zostanie znaleziony. Nie ma wpływu na inne wyjątki, które mogą być generowane. W szczególności, jeśli typ zostanie znaleziony, ale nie może zostać załadowany <xref:System.TypeLoadException> mogą być generowane nawet wtedy, gdy `throwOnError` jest `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest nieprawidłowy.  
  
—lub— 
Długość <paramref name="name" /> dłuższa niż 1024 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> jest <see langword="true" />, i nie można odnaleźć typu.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> wymaga zależnego zestawu, który nie został odnaleziony.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="name" /> wymaga zależnego zestawu, który został znaleziony, ale nie można go załadować.  
  
—lub— 
Bieżący zestaw został załadowany do kontekstu reflection-only i <paramref name="name" /> wymaga zależnego zestawu, który nie jest załadowany.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> wymaga zależnego zestawu, ale plik nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="name" /> wymaga wersji środowiska uruchomieniowego nowszej niż aktualnie załadowanych zależnego zestawu, który został skompilowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetTypes : unit -&gt; Type[]&#xA;override this.GetTypes : unit -&gt; Type[]" Usage="assembly.GetTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera typy zdefiniowane w tym zestawie.</summary>
        <returns>Tablica, która zawiera wszystkie typy, które są zdefiniowane w tym zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwracana tablica zawiera zagnieżdżone typy.  
  
 Jeśli <xref:System.Reflection.Assembly.GetTypes%2A> metoda jest wywoływana w zestawie i typ, w tym zestaw jest zależna od typu w zestawie, który nie został załadowany (na przykład, jeśli pochodzi od typu na drugi zestaw), <xref:System.Reflection.ReflectionTypeLoadException> zgłaszany. Na przykład, to nastąpić, jeśli pierwszy zestaw został załadowany z <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> lub <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metody i drugiego zestawu nie została załadowana. Możliwe również przy użyciu zestawy, ładowane przy użyciu <xref:System.Reflection.Assembly.Load%2A> i <xref:System.Reflection.Assembly.LoadFile%2A> metody, jeśli drugi zestaw nie można zlokalizować, kiedy <xref:System.Reflection.Assembly.GetTypes%2A> metoda jest wywoływana.  
  
> [!NOTE]
>  Jeśli typ został przesłany dalej do innego zestawu, nie jest ono uwzględnione w zwróconej tablicy. Aby uzyskać informacje dotyczące typu przesyłania dalej, zobacz [Type Forwarding in środowiska uruchomieniowego języka wspólnego](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 Można pobrać zbiór <xref:System.Reflection.TypeInfo> obiekty zamiast tablicę <xref:System.Type> obiekty, używają <xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType> właściwości.  
  
   
  
## Examples  
 Poniższy przykład wyświetla parametry jednej metody w typie w określonym zestawie.  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">Zestaw zawiera jeden lub więcej typów, które nie może zostać załadowany. Tablica zwrócona przez <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> zawiera właściwość tego wyjątku <see cref="T:System.Type" /> obiekt dla każdego typu, który został załadowany i <see langword="null" /> dla każdego typu, który nie można załadować, podczas gdy <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> właściwość zawiera wyjątek dla każdego typu Nie można załadować.</exception>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public virtual bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GlobalAssemblyCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool GlobalAssemblyCache { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalAssemblyCache : bool" Usage="System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.GlobalAssemblyCache</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy zestaw został załadowany z pamięci podręcznej zestawów globalnych.</summary>
        <value>
          <see langword="true" /> Jeśli zestaw został załadowany z pamięci podręcznej zestawów globalnych; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public virtual long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.HostContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HostContext As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long HostContext { long get(); };" />
      <MemberSignature Language="F#" Value="member this.HostContext : int64" Usage="System.Reflection.Assembly.HostContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kontekst hosta, za pomocą której zestaw został załadowany.</summary>
        <value>
          <see cref="T:System.Int64" /> Wartość, która wskazuje kontekst hosta, za pomocą której zestaw został załadowany, jeśli istnieje.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public virtual string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImageRuntimeVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ImageRuntimeVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ImageRuntimeVersion : string" Usage="System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ciąg reprezentujący wersję środowisko uruchomieniowe języka wspólnego (CLR) zapisywane w pliku zawierającego manifest.</summary>
        <value>Nazwa folderu wersji środowiska CLR. To nie jest pełną ścieżką.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład wartość dla platformy .NET Framework w wersji 1.1 będzie v1.1.4322. Pliki binarne dla danej wersji będą znajdować się w windir%\Microsoft.NET\Framework\v1.1.4322% ścieżki.  
  
 Domyślnie <xref:System.Reflection.Assembly.ImageRuntimeVersion%2A> ustawiono wersję środowiska CLR używanego do tworzenia zestawu. Jednak go może być ustawiona na inną wartość w czasie kompilacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member IsDefined : Type * bool -&gt; bool&#xA;override this.IsDefined : Type * bool -&gt; bool" Usage="assembly.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Typ atrybutu, który ma być sprawdzany dla tego zestawu.</param>
        <param name="inherit">Ten argument jest ignorowany w przypadku obiektów tego typu.</param>
        <summary>Wskazuje, czy określony atrybut zostały zastosowane do zestawu.</summary>
        <returns>
          <see langword="true" /> Jeśli ten atrybut został zastosowany do zestawu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod stosuje <xref:System.Reflection.AssemblyTitleAttribute> atrybut do zestawu, a następnie używa <xref:System.Reflection.Assembly.IsDefined%2A> do wskazania, czy zasada została zastosowana. Sprawdza również atrybut, który nie została zastosowana.  
  
 [!code-csharp[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/CS/isdefined.cs#1)]
 [!code-vb[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/VB/isdefined.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> używa nieprawidłowego typu.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public virtual bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDynamic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDynamic : bool" Usage="System.Reflection.Assembly.IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący zestaw został wygenerowany dynamicznie w bieżącym procesie przy użyciu odbicia emisji.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący zestaw został wygenerowany dynamicznie w bieżącym procesie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dynamiczne zestawy są reprezentowane w klasie pochodnej <xref:System.Reflection.Emit.AssemblyBuilder>.  
  
 Jeśli zestaw dynamiczny jest zapisywany na dysku, zapisany zestaw nie jest dynamiczny. Jeśli zapisany zestaw jest ładowany do innej domeny aplikacji lub procesu <xref:System.Reflection.Assembly.IsDynamic%2A> właściwość zwraca `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.Reflection.Assembly.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący zestaw jest ładowany z pełnym zaufaniem.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący zestaw jest ładowany z pełnym zaufaniem; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładuje zestaw.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tablica bajtów, która jest obrazem w formacie COFF, zawierającym emitowany zestaw.</param>
        <summary>Ładuje zestaw za pomocą wspólny format plików obiektu (COFF)-na podstawie obrazu, zawierającym emitowany zestaw. Zestaw jest ładowany do domeny aplikacji obiektu wywołującego.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poziom zaufania zestawu, który jest ładowany za pomocą tej metody jest taka sama jak poziom zaufania zestawu wywołującego. Aby załadować zestaw z tablicy bajtowej z poziomu zaufania domeny aplikacji, użyj <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> przeciążenie metody. Aby uzyskać więcej informacji dotyczących używania dowodów za pomocą przeciążenia <xref:System.Reflection.Assembly.Load%2A> Zobacz metody, które umożliwiają wykorzystywanie tablice typu byte <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> przeciążenie metody.  
  
 Rozważania na temat plików wykonywalnych języka C++ może zgłosić <xref:System.BadImageFormatException>. To prawdopodobnie spowodowane przez adresów przeniesienia kompilatora C++ lub `.reloc` sekcji z pliku wykonywalnego. Aby zachować `.reloc` adresów dla pliku wykonywalnego języka C++, określ `/fixed:no` czasu łączenia.  
  
 Należy pamiętać, że tego przeciążenia metody zawsze tworzy nową <xref:System.Reflection.Assembly> obiektu za pomocą własnej mapowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="rawAssembly" /> został skompilowany przy użyciu nowszej wersji.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Obiekt, który opisuje zestawie, który ma zostać załadowany.</param>
        <summary>Ładuje zestaw, biorąc pod uwagę jej <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> jest generowany, jeśli `assemblyRef` Określa nazwę zestawu pełnej i pierwszy zestaw, który jest zgodny z prostą nazwą ma inną wersję, kulturę lub token klucza publicznego. Moduł ładujący nie będzie sondowania dla innych zestawów, które jest zgodna z nazwą proste. Począwszy od programu .NET Framework 4, ponieważ wykonywanie kodu w zestawach zdalnego jest domyślnie wyłączony, <xref:System.IO.FileLoadException> również jest generowany, jeśli `assemblyRef` określa zestaw zdalnego. Aby włączyć wykonania kodu załadowanego z lokalizacji zdalnych, można użyć [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) element konfiguracji.     
  
> [!NOTE]
>  Nie używaj <xref:System.Reflection.AssemblyName> tylko z <xref:System.Reflection.AssemblyName.CodeBase%2A> zestawu właściwości. <xref:System.Reflection.AssemblyName.CodeBase%2A> Nie dostarcza żadnych elementów tożsamości zestawu (np. nazwę lub wersji), dlatego ładowanie nie występuje zgodnie z regułami obciążenia przez tożsamość jak można oczekiwać od <xref:System.Reflection.Assembly.Load%2A> metody. Zamiast tego zestaw jest ładowany za pomocą obciążenia z reguł. Aby uzyskać informacje dotyczące wad przy użyciu kontekst load-from, zobacz <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> przeciążenie metody lub [najlepsze rozwiązania dotyczące ładowania zestawu](~/docs/framework/deployment/best-practices-for-assembly-loading.md).  
  
 To, czy określone uprawnienia są przyznane do zestawu, czy nie, zależy od dowodów. Zasady scalania kompilowania asemblera i dowodów zabezpieczeń są następujące:  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.Load%2A> metody bez <xref:System.Security.Policy.Evidence> parametr, zestaw jest wczytywany wraz z dowodem dostarczonym przez moduł ładujący.  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.Load%2A> metody z <xref:System.Security.Policy.Evidence> parametru dowody są scalane. Dowody dostarczone jako argument do <xref:System.Reflection.Assembly.Load%2A> metoda wypierają dowody dostarczone przez moduł ładujący.  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.Load%2A> przeciążenie metody z `Byte[]` parametru, aby załadować wspólnych obiektu pliku format (COFF) obrazu, dowód jest dziedziczony z wywołującym zestawem. Dotyczy to architektury .NET Framework w wersji 1.1 z dodatkiem Service Pack 1 (SP1) i późniejszych wersji.  
  
    > [!NOTE]
    >  W .NET Framework w wersji 1.0 i w wersji 1.1 z dodatkiem SP1, gdy używasz — bez <xref:System.Reflection.Assembly.Load%2A> przeciążenie metody z `Byte[]` parametru do załadowania obrazu w formacie COFF, dowody w załączeniu. `Zone`, `Url` i `Site` są dziedziczone z zestawu wywołującego, a `Hash` i `StrongName` są pobierane z zestawu COFF.  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.Load%2A> metody z `Byte[]` parametru i <xref:System.Security.Policy.Evidence> do załadowania obrazu w formacie COFF, tylko dostarczony dowód jest wykorzystywany. Dowód wywołującego zestawu i dowody obrazu w formacie COFF jest ignorowany.  
  
 Rozważania na temat plików wykonywalnych języka C++ może zgłosić <xref:System.BadImageFormatException>. To prawdopodobnie spowodowane przez adresów przeniesienia kompilatora C++ lub `.reloc` sekcji z pliku wykonywalnego. Aby zachować `.reloc` adresów dla pliku wykonywalnego języka C++, określ `/fixed:no` czasu łączenia.  
  
> [!NOTE]
>  Jeśli oba <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> właściwości i <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> właściwości są ustawione, pierwsza próba załadowania zestawu używa nazwy wyświetlanej (łącznie z wersji, kultury i tak dalej, zwrócone przez <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> właściwości). Jeśli plik nie zostanie znaleziony, <xref:System.Reflection.AssemblyName.CodeBase%2A> służy do wyszukiwania dla zestawu. Jeśli zestaw znajduje się za pomocą <xref:System.Reflection.AssemblyName.CodeBase%2A>, nazwa wyświetlana jest dopasowywana do zestawu. Jeśli dopasowanie nie powiedzie się, <xref:System.IO.FileLoadException> zgłaszany.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Reflection.AssemblyName> obiektu i używa go do załadowania `sysglobal.dll` zestawu. Przykład następnie wyświetla pełną nazwę zestawu typów publicznych.  
  
 [!code-csharp[System.Reflection.Assembly.Load#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/Load2.cs#2)]
 [!code-vb[System.Reflection.Assembly.Load#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/Load2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.IO.IOException" />, a zamiast tego.  
  
</para>
          </block>  
  
 Nie można załadować pliku, który został znaleziony.

—lub—

<paramref name="assemblyRef" /> Określa zestaw zdalnego, ale możliwość wykonania kodu w zestawach zdalnego jest wyłączona. Zobacz <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element"> &lt;loadfromremotesources —&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> nie jest prawidłowym zestawem. —lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyRef" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">Sposoby lokalizowania zestawów przez środowisko uruchomieniowe</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member Load : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Długa forma nazwy zestawu.</param>
        <summary>Ładuje zestaw podane długich fragmentów jej nazwy.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Długich fragmentów nazwy zestawu składa się z jego prostą nazwę (np. "System" dla zestawu System.dll) wraz z jego wersji, kultury, token klucza publicznego i opcjonalnie jego architektury procesora. Odnosi się do zestawu <xref:System.Reflection.Assembly.FullName%2A> właściwości. Poniższy przykład ilustruje użycie długiej nazwy można załadować zestawu System.dll dla programu .NET Framework 4.  
  
 [!code-csharp[System.Reflection.Assembly.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/load1.cs#1)]
 [!code-vb[System.Reflection.Assembly.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/load1.vb#1)]  
  
 <xref:System.IO.FileLoadException> jest generowany, jeśli `assemblyString` Określa nazwę pełnego zestawu, a pierwszy zestaw, który jest zgodny z prostą nazwą ma inną wersję, kulturę lub token klucza publicznego. Moduł ładujący nie będzie sondowania dla innych zestawów, które jest zgodna z nazwą proste.  
  
 To, czy określone uprawnienia są przyznane do zestawu, czy nie, zależy od dowodów. Zasady scalania kompilowania asemblera i dowodów zabezpieczeń są następujące:  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.Load%2A> metody bez <xref:System.Security.Policy.Evidence> parametr, zestaw jest wczytywany wraz z dowodem dostarczonym przez moduł ładujący.  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.Load%2A> metody z <xref:System.Security.Policy.Evidence> parametru dowody są scalane. Dowody dostarczone jako argument do <xref:System.Reflection.Assembly.Load%2A> metoda wypierają dowody dostarczone przez moduł ładujący.  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.Load%2A> przeciążenie metody z `Byte[]` parametru, aby załadować wspólnych obiektu pliku format (COFF) obrazu, dowód jest dziedziczony z wywołującym zestawem. Dotyczy to architektury .NET Framework w wersji 1.1 z dodatkiem Service Pack 1 (SP1) i późniejszych wersji.  
  
    > [!NOTE]
    >  W .NET Framework w wersji 1.0 i w wersji 1.1 z dodatkiem SP1, gdy używasz — bez <xref:System.Reflection.Assembly.Load%2A> przeciążenie metody z `Byte[]` parametru do załadowania obrazu w formacie COFF, dowody w załączeniu. `Zone`, `Url` i `Site` są dziedziczone z zestawu wywołującego, a `Hash` i `StrongName` są pobierane z zestawu COFF.  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.Load%2A> metody z `Byte[]` parametru i <xref:System.Security.Policy.Evidence> do załadowania obrazu w formacie COFF, tylko dostarczony dowód jest wykorzystywany. Dowód wywołującego zestawu i dowody obrazu w formacie COFF jest ignorowany.  
  
 Rozważania na temat plików wykonywalnych języka C++ może zgłosić <xref:System.BadImageFormatException>. To prawdopodobnie spowodowane przez adresów przeniesienia kompilatora C++ lub `.reloc` sekcji z pliku wykonywalnego. Aby zachować `.reloc` adresów dla pliku wykonywalnego języka C++, określ `/fixed:no` czasu łączenia.  
  
 W wersji 2.0 środowiska .NET Framework architektura procesora jest dodawana do tożsamości zestawu i może być określona jako część zestawu ciągu nazw. Na przykład "ProcessorArchitecture = msil". Jednak jest to zalecany sposób określać nazwę zestawu do utworzenia <xref:System.Reflection.AssemblyName> obiektu i przekaż go do odpowiedniego przeciążenia <xref:System.Reflection.Assembly.Load%2A> metody. Zobacz <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład ładuje biorąc pod uwagę jego w pełni kwalifikowana nazwa zestawu i wyświetla listę wszystkich typów zawartych w określonym zestawie. Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o sposobie uzyskiwania w pełni kwalifikowanej nazwy zestawu, zobacz [nazw zestawów](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[assembly.load1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.Load1/CPP/load1.cpp#1)]
 [!code-csharp[assembly.load1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.Load1/CS/load1.cs#1)]
 [!code-vb[assembly.load1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.Load1/VB/load1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" /> jest ciągiem o zerowej długości.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyString" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">Sposoby lokalizowania zestawów przez środowisko uruchomieniowe</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tablica bajtów, która jest obrazem w formacie COFF, zawierającym emitowany zestaw.</param>
        <param name="rawSymbolStore">Tablica bajtów zawierająca bajty pierwotne reprezentujący symbole dla zestawu.</param>
        <summary>Ładuje zestaw za pomocą wspólny format plików obiektu (COFF)-na podstawie obrazu, zawierającym emitowany zestaw, opcjonalnie tym symbole dla zestawu. Zestaw jest ładowany do domeny aplikacji obiektu wywołującego.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poziom zaufania zestawu, który jest ładowany za pomocą tej metody jest taka sama jak poziom zaufania zestawu wywołującego. Aby załadować zestaw z tablicy bajtowej z poziomu zaufania domeny aplikacji, użyj <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> przeciążenie metody. Aby uzyskać więcej informacji dotyczących używania dowodów za pomocą przeciążenia <xref:System.Reflection.Assembly.Load%2A> Zobacz metody, które umożliwiają wykorzystywanie tablice typu byte <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> przeciążenie metody.  
  
 Rozważania na temat plików wykonywalnych języka C++ może zgłosić <xref:System.BadImageFormatException>. To prawdopodobnie spowodowane przez adresów przeniesienia kompilatora C++ lub `.reloc` sekcji z pliku wykonywalnego. Aby zachować `.reloc` adresów dla pliku wykonywalnego języka C++, określ `/fixed:no` czasu łączenia.  
  
 Należy pamiętać, że tego przeciążenia metody zawsze tworzy nową <xref:System.Reflection.Assembly> obiektu za pomocą własnej mapowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="rawAssembly" /> został skompilowany przy użyciu nowszej wersji.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Obiekt, który opisuje zestawie, który ma zostać załadowany.</param>
        <param name="assemblySecurity">Dowód ładowania zestawu.</param>
        <summary>Ładuje zestaw, biorąc pod uwagę jej <see cref="T:System.Reflection.AssemblyName" />. Zestaw jest ładowany do domeny przy użyciu dostarczony dowód obiektu wywołującego.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> jest generowany, jeśli `assemblyRef` Określa nazwę pełnego zestawu, a pierwszy zestaw, który jest zgodny z prostą nazwą ma inną wersję, kulturę lub token klucza publicznego. Moduł ładujący nie będzie sondowania dla innych zestawów, które jest zgodna z nazwą proste.  Począwszy od programu .NET Framework 4, ponieważ wykonywanie kodu w zestawach zdalnego jest domyślnie wyłączony, <xref:System.IO.FileLoadException> również jest generowany, jeśli `assemblyRef` określa zestaw zdalnego. Aby włączyć wykonania kodu załadowanego z lokalizacji zdalnych, można użyć [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) element konfiguracji.   
  
> [!NOTE]
>  Nie używaj <xref:System.Reflection.AssemblyName> tylko z <xref:System.Reflection.AssemblyName.CodeBase%2A> zestawu właściwości. <xref:System.Reflection.AssemblyName.CodeBase%2A> Nie dostarcza żadnych elementów tożsamości zestawu (np. nazwę lub wersji), dlatego ładowanie nie występuje zgodnie z regułami obciążenia przez tożsamość jak można oczekiwać od <xref:System.Reflection.Assembly.Load%2A> metody. Zamiast tego zestaw jest ładowany za pomocą obciążenia z reguł. Aby uzyskać informacje dotyczące wad przy użyciu kontekst load-from, zobacz <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> przeciążenie metody lub [najlepsze rozwiązania dotyczące ładowania zestawu](~/docs/framework/deployment/best-practices-for-assembly-loading.md).  
  
 To, czy określone uprawnienia są przyznane do zestawu, czy nie, zależy od dowodów. Zasady scalania kompilowania asemblera i dowodów zabezpieczeń są następujące:  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.Load%2A> metody bez <xref:System.Security.Policy.Evidence> parametr, zestaw jest wczytywany wraz z dowodem dostarczonym przez moduł ładujący.  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.Load%2A> metody z <xref:System.Security.Policy.Evidence> parametru dowody są scalane. Dowody dostarczone jako argument do <xref:System.Reflection.Assembly.Load%2A> metoda wypierają dowody dostarczone przez moduł ładujący.  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.Load%2A> przeciążenie metody z `Byte[]` parametru, aby załadować wspólnych obiektu pliku format (COFF) obrazu, dowód jest dziedziczony z wywołującym zestawem. Dotyczy to architektury .NET Framework w wersji 1.1 z dodatkiem Service Pack 1 (SP1) i późniejszych wersji.  
  
    > [!NOTE]
    >  W .NET Framework w wersji 1.0 i w wersji 1.1 z dodatkiem SP1, gdy używasz — bez <xref:System.Reflection.Assembly.Load%2A> przeciążenie metody z `Byte[]` parametru do załadowania obrazu w formacie COFF, dowody w załączeniu. `Zone`, `Url` i `Site` są dziedziczone z zestawu wywołującego, a `Hash` i `StrongName` są pobierane z zestawu COFF.  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.Load%2A> metody z `Byte[]` parametru i <xref:System.Security.Policy.Evidence> do załadowania obrazu w formacie COFF, tylko dostarczony dowód jest wykorzystywany. Dowód wywołującego zestawu i dowody obrazu w formacie COFF jest ignorowany.  
  
 Rozważania na temat plików wykonywalnych języka C++ może zgłosić <xref:System.BadImageFormatException>. To prawdopodobnie spowodowane przez adresów przeniesienia kompilatora C++ lub `.reloc` sekcji z pliku wykonywalnego. Aby zachować `.reloc` adresów dla pliku wykonywalnego języka C++, określ `/fixed:no` czasu łączenia.  
  
> [!NOTE]
>  Jeśli oba <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> właściwości i <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> właściwości są ustawione, pierwsza próba załadowania zestawu używa nazwy wyświetlanej (łącznie z wersji, kultury i tak dalej, zwrócone przez <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> właściwości). Jeśli plik nie zostanie znaleziony, <xref:System.Reflection.AssemblyName.CodeBase%2A> służy do wyszukiwania dla zestawu. Jeśli zestaw znajduje się za pomocą <xref:System.Reflection.AssemblyName.CodeBase%2A>, nazwa wyświetlana jest dopasowywana do zestawu. Jeśli dopasowanie nie powiedzie się, <xref:System.IO.FileLoadException> zgłaszany.  
  
 Jeśli wywołasz <xref:System.Reflection.Assembly.Load%2A> metoda więcej niż jeden raz na tym samym zestawie, ale przy użyciu różnych dowód, określone, środowisko uruchomieniowe języka wspólnego nie zgłasza <xref:System.IO.FileLoadException> ponieważ równości i integralności specyfikacji inny dowód nie może być określona. Używanym dowodem jest dowód na to, że odniesie się sukces za pierwszym razem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyRef" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.

—lub—

<paramref name="assemblyRef" /> Określa zestaw zdalnego, ale możliwość wykonania kodu w zestawach zdalnego jest wyłączona. Zobacz <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element"> &lt;loadfromremotesources —&gt;</see>.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">Sposoby lokalizowania zestawów przez środowisko uruchomieniowe</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Wyświetlana nazwa zestawu.</param>
        <param name="assemblySecurity">Dowód ładowania zestawu.</param>
        <summary>Ładuje zestaw biorąc pod uwagę jego nazwę wyświetlaną podczas ładowania zestawu do domeny wywołującemu, korzystając z dostarczony dowód.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> jest generowany, jeśli `assemblyString` Określa nazwę pełnego zestawu, a pierwszy zestaw, który jest zgodny z prostą nazwą ma inną wersję, kulturę lub token klucza publicznego. Moduł ładujący nie będzie sondowania dla innych zestawów, które jest zgodna z nazwą proste.  
  
 To, czy określone uprawnienia są przyznane do zestawu, czy nie, zależy od dowodów. Zasady scalania kompilowania asemblera i dowodów zabezpieczeń są następujące:  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.Load%2A> metody bez <xref:System.Security.Policy.Evidence> parametr, zestaw jest wczytywany wraz z dowodem dostarczonym przez moduł ładujący.  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.Load%2A> metody z <xref:System.Security.Policy.Evidence> parametru dowody są scalane. Dowody dostarczone jako argument do <xref:System.Reflection.Assembly.Load%2A> metoda wypierają dowody dostarczone przez moduł ładujący.  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.Load%2A> przeciążenie metody z `Byte[]` parametru, aby załadować wspólnych obiektu pliku format (COFF) obrazu, dowód jest dziedziczony z wywołującym zestawem. Dotyczy to architektury .NET Framework w wersji 1.1 z dodatkiem Service Pack 1 (SP1) i późniejszych wersji.  
  
    > [!NOTE]
    >  W .NET Framework w wersji 1.0 i w wersji 1.1 z dodatkiem SP1, gdy używasz — bez <xref:System.Reflection.Assembly.Load%2A> przeciążenie metody z `Byte[]` parametru do załadowania obrazu w formacie COFF, dowody w załączeniu. `Zone`, `Url` i `Site` są dziedziczone z zestawu wywołującego, a `Hash` i `StrongName` są pobierane z zestawu COFF.  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.Load%2A> metody z `Byte[]` parametru i <xref:System.Security.Policy.Evidence> do załadowania obrazu w formacie COFF, tylko dostarczony dowód jest wykorzystywany. Dowód wywołującego zestawu i dowody obrazu w formacie COFF jest ignorowany.  
  
 Rozważania na temat plików wykonywalnych języka C++ może zgłosić <xref:System.BadImageFormatException>. To prawdopodobnie spowodowane przez adresów przeniesienia kompilatora C++ lub `.reloc` sekcji z pliku wykonywalnego. Aby zachować `.reloc` adresów dla pliku wykonywalnego języka C++, określ `/fixed:no` czasu łączenia.  
  
 Jeśli ta metoda jest wywoływana więcej niż jeden raz na tym samym zestawie, ale z inną dowód, określone, środowisko uruchomieniowe języka wspólnego nie zgłasza <xref:System.IO.FileLoadException> ponieważ nie można określić równości i integralności specyfikacji różnych dowodów. Używanym dowodem jest dowód na to, że odniesie się sukces za pierwszym razem.  
  
 W wersji 2.0 środowiska .NET Framework architektura procesora jest dodawana do tożsamości zestawu i może być określona jako część zestawu ciągu nazw. Na przykład "ProcessorArchitecture = msil". Jednak jest to zalecany sposób określać nazwę zestawu do utworzenia <xref:System.Reflection.AssemblyName> obiektu i przekaż go do odpowiedniego przeciążenia <xref:System.Reflection.Assembly.Load%2A> metody. Zobacz <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyString" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.  
  
—lub— 
Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">Sposoby lokalizowania zestawów przez środowisko uruchomieniowe</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tablica bajtów, która jest obrazem w formacie COFF, zawierającym emitowany zestaw.</param>
        <param name="rawSymbolStore">Tablica bajtów zawierająca bajty pierwotne reprezentujący symbole dla zestawu.</param>
        <param name="securityEvidence">Dowód ładowania zestawu.</param>
        <summary>Ładuje zestaw za pomocą wspólny format plików obiektu (COFF)-na podstawie obrazu, zawierającym emitowany zestaw, opcjonalnie tym symboli i dowodu dla zestawu. Zestaw jest ładowany do domeny aplikacji obiektu wywołującego.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw jest ładowany do domeny przy użyciu dostarczony dowód obiektu wywołującego. Bajtów raw, reprezentujący symbole dla zestawu również są ładowane.  
  
 To, czy określone uprawnienia są przyznane do zestawu, czy nie, zależy od dowodów. Zasady scalania kompilowania asemblera i dowodów zabezpieczeń są następujące:  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.Load%2A> metody bez <xref:System.Security.Policy.Evidence> parametr, zestaw jest wczytywany wraz z dowodem dostarczonym przez moduł ładujący.  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.Load%2A> metody z <xref:System.Security.Policy.Evidence> parametru dowody są scalane. Dowody dostarczone jako argument do <xref:System.Reflection.Assembly.Load%2A> metoda wypierają dowody dostarczone przez moduł ładujący.  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.Load%2A> przeciążenie metody z `Byte[]` parametru do załadowania obrazu w formacie COFF, dowody jest dziedziczony z wywołującym zestawem. Dotyczy to architektury .NET Framework w wersji 1.1 z dodatkiem Service Pack 1 (SP1) i późniejszych wersji.  
  
    > [!NOTE]
    >  W .NET Framework w wersji 1.0 i w wersji 1.1 z dodatkiem SP1, gdy używasz — bez <xref:System.Reflection.Assembly.Load%2A> przeciążenie metody z `Byte[]` parametru do załadowania obrazu w formacie COFF, dowody w załączeniu. `Zone`, `Url` i `Site` są dziedziczone z zestawu wywołującego, a `Hash` i `StrongName` są pobierane z zestawu COFF.  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.Load%2A> metody z `Byte[]` parametru i <xref:System.Security.Policy.Evidence> do załadowania obrazu w formacie COFF, tylko dostarczony dowód jest wykorzystywany. Dowód wywołującego zestawu i dowody obrazu w formacie COFF są ignorowane.  
  
 Rozważania na temat plików wykonywalnych języka C++ może zgłosić <xref:System.BadImageFormatException>. To prawdopodobnie spowodowane przez adresów przeniesienia kompilatora C++ lub `.reloc` sekcji z pliku wykonywalnego. Aby zachować `.reloc` adresów dla pliku wykonywalnego języka C++, określ `/fixed:no` czasu łączenia.  
  
 Jeśli wywołasz [\], bajt\<xref:System.Reflection.Assembly.Load%2A > Metoda więcej niż jeden raz na tym samym zestawie, ale przy użyciu różnych dowód, określone, środowisko uruchomieniowe języka wspólnego nie zgłasza <xref:System.IO.FileLoadException> ponieważ Nie można ustalić równości i integralności specyfikacji różnych dowodów. Używanym dowodem jest dowód na to, że odniesie się sukces za pierwszym razem.  
  
 Należy pamiętać, że tego przeciążenia metody zawsze tworzy nową <xref:System.Reflection.Assembly> obiektu za pomocą własnej mapowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="rawAssembly" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> nie jest <see langword="null" />.  Starsza zasada CAS nie jest domyślnie włączona w [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; gdy nie jest włączone, <paramref name="securityEvidence" /> musi być <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość dostarczyć dowodów. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.SecurityContextSource -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tablica bajtów, która jest obrazem w formacie COFF, zawierającym emitowany zestaw.</param>
        <param name="rawSymbolStore">Tablica bajtów zawierająca bajty pierwotne reprezentujący symbole dla zestawu.</param>
        <param name="securityContextSource">Źródło kontekstu zabezpieczeń.</param>
        <summary>Ładuje zestaw za pomocą wspólny format plików obiektu (COFF)-na podstawie obrazu, zawierającym emitowany zestaw, opcjonalnie w tym symboli i Określanie źródła dla kontekstu zabezpieczeń. Zestaw jest ładowany do domeny aplikacji obiektu wywołującego.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw jest ładowany do domeny aplikacji obiektu wywołującego, za pomocą określonego źródła dla kontekstu zabezpieczeń. Jeśli `rawSymbolStore` określono bajtów raw, które reprezentują symbole dla zestawu również są ładowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="rawAssembly" /> został skompilowany przy użyciu nowszej wersji środowiska uruchomieniowego języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="securityContextSource" /> nie jest jedną z wartości wyliczenia.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładuje zawartość pliku zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">W pełni kwalifikowana ścieżka pliku do załadowania.</param>
        <summary>Ładuje zawartość pliku zestawu w określonej ścieżce.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Reflection.Assembly.LoadFile%2A> metodę, aby załadować i zbadaj zestawów, które mają taką samą tożsamość, ale znajdują się w różnych ścieżek. <xref:System.Reflection.Assembly.LoadFile%2A> nie ładuje pliki do kontekst load-from, a nie rozpoznać zależności za pomocą ścieżki obciążenia jako <xref:System.Reflection.Assembly.LoadFrom%2A> metody. <xref:System.Reflection.Assembly.LoadFile%2A> przydaje się w tym scenariuszu ograniczone ponieważ <xref:System.Reflection.Assembly.LoadFrom%2A> nie można załadować zestawów, które mają ten sam tożsamości, ale różnych ścieżek; będzie on ładować tylko pierwszy takiego zestawu.  

Począwszy od programu .NET Framework 4, jeśli `path` określa zestaw w lokalizacji zdalnej, z ładowaniem zestawu, jest domyślnie wyłączony, a `LoadFile` metoda zgłasza wyjątek <xref:System.IO.FileLoadException>. Aby włączyć wykonania kodu załadowanego z lokalizacji zdalnych, można użyć [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) element konfiguracji.    
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Argument nie jest ścieżką bezwzględną.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.

—lub—

Możliwość wykonania kodu w zestawach zdalnego jest wyłączona. Zobacz <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element"> &lt;loadfromremotesources —&gt;</see>.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> Parametr jest pustym ciągiem ("") lub nie istnieje.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="path" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="path" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile (path, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFile which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="path">W pełni kwalifikowana ścieżka pliku zestawu.</param>
        <param name="securityEvidence">Dowód ładowania zestawu.</param>
        <summary>Ładuje zestaw podanej ścieżce, ładowania zestawu do domeny wywołującemu, korzystając z dostarczony dowód.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Reflection.Assembly.LoadFile%2A> metodę, aby załadować i zbadaj zestawów, które mają taką samą tożsamość, ale znajdują się w różnych ścieżek. <xref:System.Reflection.Assembly.LoadFile%2A> nie ładuje pliki do <xref:System.Reflection.Assembly.LoadFrom%2A> kontekście i nie zostanie rozpoznana zależności za pomocą ścieżki obciążenia jako <xref:System.Reflection.Assembly.LoadFrom%2A> metody. <xref:System.Reflection.Assembly.LoadFile%2A> przydaje się w tym scenariuszu ograniczone ponieważ <xref:System.Reflection.Assembly.LoadFrom%2A> nie można załadować zestawów, które mają ten sam tożsamości, ale różnych ścieżek; będzie on ładować tylko pierwszy takiego zestawu.  

Począwszy od programu .NET Framework 4, jeśli `path` określa zestaw w lokalizacji zdalnej, z ładowaniem zestawu, jest domyślnie wyłączony, a `LoadFile` metoda zgłasza wyjątek <xref:System.IO.FileLoadException>. Aby włączyć wykonania kodu załadowanego z lokalizacji zdalnych, można użyć [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) element konfiguracji.    

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Argument nie jest ścieżką bezwzględną.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> Parametr jest pustym ciągiem ("") lub nie istnieje.</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.

—lub—

Możliwość wykonania kodu w zestawach zdalnego jest wyłączona. Zobacz <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element"> &lt;loadfromremotesources —&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="path" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="path" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> nie jest <see langword="null" />. Starsza zasada CAS nie jest domyślnie włączona w [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; gdy nie jest włączone, <paramref name="securityEvidence" /> musi być <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładuje zestaw.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
             
## Remarks

Począwszy od programu .NET Framework 4, możliwość wykonania kodu w zestawy, ładowane z lokalizacji zdalnych jest wyłączona domyślnie i wywołanie `LoadFrom` metoda zgłasza wyjątek <xref:System.IO.FileLoadException>. Aby załadować zestaw i wykonywanie kodu, należy:

- Jawnie utworzyć piaskownicy dla zestawu. (Zobacz [porady: uruchamianie częściowo zaufanego kodu w piaskownicy](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).)

- Uruchom kod zestawu w trybie pełnego zaufania, ustawiając `enabled` atrybutu [ `<loadFromRemoteSources>` element konfiguracji](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) do `true`. Aby uzyskać więcej informacji, zobacz [ `<loadFromRemoteSources>` element konfiguracji](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) artykułu.

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa lub ścieżka do pliku, który zawiera manifest zestawu.</param>
        <summary>Ładuje zestaw, biorąc pod uwagę jej nazwę pliku lub ścieżkę.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile` Parametru musi odwoływać się do identyfikatora URI bez znaków ucieczki. Ta metoda dostarcza znaki ucieczki dla wszystkie nieprawidłowe znaki w identyfikatorze URI.  
  
> [!NOTE]
>  Protokół transferu plików (FTP) nie jest obsługiwana. Jeśli identyfikator URI podany dla `assemblyFile` jest adresem protokołu FTP nie jest załadowany zestaw. Jest zgłaszany żaden wyjątek.  
  
 `assemblyFile` może być ścieżką bezwzględną lub względną do bieżącego katalogu i zestaw jest ładowany do domeny obiektu wywołującego.  
  
 Zestawy może być załadowany do jednej z trzech kontekstów lub może być załadowany bez kontekstu:  
  
-   Kontekst ładowania zawiera znalezione przez sondowanie zestawów: w pamięci podręcznej GAC, w zestawie hosta przechowywania znajduje się środowisko uruchomieniowe, czy w <xref:System.AppDomainSetup.ApplicationBase%2A> i <xref:System.AppDomainSetup.PrivateBinPath%2A> domeny aplikacji. Większość przeciążenia <xref:System.Reflection.Assembly.Load%2A> metoda Ładuj zestawy w tym kontekście.  
  
-   Kontekst load-from zawiera zestawy, do których użytkownik podał ścieżki nie są objęte katalogi przeszukiwane przez sondowanie. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, i <xref:System.AppDomain.ExecuteAssembly%2A> przedstawiono przykładowe metody, które są ładowane przy użyciu ścieżki. 

    Począwszy od programu .NET Framework 4, jeśli identyfikator URI `assemblyFile` określa lokalizacji zdalnej, z ładowaniem zestawu, jest domyślnie wyłączony, a `LoadFrom` metoda zgłasza wyjątek <xref:System.IO.FileLoadException>. Aby włączyć wykonania kodu załadowanego z lokalizacji zdalnych, można użyć [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) element konfiguracji.    
  
-   Kontekstu reflection-only zawiera zestawy, ładowane z <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> i <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metod; kod w tych kontekstach nie można wykonać.  
  
-   Jeśli użytkownik wygenerowany lub można odnaleźć zestawu, nie jest w jakimkolwiek kontekście. Dotyczy to zestawy, ładowane przy użyciu przeciążeń <xref:System.Reflection.Assembly.Load%2A> metodę, która Określ tablica bajtów zawierająca zestawu i aby przejściowych dynamicznych zestawów utworzonych za pomocą odbicia emisji i nie zapisano na dysku.  
  
 Kontekst load-from umożliwia zestawu do załadowania ze ścieżki nie są uwzględnione w badania, a jeszcze umożliwia zależności na tę ścieżkę, aby znaleźć i załadować, ponieważ informacje o ścieżce jest obsługiwana przez kontekst.  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A> Metoda ma następujące wady. Należy rozważyć użycie <xref:System.Reflection.Assembly.Load%2A> zamiast tego.  
  
-   Jeśli zestaw o tej samej tożsamości jest już załadowany, <xref:System.Reflection.Assembly.LoadFrom%2A> zwraca załadowany zestaw, nawet jeśli określono inną ścieżkę.  
  
-   Jeśli zestaw jest ładowany z <xref:System.Reflection.Assembly.LoadFrom%2A>, a później spróbuje załadować tego samego zestawu według nazwy wyświetlanej zestawu w kontekście ładowania, próba załadowania zakończy się niepowodzeniem. Taka sytuacja może wystąpić, gdy zestaw jest zdeserializowany.  
  
-   Jeśli zestaw jest ładowany z <xref:System.Reflection.Assembly.LoadFrom%2A>, i badania ścieżka zawiera zestaw o tej samej tożsamości, ale inną lokalizację <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, lub inne nieoczekiwane zachowania mogą wystąpić.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> żądania <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> i <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, lub <xref:System.Net.WebPermission>, w określonej ścieżce.  
  
-   Jeśli istnieje obrazu natywnego `assemblyFile`, nie jest używany. Zestawu nie może być ładowane jako niezależne od domeny.  
  
-   W .NET Framework w wersji 1.0 i 1.1 zasady nie są stosowane.  
  
   
  
## Examples  
 Poniższy przykład ładuje zestaw biorąc pod uwagę jej nazwę pliku lub ścieżkę.  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> nie zostanie znaleziony, lub moduł, który chcesz załadować nie określa rozszerzenie nazwy pliku.</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.

—lub—

Możliwość wykonania kodu w zestawach zdalnego jest wyłączona. Zobacz <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element"> &lt;loadfromremotesources —&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem; na przykład 32-bitowy zestaw w procesie 64-bitowym. Zobacz temat wyjątków, aby uzyskać więcej informacji.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.Security.SecurityException">Codebase, która nie rozpoczyna się od "file://" został określony bez wymaganych <see cref="T:System.Net.WebPermission" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> Parametr jest pustym ciągiem ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Nazwa zestawu przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania identyfikatora URI, który rozpoczyna się od "file://". Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa lub ścieżka do pliku, który zawiera manifest zestawu.</param>
        <param name="securityEvidence">Dowód ładowania zestawu.</param>
        <summary>Ładuje zestaw, biorąc pod uwagę jej dowodów zabezpieczeń pliku, jak nazwa lub ścieżka i dostarczenie.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile` Parametru musi odwoływać się do identyfikatora URI bez znaków ucieczki. Ta metoda dostarcza znaki ucieczki dla wszystkie nieprawidłowe znaki w identyfikatorze URI.  
  
> [!NOTE]
>  Protokół transferu plików (FTP) nie jest obsługiwana. Jeśli identyfikator URI podany dla `assemblyFile` jest adresem protokołu FTP nie jest załadowany zestaw. Jest zgłaszany żaden wyjątek.  
  
 `assemblyFile` może być ścieżką bezwzględną lub względną do bieżącego katalogu i zestaw jest ładowany do domeny obiektu wywołującego.  
  
 Zestawy może być załadowany do jednej z trzech kontekstów lub może być załadowany bez kontekstu:  
  
-   Kontekst ładowania zawiera znalezione przez sondowanie zestawów: w pamięci podręcznej GAC, w zestawie hosta przechowywania znajduje się środowisko uruchomieniowe, czy w <xref:System.AppDomainSetup.ApplicationBase%2A> i <xref:System.AppDomainSetup.PrivateBinPath%2A> domeny aplikacji. Większość przeciążenia <xref:System.Reflection.Assembly.Load%2A> metoda Ładuj zestawy w tym kontekście.  
  
-   Kontekst load-from zawiera zestawy, do których użytkownik podał ścieżki nie są objęte katalogi przeszukiwane przez sondowanie. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, i <xref:System.AppDomain.ExecuteAssembly%2A> przedstawiono przykładowe metody, które są ładowane przy użyciu ścieżki.

    Począwszy od programu .NET Framework 4, jeśli identyfikator URI `assemblyFile` określa lokalizacji zdalnej, z ładowaniem zestawu, jest domyślnie wyłączony, a `LoadFrom` metoda zgłasza wyjątek <xref:System.IO.FileLoadException>. Aby włączyć wykonania kodu załadowanego z lokalizacji zdalnych, można użyć [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) element konfiguracji.    
  
-   Kontekstu reflection-only zawiera zestawy, ładowane z <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> i <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metod; kod w tych kontekstach nie można wykonać.  
  
-   Jeśli użytkownik wygenerowany lub można odnaleźć zestawu, nie jest w jakimkolwiek kontekście. Dotyczy to zestawy, ładowane przy użyciu przeciążeń <xref:System.Reflection.Assembly.Load%2A> metodę, która Określ tablica bajtów zawierająca zestawu i aby przejściowych dynamicznych zestawów utworzonych za pomocą odbicia emisji i nie zapisano na dysku.  
  
 Kontekst load-from umożliwia zestawu do załadowania ze ścieżki nie są uwzględnione w badania, a jeszcze umożliwia zależności na tę ścieżkę, aby znaleźć i załadować, ponieważ informacje o ścieżce jest obsługiwana przez kontekst.  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A> Metoda ma następujące wady. Należy rozważyć użycie <xref:System.Reflection.Assembly.Load%2A> zamiast tego.  
  
-   Jeśli zestaw o tej samej tożsamości jest już załadowany, <xref:System.Reflection.Assembly.LoadFrom%2A> zwraca załadowany zestaw, nawet jeśli określono inną ścieżkę.  
  
-   Jeśli zestaw jest ładowany z <xref:System.Reflection.Assembly.LoadFrom%2A>, a później spróbuje załadować tego samego zestawu według nazwy wyświetlanej zestawu w kontekście ładowania, próba załadowania zakończy się niepowodzeniem. Taka sytuacja może wystąpić, gdy zestaw jest przeprowadzona.  
  
-   Jeśli zestaw jest ładowany z <xref:System.Reflection.Assembly.LoadFrom%2A>, i badania ścieżka zawiera zestaw o tej samej tożsamości, ale inną lokalizację <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, lub inne nieoczekiwane zachowania mogą wystąpić.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> żądania <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> i <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, lub <xref:System.Net.WebPermission>, w określonej ścieżce.  
  
-   Jeśli istnieje obrazu natywnego `assemblyFile`, nie jest używany. Zestawu nie może być ładowane jako niezależne od domeny.  
  
-   W .NET Framework w wersji 1.0 i 1.1 zasady nie są stosowane.  
  
 To, czy określone uprawnienia są przyznane do zestawu, czy nie, zależy od dowodów. Zasady scalania kompilowania asemblera i dowodów zabezpieczeń są następujące:  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.LoadFrom%2A> metody bez <xref:System.Security.Policy.Evidence> parametr, zestaw jest wczytywany wraz z dowodem dostarczonym przez moduł ładujący.  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.LoadFrom%2A> metody z <xref:System.Security.Policy.Evidence> parametru dowody są scalane. Dowody dostarczone jako argument do <xref:System.Reflection.Assembly.LoadFrom%2A> metoda wypierają dowody dostarczone przez moduł ładujący.  
  
-   Jeśli ta metoda jest wywoływana więcej niż jeden raz na tym samym zestawie, ale z inną dowód, określone, środowisko uruchomieniowe języka wspólnego nie zgłasza <xref:System.IO.FileLoadException> ponieważ nie można określić równości i integralności specyfikacji różnych dowodów. Używanym dowodem jest dowód na to, że odniesie się sukces za pierwszym razem.  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.LoadFrom%2A> metody z `Byte[]` parametr do załadowania wspólnej obiektu pliku format (COFF) obrazu, dowody w załączeniu. `Zone`, `Url` i `Site` są dziedziczone z zestawu wywołującego, a `Hash` i `StrongName` są pobierane z zestawu COFF.  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.LoadFrom%2A> metody z `Byte[]` parametru i <xref:System.Security.Policy.Evidence> do załadowania obrazu w formacie COFF, tylko dostarczony dowód jest wykorzystywany. Dowód wywołującego zestawu i dowody obrazu w formacie COFF jest ignorowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> nie zostanie znaleziony, lub moduł, który chcesz załadować nie określa rozszerzenie nazwy pliku.</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.  
  
—lub— 
<paramref name="securityEvidence" /> Nie jest niejednoznaczne i jest określone, jest nieprawidłowy.

—lub—

Możliwość wykonania kodu w zestawach zdalnego jest wyłączona. Zobacz <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element"> &lt;loadfromremotesources —&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem; na przykład 32-bitowy zestaw w procesie 64-bitowym. Zobacz temat wyjątków, aby uzyskać więcej informacji.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.Security.SecurityException">Codebase, która nie rozpoczyna się od "file://" został określony bez wymaganych <see cref="T:System.Net.WebPermission" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> Parametr jest pustym ciągiem ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Nazwa zestawu przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania identyfikatora URI, który rozpoczyna się od "file://". Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa lub ścieżka do pliku, który zawiera manifest zestawu.</param>
        <param name="hashValue">Wartość obliczona wartość skrótu.</param>
        <param name="hashAlgorithm">Algorytm wyznaczania wartości skrótu, używane do tworzenia skrótów plików oraz do generowania silnej nazwy.</param>
        <summary>Ładuje zestaw danej nazwy pliku lub ścieżki, wartość skrótu i algorytm wyznaczania wartości skrótu.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile` Parametru musi odwoływać się do identyfikatora URI bez znaków ucieczki. Ta metoda dostarcza znaki ucieczki dla wszystkie nieprawidłowe znaki w identyfikatorze URI.  
  
> [!NOTE]
>  Protokół transferu plików (FTP) nie jest obsługiwana. Jeśli identyfikator URI podany dla `assemblyFile` jest adresem protokołu FTP nie jest załadowany zestaw. Jest zgłaszany żaden wyjątek.  
  
 `assemblyFile` może być ścieżką bezwzględną lub względną do bieżącego katalogu i zestaw jest ładowany do domeny obiektu wywołującego.  
  
 Zestawy może być załadowany do jednej z trzech kontekstów lub może być załadowany bez kontekstu:  
  
-   Kontekst ładowania zawiera znalezione przez sondowanie zestawów: w globalnej pamięci podręcznej w zestawie hosta przechowywać znajduje się środowisko uruchomieniowe, czy w <xref:System.AppDomainSetup.ApplicationBase%2A> i <xref:System.AppDomainSetup.PrivateBinPath%2A> domeny aplikacji. Większość przeciążenia <xref:System.Reflection.Assembly.Load%2A> metoda Ładuj zestawy w tym kontekście.  
  
-   Kontekst load-from zawiera zestawy, do których użytkownik podał ścieżkę, która nie jest uwzględniony w badania. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, i <xref:System.AppDomain.ExecuteAssembly%2A> przedstawiono przykładowe metody, które są ładowane przy użyciu ścieżki.  

    Począwszy od programu .NET Framework 4, jeśli identyfikator URI `assemblyFile` określa lokalizacji zdalnej, z ładowaniem zestawu, jest domyślnie wyłączony, a `LoadFrom` metoda zgłasza wyjątek <xref:System.IO.FileLoadException>. Aby włączyć wykonania kodu załadowanego z lokalizacji zdalnych, można użyć [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) element konfiguracji.    
  
-   Kontekstu reflection-only zawiera zestawy, ładowane z <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> i <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metod; kod w tych kontekstach nie można wykonać.  
  
-   Jeśli użytkownik wygenerowany lub można odnaleźć zestawu, nie jest w jakimkolwiek kontekście. Dotyczy to zestawy, ładowane przy użyciu przeciążeń <xref:System.Reflection.Assembly.Load%2A> metodę, która Określ tablica bajtów zawierająca zestawu i aby przejściowych dynamicznych zestawów utworzonych za pomocą odbicia emisji i nie zapisano na dysku.  
  
 Kontekst load-from umożliwia zestawu do załadowania ze ścieżki, która nie jest uwzględniony w badania, a jeszcze umożliwia zależności na tę ścieżkę, aby znaleźć i załadować, ponieważ informacje o ścieżce jest obsługiwana przez kontekst.  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A> Metoda ma następujące wady. Należy rozważyć użycie <xref:System.Reflection.Assembly.Load%2A> zamiast tego.  
  
-   Jeśli zestaw o tej samej tożsamości jest już załadowany, <xref:System.Reflection.Assembly.LoadFrom%2A> zwraca załadowany zestaw, nawet jeśli określono inną ścieżkę.  
  
-   Jeśli zestaw jest ładowany z <xref:System.Reflection.Assembly.LoadFrom%2A>, a później spróbuje załadować tego samego zestawu według nazwy wyświetlanej zestawu w kontekście ładowania, próba załadowania zakończy się niepowodzeniem. Taka sytuacja może wystąpić, gdy zestaw jest przeprowadzona.  
  
-   Jeśli zestaw jest ładowany z <xref:System.Reflection.Assembly.LoadFrom%2A>, i badania ścieżka zawiera zestaw o tej samej tożsamości, ale inną lokalizację <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, lub inne nieoczekiwane zachowania mogą wystąpić.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> żądania <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> i <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, lub <xref:System.Net.WebPermission>, w określonej ścieżce.  
  
-   Jeśli istnieje obrazu natywnego `assemblyFile`, nie jest używany. Nie można załadować zestawów jako neutralnych dla domen.  
  
 Zestaw jest wczytywany wraz z dowodem dostarczonym przez moduł ładujący.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> nie zostanie znaleziony, lub moduł, który chcesz załadować nie określa rozszerzenie nazwy pliku.</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.

—lub—

Możliwość wykonania kodu w zestawach zdalnego jest wyłączona. Zobacz <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element"> &lt;loadfromremotesources —&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem; na przykład 32-bitowy zestaw w procesie 64-bitowym. Zobacz temat wyjątków, aby uzyskać więcej informacji.  
  
—lub— 
 <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji środowiska uruchomieniowego języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
        <exception cref="T:System.Security.SecurityException">Codebase, która nie rozpoczyna się od "file://" został określony bez wymaganych <see cref="T:System.Net.WebPermission" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> Parametr jest pustym ciągiem ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Nazwa zestawu przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania identyfikatora URI, który rozpoczyna się od "file://". Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa lub ścieżka do pliku, który zawiera manifest zestawu.</param>
        <param name="securityEvidence">Dowód ładowania zestawu.</param>
        <param name="hashValue">Wartość obliczona wartość skrótu.</param>
        <param name="hashAlgorithm">Algorytm wyznaczania wartości skrótu, używane do tworzenia skrótów plików oraz do generowania silnej nazwy.</param>
        <summary>Ładuje zestaw podana nazwa pliku lub ścieżki, dowodów zabezpieczeń, wartość skrótu i algorytm wyznaczania wartości skrótu.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile` Parametru musi odwoływać się do identyfikatora URI bez znaków ucieczki. Ta metoda dostarcza znaki ucieczki dla wszystkie nieprawidłowe znaki w identyfikatorze URI.  
  
> [!NOTE]
>  Protokół transferu plików (FTP) nie jest obsługiwana. Jeśli identyfikator URI podany dla `assemblyFile` jest adresem protokołu FTP nie jest załadowany zestaw. Jest zgłaszany żaden wyjątek.  
  
 `assemblyFile` może być ścieżką bezwzględną lub względną do bieżącego katalogu i zestaw jest ładowany do domeny obiektu wywołującego.  
  
 Zestawy może być załadowany do jednej z trzech kontekstów lub może być załadowany bez kontekstu:  
  
-   Kontekst ładowania zawiera znalezione przez sondowanie zestawów: w pamięci podręcznej GAC, w zestawie hosta przechowywania znajduje się środowisko uruchomieniowe, czy w <xref:System.AppDomainSetup.ApplicationBase%2A> i <xref:System.AppDomainSetup.PrivateBinPath%2A> domeny aplikacji. Większość przeciążenia <xref:System.Reflection.Assembly.Load%2A> metoda Ładuj zestawy w tym kontekście.  
  
-   Kontekst load-from zawiera zestawy, do których użytkownik podał ścieżki nie są objęte katalogi przeszukiwane przez sondowanie. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, i <xref:System.AppDomain.ExecuteAssembly%2A> przedstawiono przykładowe metody, które są ładowane przy użyciu ścieżki.  

    Począwszy od programu .NET Framework 4, jeśli identyfikator URI `assemblyFile` określa lokalizacji zdalnej, z ładowaniem zestawu, jest domyślnie wyłączony, a `LoadFrom` metoda zgłasza wyjątek <xref:System.IO.FileLoadException>. Aby włączyć wykonania kodu załadowanego z lokalizacji zdalnych, można użyć [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) element konfiguracji.    
  
-   Kontekstu reflection-only zawiera zestawy, ładowane z <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> i <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metod; kod w tych kontekstach nie można wykonać.  
  
-   Jeśli użytkownik wygenerowany lub można odnaleźć zestawu, nie jest w jakimkolwiek kontekście. Dotyczy to zestawy, ładowane przy użyciu przeciążeń <xref:System.Reflection.Assembly.Load%2A> metodę, która Określ tablica bajtów zawierająca zestawu i aby przejściowych dynamicznych zestawów utworzonych za pomocą odbicia emisji i nie zapisano na dysku.  
  
 Kontekst load-from umożliwia zestawu do załadowania ze ścieżki nie są uwzględnione w badania, a jeszcze umożliwia zależności na tę ścieżkę, aby znaleźć i załadować, ponieważ informacje o ścieżce jest obsługiwana przez kontekst.  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A> Metoda ma następujące wady. Należy rozważyć użycie <xref:System.Reflection.Assembly.Load%2A> zamiast tego.  
  
-   Jeśli zestaw o tej samej tożsamości jest już załadowany, <xref:System.Reflection.Assembly.LoadFrom%2A> zwraca załadowany zestaw, nawet jeśli określono inną ścieżkę.  
  
-   Jeśli zestaw jest ładowany z <xref:System.Reflection.Assembly.LoadFrom%2A>, a później spróbuje załadować tego samego zestawu według nazwy wyświetlanej zestawu w kontekście ładowania, próba załadowania zakończy się niepowodzeniem. Taka sytuacja może wystąpić, gdy zestaw jest przeprowadzona.  
  
-   Jeśli zestaw jest ładowany z <xref:System.Reflection.Assembly.LoadFrom%2A>, i badania ścieżka zawiera zestaw o tej samej tożsamości, ale inną lokalizację <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, lub inne nieoczekiwane zachowania mogą wystąpić.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> żądania <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> i <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, lub <xref:System.Net.WebPermission>, w określonej ścieżce.  
  
-   Jeśli istnieje obrazu natywnego `assemblyFile`, nie jest używany. Zestawu nie może być ładowane jako niezależne od domeny.  
  
-   W .NET Framework w wersji 1.0 i 1.1 zasady nie są stosowane.  
  
 To, czy określone uprawnienia są przyznane do zestawu, czy nie, zależy od dowodów. Zasady scalania kompilowania asemblera i dowodów zabezpieczeń są następujące:  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.LoadFrom%2A> metody bez <xref:System.Security.Policy.Evidence> parametr, zestaw jest wczytywany wraz z dowodem dostarczonym przez moduł ładujący.  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.LoadFrom%2A> metody z <xref:System.Security.Policy.Evidence> parametru dowody są scalane. Dowody dostarczone jako argument do <xref:System.Reflection.Assembly.LoadFrom%2A> metoda wypierają dowody dostarczone przez moduł ładujący.  
  
-   Jeśli ta metoda jest wywoływana więcej niż jeden raz na tym samym zestawie, ale z inną dowód, określone, środowisko uruchomieniowe języka wspólnego nie zgłasza <xref:System.IO.FileLoadException> ponieważ nie można określić równości i integralności specyfikacji różnych dowodów. Używanym dowodem jest dowód na to, że odniesie się sukces za pierwszym razem.  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.LoadFrom%2A> metody z `Byte[]` parametr do załadowania wspólnej obiektu pliku format (COFF) obrazu, dowody w załączeniu. `Zone`, `Url` i `Site` są dziedziczone z zestawu wywołującego, a `Hash` i `StrongName` są pobierane z zestawu COFF.  
  
-   Kiedy używasz <xref:System.Reflection.Assembly.LoadFrom%2A> metody z `Byte[]` parametru i <xref:System.Security.Policy.Evidence> do załadowania obrazu w formacie COFF, tylko dostarczony dowód jest wykorzystywany. Dowód wywołującego zestawu i dowody obrazu w formacie COFF jest ignorowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> nie zostanie znaleziony, lub moduł, który chcesz załadować nie określa rozszerzenie nazwy pliku.</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.  
  
—lub— 
<paramref name="securityEvidence" /> Nie jest niejednoznaczne i jest określone, jest nieprawidłowy.

—lub—

Możliwość wykonania kodu w zestawach zdalnego jest wyłączona. Zobacz <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element"> &lt;loadfromremotesources —&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem; na przykład 32-bitowy zestaw w procesie 64-bitowym. Zobacz temat wyjątków, aby uzyskać więcej informacji.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.Security.SecurityException">Codebase, która nie rozpoczyna się od "file://" został określony bez wymaganych <see cref="T:System.Net.WebPermission" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> Parametr jest pustym ciągiem ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Nazwa zestawu przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania identyfikatora URI, który rozpoczyna się od "file://". Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadModule">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładuje moduł wewnętrzny do tego zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadModule (moduleName As String, rawModule As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">Nazwa modułu. Ten ciąg musi odpowiadać nazwa pliku, w tym zestawie manifeście.</param>
        <param name="rawModule">Tablica bajtów, która jest obrazem formacie coff, zawierające moduł emitowany lub zasobu.</param>
        <summary>Ładuje moduł wewnętrzny do tego zestawu, za pomocą wspólny format plików obiektu (COFF)-na podstawie obrazu zawierającego emitowany modułu lub plik zasobów.</summary>
        <returns>Załadowanym module.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> lub <paramref name="rawModule" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="moduleName" /> niezgodny wpis w pliku w manifeście tego zestawu.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawModule" /> nie jest prawidłową modułu.</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LoadModule (moduleName As String, rawModule As Byte(), rawSymbolStore As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">Nazwa modułu. Ten ciąg musi odpowiadać nazwa pliku, w tym zestawie manifeście.</param>
        <param name="rawModule">Tablica bajtów, która jest obrazem formacie coff, zawierające moduł emitowany lub zasobu.</param>
        <param name="rawSymbolStore">Tablica bajtów zawierająca bajtów raw, reprezentujący symboli dla modułu. Musi być <see langword="null" /> Jeśli jest to plik zasobów.</param>
        <summary>Ładuje moduł wewnętrzny do tego zestawu, za pomocą wspólny format plików obiektu (COFF)-na podstawie obrazu zawierającego emitowany modułu lub plik zasobów. Bajtów raw, reprezentujący symboli dla modułu, również są ładowane.</summary>
        <returns>Załadowanym module.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> lub <paramref name="rawModule" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="moduleName" /> niezgodny wpis w pliku w manifeście tego zestawu.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawModule" /> nie jest prawidłową modułu.</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadWithPartialName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładuje zestaw z katalogu aplikacji lub z globalnej pamięci podręcznej przy użyciu nazwy częściowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Przeciążenia <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> metody są przestarzałe i został zachowany na potrzeby zgodności z poprzednimi wersjami. Nieprzestarzała alternatywa to <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName partialName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partialName">Wyświetlana nazwa zestawu.</param>
        <summary>Ładuje zestaw z katalogu aplikacji lub z globalnej pamięci podręcznej przy użyciu nazwy częściowej.</summary>
        <returns>Załadowany zestaw. Jeśli <paramref name="partialName" /> nie zostanie znaleziony, Metoda ta zwraca <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29> Metoda jest przestarzała i zostały zachowane dla zgodności z poprzednimi wersjami. Nieprzestarzała alternatywa to <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.  
  
 Aplikacje, które ładować zestawy przy użyciu tej metody wpłynie uaktualnienia tych zestawów. W związku z tym nie należy używać tej metody; zmodyfikowanie aplikacji do korzystania z <xref:System.Reflection.Assembly.Load%28System.String%29> przeciążenie metody lub <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> przeciążenie metody.  
  
 Najpierw wywołuje tę metodę <xref:System.Reflection.Assembly.Load%2A>. Jeśli zestaw nie zostanie znaleziony, ta metoda zwraca zestaw z globalnej pamięci podręcznej, która ma tej samej prostej nazwie i najwyższy numer wersji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partialName" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="partialName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName (partialName, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="partialName">Wyświetlana nazwa zestawu.</param>
        <param name="securityEvidence">Dowód ładowania zestawu.</param>
        <summary>Ładuje zestaw z katalogu aplikacji lub z globalnej pamięci podręcznej przy użyciu nazwy częściowej. Zestaw jest ładowany do domeny przy użyciu dostarczony dowód obiektu wywołującego.</summary>
        <returns>Załadowany zestaw. Jeśli <paramref name="partialName" /> nie zostanie znaleziony, Metoda ta zwraca <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29> Metoda jest przestarzała i zostały zachowane dla zgodności z poprzednimi wersjami. Nieprzestarzała alternatywa to <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.  
  
 Dowód jest zestaw informacji stanowi danych wejściowych do decyzji dotyczących zasad zabezpieczeń, takie jak uprawnienia, jakie może otrzymać kodu.  
  
 Aplikacje, które ładować zestawy przy użyciu tej metody wpłynie uaktualnienia tych zestawów. W związku z tym nie należy używać tej metody; zmodyfikowanie aplikacji do korzystania z <xref:System.Reflection.Assembly.Load%2A> metody lub <xref:System.Reflection.Assembly.LoadFrom%2A> metody.  
  
 Najpierw wywołuje tę metodę <xref:System.Reflection.Assembly.Load%2A>. Jeśli zestaw nie zostanie znaleziony, ta metoda zwraca zestaw z globalnej pamięci podręcznej, która ma tej samej prostej nazwie i najwyższy numer wersji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi zestawami, dowodów.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partialName" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="partialName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">wywoływanie niezarządzanego kodu i ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Location" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Location As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Location { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Location : string" Usage="System.Reflection.Assembly.Location" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Location</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pełną ścieżkę lub lokalizacji UNC załadowanego pliku, który zawiera manifest.</summary>
        <value>Lokalizację załadowanego pliku, który zawiera manifest. Jeśli załadowany plik został skopiowany w tle, lokalizacja jest plik po jego kopiowane w tle. Jeśli zestaw jest ładowany z tablicy bajtowej, takie jak czas za pomocą <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /> przeciążenia metody, wartość zwracana jest pustym ciągiem ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać lokalizację, zanim plik został skopiowany w tle, należy użyć <xref:System.Reflection.Assembly.CodeBase%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład Wyświetla lokalizację załadowanego pliku, który zawiera manifest.  
  
 [!code-cpp[System.Reflection.Assembly#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#3)]
 [!code-csharp[System.Reflection.Assembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#3)]
 [!code-vb[System.Reflection.Assembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Bieżący zestaw jest zestawu dynamicznego, reprezentowane przez <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> obiektu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do ścieżki. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Kopiowanie zestawów w tle</related>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ManifestModule" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ManifestModule As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ ManifestModule { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ManifestModule : System.Reflection.Module" Usage="System.Reflection.Assembly.ManifestModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł, który zawiera manifest dla bieżącego zestawu.</summary>
        <value>Moduł, który zawiera manifest zestawu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleResolve">
      <MemberSignature Language="C#" Value="public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Reflection.ModuleResolveEventHandler ModuleResolve" />
      <MemberSignature Language="DocId" Value="E:System.Reflection.Assembly.ModuleResolve" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Custom Event ModuleResolve As ModuleResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Reflection::ModuleResolveEventHandler ^ ModuleResolve;" />
      <MemberSignature Language="F#" Value="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " Usage="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Runtime.InteropServices._Assembly.ModuleResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ModuleResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy moduł ładujący wspólnego języka środowiska uruchomieniowego klasy nie można rozpoznać odwołania do wewnętrznych modułu zestawu w normalny sposób.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie umożliwia wywołanie zwrotne szansę, aby znaleźć i załadować moduł sam i przywrócić go.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Modules" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Modules As IEnumerable(Of Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ Modules { System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : seq&lt;System.Reflection.Module&gt;" Usage="System.Reflection.Assembly.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję, która zawiera moduły w tym zestawie.</summary>
        <value>Kolekcja, która zawiera moduły w tym zestawie.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">Zestaw do porównania z <c>prawo</c>.</param>
        <param name="right">Zestaw do porównania z <c>po lewej stronie</c>.</param>
        <summary>Wskazuje, czy dwa <see cref="T:System.Reflection.Assembly" /> obiekty są sobie równe.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="System.Reflection.Assembly.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">Zestaw do porównania z <c>prawo</c>.</param>
        <param name="right">Zestaw do porównania z <c>po lewej stronie</c>.</param>
        <summary>Wskazuje, czy dwa <see cref="T:System.Reflection.Assembly" /> obiekty nie są równe.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> nie jest równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.Reflection.Assembly.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zestaw uprawnień w bieżącym zestawie.</summary>
        <value>Zestaw uprawnień w bieżącym zestawie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet> obiekty mogą zawierać poufne informacje, takie jak ścieżki. W związku z tym pełne zaufanie jest wymagany dostęp do tych obiektów.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ReflectionOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReflectionOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ReflectionOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnly : bool" Usage="System.Reflection.Assembly.ReflectionOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Boolean" /> wartość wskazującą, czy ten zestaw został załadowany do kontekstu reflection-only.</summary>
        <value>
          <see langword="true" /> Jeśli zestaw został załadowany do kontekstu reflection-only zamiast kontekstu wykonania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zestaw został załadowany do kontekstu reflection-only, za pomocą <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> metody, nie można wykonać kod w zestawie. Aby wykonać kod, zestaw musi być ładowane do kontekstu wykonywania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReflectionOnlyLoad">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładuje zestaw do kontekstu reflection-only, gdzie można zbadać, ale nie wykonany.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tablica bajtów, która jest obrazem w formacie COFF, zawierającym emitowany zestaw.</param>
        <summary>Ładuje zestaw z wspólny format plików obiektu (COFF)-na podstawie obrazu, zawierającym emitowany zestaw. Zestaw jest ładowany do kontekstu reflection-only domeny aplikacji obiektu wywołującego.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można wykonać kodu z zestawu ładowane do kontekstu reflection-only. Wykonanie kodu, zestaw muszą zostać załadowane do także kontekstu wykonania za pomocą <xref:System.Reflection.Assembly.Load%2A> metody.  
  
 Kontekstu reflection-only nie różni się od innych kontekstach. Zestawy, które są ładowane do kontekstu może zostać zwolniona tylko przez rozładowywania domeny aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="rawAssembly" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="rawAssembly" /> Nie można załadować.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Nazwa wyświetlana zestawu, ponieważ zwróciło <see cref="P:System.Reflection.AssemblyName.FullName" /> właściwości.</param>
        <summary>Ładuje zestaw do kontekstu reflection-only, biorąc pod uwagę jego nazwę wyświetlaną.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zależności nie są automatycznie ładowane do kontekstu reflection-only.  
  
 Nie można wykonać kodu z zestawu ładowane do kontekstu reflection-only. Wykonanie kodu, zestaw muszą zostać załadowane do także kontekstu wykonania za pomocą <xref:System.Reflection.Assembly.Load%2A> metody.  
  
 To, czy określone uprawnienia są przyznane do zestawu, czy nie, zależy od dowodów. Zasady scalania kompilowania asemblera i dowodów zabezpieczeń są następujące:  
  
> [!NOTE]
>  Rozważania na temat plików wykonywalnych skompilowany w języku C++ może zgłosić <xref:System.IO.FileLoadException>. Jest to najprawdopodobniej spowodowane przez kompilatora C++ adresów przeniesienia lub sekcji .reloc z pliku wykonywalnego. Aby zachować adres .reloc, należy określić `/fixed:no` czasu łączenia.  
  
 Kontekstu reflection-only nie różni się od innych kontekstach. Zestawy, które są ładowane do kontekstu może zostać zwolniona tylko przez rozładowywania domeny aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" /> jest pustym ciągiem ("").</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyString" /> został znaleziony, lecz nie może zostać załadowany.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyString" /> został skompilowany przy użyciu nowszej wersji.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Ścieżka pliku, który zawiera manifest zestawu.</param>
        <summary>Ładuje zestawu do kontekstu reflection-only, w podanej ścieżce.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zależności nie są automatycznie ładowane do kontekstu reflection-only. Automatyczne ładowanie zależności, obsługi <xref:System.AppDomain.ReflectionOnlyAssemblyResolve> zdarzeń i obciążenia zależności w obsłudze zdarzeń.  
  
 Nie można uruchomić kod z zestawu, który został załadowany do kontekstu reflection-only. Aby wykonać ten kod, ładowanie zestawu z <xref:System.Reflection.Assembly.LoadFile%2A> metody.  
  
 `assemblyFile` Parametru musi odwoływać się do identyfikatora URI bez znaków ucieczki. Ta metoda dostarcza znaki ucieczki dla wszystkie nieprawidłowe znaki w identyfikatorze URI.  
  
 Ścieżka określona dla `assemblyFile` względem bieżącego katalogu. Zestaw jest ładowany do domeny obiektu wywołującego.  
  
 Kontekstu reflection-only nie różni się od innych kontekstach. Zestawy, które są ładowane do kontekstu może zostać zwolniona tylko przez rozładowywania domeny aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> nie zostanie znaleziony, lub moduł, który chcesz załadować nie określa rozszerzenie nazwy pliku.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyFile" /> zostanie znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana i <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.Security.SecurityException">Codebase, która nie rozpoczyna się od "file://" został określony bez wymaganych <see cref="T:System.Net.WebPermission" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Nazwa zestawu przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> jest pustym ciągiem ("").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania identyfikatora URI, który rozpoczyna się od "file://". Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.SecurityRuleSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SecurityRuleSet As SecurityRuleSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::SecurityRuleSet SecurityRuleSet { System::Security::SecurityRuleSet get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityRuleSet : System.Security.SecurityRuleSet" Usage="System.Reflection.Assembly.SecurityRuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, który zestaw zabezpieczeń reguły środowisko uruchomieniowe języka wspólnego (CLR) wymusza dla tego zestawu.</summary>
        <value>Zestaw reguł zabezpieczeń CLR wymusza dla tego zestawu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie zestawy, które kompilujesz z [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] mają przezroczystości, mimo że jawnie uczynić je w zamian. Zestawy, które zostały skompilowane z wcześniejszymi wersjami programu .NET Framework ma poziom 1 przejrzystości.  
  
 Zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/misc/security-transparent-code.md">Kod o przezroczystym poziomie bezpieczeństwa</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Zmiany zabezpieczeń w programie .NET Framework 4</related>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Assembly.GetType">
      <MemberSignature Language="C#" Value="Type _Assembly.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._Assembly.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _Assembly.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._Assembly.GetType() = System::Runtime::InteropServices::_Assembly::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca typ bieżącego wystąpienia.</summary>
        <returns>Obiekt, który reprezentuje <see cref="T:System.Reflection.Assembly" /> typu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="assembly.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca pełną nazwę zestawu, nazywane również nazwę wyświetlaną.</summary>
        <returns>Pełna nazwa zestawu lub nazwa klasy, jeśli nie można określić pełną nazwę zestawu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly UnsafeLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ UnsafeLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member UnsafeLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.UnsafeLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa lub ścieżka do pliku, który zawiera manifest zestawu.</param>
        <summary>Ładuje zestaw do kontekst load-from, z pominięciem niektóre testy zabezpieczeń.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody można załadować zestawu lokalne, które system operacyjny został oznaczony jako załadowaniu z sieci Web (na przykład tymczasowego pliku, który został pobrany z Internetu lub sieci intranet). Przed [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], takie zestawy były automatycznie ładowany do domeny aplikacji w trybie piaskownicy. Począwszy od [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], są one załadowane z pełnym zaufaniem.  
  
 Jako alternatywa dla użycia tej metody, można zastosować [ &lt;NetFx40_LegacySecurityPolicy&gt; elementu](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md) w pliku konfiguracyjnym aplikacji. Powoduje to, że środowisko uruchomieniowe języka wspólnego przywrócić zasady zabezpieczeń [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
> [!CAUTION]
>  Jeśli używasz jednej z tych rozwiązań, należy się upewnić, bezpiecznego załadować `assemblyFile` z pełnym zaufaniem.  
  
 Omówienie konteksty ładowania, łącznie z kontekstem obciążenia z zobacz <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> przeciążenie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> nie zostanie znaleziony, lub moduł, który chcesz załadować nie określa rozszerzenie nazwy pliku.</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji środowiska uruchomieniowego języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
        <exception cref="T:System.Security.SecurityException">Codebase, która nie rozpoczyna się od "file://" został określony bez wymaganych <see cref="T:System.Net.WebPermission" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> Parametr jest pustym ciągiem ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Nazwa zestawu przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
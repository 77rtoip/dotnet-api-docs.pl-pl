<Type Name="Assembly" FullName="System.Reflection.Assembly">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b227ddef44e3b1f51bb9ce74f6559f8fd0369913" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36640216" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Assembly, System.Runtime.Serialization.ISerializable, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Assembly extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Assembly, class System.Runtime.Serialization.ISerializable, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Assembly" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Assembly&#xA;Implements _Assembly, ICustomAttributeProvider, IEvidenceFactory, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Assembly abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Assembly, System::Runtime::Serialization::ISerializable, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type Assembly = class&#xA;    interface ICustomAttributeProvider&#xA;    interface _Assembly&#xA;    interface IEvidenceFactory&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Assembly</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Assembly))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje zestawu, który jest wielokrotnego użytku, znalezienie i samoopisujące bloku konstrukcyjnego typowych aplikacji środowiska wykonawczego języka.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Reflection.Assembly> klasy można załadować zestawów, aby zapoznać się z części metadanych i składnika zestawy, do odnajdywania typów zawartych w zestawach, a także tworzenie wystąpień tych typów.  
  
 Aby uzyskać tablicę <xref:System.Reflection.Assembly> obiekty obecnie reprezentujący zestawy ładowane do domeny aplikacji (na przykład domyślnej domeny aplikacji prostego projektu), użyj <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> — metoda.  
  
 Ładowanie zestawów dynamicznie, <xref:System.Reflection.Assembly> klasa udostępnia następujące metody statyczne (`Shared` metod w języku Visual Basic). Zestawy są ładowane do domeny aplikacji, w którym występuje operacji ładowania.  
  
-   Jest zalecanym sposobem ładowanie zestawów do użycia <xref:System.AppDomain.Load%2A> metodę, która identyfikuje zestaw ładowany według jego nazwy wyświetlanej (na przykład "System.Windows.Forms, wersja = 2.0.0.0, Culture = neutral, PublicKeyToken = b77a5c561934e089"). Wyszukiwanie zestawu regułom opisanego w [jak zestawy środowiska wykonawczego lokalizuje](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md).  
  
-   <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> i <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metody umożliwiają załadowania zestawu w celu odbicia, ale nie do wykonania. Na przykład zestawu, który jest przeznaczony dla platformy 64-bitowej można zbadać przez kod, który działa na 32-bitowej platformy.  
  
-   <xref:System.Reflection.Assembly.LoadFile%2A> i <xref:System.Reflection.Assembly.LoadFrom%2A> metody są udostępniane dla rzadkich scenariusze, w których zestaw musi zostać zidentyfikowane na podstawie ścieżki.  
  
 Aby uzyskać <xref:System.Reflection.Assembly> obiekt zawierający obecnie wykonywany zestaw, użyj <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> metody.  
  
 Wiele elementów członkowskich z <xref:System.Reflection.Assembly> klasy zawierają informacje o zestawie. Na przykład:  
  
-   <xref:System.Reflection.Assembly.GetName%2A> Metoda zwraca <xref:System.Reflection.AssemblyName> obiekt, który zapewnia dostęp do części nazwy wyświetlanej zestawu.  
  
-   <xref:System.Reflection.Assembly.GetCustomAttributes%2A> Metoda Wyświetla atrybuty stosowane do zestawu.  
  
-   <xref:System.Reflection.Assembly.GetFiles%2A> Metoda zapewnia dostęp do plików w manifeście zestawu.  
  
-   <xref:System.Reflection.Assembly.GetManifestResourceNames%2A> Metoda zapewnia nazw zasobów w manifeście zestawu.  
  
 <xref:System.Reflection.Assembly.GetTypes%2A> Metoda Wyświetla listę wszystkich typów w zestawie. <xref:System.Reflection.Assembly.GetExportedTypes%2A> Metoda Wyświetla listę typów, które są widoczne dla wywołań poza zestaw. <xref:System.Reflection.Assembly.GetType%2A> Metody można użyć do wyszukiwania określonego typu w zestawie. <xref:System.Reflection.Assembly.CreateInstance%2A> Metody można użyć do wyszukiwania i tworzenie wystąpień typów w zestawie.  
  
 Aby uzyskać więcej informacji na zestawy, zobacz sekcję "Domen i zestawów aplikacji" w [domen aplikacji](~/docs/framework/app-domains/application-domains.md) tematu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak uzyskać obecnie wykonywany zestaw, utworzyć wystąpienia typu zawartych w tym zestawie i wywoływanie jednej z metod typu z późnym wiązaniem. W tym celu przykładowy kod definiuje klasę o nazwie `Example`, za pomocą metody o nazwie `SampleMethod`. Konstruktor klasy akceptuje całkowitą, która jest używana do obliczania wartość zwracaną przez metodę.  
  
 Przykład kodu pokazuje również użycie <xref:System.Reflection.Assembly.GetName%2A> metodę, aby uzyskać <xref:System.Reflection.AssemblyName> obiektu, który może służyć do analizy pełną nazwę zestawu. W przykładzie przedstawiono numer wersji zestawu, <xref:System.Reflection.Assembly.CodeBase%2A> właściwości oraz <xref:System.Reflection.Assembly.EntryPoint%2A> właściwości.  
  
 [!code-cpp[AssemblyClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyClass/cpp/source.cpp#1)]
 [!code-csharp[AssemblyClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyClass/cs/source.cs#1)]
 [!code-vb[AssemblyClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyClass/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">aby uzyskać pełne zaufanie dla obiektów dziedziczących. Klasa ta nie może być dziedziczona przez kod częściowo zaufany.</permission>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <altmember cref="T:System.AppDomain" />
    <altmember cref="T:System.Reflection.AssemblyName" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Assembly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Assembly();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Reflection.Assembly" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest wywoływany przez klas pochodnych podczas budowy <xref:System.Reflection.Assembly> obiektów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public virtual string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeBase : string" Usage="System.Reflection.Assembly.CodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.CodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lokalizację zestawu określone pierwotnie, na przykład w <see cref="T:System.Reflection.AssemblyName" /> obiektu.</summary>
        <value>Lokalizacja zestawu pierwotnie określony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać ścieżka bezwzględna do załadowany plik zawierający manifestu, należy użyć <xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType> właściwości zamiast tego.  
  
 Jeśli zestaw został załadowany jako tablicę bajtów, za pomocą przeciążenia <xref:System.Reflection.Assembly.Load%2A> metodę, która pobiera tablicę bajtów, ta właściwość zwraca lokalizacji obiektu wywołującego metody, nie lokalizacji załadowanego zestawu.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Reflection.Assembly.CodeBase%2A> właściwości.  
  
 [!code-cpp[System.Reflection.Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/codebase1.cpp#1)]
 [!code-csharp[System.Reflection.Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/codebase1.cs#1)]
 [!code-vb[System.Reflection.Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/codebase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do ścieżki. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lokalizuje typu z tego zestawu i tworzy wystąpienie klasy przy użyciu aktywatora systemu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string -&gt; obj&#xA;override this.CreateInstance : string -&gt; obj" Usage="assembly.CreateInstance typeName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> Typu do zlokalizowania.</param>
        <summary>Lokalizuje określonego typu z tego zestawu i tworzy wystąpienie klasy przy użyciu aktywatora systemu, z uwzględnieniem wielkości liter w wyszukiwaniu.</summary>
        <returns>Wystąpienia określonego typu utworzone przy użyciu domyślnego konstruktora; lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie znaleziono. Typ został rozwiązany za pomocą domyślnego integratora bez określenia kultury lub aktywacji atrybutów i z <see cref="T:System.Reflection.BindingFlags" /> ustawioną <see langword="Public" /> lub <see langword="Instance" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie można znaleźć środowiska uruchomieniowego `typeName` w <xref:System.Reflection.Assembly> wystąpienie, zwraca `null` zamiast generowania wyjątku. Taka sytuacja może wystąpić, ponieważ:  
  
-   Nie określono w pełni kwalifikowana nazwa typu.  
  
-   Określeniu pełni kwalifikowaną nazwę typu, ale jego case nie jest zgodna w przypadku typu <xref:System.Type.FullName%2A?displayProperty=nameWithType> właściwości. Dla porównania bez uwzględniania wielkości liter `typeName` z pełną nazwą typu, należy wywołać <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> przeciążenia i określ `true` dla `ignoreCase` argumentu.  
  
-   Typ nie istnieje w bieżącym <xref:System.Reflection.Assembly> wystąpienia.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `Person` klasy i wywołania <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> metodę, aby utworzyć.  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance1.cs#1)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> to ciąg pusty ("") lub ciągiem zaczynającym się znakiem null.  - lub - bieżący zestaw został załadowany do kontekstu reflection-only.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> wymaga zestawu zależnego, którego nie można odnaleźć.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> wymaga zestawu zależnego, który został znaleziony, ale nie można go załadować.  - lub - bieżący zestaw został załadowany do kontekstu reflection-only i <paramref name="typeName" /> wymaga zestawu zależnego, który nie jest załadowany.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> wymaga zestawu zależnego, ale plik nie jest prawidłowym zestawem.  - lub - <paramref name="typeName" /> wymaga zestawu zależnego, który został skompilowany dla wersji środowiska uruchomieniowego, która jest nowsza niż wersja aktualnie załadowany.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String, ignoreCase As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool -&gt; obj&#xA;override this.CreateInstance : string * bool -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> Typu do zlokalizowania.</param>
        <param name="ignoreCase">
          <see langword="true" /> ignorowanie wielkości liter nazwy typu; w przeciwnym razie <see langword="false" />.</param>
        <summary>Lokalizuje określonego typu z tego zestawu i tworzy wystąpienie klasy przy użyciu aktywatora systemu opcjonalne wyszukiwanie z uwzględnieniem wielkości liter.</summary>
        <returns>Wystąpienia określonego typu utworzone przy użyciu domyślnego konstruktora; lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie znaleziono. Typ został rozwiązany za pomocą domyślnego integratora bez określenia kultury lub aktywacji atrybutów i z <see cref="T:System.Reflection.BindingFlags" /> ustawioną <see langword="Public" /> lub <see langword="Instance" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie można znaleźć środowiska uruchomieniowego `typeName` w <xref:System.Reflection.Assembly> wystąpienie, zwraca `null` zamiast generowania wyjątku. Taka sytuacja może wystąpić, ponieważ:  
  
-   Nie określono w pełni kwalifikowana nazwa typu.  
  
-   Typ nie istnieje w bieżącym <xref:System.Reflection.Assembly> wystąpienia.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `Person` klasy. Następnie wywołuje <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> metody można utworzyć wystąpienia, ale ponieważ wielkość liter w wyrazie `typeName` argument nie jest zgodna z typem <xref:System.Type.FullName%2A> właściwości, metoda zwraca `null`. Kiedy przykładzie przechodzi do tych samych parametrach <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> przeciążenia i określa, że porównanie powinno być bez uwzględniania wielkości liter, `Person` klasa zostanie znaleziony, a `Person` pomyślnym utworzeniu wystąpienia obiektu.  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance2.cs#2)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> to ciąg pusty ("") lub ciągiem zaczynającym się znakiem null.  - lub - bieżący zestaw został załadowany do kontekstu reflection-only.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> wymaga zestawu zależnego, którego nie można odnaleźć.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> wymaga zestawu zależnego, który został znaleziony, ale nie można go załadować.  - lub - bieżący zestaw został załadowany do kontekstu reflection-only i <paramref name="typeName" /> wymaga zestawu zależnego, który nie jest załadowany.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> wymaga zestawu zależnego, ale plik nie jest prawidłowym zestawem.  - lub - <paramref name="typeName" /> wymaga zestawu zależnego, który został skompilowany dla wersji środowiska uruchomieniowego, która jest nowsza niż wersja aktualnie załadowany.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj&#xA;override this.CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> Typu do zlokalizowania.</param>
        <param name="ignoreCase">
          <see langword="true" /> ignorowanie wielkości liter nazwy typu; w przeciwnym razie <see langword="false" />.</param>
        <param name="bindingAttr">Maska bitów, które ma wpływ na sposób, w której jest przeprowadzane wyszukiwanie. Wartość jest kombinacją flag bitowych z <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="binder">Obiekt, który umożliwia powiązanie koercja argumentu typy wywołania elementów członkowskich i pobieranie <see langword="MemberInfo" /> obiektów za pomocą odbicia. Jeśli <c>integratora</c> jest <see langword="null" />, używany jest domyślny integrator.</param>
        <param name="args">Tablica zawiera argumenty, które mają zostać przekazany do konstruktora. Ta tablica argumentów musi zgodne w polu numer zamówienia i wpisz parametry konstruktora do wywołania. W razie potrzeby konstruktora domyślnego <c>argumentów</c> musi być pustą tablicę lub <see langword="null" />.</param>
        <param name="culture">Wystąpienie <see langword="CultureInfo" /> używane do sterowania koercja typów. Jeśli jest to <see langword="null" />, <see langword="CultureInfo" /> służy bieżącego wątku. (Jest to konieczne przekonwertować <see langword="String" /> reprezentujący 1000 do <see langword="Double" /> wartość, na przykład, ponieważ 1000 jest inaczej reprezentowany przez innych kultur.)</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj tablicę, która zawiera jedną <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Lokalizuje określonego typu z tego zestawu i tworzy wystąpienie przy użyciu aktywatora systemu opcjonalne wyszukiwanie z uwzględnieniem wielkości liter i o określonej kultury, argumentów i atrybuty powiązania i aktywacji.</summary>
        <returns>Wystąpienia określonego typu lub <see langword="null" /> Jeśli <paramref name="typeName" /> nie znaleziono. Podanych argumentów są używane do rozpoznawania typu i powiązać konstruktora, który służy do tworzenia wystąpienia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> to ciąg pusty ("") lub ciągiem zaczynającym się znakiem null.  - lub - bieżący zestaw został załadowany do kontekstu reflection-only.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.NotSupportedException">Tablica atrybutów niepustym aktywacji jest przekazywany do typu, który nie dziedziczy z <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> wymaga zestawu zależnego, którego nie można odnaleźć.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> wymaga zestawu zależnego, który został znaleziony, ale nie można go załadować.  - lub - bieżący zestaw został załadowany do kontekstu reflection-only i <paramref name="typeName" /> wymaga zestawu zależnego, który nie jest załadowany.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> wymaga zestawu zależnego, ale plik nie jest prawidłowym zestawem.  - lub - <paramref name="typeName" /> wymaga zestawu zależnego, które, który został skompilowany dla wersji środowiska uruchomieniowego, która jest nowsza niż wersja aktualnie załadowany.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby utworzyć wystąpienie obiektu delegowanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateQualifiedName">
      <MemberSignature Language="C#" Value="public static string CreateQualifiedName (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateQualifiedName(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateQualifiedName (assemblyName As String, typeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CreateQualifiedName(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateQualifiedName : string * string -&gt; string" Usage="System.Reflection.Assembly.CreateQualifiedName (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa wyświetlana zestawu.</param>
        <param name="typeName">Pełna nazwa typu.</param>
        <summary>Tworzy nazwę typu kwalifikowana przez nazwę wyświetlaną jego zestaw.</summary>
        <returns>Pełna nazwa typu kwalifikowana przez nazwę wyświetlaną zestawu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Format zwrócony ciąg jest:  
  
 \<Właściwości FullTypeName >, \<AssemblyDisplayName >  
  
 Zobacz <xref:System.Reflection.AssemblyName> opis format nazwy wyświetlanej zestawu.  
  
 Aby uwzględnić zmiany w wersji środowiska CLR, użyj tej metody zamiast konstruowania kwalifikowaną nazwę użytkownika.  Aby uzyskać informacje o nazwy kwalifikowanej zestawu, zobacz <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CustomAttributes : seq&lt;System.Reflection.CustomAttributeData&gt;" Usage="System.Reflection.Assembly.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję zawierającą ten zestaw atrybutów niestandardowych.</summary>
        <value>Kolekcja, która zawiera ten zestaw atrybutów niestandardowych.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.DefinedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefinedTypes As IEnumerable(Of TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ DefinedTypes { System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefinedTypes : seq&lt;System.Reflection.TypeInfo&gt;" Usage="System.Reflection.Assembly.DefinedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję typów zdefiniowanych w tym zestawie.</summary>
        <value>Kolekcja typów zdefiniowanych w tym zestawie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.DefinedTypes%2A> Właściwości jest porównywalna <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> metody, z wyjątkiem <xref:System.Reflection.Assembly.DefinedTypes%2A> właściwość zwraca kolekcję <xref:System.Reflection.TypeInfo> obiekty i <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> metoda zwraca tablicę <xref:System.Type> obiektów.  
  
 Zwracana tablica zawiera zagnieżdżone typy.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Assembly.GetTypes" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntryPoint As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ EntryPoint { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EntryPoint : System.Reflection.MethodInfo" Usage="System.Reflection.Assembly.EntryPoint" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EntryPoint</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera punkt wejścia tego zestawu.</summary>
        <value>Obiekt, który reprezentuje punkt wejścia tego zestawu. Jeśli zostanie znaleziony żaden punkt wejścia (na przykład zestawu jest biblioteki DLL), <see langword="null" /> jest zwracany.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="assembly.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Obiekt, który ma zostać porównany z tym wystąpieniem.</param>
        <summary>Określa, czy ten zestaw i określonego obiektu są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="o" /> jest taki sam, jak to wystąpienie w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.Equals%2A> Metoda wykonuje test równości odwołań określić, czy bieżące wystąpienie i `o` są takie same.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public virtual string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EscapedCodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EscapedCodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EscapedCodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EscapedCodeBase : string" Usage="System.Reflection.Assembly.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EscapedCodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator URI, znaki specjalne w tym reprezentujący bazowej kodu.</summary>
        <value>Identyfikator URI z znaki specjalne.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do ścieżki. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.Reflection.Assembly.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Evidence</InterfaceMember>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dowody dla tego zestawu.</summary>
        <value>Dowody dla tego zestawu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dowód jest zbiorem informacji, który stanowi do decyzji dotyczących zasad zabezpieczeń, takich jak uprawnienia wejściowy może zostać przydzielony do kodu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExportedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; ExportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; ExportedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ExportedTypes As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ ExportedTypes { System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExportedTypes : seq&lt;Type&gt;" Usage="System.Reflection.Assembly.ExportedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję typy publiczne zdefiniowane w tym zestawie, które są widoczne poza zestaw.</summary>
        <value>Kolekcja typy publiczne zdefiniowane w tym zestawie, które są widoczne poza zestaw.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.Assembly.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę wyświetlaną zestawu.</summary>
        <value>Wyświetlana nazwa zestawu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zobacz <xref:System.Reflection.AssemblyName> opis format nazwy wyświetlanej zestawu.  
  
> [!NOTE]
>  Pisanie kodu można przeanalizować nazwy wyświetlane nie jest zalecane. Zamiast tego należy przekazać nazwę wyświetlaną na <xref:System.Reflection.AssemblyName.%23ctor%2A> konstruktora, który go analizuje i wypełnienie odpowiednich pól nowej <xref:System.Reflection.AssemblyName>.  
  
 W wersji 2.0 środowiska .NET Framework architektura procesora jest dodawana do tożsamości zestawu i może być określona jako część zestawu ciągu nazw. Jednak nie jest uwzględnione w ciągu zwróconego przez <xref:System.Reflection.Assembly.FullName%2A> właściwości ze względu na zgodność. Zobacz <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład pobiera nazwę wyświetlaną aktualnie wykonywane zestawu i nazwa wyświetlana zestawu, który zawiera <xref:System.Int32> typu (`int` w języku C# `Integer` w języku Visual Basic).  
  
 [!code-cpp[Assembly.FullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.FullName/CPP/Example.cpp#1)]
 [!code-csharp[Assembly.FullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.FullName/CS/Example.cs#1)]
 [!code-vb[Assembly.FullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.FullName/VB/Example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetAssembly (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetAssembly(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetAssembly(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetAssembly : Type -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetAssembly type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Obiekt reprezentujący typ w zestawie, który zostanie zwrócony.</param>
        <summary>Pobiera obecnie załadowanych zestawu, w którym jest zdefiniowany określonego typu.</summary>
        <returns>Zestaw, w którym jest zdefiniowany określonego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody jest odpowiednikiem pobierania wartości <xref:System.Type.Assembly?displayProperty=nameWithType> właściwości. Jednak <xref:System.Type.Assembly?displayProperty=nameWithType> właściwości zwykle zapewnia lepszą wydajność.  
  
 Aby wywołać tę metodę, należy skonfigurować <xref:System.Type> obiektu, co oznacza, że zestaw, w którym zdefiniowana jest klasa musi już być załadowany.  
  
   
  
## Examples  
 Poniższy przykład pobiera zestawu, który zawiera <xref:System.Int32> wpisz i wyświetla jego nazwy i lokalizacji pliku.  
  
 [!code-cpp[System.Reflection.Assembly#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/GetAssembly1.cpp#12)]
 [!code-csharp[System.Reflection.Assembly#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/GetAssembly1.cs#12)]
 [!code-vb[System.Reflection.Assembly#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/GetAssembly1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCallingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCallingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCallingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCallingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCallingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCallingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetCallingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetCallingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Reflection.Assembly" /> metody, który wywołał metodę aktualnie wykonywane.</summary>
        <returns>
          <see langword="Assembly" /> Obiektu metody, który wywołał metodę aktualnie wykonywane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli metoda wywołującym <xref:System.Reflection.Assembly.GetCallingAssembly%2A> — metoda jest rozwinięty tekście przez kompilator just-in-time (JIT), lub jeśli swojego obiektu wywołującego jest wbudowany rozwinięte, zestaw zwrócony przez <xref:System.Reflection.Assembly.GetCallingAssembly%2A> może różnić się nieoczekiwanie. Rozważmy na przykład następujących metod i zestawów:  
  
-   Metoda `M1` w zestawie `A1` wywołania <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.  
  
-   Metoda `M2` w zestawie `A2` wywołania `M1`.  
  
-   Metoda `M3` w zestawie `A3` wywołania `M2`.  
  
 Gdy `M1` nie jest wbudowane, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> zwraca `A2`. Gdy `M1` jest wbudowane, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> zwraca `A3`. Podobnie, jeśli `M2` nie jest wbudowane, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> zwraca `A2`. Gdy `M2` jest wbudowane, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> zwraca `A3`.  
  
 Występuje także w tym celu po `M1` wykonuje jako wywołania tail `M2`, lub gdy `M2` wykonuje jako wywołania tail `M3`. Można wyłączyć przy użyciu kompilatora JIT od ze śródwierszowaniem metodę, która wywołuje <xref:System.Reflection.Assembly.GetCallingAssembly%2A>, stosując <xref:System.Runtime.CompilerServices.MethodImplAttribute> atrybutem <xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType> flagę, ale nie istnieje podobny mechanizm zapobiegania wywołania tail.  
  
   
  
## Examples  
 Poniższy przykład pobiera wywołującego zestawu bieżącej metody.  
  
 [!code-cpp[System.Reflection.Assembly#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/getcallingassembly1.cpp#4)]
 [!code-csharp[System.Reflection.Assembly#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/getcallingassembly1.cs#4)]
 [!code-vb[System.Reflection.Assembly#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/getcallingassembly1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera atrybuty niestandardowe dla tego zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : bool -&gt; obj[]&#xA;override this.GetCustomAttributes : bool -&gt; obj[]" Usage="assembly.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">Ten argument jest ignorowany dla obiektów typu <see cref="T:System.Reflection.Assembly" />.</param>
        <summary>Pobiera atrybuty niestandardowe dla tego zestawu.</summary>
        <returns>Tablica, która zawiera atrybuty niestandardowe dla tego zestawu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda implementuje odpowiadającego <xref:System.Reflection.ICustomAttributeProvider> metody interfejsu. W związku z tym `inherit` musi zostać określony parametr, nawet jeśli zostanie zignorowany.  
  
 Pseudo-atrybut wskazuje bits musi być ustawiona, gdy obecny jest atrybut metadane core. W odróżnieniu od atrybutu niestandardowego rozszerza metadanych dla typu, który zostanie zapisany wraz z typem pseudo-atrybutu modyfikuje metadanych dla typu, a następnie jest odrzucany. Niektóre wynikowy usługi bits nie jest dostępny za pomocą odbicia istniejących interfejsów API.  
  
 W poniższej tabeli przedstawiono różne pseudo-atrybuty i metody dostępu dla usługi bits, które są dostępne w odbicia.  
  
|Pseudo-atrybutu|Metadane usługi Bits|Metoda dostępu odbicia|  
|-----------------------|-------------------|-------------------------|  
|Elementu DllImportAttribute|CorPInvokeMap<br /><br /> Nazwa biblioteki DLL|Nie dostępu dla PInvokeMap dla zwykłej metody/globalne atrybuty metody.<br /><br /> Nie metody dostępu dla nazwy biblioteki DLL.|  
|GuidAttribute|Przechowywane jako atrybut niestandardowy rzeczywistym.|Dostępne jako atrybut niestandardowy rzeczywistym.|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|Różne usługi bits.|Brak akcesora.|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags().OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags().OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|Structlayoutattribute —|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> Klasa pakowania.|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> Brak akcesora.|  
|FieldOffsetAttribute|Przesunięcie pola.|Brak akcesora.|  
|AssemblyLoadAttribute|CorAssemblyFlags|Brak metody dostępu i modułu wyliczającego.|  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : Type * bool -&gt; obj[]&#xA;override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="assembly.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Typ, dla którego mają zostać zwrócone atrybutów niestandardowych.</param>
        <param name="inherit">Ten argument jest ignorowany dla obiektów typu <see cref="T:System.Reflection.Assembly" />.</param>
        <summary>Pobiera atrybuty niestandardowe dla tego zestawu jako określonego typu.</summary>
        <returns>Tablica zawierająca atrybuty niestandardowe dla tego zestawu określoną przez <paramref name="attributeType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda implementuje odpowiadającego <xref:System.Reflection.ICustomAttributeProvider> metody interfejsu. W związku z tym `inherit` musi zostać określony parametr, nawet jeśli zostanie zignorowany.  
  
 Pseudo-atrybut wskazuje bits musi być ustawiona, gdy obecny jest atrybut metadane core. W odróżnieniu od atrybutu niestandardowego rozszerza metadanych dla typu, który zostanie zapisany wraz z typem pseudo-atrybutu modyfikuje metadanych dla typu, a następnie jest odrzucany. Niektóre wynikowy usługi bits nie jest dostępny za pomocą odbicia istniejących interfejsów API.  
  
 W poniższej tabeli przedstawiono różne pseudo-atrybuty i metody dostępu dla usługi bits, które są dostępne w odbicia.  
  
|Pseudo-atrybutu|Metadane usługi Bits|Metoda dostępu odbicia|  
|-----------------------|-------------------|-------------------------|  
|Elementu DllImportAttribute|CorPInvokeMap<br /><br /> Nazwa biblioteki DLL|Nie dostępu dla PInvokeMap dla zwykłej metody/globalne atrybuty metody.<br /><br /> Nie metody dostępu dla nazwy biblioteki DLL.|  
|GuidAttribute|Przechowywane jako atrybut niestandardowy rzeczywistym.|Dostępne jako atrybut niestandardowy rzeczywistym.|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|Różne usługi bits.|Brak akcesora.|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags().OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags().OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|Structlayoutattribute —|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> Klasa pakowania.|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> Brak akcesora.|  
|FieldOffsetAttribute|Przesunięcie pola.|Brak akcesora.|  
|AssemblyLoadAttribute|CorAssemblyFlags|Brak metody dostępu i modułu wyliczającego.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> nie jest typem środowiska wykonawczego.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;&#xA;override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="assembly.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca informacje o atrybutach, które zostały zastosowane do bieżącego <see cref="T:System.Reflection.Assembly" />, wyrażone jako <see cref="T:System.Reflection.CustomAttributeData" /> obiektów.</summary>
        <returns>Ogólny listę <see cref="T:System.Reflection.CustomAttributeData" /> obiekty reprezentujące dane dotyczące atrybutów, które zostały zastosowane do bieżącego zestawu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody do sprawdzenia kod w kontekście tylko odbicie w przypadkach, gdzie same atrybuty niestandardowe są zdefiniowane w kodzie, który jest ładowany do kontekstu reflection-only atrybutów niestandardowych. Metod, takich jak <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> i <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> nie można użyć w takich przypadkach, ponieważ tworzenia wystąpień atrybutów. Nie można wykonać kodu w kontekstu reflection-only. Aby uzyskać więcej informacji i na przykład kod, zobacz <xref:System.Reflection.CustomAttributeData> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetEntryAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetEntryAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEntryAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetEntryAssembly();" />
      <MemberSignature Language="F#" Value="static member GetEntryAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetEntryAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera pliku wykonywalnego procesu w domyślnej domeny aplikacji. W innych domenach aplikacji jest to pierwszy plik wykonywalny, który została wykonana przez <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</summary>
        <returns>Zestaw, który jest pliku wykonywalnego procesu w domyślnej domeny aplikacji lub pierwszy plik wykonywalny, który została wykonana przez <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />. Może zwrócić <see langword="null" /> przy wywołaniach z kodem niezarządzanym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> Metoda może zwracać `null` po zarządzany zestaw został załadowany z niezarządzanych aplikacji. Na przykład, jeśli Niezarządzana aplikacja tworzy wystąpienie napisane w języku C#, wywołanie składnika modelu COM <xref:System.Reflection.Assembly.GetEntryAssembly%2A> metoda ze składnika C# zwraca wartość null, powodu kodu niezarządzanego, a nie zestaw zarządzany punkt wejścia dla procesu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExecutingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetExecutingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetExecutingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExecutingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExecutingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetExecutingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetExecutingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetExecutingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera zestaw, który zawiera kod, który jest aktualnie wykonywany.</summary>
        <returns>Zestaw, który zawiera kod, który jest aktualnie wykonywany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ze względu na wydajność należy wywołać tej metody tylko wtedy, gdy nie wiadomo, w czasie projektowania, jakie zestawu jest aktualnie wykonywany. Zalecanym sposobem pobrania <xref:System.Reflection.Assembly> obiekt, który reprezentuje bieżący zestaw jest użycie <xref:System.Type.Assembly%2A?displayProperty=nameWithType> właściwości typu znaleziono w zestawie, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/assembly1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/assembly1.vb#1)]  
  
 Aby uzyskać zestaw, który zawiera metodę o nazwie aktualnie wykonywanego kodu, należy użyć <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Type.Assembly%2A?displayProperty=nameWithType> właściwości do pobrania obecnie wykonywany zestaw na podstawie typu zawartych w tym zestawie. Wywołuje również <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> metodę, aby pokazać, że zwraca <xref:System.Reflection.Assembly> obiekt, który reprezentuje tego samego zestawu.  
  
 [!code-cpp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cpp/getexecutingassembly1.cpp#5)]
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/getexecutingassembly1.cs#5)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/getexecutingassembly1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetExportedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetExportedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetExportedTypes : unit -&gt; Type[]&#xA;override this.GetExportedTypes : unit -&gt; Type[]" Usage="assembly.GetExportedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetExportedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera typy publiczne zdefiniowane w tym zestawie, które są widoczne poza zestaw.</summary>
        <returns>Tablica, która reprezentuje typy zdefiniowane w tym zestawie, które są widoczne poza zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tylko typy widoczny spoza zestawu są typy publiczne i typy publiczne zagnieżdżone w innych typów publicznych.  
  
   
  
## Examples  
 Poniższy przykładowy kod definiuje liczbę klas z różnymi poziomami dostępu i połączeń <xref:System.Reflection.Assembly.GetExportedTypes%2A> Aby wyświetlić te, które są widoczne na poza zestaw.  
  
 [!code-cpp[Assembly.GetExportedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.GetExportedTypes/CPP/source.cpp#1)]
 [!code-csharp[Assembly.GetExportedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.GetExportedTypes/CS/source.cs#1)]
 [!code-vb[Assembly.GetExportedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.GetExportedTypes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Zestaw jest zestawie dynamicznym.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można załadować zestawu zależnego.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFile (name As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::FileStream ^ GetFile(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetFile : string -&gt; System.IO.FileStream&#xA;override this.GetFile : string -&gt; System.IO.FileStream" Usage="assembly.GetFile name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFile(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa określonego pliku. Nie dołączaj ścieżkę do pliku.</param>
        <summary>Pobiera <see cref="T:System.IO.FileStream" /> określonego pliku w tabeli pliku manifestu tego zestawu.</summary>
        <returns>Strumień, który zawiera określony plik lub <see langword="null" /> Jeśli plik nie został znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda działa na obu pliki publicznego i prywatnego zasobów.  
  
 `name` Nie może zawierać ścieżkę do pliku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> Parametr jest pustym ciągiem ("").</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> Nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> nie jest prawidłowym zestawem.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do ścieżki i do odczytu określonego pliku. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera pliki w tabeli plików manifestu zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles () As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : unit -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : unit -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera pliki w tabeli plików manifestu zestawu.</summary>
        <returns>Tablica strumieni, które zawierają pliki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda działa na plikach zasobów publicznych i prywatnych.  
  
 To przeciążenie jest odpowiednikiem wywołania <xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29> przeciążenia i określając `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku.</exception>
        <exception cref="T:System.BadImageFormatException">Plik nie jest prawidłowym zestawem.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles (getResourceModules As Boolean) As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : bool -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : bool -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <see langword="true" /> Aby uwzględnić modułów zasobów; w przeciwnym razie <see langword="false" />.</param>
        <summary>Pobiera pliki w tabeli plików manifestu zestawu, określając, czy dołączać moduły zasobów.</summary>
        <returns>Tablica strumieni, które zawierają pliki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda działa na plikach zasobów publicznych i prywatnych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku.</exception>
        <exception cref="T:System.BadImageFormatException">Plik nie jest prawidłowym zestawem.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetForwardedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetForwardedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetForwardedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetForwardedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetForwardedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetForwardedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetForwardedTypes : unit -&gt; Type[]&#xA;override this.GetForwardedTypes : unit -&gt; Type[]" Usage="assembly.GetForwardedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="assembly.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla tego wystąpienia.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLoadedModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wszystkie moduły załadowane, które należą do tego zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLoadedModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules();" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wszystkie moduły załadowane, które należą do tego zestawu.</summary>
        <returns>Tablica modułów.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLoadedModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <see langword="true" /> Aby uwzględnić modułów zasobów; w przeciwnym razie <see langword="false" />.</param>
        <summary>Pobiera wszystkie moduły załadowane wchodzących w skład tego zestawu, określając, czy dołączać moduły zasobów.</summary>
        <returns>Tablica modułów.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceInfo (resourceName As String) As ManifestResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ManifestResourceInfo ^ GetManifestResourceInfo(System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo&#xA;override this.GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo" Usage="assembly.GetManifestResourceInfo resourceName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceInfo(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName">Uwzględniana wielkość liter nazwy zasobu.</param>
        <summary>Zwraca informacje o sposobie utrwaleniu danego zasobu.</summary>
        <returns>Obiekt, który jest wypełniane przy użyciu informacji o topologii zasobu lub <see langword="null" /> Jeśli zasób nie zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informacje o zasobie, jest zwracana tylko wtedy, gdy zasób jest widoczny dla obiekt wywołujący lub obiektu wywołującego <xref:System.Security.Permissions.ReflectionPermission>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceName" /> Parametr jest pustym ciągiem ("").</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetManifestResourceNames();" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceNames : unit -&gt; string[]&#xA;override this.GetManifestResourceNames : unit -&gt; string[]" Usage="assembly.GetManifestResourceNames " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceNames</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca nazwy wszystkich zasobów w tym zestawie.</summary>
        <returns>Tablica zawierająca nazwy wszystkich zasobów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć nazwy zasobu w tablicy zwracanej przez tę metodę w następujący sposób:  
  
-   Można przekazać nazwę zasobu, aby <xref:System.Reflection.Assembly.GetManifestResourceInfo%2A> metody, aby uzyskać dodatkowe informacje o zasobie.  
  
-   Jeśli nazwa określa plik binarny .resources, możesz usunąć rozszerzenie pliku .resources i przekaż go do <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType> Konstruktor do tworzenia wystąpienia menedżera zasobów.  
  
-   Można przekazać nazwę zasobu, aby <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> metoda pobierania <xref:System.IO.Stream> obiekt, który można następnie przekazać do <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> konstruktora.  
  
-   Można przekazać nazwę zasobu, aby <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> metoda pobierania <xref:System.IO.Stream> obiekt, który można następnie przekazać do <xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> konstruktora.  
  
 Informacje o zasobie, jest zwracana tylko wtedy, gdy zasób jest widoczny dla obiekt wywołujący lub obiektu wywołującego <xref:System.Security.Permissions.ReflectionPermission>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetManifestResourceStream">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładuje określony zasób manifestu z tego zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceStream (name As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Z uwzględnieniem wielkości liter nazwy zasobu manifestu żądanej.</param>
        <summary>Ładuje określony zasób manifestu z tego zestawu.</summary>
        <returns>Zasób manifestu; lub <see langword="null" /> podczas kompilacji nie określono żadnych zasobów lub zasobu nie jest widoczny dla obiekt wywołujący.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zasób manifestu jest zasobu (np. plik obrazu), który jest osadzony w zestawie w czasie kompilacji. Aby uzyskać więcej informacji o zasobach manifestu, zobacz [podstawowe informacje dotyczące programu Microsoft .NET Framework zasobów](http://go.microsoft.com/fwlink/?LinkId=204554) w bibliotece MSDN.  
  
 Informacje o zasobie, jest zwracana tylko wtedy, gdy zasób jest widoczny dla obiekt wywołujący lub obiektu wywołującego <xref:System.Security.Permissions.ReflectionPermission>.  
  
> [!NOTE]
>  Ta metoda zwraca `null` dostępu do prywatnego zasobu w innym zestawie, jeśli element wywołujący nie ma <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flagi.  
  
 Jeśli plik zasobów zawiera manifest zestawu <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> zwraca <xref:System.IO.Stream> obiekt nawet wtedy, gdy plik zasobu nie może zostać znaleziony na dysku w czasie. Jeśli plik zasobu nie zostanie znaleziony, przekazywanie powstałe w ten sposób <xref:System.IO.Stream> do obiektu <xref:System.Resources.ResourceReader> przyczyny konstruktora <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> Parametr jest pustym ciągiem ("").</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para> [.NET dla aplikacji ze Sklepu Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośne Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) klasy, catch wyjątku klasy podstawowej <see cref="T:System.IO.IOException" />, zamiast tego.  </para>
          </block>  Nie można załadować pliku, który został znaleziony.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> Nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> nie jest prawidłowym zestawem.</exception>
        <exception cref="T:System.NotImplementedException">Zasób długość jest większa niż <see cref="F:System.Int64.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : Type * string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : Type * string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream (type, name)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ, w których przestrzeń nazw jest używana do określania zakresu nazwy zasobu manifestu.</param>
        <param name="name">Z uwzględnieniem wielkości liter nazwy zasobu manifestu żądanej.</param>
        <summary>Ładuje określony zasób manifestu, ograniczone w zależności od przestrzeni nazw określonego typu z tego zestawu.</summary>
        <returns>Zasób manifestu; lub <see langword="null" /> podczas kompilacji nie określono żadnych zasobów lub zasobu nie jest widoczny dla obiekt wywołujący.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład, jeśli Pełna nazwa określona dla `type` jest "MyNameSpace.MyClasses" i `name` jest "Net", ta metoda przeciążenia wyszukuje zasób o nazwie "MyNameSpace.Net".  
  
 Zasób manifestu jest zasobu (np. plik obrazu), który jest osadzony w zestawie w czasie kompilacji. Aby uzyskać więcej informacji o zasobach manifestu, zobacz [podstawowe informacje dotyczące programu Microsoft .NET Framework zasobów](http://go.microsoft.com/fwlink/?LinkId=204554) w bibliotece MSDN.  
  
 Informacje o zasobie, jest zwracana tylko wtedy, gdy zasób jest widoczny dla obiekt wywołujący lub obiektu wywołującego <xref:System.Security.Permissions.ReflectionPermission>.  
  
> [!NOTE]
>  Ta metoda zwraca `null` dostępu do prywatnego zasobu w innym zestawie, jeśli element wywołujący nie ma <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flagi.  
  
 Jeśli plik zasobów zawiera manifest zestawu <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> zwraca <xref:System.IO.Stream> obiekt nawet wtedy, gdy plik zasobu nie może zostać znaleziony na dysku w czasie. Jeśli plik zasobu nie zostanie znaleziony, przekazywanie powstałe w ten sposób <xref:System.IO.Stream> do obiektu <xref:System.Resources.ResourceReader> przyczyny konstruktora <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> Parametr jest pustym ciągiem ("").</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> Nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> nie jest prawidłowym zestawem.</exception>
        <exception cref="T:System.NotImplementedException">Zasób długość jest większa niż <see cref="F:System.Int64.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnym wiązaniem za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModule(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModule (name As String) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ GetModule(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetModule : string -&gt; System.Reflection.Module&#xA;override this.GetModule : string -&gt; System.Reflection.Module" Usage="assembly.GetModule name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModule(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa modułu żądanej.</param>
        <summary>Pobiera określony moduł, w tym zestawie.</summary>
        <returns>Moduł żądanej, lub <see langword="null" /> Jeśli moduł nie zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda działa w nazwach plików.  
  
 Klasy w `Reflection.Emit` przestrzeni nazw Emituj nazwę zakresu module dynamicznym. Nazwa zakresu można ustalić przy <xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType> właściwości. Rodzaj modułu chcesz przekazać `Assembly.GetModule`. Na przykład, jeśli chcesz, aby moduł, który zawiera manifest zestawu, przekazywania zakresu nazwy modułu do `GetModule`. W przeciwnym razie Podaj nazwę pliku modułu. Zestawy ładowane przez jedną z `Load` metody, które ma parametr typu byte [] mają tylko jeden moduł i jest moduł manifestu. Zawsze wyszukiwać tych modułów przy użyciu nazwy zakresu.  
  
 Typ może zostać pobrany z określonego modułu przy użyciu <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>. Wywoływanie `Module.GetType` moduł zawierający manifest nie będzie inicjował wyszukiwania całego zestawu. Aby pobrać typu z zestawu, niezależnie od tego, który moduł jest, należy wywołać <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> Parametr jest pustym ciągiem ("").</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> Nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> nie jest prawidłowym zestawem.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wszystkie moduły, które są częścią tego zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules();" />
      <MemberSignature Language="F#" Value="abstract member GetModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wszystkie moduły, które są częścią tego zestawu.</summary>
        <returns>Tablica modułów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda działa na plikach zasobów publicznych i prywatnych.  
  
> [!NOTE]
>  Moduły muszą wysyłanego z rozszerzeń nazw plików.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono Nazwa modułu w zwrócony tablicy, która zawiera manifest zestawu.  
  
 [!code-cpp[Classic Assembly.GetModules Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Assembly.GetModules Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CS/source.cs#1)]
 [!code-vb[Classic Assembly.GetModules Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Moduł do załadowania nie określa rozszerzenie nazwy pliku.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <see langword="true" /> Aby uwzględnić modułów zasobów; w przeciwnym razie <see langword="false" />.</param>
        <summary>Pobiera wszystkie moduły, które są częścią tego zestawu, określając, czy dołączać moduły zasobów.</summary>
        <returns>Tablica modułów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda działa na plikach zasobów publicznych i prywatnych.  
  
> [!NOTE]
>  Moduły muszą wysyłanego z rozszerzeń nazw plików.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetName">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera <see cref="T:System.Reflection.AssemblyName" /> dla tego zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName () As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName();" />
      <MemberSignature Language="F#" Value="abstract member GetName : unit -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : unit -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.Reflection.AssemblyName" /> dla tego zestawu.</summary>
        <returns>Obiekt, który zawiera nazwę wyświetlaną pełni przeanalizowany dla tego zestawu.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do ścieżki zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName (copiedName As Boolean) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName(bool copiedName);" />
      <MemberSignature Language="F#" Value="abstract member GetName : bool -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : bool -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName copiedName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="copiedName">
          <see langword="true" /> Aby ustawić <see cref="P:System.Reflection.Assembly.CodeBase" /> do lokalizacji zestawu po jego tle; <see langword="false" /> można ustawić <see cref="P:System.Reflection.Assembly.CodeBase" /> do oryginalnej lokalizacji.</param>
        <summary>Pobiera <see cref="T:System.Reflection.AssemblyName" /> dla tego zestawu określoną przez ustawienie codebase <paramref name="copiedName" />.</summary>
        <returns>Obiekt, który zawiera nazwę wyświetlaną pełni przeanalizowany dla tego zestawu.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do ścieżki zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="assembly.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Obiekt wypełniana informacje o serializacji.</param>
        <param name="context">Kontekst docelowy serializacji.</param>
        <summary>Pobiera informacje o serializacji wszystkie dane potrzebne do reinstantiate tego zestawu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReferencedAssemblies () As AssemblyName()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::AssemblyName ^&gt; ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]&#xA;override this.GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]" Usage="assembly.GetReferencedAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetReferencedAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.Reflection.AssemblyName" /> obiektów dla wszystkich zestawów odwołuje się ten zestaw.</summary>
        <returns>Tablica zawiera nazwy wyświetlane pełni przeanalizowane wszystkie zestawy odwołuje się ten zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> właściwość <xref:System.Reflection.AssemblyName> obiekt, który jest zwracany przez tę metodę jest <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> przypadku nie algorytmu wyznaczania wartości skrótu dla przywoływanego zestawu lub jeśli nie jest algorytm wyznaczania wartości skrótu przywoływanego zestawu identyfikowane przez <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> wyliczenia. W poprzednich wersjach programu .NET Framework <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> właściwości zwróconej <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType> w takiej sytuacji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wywołanie <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> metody. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Reflection.Assembly> klasy.  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSatelliteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera zestawu satelickiego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSatelliteAssembly (culture As CultureInfo) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly culture" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Określona kultura.</param>
        <summary>Pobiera zestawu satelickiego dla określonej kultury.</summary>
        <returns>Zestawu satelickiego określony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestawy satelickie zawiera zlokalizowane zasoby, w odróżnieniu od aplikacji głównej zestawy, które zawierają kod wykonywalny niemożliwe do zlokalizowania i zasobów dla kultury pojedynczego służące jako domyślne lub kultury neutralnej.  
  
 Wywołaj tę metodę, aby użyć bieżącej wersji zestawu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć zestawu.</exception>
        <exception cref="T:System.IO.FileLoadException">Znaleziono zestaw satelicki z pasująca nazwa pliku, ale <see langword="CultureInfo" /> określony jest niezgodny.</exception>
        <exception cref="T:System.BadImageFormatException">Zestawu satelickiego nie jest prawidłowym zestawem.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture, Version ^ version);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly (culture, version)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <param name="culture">Określona kultura.</param>
        <param name="version">Wersja zestawu satelickiego.</param>
        <summary>Pobiera określoną wersję z zestawu satelickiego dla określonej kultury.</summary>
        <returns>Zestawu satelickiego określony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestawy satelickie zawiera zlokalizowane zasoby, w odróżnieniu od aplikacji głównej zestawy, które zawierają kod wykonywalny niemożliwe do zlokalizowania i zasobów dla kultury pojedynczego służące jako domyślne lub kultury neutralnej.  
  
 Wywołanie <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> przeciążenia, aby użyć bieżącej wersji zestawu.  
  
 Jeśli `version` jest `null`, bieżąca wersja zestawu jest używana, gdy zasób oraz zestawy główne są podpisane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileLoadException">Znaleziono zestaw satelicki z pasująca nazwa pliku, ale <see langword="CultureInfo" /> lub wersji jest niezgodny z określony.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć zestawu.</exception>
        <exception cref="T:System.BadImageFormatException">Zestawu satelickiego nie jest prawidłowym zestawem.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera <see cref="T:System.Type" /> obiekt, który reprezentuje określonego typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="assembly.GetType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Pełna nazwa typu.</param>
        <summary>Pobiera <see cref="T:System.Type" /> obiektu o określonej nazwie w wystąpieniu zestawu.</summary>
        <returns>Obiekt reprezentujący określonej klasy lub <see langword="null" /> Jeśli klasa nie zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wyszukuje tylko bieżące wystąpienie zestawu. `name` Parametr zawiera przestrzeń nazw, ale nie zestawu. Aby wyszukać innych zestawów dla typu, należy użyć <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> przeciążenie metody, które można opcjonalnie dołączyć nazwy wyświetlanej zestawu jako część nazwy typu.  
  
> [!NOTE]
>  Jeśli typ został przesłany dalej do innego zestawu, nadal jest zwracana przez tę metodę. Aby uzyskać informacje na przekazywanie dalej typu, zobacz [typu funkcji przekazywania w środowisko uruchomieniowe języka wspólnego](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano abstrakcyjnego `MeansOfTransportation` klasy w `Transportation` przestrzeni nazw. Wywołuje <xref:System.Reflection.Assembly.GetType%28System.String%29> metodę, aby pobrać jego <xref:System.Type> obiektu, wywołania <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> metody, aby uzyskać tablicę <xref:System.Reflection.PropertyInfo> obiektów, które reprezentują właściwości typu, a następnie wyświetla informacje od typu właściwości jako abstract. Należy pamiętać, że wywołanie <xref:System.Reflection.Assembly.GetType%28System.String%29> — metoda korzysta z w pełni kwalifikowana nazwa typu (to znaczy jego przestrzeń nazw wraz z jego nazwa typu).  
  
 [!code-csharp[System.Reflection.Assembly.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.gettype/vb/gettype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> wymaga zestawu zależnego, którego nie można odnaleźć.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para> [.NET dla aplikacji ze Sklepu Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośne Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) klasy, catch wyjątku klasy podstawowej <see cref="T:System.IO.IOException" />, zamiast tego.  </para>
          </block>
          <paramref name="name" /> wymaga zestawu zależnego, który został znaleziony, ale nie można go załadować.  - lub - bieżący zestaw został załadowany do kontekstu reflection-only i <paramref name="name" /> wymaga zestawu zależnego, który nie jest załadowany.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> wymaga zestawu zależnego, ale plik nie jest prawidłowym zestawem.  - lub - <paramref name="name" /> wymaga zestawu zależnego, który został skompilowany dla wersji później niż aktualnie załadowany wersji środowiska uruchomieniowego.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Pełna nazwa typu.</param>
        <param name="throwOnError">
          <see langword="true" /> Aby zgłosić wyjątek, jeśli typ nie zostanie odnaleziony; <see langword="false" /> do zwrócenia <see langword="null" />.</param>
        <summary>Pobiera <see cref="T:System.Type" /> obiektu o określonej nazwie w wystąpieniu zestawu i opcjonalnie zgłasza wyjątek, jeśli typ nie zostanie znaleziony.</summary>
        <returns>Obiekt, który reprezentuje określonej klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wyszukuje tylko bieżące wystąpienie zestawu. `name` Parametr zawiera przestrzeń nazw, ale nie zestawu. Aby wyszukać innych zestawów dla typu, należy użyć <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> przeciążenie metody, które można opcjonalnie dołączyć nazwy wyświetlanej zestawu jako część nazwy typu.  
  
> [!NOTE]
>  Jeśli typ został przesłany dalej do innego zestawu, nadal jest zwracana przez tę metodę. Aby uzyskać informacje na przekazywanie dalej typu, zobacz [typu funkcji przekazywania w środowisko uruchomieniowe języka wspólnego](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 `throwOnError` Parametr wpływa tylko na, co się stanie, jeśli nie znaleziono typu. Nie ma ona wpływu na pozostałe wyjątki, które może zostać zgłoszony. W szczególności, jeśli typ zostanie znaleziony, ale nie może zostać załadowany <xref:System.TypeLoadException> może zostać zgłoszony, nawet jeśli `throwOnError` jest `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest nieprawidłowy.  - lub - długość <paramref name="name" /> przekracza 1024 znaki.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> jest <see langword="true" />, i nie można odnaleźć typu.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> wymaga zestawu zależnego, którego nie można odnaleźć.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="name" /> wymaga zestawu zależnego, który został znaleziony, ale nie można go załadować.  - lub - bieżący zestaw został załadowany do kontekstu reflection-only i <paramref name="name" /> wymaga zestawu zależnego, który nie jest załadowany.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> wymaga zestawu zależnego, ale plik nie jest prawidłowym zestawem.  - lub - <paramref name="name" /> wymaga zestawu zależnego, który został skompilowany dla wersji później niż aktualnie załadowany wersji środowiska uruchomieniowego.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Pełna nazwa typu.</param>
        <param name="throwOnError">
          <see langword="true" /> Aby zgłosić wyjątek, jeśli typ nie zostanie odnaleziony; <see langword="false" /> do zwrócenia <see langword="null" />.</param>
        <param name="ignoreCase">
          <see langword="true" /> ignorowanie wielkości liter nazwy typu; w przeciwnym razie <see langword="false" />.</param>
        <summary>Pobiera <see cref="T:System.Type" /> obiektu o określonej nazwie w wystąpieniu zestawu z opcją uwzględniania wielkości liter i zgłaszanie wyjątku, jeśli typ nie zostanie znaleziony.</summary>
        <returns>Obiekt, który reprezentuje określonej klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wyszukuje tylko bieżące wystąpienie zestawu. `name` Parametr zawiera przestrzeń nazw, ale nie zestawu. Aby wyszukać innych zestawów dla typu, należy użyć <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> przeciążenie metody, które można opcjonalnie dołączyć nazwy wyświetlanej zestawu jako część nazwy typu.  
  
> [!NOTE]
>  Jeśli typ został przesłany dalej do innego zestawu, nadal jest zwracana przez tę metodę. Aby uzyskać informacje na przekazywanie dalej typu, zobacz [typu funkcji przekazywania w środowisko uruchomieniowe języka wspólnego](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 `throwOnError` Parametr wpływa tylko na, co się stanie, jeśli nie znaleziono typu. Nie ma ona wpływu na pozostałe wyjątki, które może zostać zgłoszony. W szczególności, jeśli typ zostanie znaleziony, ale nie może zostać załadowany <xref:System.TypeLoadException> może zostać zgłoszony, nawet jeśli `throwOnError` jest `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest nieprawidłowy.  - lub - długość <paramref name="name" /> przekracza 1024 znaki.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> jest <see langword="true" />, i nie można odnaleźć typu.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> wymaga zestawu zależnego, którego nie można odnaleźć.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="name" /> wymaga zestawu zależnego, który został znaleziony, ale nie można go załadować.  - lub - bieżący zestaw został załadowany do kontekstu reflection-only i <paramref name="name" /> wymaga zestawu zależnego, który nie jest załadowany.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> wymaga zestawu zależnego, ale plik nie jest prawidłowym zestawem.  - lub - <paramref name="name" /> wymaga zestawu zależnego, który został skompilowany dla wersji później niż aktualnie załadowany wersji środowiska uruchomieniowego.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetTypes : unit -&gt; Type[]&#xA;override this.GetTypes : unit -&gt; Type[]" Usage="assembly.GetTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera typy zdefiniowane w tym zestawie.</summary>
        <returns>Tablica, która zawiera wszystkie typy, które są zdefiniowane w tym zestawie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwracana tablica zawiera zagnieżdżone typy.  
  
 Jeśli <xref:System.Reflection.Assembly.GetTypes%2A> wywoływana jest metoda zestawu i typ w tym zestawie jest zależny od typu w zestawie, który nie został załadowany (na przykład, jeśli pochodzi od typu w zestawie drugi), <xref:System.Reflection.ReflectionTypeLoadException> jest generowany. Na przykład może się to zdarzyć, jeśli pierwszy zestaw został załadowany z <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> lub <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metod, a drugi zestaw nie został załadowany. Możliwe również przy zestawy ładowane przy użyciu <xref:System.Reflection.Assembly.Load%2A> i <xref:System.Reflection.Assembly.LoadFile%2A> metody, jeśli drugi zestaw nie można znaleźć, kiedy <xref:System.Reflection.Assembly.GetTypes%2A> metoda jest wywoływana.  
  
> [!NOTE]
>  Jeśli typ został przesłany dalej do innego zestawu, nie jest uwzględniony w zwróconej tablicy. Aby uzyskać informacje na przekazywanie dalej typu, zobacz [typu funkcji przekazywania w środowisko uruchomieniowe języka wspólnego](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 Do pobierania kolekcję <xref:System.Reflection.TypeInfo> obiektów zamiast tablicy <xref:System.Type> obiektów, użyj <xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType> właściwości.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono parametry jednej metody w typie w określonym zestawie.  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">Zestaw zawiera jeden lub więcej typów, które nie może zostać załadowany. Tablica zwrócona przez <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> zawiera właściwości tego wyjątku <see cref="T:System.Type" /> obiekt dla każdego typu, który został załadowany i <see langword="null" /> dla każdego typu nie można załadować, podczas gdy <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> właściwość zawiera wyjątek dla każdego typu Nie można załadować.</exception>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public virtual bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GlobalAssemblyCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool GlobalAssemblyCache { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalAssemblyCache : bool" Usage="System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.GlobalAssemblyCache</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy zestaw został załadowany z pamięci podręcznej GAC.</summary>
        <value>
          <see langword="true" /> Jeśli zestaw został załadowany z pamięci podręcznej GAC; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public virtual long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.HostContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HostContext As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long HostContext { long get(); };" />
      <MemberSignature Language="F#" Value="member this.HostContext : int64" Usage="System.Reflection.Assembly.HostContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kontekst hosta, z którym zestaw został załadowany.</summary>
        <value>
          <see cref="T:System.Int64" /> Wartość wskazującą, z którym zestaw został załadowany, jeśli kontekst hosta.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public virtual string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImageRuntimeVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ImageRuntimeVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ImageRuntimeVersion : string" Usage="System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ciąg reprezentujący wersji środowisko uruchomieniowe języka wspólnego (CLR) zapisywane w pliku zawierającego manifestu.</summary>
        <value>Nazwa folderu wersji środowiska CLR. To nie jest pełną ścieżką.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład wartość dla środowiska .NET Framework w wersji 1.1 się v1.1.4322. Pliki binarne dla tej wersji będą znajdować się w windir%\Microsoft.NET\Framework\v1.1.4322% ścieżki.  
  
 Domyślnie <xref:System.Reflection.Assembly.ImageRuntimeVersion%2A> ma ustawioną wartość wersji środowiska CLR, używany do tworzenia zestawu. Jednak go może ustawiono na inną wartość w czasie kompilacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member IsDefined : Type * bool -&gt; bool&#xA;override this.IsDefined : Type * bool -&gt; bool" Usage="assembly.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Typ atrybutu, który ma być sprawdzana dla tego zestawu.</param>
        <param name="inherit">Ten argument jest ignorowany w przypadku obiektów tego typu.</param>
        <summary>Wskazuje, czy określony atrybut zostały zastosowane do zestawu.</summary>
        <returns>
          <see langword="true" /> Jeśli ten atrybut został zastosowany do zestawu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu dotyczy <xref:System.Reflection.AssemblyTitleAttribute> atrybut do zestawu, a następnie używa <xref:System.Reflection.Assembly.IsDefined%2A> wskazująca, czy została zastosowana. On również testy atrybut, który nie został zastosowany.  
  
 [!code-csharp[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/CS/isdefined.cs#1)]
 [!code-vb[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/VB/isdefined.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> używa nieprawidłowego typu.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public virtual bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDynamic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDynamic : bool" Usage="System.Reflection.Assembly.IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący zestaw został wygenerowany dynamicznie w bieżącym procesie przy użyciu odbicia emisji.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący zestaw został wygenerowany dynamicznie w bieżącym procesie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dynamiczne zestawy są reprezentowane przez klasy pochodnej <xref:System.Reflection.Emit.AssemblyBuilder>.  
  
 Gdy zestawie dynamicznym jest zapisywany na dysku, zapisane zestawu nie jest dyskiem dynamicznym. Jeśli zapisane zestaw jest ładowany do innej domeny aplikacji lub proces, <xref:System.Reflection.Assembly.IsDynamic%2A> zwraca właściwość `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.Reflection.Assembly.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący zestaw jest ładowany z pełnym zaufaniem.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący zestaw jest ładowany z pełnym zaufaniem; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładuje zestaw.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tablica bajtów, która jest obrazem w formacie COFF, zawierającym emitowany zestaw.</param>
        <summary>Ładuje zestaw z typowych format pliku obiektu (COFF)-emitowany zestawu zawierającego obraz. Zestaw jest ładowany do domeny aplikacji obiektu wywołującego.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poziom zaufania zestawu, który jest ładowany za pomocą tej metody jest taki sam jak poziom zaufania wywołującego zestawu. Aby załadować zestawu z tablicy bajtów z poziomem zaufania domeny aplikacji, należy użyć <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> przeciążenie metody. Aby uzyskać więcej informacji o używaniu dowód z przeciążeń <xref:System.Reflection.Assembly.Load%2A> metody prowadzące tablice typu byte, zobacz <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> przeciążenie metody.  
  
 Zdarzenie odzwierciedla na plików wykonywalnych języka C++ może zgłosić <xref:System.BadImageFormatException>. To prawdopodobnie spowodowane przez kompilator języka C++, usuwanie adresów relokacji lub `.reloc` sekcji z pliku wykonywalnego. Aby zachować `.reloc` adresów dla pliku wykonywalnego C++, określ `/fixed:no` gdy połączenie jest ustanawiane.  
  
 Należy pamiętać, że tego przeciążenia metody zawsze tworzy nową <xref:System.Reflection.Assembly> obiekt z jego własnej mapowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="rawAssembly" /> został skompilowany przy użyciu nowszej wersji.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Obiekt, który opisuje zestawu do załadowania.</param>
        <summary>Ładuje zestaw podane jego <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> wygenerowany, jeśli `assemblyRef` Określa pełną nazwą zestawu i pierwszego zestawu, który odpowiada nazwie proste ma inną wersję, kulturę lub token klucza publicznego. Moduł ładujący nie będzie badania innych zestawów zgodnych prostą nazwą.  
  
> [!NOTE]
>  Nie używaj <xref:System.Reflection.AssemblyName> tylko z <xref:System.Reflection.AssemblyName.CodeBase%2A> zestawu właściwości. <xref:System.Reflection.AssemblyName.CodeBase%2A> Właściwości nie dostarcza żadnych elementów tożsamości zestawu (np. nazwę lub wersję), dlatego podczas ładowania nie występuje zgodnie z regułami obciążenia przez tożsamości, zgodnie z oczekiwaniami z <xref:System.Reflection.Assembly.Load%2A> metody. Zamiast tego zestaw został załadowany przy użyciu reguł obciążenia z. Aby uzyskać informacje o wad przy użyciu kontekst load-from, zobacz <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> przeciążenie metody lub [najlepsze rozwiązania dotyczące ładowania zestawu](~/docs/framework/deployment/best-practices-for-assembly-loading.md).  
  
 To, czy określone uprawnienia są przyznane do zestawu, czy nie, zależy od dowodów. Zasady scalania kompilowania asemblera i dowodów zabezpieczeń są następujące:  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.Load%2A> metody bez <xref:System.Security.Policy.Evidence> parametru zestaw jest ładowany dowody, który dostarcza modułu ładującego.  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.Load%2A> metody z <xref:System.Security.Policy.Evidence> parametru części dowód są łączone ze sobą. Elementy dowody dostarczone jako argument <xref:System.Reflection.Assembly.Load%2A> metody zastępują elementy dowody dostarczone przez moduł ładujący.  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.Load%2A> przeciążenie metody z `Byte[]` parametru załadować wspólnych obiektu pliku formatu (COFF) obraz, dowód jest odziedziczone wywołującego zestawu. Dotyczy to architektury .NET Framework w wersji 1.1 z dodatkiem Service Pack 1 (SP1) i późniejszych wersji.  
  
    > [!NOTE]
    >  W programie .NET Framework w wersji 1.0, jak i w wersji 1.1 bez dodatku SP1, korzystając z <xref:System.Reflection.Assembly.Load%2A> przeciążenie metody z `Byte[]` parametr, aby załadować obrazu COFF, dowód jest połączona. `Zone`, `Url` i `Site` są dziedziczone z wywołującego zestawu i `Hash` i `StrongName` są pobierane z zestawu COFF.  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.Load%2A> metody z `Byte[]` parametru i <xref:System.Security.Policy.Evidence> można załadować obrazu COFF, jest używany tylko dowód dostarczony. Dowód wywołującego zestawu i dokumenty obrazu COFF jest ignorowana.  
  
 Zdarzenie odzwierciedla na plików wykonywalnych języka C++ może zgłosić <xref:System.BadImageFormatException>. To prawdopodobnie spowodowane przez kompilator języka C++, usuwanie adresów relokacji lub `.reloc` sekcji z pliku wykonywalnego. Aby zachować `.reloc` adresów dla pliku wykonywalnego C++, określ `/fixed:no` gdy połączenie jest ustanawiane.  
  
> [!NOTE]
>  Jeśli oba <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> właściwości i <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> właściwości są ustawione, pierwsza próba załadowania zestawu, użyta zostanie nazwa wyświetlana (łącznie z wersji, kultury i tak dalej zwrócony przez <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> właściwości). Jeśli plik nie zostanie znaleziony, <xref:System.Reflection.AssemblyName.CodeBase%2A> służy do wyszukiwania zestawu. Jeśli zestaw znajduje się za pomocą <xref:System.Reflection.AssemblyName.CodeBase%2A>, nazwa wyświetlana jest dopasowywana do zestawu. W przypadku niepowodzenia dopasowania <xref:System.IO.FileLoadException> jest generowany.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Reflection.AssemblyName> obiektu i używa go do załadowania `sysglobal.dll` zestawu. W przykładzie przedstawiono następnie pełną nazwą zestawu typy publiczne.  
  
 [!code-csharp[System.Reflection.Assembly.Load#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/Load2.cs#2)]
 [!code-vb[System.Reflection.Assembly.Load#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/Load2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> Nie znaleziono.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para> [.NET dla aplikacji ze Sklepu Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośne Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) klasy, catch wyjątku klasy podstawowej <see cref="T:System.IO.IOException" />, zamiast tego.  </para>
          </block>  Nie można załadować pliku, który został znaleziony.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> nie jest prawidłowym zestawem. - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyRef" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member Load : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Długich fragmentów nazwy zestawu.</param>
        <summary>Ładuje zestaw podane długich fragmentów jej nazwy.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Długą formę nazwy zestawu składa się z jego prostą nazwą (takie jak "System" dla zestawu System.dll) wraz z jego wersji, kultury, tokenu klucza publicznego i opcjonalnie jego architektury procesora. Odnosi się do zestawu <xref:System.Reflection.Assembly.FullName%2A> właściwości. Poniższy przykład przedstawia użycie długa nazwa załadować zestawu System.dll dla programu .NET Framework 4.  
  
 [!code-csharp[System.Reflection.Assembly.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/load1.cs#1)]
 [!code-vb[System.Reflection.Assembly.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/load1.vb#1)]  
  
 <xref:System.IO.FileLoadException> wygenerowany, jeśli `assemblyString` Określa pełną nazwą zestawu i pierwszego zestawu, który odpowiada nazwie proste ma inną wersję, kulturę lub token klucza publicznego. Moduł ładujący nie będzie badania innych zestawów zgodnych prostą nazwą.  
  
 To, czy określone uprawnienia są przyznane do zestawu, czy nie, zależy od dowodów. Zasady scalania kompilowania asemblera i dowodów zabezpieczeń są następujące:  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.Load%2A> metody bez <xref:System.Security.Policy.Evidence> parametru zestaw jest ładowany dowody, który dostarcza modułu ładującego.  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.Load%2A> metody z <xref:System.Security.Policy.Evidence> parametru części dowód są łączone ze sobą. Elementy dowody dostarczone jako argument <xref:System.Reflection.Assembly.Load%2A> metody zastępują elementy dowody dostarczone przez moduł ładujący.  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.Load%2A> przeciążenie metody z `Byte[]` parametru załadować wspólnych obiektu pliku formatu (COFF) obraz, dowód jest odziedziczone wywołującego zestawu. Dotyczy to architektury .NET Framework w wersji 1.1 z dodatkiem Service Pack 1 (SP1) i późniejszych wersji.  
  
    > [!NOTE]
    >  W programie .NET Framework w wersji 1.0, jak i w wersji 1.1 bez dodatku SP1, korzystając z <xref:System.Reflection.Assembly.Load%2A> przeciążenie metody z `Byte[]` parametr, aby załadować obrazu COFF, dowód jest połączona. `Zone`, `Url` i `Site` są dziedziczone z wywołującego zestawu i `Hash` i `StrongName` są pobierane z zestawu COFF.  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.Load%2A> metody z `Byte[]` parametru i <xref:System.Security.Policy.Evidence> można załadować obrazu COFF, jest używany tylko dowód dostarczony. Dowód wywołującego zestawu i dokumenty obrazu COFF jest ignorowana.  
  
 Zdarzenie odzwierciedla na plików wykonywalnych języka C++ może zgłosić <xref:System.BadImageFormatException>. To prawdopodobnie spowodowane przez kompilator języka C++, usuwanie adresów relokacji lub `.reloc` sekcji z pliku wykonywalnego. Aby zachować `.reloc` adresów dla pliku wykonywalnego C++, określ `/fixed:no` gdy połączenie jest ustanawiane.  
  
 W wersji 2.0 środowiska .NET Framework architektura procesora jest dodawana do tożsamości zestawu i może być określona jako część zestawu ciągu nazw. Na przykład "ProcessorArchitecture = msil". Jednak określać nazwę zestawu zalecaną metodą jest utworzenie <xref:System.Reflection.AssemblyName> obiektu i przekaż go do odpowiedniego przeciążenia <xref:System.Reflection.Assembly.Load%2A> metody. Zobacz <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład ładuje jego w pełni kwalifikowana nazwa zestawu i wyświetla listę wszystkich typów zawartych w określonym zestawie. Aby ten przykładowy kod zadziałał, należy podać w pełni kwalifikowaną nazwę zestawu. Aby uzyskać informacje o tym, jak można uzyskać w pełni kwalifikowanej nazwy zestawu, zobacz [nazwy zestawu](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[assembly.load1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.Load1/CPP/load1.cpp#1)]
 [!code-csharp[assembly.load1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.Load1/CS/load1.cs#1)]
 [!code-vb[assembly.load1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.Load1/VB/load1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" /> jest ciągiem o zerowej długości.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> Nie znaleziono.</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyString" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tablica bajtów, która jest obrazem w formacie COFF, zawierającym emitowany zestaw.</param>
        <param name="rawSymbolStore">Tablica bajtów zawierająca bajty raw reprezentujący symboli dla zestawu.</param>
        <summary>Ładuje zestaw z typowych format pliku obiektu (COFF) — na podstawie obrazu zawierającego emitowany zestawu, opcjonalnie tym symboli dla zestawu. Zestaw jest ładowany do domeny aplikacji obiektu wywołującego.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poziom zaufania zestawu, który jest ładowany za pomocą tej metody jest taki sam jak poziom zaufania wywołującego zestawu. Aby załadować zestawu z tablicy bajtów z poziomem zaufania domeny aplikacji, należy użyć <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> przeciążenie metody. Aby uzyskać więcej informacji o używaniu dowód z przeciążeń <xref:System.Reflection.Assembly.Load%2A> metody prowadzące tablice typu byte, zobacz <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> przeciążenie metody.  
  
 Zdarzenie odzwierciedla na plików wykonywalnych języka C++ może zgłosić <xref:System.BadImageFormatException>. To prawdopodobnie spowodowane przez kompilator języka C++, usuwanie adresów relokacji lub `.reloc` sekcji z pliku wykonywalnego. Aby zachować `.reloc` adresów dla pliku wykonywalnego C++, określ `/fixed:no` gdy połączenie jest ustanawiane.  
  
 Należy pamiętać, że tego przeciążenia metody zawsze tworzy nową <xref:System.Reflection.Assembly> obiekt z jego własnej mapowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="rawAssembly" /> został skompilowany przy użyciu nowszej wersji.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Obiekt, który opisuje zestawu do załadowania.</param>
        <param name="assemblySecurity">Dowód ładowania zestawu.</param>
        <summary>Ładuje zestaw podane jego <see cref="T:System.Reflection.AssemblyName" />. Zestaw jest ładowany do domeny za pomocą dostarczonego dowód obiektu wywołującego.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> wygenerowany, jeśli `assemblyRef` Określa pełną nazwą zestawu i pierwszego zestawu, który odpowiada nazwie proste ma inną wersję, kulturę lub token klucza publicznego. Moduł ładujący nie będzie badania innych zestawów zgodnych prostą nazwą.  
  
> [!NOTE]
>  Nie używaj <xref:System.Reflection.AssemblyName> tylko z <xref:System.Reflection.AssemblyName.CodeBase%2A> zestawu właściwości. <xref:System.Reflection.AssemblyName.CodeBase%2A> Właściwości nie dostarcza żadnych elementów tożsamości zestawu (np. nazwę lub wersję), dlatego podczas ładowania nie występuje zgodnie z regułami obciążenia przez tożsamości, zgodnie z oczekiwaniami z <xref:System.Reflection.Assembly.Load%2A> metody. Zamiast tego zestaw został załadowany przy użyciu reguł obciążenia z. Aby uzyskać informacje o wad przy użyciu kontekst load-from, zobacz <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> przeciążenie metody lub [najlepsze rozwiązania dotyczące ładowania zestawu](~/docs/framework/deployment/best-practices-for-assembly-loading.md).  
  
 To, czy określone uprawnienia są przyznane do zestawu, czy nie, zależy od dowodów. Zasady scalania kompilowania asemblera i dowodów zabezpieczeń są następujące:  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.Load%2A> metody bez <xref:System.Security.Policy.Evidence> parametru zestaw jest ładowany dowody, który dostarcza modułu ładującego.  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.Load%2A> metody z <xref:System.Security.Policy.Evidence> parametru części dowód są łączone ze sobą. Elementy dowody dostarczone jako argument <xref:System.Reflection.Assembly.Load%2A> metody zastępują elementy dowody dostarczone przez moduł ładujący.  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.Load%2A> przeciążenie metody z `Byte[]` parametru załadować wspólnych obiektu pliku formatu (COFF) obraz, dowód jest odziedziczone wywołującego zestawu. Dotyczy to architektury .NET Framework w wersji 1.1 z dodatkiem Service Pack 1 (SP1) i późniejszych wersji.  
  
    > [!NOTE]
    >  W programie .NET Framework w wersji 1.0, jak i w wersji 1.1 bez dodatku SP1, korzystając z <xref:System.Reflection.Assembly.Load%2A> przeciążenie metody z `Byte[]` parametr, aby załadować obrazu COFF, dowód jest połączona. `Zone`, `Url` i `Site` są dziedziczone z wywołującego zestawu i `Hash` i `StrongName` są pobierane z zestawu COFF.  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.Load%2A> metody z `Byte[]` parametru i <xref:System.Security.Policy.Evidence> można załadować obrazu COFF, jest używany tylko dowód dostarczony. Dowód wywołującego zestawu i dokumenty obrazu COFF jest ignorowana.  
  
 Zdarzenie odzwierciedla na plików wykonywalnych języka C++ może zgłosić <xref:System.BadImageFormatException>. To prawdopodobnie spowodowane przez kompilator języka C++, usuwanie adresów relokacji lub `.reloc` sekcji z pliku wykonywalnego. Aby zachować `.reloc` adresów dla pliku wykonywalnego C++, określ `/fixed:no` gdy połączenie jest ustanawiane.  
  
> [!NOTE]
>  Jeśli oba <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> właściwości i <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> właściwości są ustawione, pierwsza próba załadowania zestawu, użyta zostanie nazwa wyświetlana (łącznie z wersji, kultury i tak dalej zwrócony przez <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> właściwości). Jeśli plik nie zostanie znaleziony, <xref:System.Reflection.AssemblyName.CodeBase%2A> służy do wyszukiwania zestawu. Jeśli zestaw znajduje się za pomocą <xref:System.Reflection.AssemblyName.CodeBase%2A>, nazwa wyświetlana jest dopasowywana do zestawu. W przypadku niepowodzenia dopasowania <xref:System.IO.FileLoadException> jest generowany.  
  
 Jeśli należy wywołać <xref:System.Reflection.Assembly.Load%2A> metody więcej niż raz na tym samym zestawie, ale z inną dowód, określony środowisko uruchomieniowe języka wspólnego nie zgłasza <xref:System.IO.FileLoadException> ponieważ równości i integralności specyfikacji różnych dowód nie może być określona. Używanym dowodem jest dowód na to, że odniesie się sukces za pierwszym razem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> Nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyRef" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Wyświetlana nazwa zestawu.</param>
        <param name="assemblySecurity">Dowód ładowania zestawu.</param>
        <summary>Ładuje zestaw podanej nazwy wyświetlanej, podczas ładowania zestawu do domeny za pomocą dostarczonego dowód obiektu wywołującego.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> wygenerowany, jeśli `assemblyString` Określa pełną nazwą zestawu i pierwszego zestawu, który odpowiada nazwie proste ma inną wersję, kulturę lub token klucza publicznego. Moduł ładujący nie będzie badania innych zestawów zgodnych prostą nazwą.  
  
 To, czy określone uprawnienia są przyznane do zestawu, czy nie, zależy od dowodów. Zasady scalania kompilowania asemblera i dowodów zabezpieczeń są następujące:  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.Load%2A> metody bez <xref:System.Security.Policy.Evidence> parametru zestaw jest ładowany dowody, który dostarcza modułu ładującego.  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.Load%2A> metody z <xref:System.Security.Policy.Evidence> parametru części dowód są łączone ze sobą. Elementy dowody dostarczone jako argument <xref:System.Reflection.Assembly.Load%2A> metody zastępują elementy dowody dostarczone przez moduł ładujący.  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.Load%2A> przeciążenie metody z `Byte[]` parametru załadować wspólnych obiektu pliku formatu (COFF) obraz, dowód jest odziedziczone wywołującego zestawu. Dotyczy to architektury .NET Framework w wersji 1.1 z dodatkiem Service Pack 1 (SP1) i późniejszych wersji.  
  
    > [!NOTE]
    >  W programie .NET Framework w wersji 1.0, jak i w wersji 1.1 bez dodatku SP1, korzystając z <xref:System.Reflection.Assembly.Load%2A> przeciążenie metody z `Byte[]` parametr, aby załadować obrazu COFF, dowód jest połączona. `Zone`, `Url` i `Site` są dziedziczone z wywołującego zestawu i `Hash` i `StrongName` są pobierane z zestawu COFF.  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.Load%2A> metody z `Byte[]` parametru i <xref:System.Security.Policy.Evidence> można załadować obrazu COFF, jest używany tylko dowód dostarczony. Dowód wywołującego zestawu i dokumenty obrazu COFF jest ignorowana.  
  
 Zdarzenie odzwierciedla na plików wykonywalnych języka C++ może zgłosić <xref:System.BadImageFormatException>. To prawdopodobnie spowodowane przez kompilator języka C++, usuwanie adresów relokacji lub `.reloc` sekcji z pliku wykonywalnego. Aby zachować `.reloc` adresów dla pliku wykonywalnego C++, określ `/fixed:no` gdy połączenie jest ustanawiane.  
  
 Jeśli ta metoda jest wywoływana więcej niż raz w tym samym zestawie, ale z inną dowód, określony, środowisko uruchomieniowe języka wspólnego nie zgłasza <xref:System.IO.FileLoadException> ponieważ równości i integralności specyfikacji różnych dowód nie może być określony. Używanym dowodem jest dowód na to, że odniesie się sukces za pierwszym razem.  
  
 W wersji 2.0 środowiska .NET Framework architektura procesora jest dodawana do tożsamości zestawu i może być określona jako część zestawu ciągu nazw. Na przykład "ProcessorArchitecture = msil". Jednak określać nazwę zestawu zalecaną metodą jest utworzenie <xref:System.Reflection.AssemblyName> obiektu i przekaż go do odpowiedniego przeciążenia <xref:System.Reflection.Assembly.Load%2A> metody. Zobacz <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> Nie znaleziono.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyString" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.  - lub - zestawu lub moduł został załadowany z dwóch różnych też dowody.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tablica bajtów, która jest obrazem w formacie COFF, zawierającym emitowany zestaw.</param>
        <param name="rawSymbolStore">Tablica bajtów zawierająca bajty raw reprezentujący symboli dla zestawu.</param>
        <param name="securityEvidence">Dowód ładowania zestawu.</param>
        <summary>Ładuje zestaw z typowych format pliku obiektu (COFF) — na podstawie obrazu zawierającego emitowany zestawu, opcjonalnie tym symbole i dowody dla zestawu. Zestaw jest ładowany do domeny aplikacji obiektu wywołującego.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw jest ładowany do domeny za pomocą dostarczonego dowód obiektu wywołującego. Nieprzetworzona bajtów reprezentujący symboli dla zestawu również są ładowane.  
  
 To, czy określone uprawnienia są przyznane do zestawu, czy nie, zależy od dowodów. Zasady scalania kompilowania asemblera i dowodów zabezpieczeń są następujące:  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.Load%2A> metody bez <xref:System.Security.Policy.Evidence> parametru zestaw jest ładowany dowody, który dostarcza modułu ładującego.  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.Load%2A> metody z <xref:System.Security.Policy.Evidence> parametru części dowód są łączone ze sobą. Elementy dowody dostarczone jako argument <xref:System.Reflection.Assembly.Load%2A> metody zastępują elementy dowody dostarczone przez moduł ładujący.  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.Load%2A> przeciążenie metody z `Byte[]` parametr, aby załadować obrazu COFF, dowód jest odziedziczone wywołującego zestawu. Dotyczy to architektury .NET Framework w wersji 1.1 z dodatkiem Service Pack 1 (SP1) i późniejszych wersji.  
  
    > [!NOTE]
    >  W programie .NET Framework w wersji 1.0, jak i w wersji 1.1 bez dodatku SP1, korzystając z <xref:System.Reflection.Assembly.Load%2A> przeciążenie metody z `Byte[]` parametr, aby załadować obrazu COFF, dowód jest połączona. `Zone`, `Url` i `Site` są dziedziczone z wywołującego zestawu i `Hash` i `StrongName` są pobierane z zestawu COFF.  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.Load%2A> metody z `Byte[]` parametru i <xref:System.Security.Policy.Evidence> można załadować obrazu COFF, jest używany tylko dowód dostarczony. Dowód wywołującego zestawu i dowód obrazu COFF zostaną zignorowane.  
  
 Zdarzenie odzwierciedla na plików wykonywalnych języka C++ może zgłosić <xref:System.BadImageFormatException>. To prawdopodobnie spowodowane przez kompilator języka C++, usuwanie adresów relokacji lub `.reloc` sekcji z pliku wykonywalnego. Aby zachować `.reloc` adresów dla pliku wykonywalnego C++, określ `/fixed:no` gdy połączenie jest ustanawiane.  
  
 Jeśli wywołujesz [\], bajtów\<xref:System.Reflection.Assembly.Load%2A > Metoda więcej niż raz na tym samym zestawie, ale z inną dowód, określony środowisko uruchomieniowe języka wspólnego nie zgłasza <xref:System.IO.FileLoadException> ponieważ Nie można określić równości i integralności specyfikacji różnych dowód. Używanym dowodem jest dowód na to, że odniesie się sukces za pierwszym razem.  
  
 Należy pamiętać, że tego przeciążenia metody zawsze tworzy nową <xref:System.Reflection.Assembly> obiekt z jego własnej mapowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="rawAssembly" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> nie jest <see langword="null" />.  Starszą zasadę nie jest domyślnie włączona w [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)]; gdy nie jest włączone, <paramref name="securityEvidence" /> musi być <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość udowodnić. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.SecurityContextSource -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tablica bajtów, która jest obrazem w formacie COFF, zawierającym emitowany zestaw.</param>
        <param name="rawSymbolStore">Tablica bajtów zawierająca bajty raw reprezentujący symboli dla zestawu.</param>
        <param name="securityContextSource">Źródło kontekstu zabezpieczeń.</param>
        <summary>Ładuje zestaw z typowych format pliku obiektu (COFF) — na podstawie obrazu zawierający emitowany zestawu, opcjonalnie w tym symbole i Określanie źródła dla kontekstu zabezpieczeń. Zestaw jest ładowany do domeny aplikacji obiektu wywołującego.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw jest ładowany do domeny aplikacji obiektu wywołującego przy użyciu określonego źródła dla kontekstu zabezpieczeń. Jeśli `rawSymbolStore` określono również załadowano raw bajtów, które reprezentują symboli dla zestawu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> nie jest prawidłowym zestawem.  - lub - <paramref name="rawAssembly" /> został skompilowany przy użyciu nowszej wersji środowiska CLR niż wersja, który jest aktualnie załadowany.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="securityContextSource" /> nie jest jedną z wartości wyliczenia.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładuje zawartość pliku zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Pełna ścieżka pliku do załadowania.</param>
        <summary>Ładuje zawartość pliku zestawu w określonej ścieżce.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Reflection.Assembly.LoadFile%2A> metodę, aby załadować i sprawdź, czy zestawy, które mają taką samą tożsamość, ale znajdują się w innej ścieżki.<xref:System.Reflection.Assembly.LoadFile%2A> plików nie zostanie załadowany w kontekście ładowania z, a nie rozpoznać zależności przy użyciu ścieżki obciążenia, jako <xref:System.Reflection.Assembly.LoadFrom%2A> metoda wykonuje. <xref:System.Reflection.Assembly.LoadFile%2A> przydaje się w tym scenariuszu ograniczona ponieważ <xref:System.Reflection.Assembly.LoadFrom%2A> nie można załadować zestawów, która ma tej samej tożsamości, ale różne ścieżki; zostanie załadowany tylko pierwszy takiego zestawu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Argument nie jest ścieżką bezwzględną.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> Parametr jest pustym ciągiem ("") lub nie istnieje.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="path" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="path" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile (path, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="path">Pełna ścieżka pliku zestawu.</param>
        <param name="securityEvidence">Dowód ładowania zestawu.</param>
        <summary>Ładuje zestaw podanej ścieżki, podczas ładowania zestawu do domeny za pomocą dostarczonego dowód obiektu wywołującego.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Reflection.Assembly.LoadFile%2A> metodę, aby załadować i sprawdź, czy zestawy, które mają taką samą tożsamość, ale znajdują się w innej ścieżki. <xref:System.Reflection.Assembly.LoadFile%2A> nie ładować pliki do <xref:System.Reflection.Assembly.LoadFrom%2A> kontekstu i nie rozpoznać zależności przy użyciu ścieżki obciążenia, jako <xref:System.Reflection.Assembly.LoadFrom%2A> metoda wykonuje. <xref:System.Reflection.Assembly.LoadFile%2A> przydaje się w tym scenariuszu ograniczona ponieważ <xref:System.Reflection.Assembly.LoadFrom%2A> nie można załadować zestawów, która ma tej samej tożsamości, ale różne ścieżki; zostanie załadowany tylko pierwszy takiego zestawu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Argument nie jest ścieżką bezwzględną.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> Parametr jest pustym ciągiem ("") lub nie istnieje.</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="path" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="path" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> nie jest <see langword="null" />. Starszą zasadę nie jest domyślnie włączona w [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)]; gdy nie jest włączone, <paramref name="securityEvidence" /> musi być <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Dostęp umożliwiający odczyt z pliku lub katalogu oraz dostęp do informacji w samej ścieżce. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładuje zestaw.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa lub ścieżka pliku, który zawiera manifest zestawu.</param>
        <summary>Ładuje zestaw podano jej nazwy lub ścieżki pliku.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile` Parametru musi odwoływać się do identyfikatora URI bez znaki specjalne. Ta metoda zawiera znaki specjalne dla wszystkich nieprawidłowe znaki w identyfikatorze URI.  
  
> [!NOTE]
>  Protokół transferu plików (FTP) nie jest obsługiwana. Jeśli podany identyfikator URI dla `assemblyFile` adres FTP zestaw nie został załadowany. Nie wyjątek.  
  
 `assemblyFile` może być bezwzględny lub względny w bieżącym katalogu i zestaw jest ładowany do domeny obiektu wywołującego.  
  
 Zestawy mogą być ładowane do jednego z trzech kontekstów lub może być załadowany bez kontekstu:  
  
-   W kontekście ładowania zawiera zestawy znalezione przez sondowanie: w pamięci podręcznej GAC, w zestawie hosta, jeśli jest obsługiwana przez środowisko uruchomieniowe i przechowywać w <xref:System.AppDomainSetup.ApplicationBase%2A> i <xref:System.AppDomainSetup.PrivateBinPath%2A> domeny aplikacji. Większość przeciążeń <xref:System.Reflection.Assembly.Load%2A> metody Ładuj zestawy w tym kontekście.  
  
-   Kontekst load-from zawiera zestawy, do których użytkownik podał ścieżki nie jest uwzględniony w katalogach przeszukiwane przez sondowanie. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, i <xref:System.AppDomain.ExecuteAssembly%2A> przedstawiono metody, które są ładowane przez ścieżkę.  
  
-   Kontekstu reflection-only zawiera zestawy ładowane z <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> i <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metod; kod w tych kontekstach nie można wykonać.  
  
-   Jeśli użytkownik generowany lub znaleziono zestaw, nie jest w dowolnym kontekście. Dotyczy to zestawy ładowane przy użyciu przeciążeń <xref:System.Reflection.Assembly.Load%2A> metodę Określ tablica bajtów zawierająca zestawu i aby przejściowych dynamicznych zestawów utworzonych za pomocą odbicia Emituj i nie zapisano na dysku.  
  
 Kontekst load-from umożliwia zestawu do załadowania ze ścieżki nie jest uwzględniony w sondowanie i jeszcze umożliwia zależności na tej ścieżce odnaleźć i załadować, ponieważ informacje o ścieżce jest obsługiwana przez kontekst.  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A> Metoda ma następujące wady. Należy rozważyć użycie <xref:System.Reflection.Assembly.Load%2A> zamiast tego.  
  
-   Jeśli zestaw o tej samej tożsamości jest już załadowany, <xref:System.Reflection.Assembly.LoadFrom%2A> zwraca załadowany zestaw nawet wtedy, gdy określono inną ścieżkę.  
  
-   Jeśli zestaw jest ładowany z <xref:System.Reflection.Assembly.LoadFrom%2A>i później próbuje załadować tego samego zestawu według nazwy wyświetlanej zestawu w kontekście ładowania, próba załadowania kończy się niepowodzeniem. Taka sytuacja może wystąpić, gdy zestaw jest zdeserializowany.  
  
-   Jeśli zestaw jest ładowany z <xref:System.Reflection.Assembly.LoadFrom%2A>, i ścieżki próbkowania zawiera zestaw o tej samej tożsamości, ale inną lokalizację, <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, lub mogą występować inne nieoczekiwane zachowania.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> wymagania <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> i <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, lub <xref:System.Net.WebPermission>, w określonej ścieżce.  
  
-   Jeśli istnieje obrazu macierzystego dla `assemblyFile`, nie jest używany. Zestaw nie może być załadowany jako neutralny dla domen.  
  
-   W programie .NET Framework w wersji 1.0, 1.1 nie są stosowane zasady.  
  
   
  
## Examples  
 Poniższy przykład ładuje zestaw podano jej nazwy lub ścieżki pliku.  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> nie zostanie znaleziony, lub próby załadowania modułu nie określa rozszerzenie nazwy pliku.</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem; na przykład zestawem 32-bitowe w procesie 64-bitowych. Zobacz temat wyjątek, aby uzyskać więcej informacji.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.Security.SecurityException">Codebase, który rozpoczyna się od "file://" został określony bez wymaganego <see cref="T:System.Net.WebPermission" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> Parametr jest pustym ciągiem ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Nazwa zestawu przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania identyfikatora URI, który rozpoczyna się od "file://". Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa lub ścieżka pliku, który zawiera manifest zestawu.</param>
        <param name="securityEvidence">Dowód ładowania zestawu.</param>
        <summary>Ładuje zestaw podane jego dowodów zabezpieczeń plików, jak nazwa lub ścieżka i dostarczenie.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile` Parametru musi odwoływać się do identyfikatora URI bez znaki specjalne. Ta metoda zawiera znaki specjalne dla wszystkich nieprawidłowe znaki w identyfikatorze URI.  
  
> [!NOTE]
>  Protokół transferu plików (FTP) nie jest obsługiwana. Jeśli podany identyfikator URI dla `assemblyFile` adres FTP zestaw nie został załadowany. Nie wyjątek.  
  
 `assemblyFile` może być bezwzględny lub względny w bieżącym katalogu i zestaw jest ładowany do domeny obiektu wywołującego.  
  
 Zestawy mogą być ładowane do jednego z trzech kontekstów lub może być załadowany bez kontekstu:  
  
-   W kontekście ładowania zawiera zestawy znalezione przez sondowanie: w pamięci podręcznej GAC, w zestawie hosta, jeśli jest obsługiwana przez środowisko uruchomieniowe i przechowywać w <xref:System.AppDomainSetup.ApplicationBase%2A> i <xref:System.AppDomainSetup.PrivateBinPath%2A> domeny aplikacji. Większość przeciążeń <xref:System.Reflection.Assembly.Load%2A> metody Ładuj zestawy w tym kontekście.  
  
-   Kontekst load-from zawiera zestawy, do których użytkownik podał ścieżki nie jest uwzględniony w katalogach przeszukiwane przez sondowanie. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, i <xref:System.AppDomain.ExecuteAssembly%2A> przedstawiono metody, które są ładowane przez ścieżkę.  
  
-   Kontekstu reflection-only zawiera zestawy ładowane z <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> i <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metod; kod w tych kontekstach nie można wykonać.  
  
-   Jeśli użytkownik generowany lub znaleziono zestaw, nie jest w dowolnym kontekście. Dotyczy to zestawy ładowane przy użyciu przeciążeń <xref:System.Reflection.Assembly.Load%2A> metodę Określ tablica bajtów zawierająca zestawu i aby przejściowych dynamicznych zestawów utworzonych za pomocą odbicia Emituj i nie zapisano na dysku.  
  
 Kontekst load-from umożliwia zestawu do załadowania ze ścieżki nie jest uwzględniony w sondowanie i jeszcze umożliwia zależności na tej ścieżce odnaleźć i załadować, ponieważ informacje o ścieżce jest obsługiwana przez kontekst.  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A> Metoda ma następujące wady. Należy rozważyć użycie <xref:System.Reflection.Assembly.Load%2A> zamiast tego.  
  
-   Jeśli zestaw o tej samej tożsamości jest już załadowany, <xref:System.Reflection.Assembly.LoadFrom%2A> zwraca załadowany zestaw nawet wtedy, gdy określono inną ścieżkę.  
  
-   Jeśli zestaw jest ładowany z <xref:System.Reflection.Assembly.LoadFrom%2A>i później próbuje załadować tego samego zestawu według nazwy wyświetlanej zestawu w kontekście ładowania, próba załadowania kończy się niepowodzeniem. Taka sytuacja może wystąpić, gdy zestaw jest deserializacji.  
  
-   Jeśli zestaw jest ładowany z <xref:System.Reflection.Assembly.LoadFrom%2A>, i ścieżki próbkowania zawiera zestaw o tej samej tożsamości, ale inną lokalizację, <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, lub mogą występować inne nieoczekiwane zachowania.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> wymagania <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> i <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, lub <xref:System.Net.WebPermission>, w określonej ścieżce.  
  
-   Jeśli istnieje obrazu macierzystego dla `assemblyFile`, nie jest używany. Zestaw nie może być załadowany jako neutralny dla domen.  
  
-   W programie .NET Framework w wersji 1.0, 1.1 nie są stosowane zasady.  
  
 To, czy określone uprawnienia są przyznane do zestawu, czy nie, zależy od dowodów. Zasady scalania kompilowania asemblera i dowodów zabezpieczeń są następujące:  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.LoadFrom%2A> metody bez <xref:System.Security.Policy.Evidence> parametru zestaw jest ładowany dowody, który dostarcza modułu ładującego.  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.LoadFrom%2A> metody z <xref:System.Security.Policy.Evidence> parametru części dowód są łączone ze sobą. Elementy dowody dostarczone jako argument <xref:System.Reflection.Assembly.LoadFrom%2A> metody zastępują elementy dowody dostarczone przez moduł ładujący.  
  
-   Jeśli ta metoda jest wywoływana więcej niż raz w tym samym zestawie, ale z inną dowód, określony, środowisko uruchomieniowe języka wspólnego nie zgłasza <xref:System.IO.FileLoadException> ponieważ równości i integralności specyfikacji różnych dowód nie może być określony. Używanym dowodem jest dowód na to, że odniesie się sukces za pierwszym razem.  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.LoadFrom%2A> metody z `Byte[]` parametru załadować wspólnych obiektu pliku formatu (COFF) obraz, dowód jest połączona. `Zone`, `Url` i `Site` są dziedziczone z wywołującego zestawu i `Hash` i `StrongName` są pobierane z zestawu COFF.  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.LoadFrom%2A> metody z `Byte[]` parametru i <xref:System.Security.Policy.Evidence> można załadować obrazu COFF, jest używany tylko dowód dostarczony. Dowód wywołującego zestawu i dokumenty obrazu COFF jest ignorowana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> nie zostanie znaleziony, lub próby załadowania modułu nie określa rozszerzenie nazwy pliku.</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.  - lub - <paramref name="securityEvidence" /> nie jest niejednoznaczne i określone jest nieprawidłowy.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem; na przykład zestawem 32-bitowe w procesie 64-bitowych. Zobacz temat wyjątek, aby uzyskać więcej informacji.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.Security.SecurityException">Codebase, który rozpoczyna się od "file://" został określony bez wymaganego <see cref="T:System.Net.WebPermission" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> Parametr jest pustym ciągiem ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Nazwa zestawu przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania identyfikatora URI, który rozpoczyna się od "file://". Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa lub ścieżka pliku, który zawiera manifest zestawu.</param>
        <param name="hashValue">Wartość obliczana wartość skrótu.</param>
        <param name="hashAlgorithm">Algorytm wyznaczania wartości skrótu używany do tworzenia skrótów plików, a także do generowania silnej nazwy.</param>
        <summary>Ładuje zestaw podana nazwa pliku lub ścieżka, wartość skrótu i algorytmu wyznaczania wartości skrótu.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile` Parametru musi odwoływać się do identyfikatora URI bez znaki specjalne. Ta metoda zawiera znaki specjalne dla wszystkich nieprawidłowe znaki w identyfikatorze URI.  
  
> [!NOTE]
>  Protokół transferu plików (FTP) nie jest obsługiwana. Jeśli podany identyfikator URI dla `assemblyFile` adres FTP zestaw nie został załadowany. Nie wyjątek.  
  
 `assemblyFile` może być bezwzględny lub względny w bieżącym katalogu i zestaw jest ładowany do domeny obiektu wywołującego.  
  
 Zestawy mogą być ładowane do jednego z trzech kontekstów lub może być załadowany bez kontekstu:  
  
-   W kontekście ładowania zawiera zestawy znalezione przez sondowanie: w globalnej pamięci podręcznej zestawów, w zestawie hosta, jeśli jest obsługiwana przez środowisko uruchomieniowe i przechowywać w <xref:System.AppDomainSetup.ApplicationBase%2A> i <xref:System.AppDomainSetup.PrivateBinPath%2A> domeny aplikacji. Większość przeciążeń <xref:System.Reflection.Assembly.Load%2A> metody Ładuj zestawy w tym kontekście.  
  
-   Kontekst load-from zawiera zestawy, do których użytkownik podał ścieżki, które nie są uwzględnione w sondowanie. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, i <xref:System.AppDomain.ExecuteAssembly%2A> przedstawiono metody, które są ładowane przez ścieżkę.  
  
-   Kontekstu reflection-only zawiera zestawy ładowane z <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> i <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metod; kod w tych kontekstach nie można wykonać.  
  
-   Jeśli użytkownik generowany lub znaleziono zestaw, nie jest w dowolnym kontekście. Dotyczy to zestawy ładowane przy użyciu przeciążeń <xref:System.Reflection.Assembly.Load%2A> metodę Określ tablica bajtów zawierająca zestawu i aby przejściowych dynamicznych zestawów utworzonych za pomocą odbicia Emituj i nie zapisano na dysku.  
  
 Kontekst load-from umożliwia zestawu do załadowania ze ścieżki, które nie są uwzględnione w sondowanie i jeszcze umożliwia zależności na tej ścieżce odnaleźć i załadować, ponieważ informacje o ścieżce jest obsługiwana przez kontekst.  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A> Metoda ma następujące wady. Należy rozważyć użycie <xref:System.Reflection.Assembly.Load%2A> zamiast tego.  
  
-   Jeśli zestaw o tej samej tożsamości jest już załadowany, <xref:System.Reflection.Assembly.LoadFrom%2A> zwraca załadowany zestaw nawet wtedy, gdy określono inną ścieżkę.  
  
-   Jeśli zestaw jest ładowany z <xref:System.Reflection.Assembly.LoadFrom%2A>i później próbuje załadować tego samego zestawu według nazwy wyświetlanej zestawu w kontekście ładowania, próba załadowania kończy się niepowodzeniem. Taka sytuacja może wystąpić, gdy zestaw jest deserializacji.  
  
-   Jeśli zestaw jest ładowany z <xref:System.Reflection.Assembly.LoadFrom%2A>, i ścieżki próbkowania zawiera zestaw o tej samej tożsamości, ale inną lokalizację, <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, lub mogą występować inne nieoczekiwane zachowania.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> wymagania <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> i <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, lub <xref:System.Net.WebPermission>, w określonej ścieżce.  
  
-   Jeśli istnieje obrazu macierzystego dla `assemblyFile`, nie jest używany. Nie można załadować zestawu jako neutralne dla domen.  
  
 Zestaw jest ładowany dowody, który dostarcza modułu ładującego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> nie zostanie znaleziony, lub próby załadowania modułu nie określa rozszerzenie nazwy pliku.</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem; na przykład zestawem 32-bitowe w procesie 64-bitowych. Zobacz temat wyjątek, aby uzyskać więcej informacji.  - lub - <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji środowiska CLR niż wersja, który jest aktualnie załadowany.</exception>
        <exception cref="T:System.Security.SecurityException">Codebase, który rozpoczyna się od "file://" został określony bez wymaganego <see cref="T:System.Net.WebPermission" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> Parametr jest pustym ciągiem ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Nazwa zestawu przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania identyfikatora URI, który rozpoczyna się od "file://". Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa lub ścieżka pliku, który zawiera manifest zestawu.</param>
        <param name="securityEvidence">Dowód ładowania zestawu.</param>
        <param name="hashValue">Wartość obliczana wartość skrótu.</param>
        <param name="hashAlgorithm">Algorytm wyznaczania wartości skrótu używany do tworzenia skrótów plików, a także do generowania silnej nazwy.</param>
        <summary>Ładuje zestaw podana nazwa pliku lub ścieżka, dowodów zabezpieczeń, wartość skrótu i algorytmu wyznaczania wartości skrótu.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile` Parametru musi odwoływać się do identyfikatora URI bez znaki specjalne. Ta metoda zawiera znaki specjalne dla wszystkich nieprawidłowe znaki w identyfikatorze URI.  
  
> [!NOTE]
>  Protokół transferu plików (FTP) nie jest obsługiwana. Jeśli podany identyfikator URI dla `assemblyFile` adres FTP zestaw nie został załadowany. Nie wyjątek.  
  
 `assemblyFile` może być bezwzględny lub względny w bieżącym katalogu i zestaw jest ładowany do domeny obiektu wywołującego.  
  
 Zestawy mogą być ładowane do jednego z trzech kontekstów lub może być załadowany bez kontekstu:  
  
-   W kontekście ładowania zawiera zestawy znalezione przez sondowanie: w pamięci podręcznej GAC, w zestawie hosta, jeśli jest obsługiwana przez środowisko uruchomieniowe i przechowywać w <xref:System.AppDomainSetup.ApplicationBase%2A> i <xref:System.AppDomainSetup.PrivateBinPath%2A> domeny aplikacji. Większość przeciążeń <xref:System.Reflection.Assembly.Load%2A> metody Ładuj zestawy w tym kontekście.  
  
-   Kontekst load-from zawiera zestawy, do których użytkownik podał ścieżki nie jest uwzględniony w katalogach przeszukiwane przez sondowanie. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, i <xref:System.AppDomain.ExecuteAssembly%2A> przedstawiono metody, które są ładowane przez ścieżkę.  
  
-   Kontekstu reflection-only zawiera zestawy ładowane z <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> i <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metod; kod w tych kontekstach nie można wykonać.  
  
-   Jeśli użytkownik generowany lub znaleziono zestaw, nie jest w dowolnym kontekście. Dotyczy to zestawy ładowane przy użyciu przeciążeń <xref:System.Reflection.Assembly.Load%2A> metodę Określ tablica bajtów zawierająca zestawu i aby przejściowych dynamicznych zestawów utworzonych za pomocą odbicia Emituj i nie zapisano na dysku.  
  
 Kontekst load-from umożliwia zestawu do załadowania ze ścieżki nie jest uwzględniony w sondowanie i jeszcze umożliwia zależności na tej ścieżce odnaleźć i załadować, ponieważ informacje o ścieżce jest obsługiwana przez kontekst.  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A> Metoda ma następujące wady. Należy rozważyć użycie <xref:System.Reflection.Assembly.Load%2A> zamiast tego.  
  
-   Jeśli zestaw o tej samej tożsamości jest już załadowany, <xref:System.Reflection.Assembly.LoadFrom%2A> zwraca załadowany zestaw nawet wtedy, gdy określono inną ścieżkę.  
  
-   Jeśli zestaw jest ładowany z <xref:System.Reflection.Assembly.LoadFrom%2A>i później próbuje załadować tego samego zestawu według nazwy wyświetlanej zestawu w kontekście ładowania, próba załadowania kończy się niepowodzeniem. Taka sytuacja może wystąpić, gdy zestaw jest deserializacji.  
  
-   Jeśli zestaw jest ładowany z <xref:System.Reflection.Assembly.LoadFrom%2A>, i ścieżki próbkowania zawiera zestaw o tej samej tożsamości, ale inną lokalizację, <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, lub mogą występować inne nieoczekiwane zachowania.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> wymagania <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> i <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, lub <xref:System.Net.WebPermission>, w określonej ścieżce.  
  
-   Jeśli istnieje obrazu macierzystego dla `assemblyFile`, nie jest używany. Zestaw nie może być załadowany jako neutralny dla domen.  
  
-   W programie .NET Framework w wersji 1.0, 1.1 nie są stosowane zasady.  
  
 To, czy określone uprawnienia są przyznane do zestawu, czy nie, zależy od dowodów. Zasady scalania kompilowania asemblera i dowodów zabezpieczeń są następujące:  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.LoadFrom%2A> metody bez <xref:System.Security.Policy.Evidence> parametru zestaw jest ładowany dowody, który dostarcza modułu ładującego.  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.LoadFrom%2A> metody z <xref:System.Security.Policy.Evidence> parametru części dowód są łączone ze sobą. Elementy dowody dostarczone jako argument <xref:System.Reflection.Assembly.LoadFrom%2A> metody zastępują elementy dowody dostarczone przez moduł ładujący.  
  
-   Jeśli ta metoda jest wywoływana więcej niż raz w tym samym zestawie, ale z inną dowód, określony, środowisko uruchomieniowe języka wspólnego nie zgłasza <xref:System.IO.FileLoadException> ponieważ równości i integralności specyfikacji różnych dowód nie może być określony. Używanym dowodem jest dowód na to, że odniesie się sukces za pierwszym razem.  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.LoadFrom%2A> metody z `Byte[]` parametru załadować wspólnych obiektu pliku formatu (COFF) obraz, dowód jest połączona. `Zone`, `Url` i `Site` są dziedziczone z wywołującego zestawu i `Hash` i `StrongName` są pobierane z zestawu COFF.  
  
-   Jeśli używasz <xref:System.Reflection.Assembly.LoadFrom%2A> metody z `Byte[]` parametru i <xref:System.Security.Policy.Evidence> można załadować obrazu COFF, jest używany tylko dowód dostarczony. Dowód wywołującego zestawu i dokumenty obrazu COFF jest ignorowana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> nie zostanie znaleziony, lub próby załadowania modułu nie określa rozszerzenie nazwy pliku.</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.  - lub - <paramref name="securityEvidence" /> nie jest niejednoznaczne i określone jest nieprawidłowy.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem; na przykład zestawem 32-bitowe w procesie 64-bitowych. Zobacz temat wyjątek, aby uzyskać więcej informacji.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.Security.SecurityException">Codebase, który rozpoczyna się od "file://" został określony bez wymaganego <see cref="T:System.Net.WebPermission" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> Parametr jest pustym ciągiem ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Nazwa zestawu przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ładowanie zestawu z dowodem. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania identyfikatora URI, który rozpoczyna się od "file://". Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadModule">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładuje moduł wewnętrzny do tego zestawu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadModule (moduleName As String, rawModule As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">Nazwa modułu. Ten ciąg musi odpowiadać nazwie pliku w manifeście tego zestawu.</param>
        <param name="rawModule">Tablica bajtów to obraz na podstawie COFF zawierające moduł emitowany lub zasobu.</param>
        <summary>Ładuje moduł wewnętrzny do tego zestawu z typowych format pliku obiektu (COFF) — na podstawie obrazu zawierające moduł emitowany lub pliku zasobu.</summary>
        <returns>Załadować modułu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> lub <paramref name="rawModule" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="moduleName" /> wpis w pliku w manifeście ten zestaw nie jest zgodna.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawModule" /> nie jest prawidłowym modułem.</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LoadModule (moduleName As String, rawModule As Byte(), rawSymbolStore As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">Nazwa modułu. Ten ciąg musi odpowiadać nazwie pliku w manifeście tego zestawu.</param>
        <param name="rawModule">Tablica bajtów to obraz na podstawie COFF zawierające moduł emitowany lub zasobu.</param>
        <param name="rawSymbolStore">Tablica bajtów zawierająca raw bajtów reprezentujący symboli dla modułu. Musi być <see langword="null" /> , jeśli jest to plik zasobu.</param>
        <summary>Ładuje moduł wewnętrzny do tego zestawu z typowych format pliku obiektu (COFF) — na podstawie obrazu zawierające moduł emitowany lub pliku zasobu. Nieprzetworzona bajtów reprezentujący symboli dla modułu również są ładowane.</summary>
        <returns>Załadować modułu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> lub <paramref name="rawModule" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="moduleName" /> wpis w pliku w manifeście ten zestaw nie jest zgodna.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawModule" /> nie jest prawidłowym modułem.</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Dostarczanie dowodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadWithPartialName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładuje zestaw z katalogu aplikacji lub z globalnej pamięci podręcznej zestawów przy użyciu część nazwy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Przeciążeń <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> metody są przestarzałe i został zachowany na potrzeby zgodności z poprzednimi wersjami. Nieprzestarzała alternatywa to <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName partialName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partialName">Wyświetlana nazwa zestawu.</param>
        <summary>Ładuje zestaw z katalogu aplikacji lub z globalnej pamięci podręcznej zestawów przy użyciu część nazwy.</summary>
        <returns>Załadowany zestaw. Jeśli <paramref name="partialName" /> nie zostanie znaleziony, ta metoda zwraca <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29> Metoda jest przestarzała i została zatrzymana dla zgodności z poprzednimi wersjami. Nieprzestarzała alternatywa to <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.  
  
 Aplikacje, które ładować zestawów z tą metodą dotyczy uaktualnień tych zestawów. W związku z tym nie należy używać tej metody; zmodyfikowanie aplikacji na używanie <xref:System.Reflection.Assembly.Load%28System.String%29> przeciążenie metody lub <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> przeciążenie metody.  
  
 Ta metoda najpierw wywołuje <xref:System.Reflection.Assembly.Load%2A>. Jeśli zestaw nie zostanie znaleziony, ta metoda zwraca zestaw z globalnej pamięci podręcznej zestawów, który ma taką samą prostą nazwę i najwyższym numerze wersji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partialName" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="partialName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName (partialName, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="partialName">Wyświetlana nazwa zestawu.</param>
        <param name="securityEvidence">Dowód ładowania zestawu.</param>
        <summary>Ładuje zestaw z katalogu aplikacji lub z globalnej pamięci podręcznej zestawów przy użyciu część nazwy. Zestaw jest ładowany do domeny za pomocą dostarczonego dowód obiektu wywołującego.</summary>
        <returns>Załadowany zestaw. Jeśli <paramref name="partialName" /> nie zostanie znaleziony, ta metoda zwraca <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29> Metoda jest przestarzała i została zatrzymana dla zgodności z poprzednimi wersjami. Nieprzestarzała alternatywa to <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.  
  
 Dowód jest zbiorem informacji, który stanowi do decyzji dotyczących zasad zabezpieczeń, takich jak uprawnienia wejściowy może zostać przydzielony do kodu.  
  
 Aplikacje, które ładować zestawów z tą metodą dotyczy uaktualnień tych zestawów. W związku z tym nie należy używać tej metody; zmodyfikowanie aplikacji na używanie <xref:System.Reflection.Assembly.Load%2A> metody lub <xref:System.Reflection.Assembly.LoadFrom%2A> metody.  
  
 Ta metoda najpierw wywołuje <xref:System.Reflection.Assembly.Load%2A>. Jeśli zestaw nie zostanie znaleziony, ta metoda zwraca zestaw z globalnej pamięci podręcznej zestawów, który ma taką samą prostą nazwę i najwyższym numerze wersji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Dwa razy z dwóch różnych zestawów dowód załadowania zestawu lub modułu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partialName" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="partialName" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie kodu niezarządzanego i załadowania zestawu z dowód. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Location" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Location As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Location { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Location : string" Usage="System.Reflection.Assembly.Location" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Location</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pełną ścieżkę lub lokalizacji UNC załadować pliku, który zawiera plik manifestu.</summary>
        <value>Lokalizacja załadować pliku, który zawiera plik manifestu. Jeśli załadowany plik został skopiowany w tle, lokalizacja jest plikiem po skopiować w tle. Jeśli zestaw jest ładowany z tablicy bajtów, takie jak kiedy przy użyciu <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /> przeciążenie metody, wartość zwracana jest pustym ciągiem ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać lokalizację, zanim plik został skopiowany w tle, należy użyć <xref:System.Reflection.Assembly.CodeBase%2A> właściwości.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono lokalizację załadować pliku, który zawiera plik manifestu.  
  
 [!code-cpp[System.Reflection.Assembly#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#3)]
 [!code-csharp[System.Reflection.Assembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#3)]
 [!code-vb[System.Reflection.Assembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Bieżący zestaw jest zestawie dynamicznym reprezentowany przez <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> obiektu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do ścieżki. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ManifestModule" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ManifestModule As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ ManifestModule { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ManifestModule : System.Reflection.Module" Usage="System.Reflection.Assembly.ManifestModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł, który zawiera manifest dla bieżącego zestawu.</summary>
        <value>Moduł, który zawiera manifest zestawu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleResolve">
      <MemberSignature Language="C#" Value="public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Reflection.ModuleResolveEventHandler ModuleResolve" />
      <MemberSignature Language="DocId" Value="E:System.Reflection.Assembly.ModuleResolve" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Custom Event ModuleResolve As ModuleResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Reflection::ModuleResolveEventHandler ^ ModuleResolve;" />
      <MemberSignature Language="F#" Value="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " Usage="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Runtime.InteropServices._Assembly.ModuleResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ModuleResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy moduł ładujący klasy wspólne środowiska wykonawczego języka nie można rozpoznać odwołania do wewnętrznego modułu zestawu za pomocą normalny sposób.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie zawiera wywołanie zwrotne szansę, aby odnaleźć i załadować samego modułu i przywrócić go.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Modules" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Modules As IEnumerable(Of Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ Modules { System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : seq&lt;System.Reflection.Module&gt;" Usage="System.Reflection.Assembly.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję, która zawiera moduły, w tym zestawie.</summary>
        <value>Kolekcja, która zawiera moduły, w tym zestawie.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">Zestaw do porównania <c>prawo</c>.</param>
        <param name="right">Zestaw do porównania <c>po lewej stronie</c>.</param>
        <summary>Wskazuje, czy dwa <see cref="T:System.Reflection.Assembly" /> obiekty są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="System.Reflection.Assembly.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">Zestaw do porównania <c>prawo</c>.</param>
        <param name="right">Zestaw do porównania <c>po lewej stronie</c>.</param>
        <summary>Wskazuje, czy dwa <see cref="T:System.Reflection.Assembly" /> obiekty nie są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> nie jest równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.Reflection.Assembly.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zestaw grant bieżącego zestawu.</summary>
        <value>Zestaw grant bieżącego zestawu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet> obiekty mogą zawierać poufne informacje, takie jak ścieżki. W związku z tym pełnego zaufania jest wymagany dostęp do tych obiektów.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ReflectionOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReflectionOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ReflectionOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnly : bool" Usage="System.Reflection.Assembly.ReflectionOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Boolean" /> wartość wskazującą, czy ten zestaw został załadowany do kontekstu reflection-only.</summary>
        <value>
          <see langword="true" /> Jeśli zestaw został załadowany do kontekstu reflection-only zamiast kontekstu wykonywania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw został załadowany do kontekstu reflection-only, przy użyciu <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> metody, nie można wykonać kod w zestawie. Wykonanie kodu, zestaw muszą być załadowane do kontekstu wykonywania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReflectionOnlyLoad">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładuje zestawu do kontekstu reflection-only, gdzie można zbadać, ale nie wykonano.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tablica bajtów, która jest obrazem w formacie COFF, zawierającym emitowany zestaw.</param>
        <summary>Ładuje zestaw z typowych format pliku obiektu (COFF)-emitowany zestawu zawierającego obraz. Zestaw jest ładowany do kontekstu reflection-only domeny aplikacji obiektu wywołującego.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można wykonać kod w zestawie załadowanym do kontekstu reflection-only. Wykonanie kodu, zestaw muszą zostać załadowane do kontekstu wykonywania również przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody.  
  
 Kontekstu reflection-only nie różni się od innych kontekstach. Zestawy, które są ładowane w kontekście może zostać zwolniona tylko przez zwalnianie domen aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="rawAssembly" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="rawAssembly" /> Nie można go załadować.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Nazwa wyświetlana zestawu zwrócony przez <see cref="P:System.Reflection.AssemblyName.FullName" /> właściwości.</param>
        <summary>Ładuje zestaw do kontekstu reflection-only podanej nazwy wyświetlanej.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zależności nie są ładowane automatycznie do kontekstu reflection-only.  
  
 Nie można wykonać kod w zestawie załadowanym do kontekstu reflection-only. Wykonanie kodu, zestaw muszą zostać załadowane do kontekstu wykonywania również przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody.  
  
 To, czy określone uprawnienia są przyznane do zestawu, czy nie, zależy od dowodów. Zasady scalania kompilowania asemblera i dowodów zabezpieczeń są następujące:  
  
> [!NOTE]
>  Zdarzenie odzwierciedla na pliki wykonywalne skompilowany w języku C++ może zgłosić <xref:System.IO.FileLoadException>. Jest to najprawdopodobniej spowodowane przez kompilator języka C++, usuwanie adresy relokacji lub sekcji .reloc z pliku wykonywalnego. Aby zachować adres .reloc, określ `/fixed:no` gdy połączenie jest ustanawiane.  
  
 Kontekstu reflection-only nie różni się od innych kontekstach. Zestawy, które są ładowane w kontekście może zostać zwolniona tylko przez zwalnianie domen aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" /> to ciąg pusty ("").</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> Nie znaleziono.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyString" /> został znaleziony, lecz nie może zostać załadowany.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyString" /> został skompilowany przy użyciu nowszej wersji.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Ścieżka pliku, który zawiera manifest zestawu.</param>
        <summary>Ładuje zestaw do kontekstu reflection-only podanej ścieżki.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zależności nie są ładowane automatycznie do kontekstu reflection-only. Automatyczne ładowanie zależności, obsługi <xref:System.AppDomain.ReflectionOnlyAssemblyResolve> zdarzeń i obciążenia zależności w obsłudze zdarzeń.  
  
 Nie można uruchomić kod z zestawu, który został załadowany do kontekstu reflection-only. Do wykonania kodu, załadować zestawu z <xref:System.Reflection.Assembly.LoadFile%2A> metody.  
  
 `assemblyFile` Parametru musi odwoływać się do identyfikatora URI bez znaki specjalne. Ta metoda zawiera znaki specjalne dla wszystkich nieprawidłowe znaki w identyfikatorze URI.  
  
 Ścieżka określona dla `assemblyFile` jest względne wobec bieżącego katalogu. Zestaw jest ładowany do domeny obiektu wywołującego.  
  
 Kontekstu reflection-only nie różni się od innych kontekstach. Zestawy, które są ładowane w kontekście może zostać zwolniona tylko przez zwalnianie domen aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> nie zostanie znaleziony, lub próby załadowania modułu nie określa rozszerzenie nazwy pliku.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyFile" /> został znaleziony, lecz nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji.</exception>
        <exception cref="T:System.Security.SecurityException">Codebase, który rozpoczyna się od "file://" został określony bez wymaganego <see cref="T:System.Net.WebPermission" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Nazwa zestawu przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> to ciąg pusty ("").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania identyfikatora URI, który rozpoczyna się od "file://". Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.SecurityRuleSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SecurityRuleSet As SecurityRuleSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::SecurityRuleSet SecurityRuleSet { System::Security::SecurityRuleSet get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityRuleSet : System.Security.SecurityRuleSet" Usage="System.Reflection.Assembly.SecurityRuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, który zestaw zabezpieczeń zasady środowisko uruchomieniowe języka wspólnego (CLR) wymusza dla tego zestawu.</summary>
        <value>Zestaw reguł zabezpieczeń, który wymusza CLR dla tego zestawu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie, zestawy, które kompilacji z [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ma przezroczystości, mimo że jawnie uczynić je w zamian. Zestawy, które zostały skompilowane z wcześniejszymi wersjami programu .NET Framework ma przezroczystość poziomu 1.  
  
 Zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Assembly.GetType">
      <MemberSignature Language="C#" Value="Type _Assembly.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._Assembly.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _Assembly.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._Assembly.GetType() = System::Runtime::InteropServices::_Assembly::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca typ bieżącego wystąpienia.</summary>
        <returns>Obiekt reprezentujący <see cref="T:System.Reflection.Assembly" /> typu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="assembly.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca pełną nazwę zestawu, znanej także jako nazwa wyświetlana.</summary>
        <returns>Pełna nazwa zestawu lub nazwę klasy, jeśli nie można określić pełną nazwę zestawu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly UnsafeLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ UnsafeLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member UnsafeLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.UnsafeLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa lub ścieżka pliku, który zawiera manifest zestawu.</param>
        <summary>Ładuje zestaw w kontekście ładowania z, pomijanie niektórych kontroli zabezpieczeń.</summary>
        <returns>Załadowany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody można załadować zestawu lokalnego, który system operacyjny został oznaczony jako została załadowana z sieci Web (na przykład tymczasowego pliku, który został pobrany z Internetu lub intranetu). Przed [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], takie zestawy zostały automatycznie załadowany w domenie aplikacji piaskownicy. Począwszy od [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], są załadowane z pełnym zaufaniem.  
  
 Alternatywą wobec za pomocą tej metody można zastosować [ &lt;NetFx40_LegacySecurityPolicy&gt; elementu](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md) w pliku konfiguracyjnym aplikacji. Powoduje to plików wykonywalnych języka przywrócić zasady zabezpieczeń [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
> [!CAUTION]
>  Jeśli używasz jednego z tych rozwiązań, należy się upewnić, bezpiecznego załadować `assemblyFile` przy pełnym zaufaniu.  
  
 Omówienie kontekstów obciążenia, w tym kontekst load-from zobacz <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> przeciążenie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> nie zostanie znaleziony, lub próby załadowania modułu nie określa rozszerzenie nazwy pliku.</exception>
        <exception cref="T:System.IO.FileLoadException">Nie można załadować pliku, który został znaleziony.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  - lub - <paramref name="assemblyFile" /> został skompilowany przy użyciu nowszej wersji środowiska CLR niż wersja, który jest aktualnie załadowany.</exception>
        <exception cref="T:System.Security.SecurityException">Codebase, który rozpoczyna się od "file://" został określony bez wymaganego <see cref="T:System.Net.WebPermission" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> Parametr jest pustym ciągiem ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Nazwa zestawu przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
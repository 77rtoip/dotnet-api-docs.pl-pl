<Type Name="MethodBase" FullName="System.Reflection.MethodBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="23a44364925adaf0829ea5e88e965e5261874844" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69276141" /></Metadata><TypeSignature Language="C#" Value="public abstract class MethodBase : System.Reflection.MemberInfo, System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit MethodBase extends System.Reflection.MemberInfo implements class System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.MethodBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MethodBase&#xA;Inherits MemberInfo&#xA;Implements _MethodBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBase abstract : System::Reflection::MemberInfo, System::Runtime::InteropServices::_MethodBase" />
  <TypeSignature Language="F#" Value="type MethodBase = class&#xA;    inherit MemberInfo&#xA;    interface _MethodBase" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodBase</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBase))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="5aedc-101">Zawiera informacje o metodach i konstruktorach.</span><span class="sxs-lookup"><span data-stu-id="5aedc-101">Provides information about methods and constructors.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-102">`MethodBase`jest klasą <xref:System.Reflection.MethodInfo> bazową i <xref:System.Reflection.ConstructorInfo>.</span><span class="sxs-lookup"><span data-stu-id="5aedc-102">`MethodBase` is the base class of <xref:System.Reflection.MethodInfo> and <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="5aedc-103">aby uzyskać pełne zaufanie dla obiektów dziedziczących.</span><span class="sxs-lookup"><span data-stu-id="5aedc-103">for full trust for inheritors.</span></span> <span data-ttu-id="5aedc-104">Klasa ta nie może być dziedziczona przez kod częściowo zaufany.</span><span class="sxs-lookup"><span data-stu-id="5aedc-104">This class cannot be inherited by partially trusted code.</span></span></permission>
    <threadsafe><span data-ttu-id="5aedc-105">Ten typ jest bezpieczny wątkowo.</span><span class="sxs-lookup"><span data-stu-id="5aedc-105">This type is thread safe.</span></span></threadsafe>
    <block subset="none" type="overrides"><para><span data-ttu-id="5aedc-106">Gdy dziedziczysz z <see langword="MethodBase" />, musisz zastąpić następujące elementy członkowskie: <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" /> <see cref="P:System.Reflection.MethodBase.MethodHandle" /> <see cref="M:System.Reflection.MethodBase.GetParameters" /> <see cref="P:System.Reflection.MethodBase.Attributes" /> <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /> ,<see cref="P:System.Reflection.MemberInfo.MemberType" /> ,,<see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> ,,,,,, <see cref="P:System.Reflection.MemberInfo.ReflectedType" /> <see cref="P:System.Reflection.MemberInfo.Name" /> <see cref="P:System.Reflection.MemberInfo.DeclaringType" /> , <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />i .<see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /></span><span class="sxs-lookup"><span data-stu-id="5aedc-106">When you inherit from <see langword="MethodBase" />, you must override the following members: <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, and <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />.</span></span></para></block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5aedc-107">Inicjuje nowe wystąpienie klasy <see cref="T:System.Reflection.MethodBase" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="5aedc-107">Initializes a new instance of the <see cref="T:System.Reflection.MethodBase" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="5aedc-108">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="5aedc-108">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="5aedc-109">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="5aedc-109">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.MethodBase.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-110">Pobiera atrybuty skojarzone z tą metodą.</span><span class="sxs-lookup"><span data-stu-id="5aedc-110">Gets the attributes associated with this method.</span></span></summary>
        <value><span data-ttu-id="5aedc-111">Jedna z <see cref="T:System.Reflection.MethodAttributes" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="5aedc-111">One of the <see cref="T:System.Reflection.MethodAttributes" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-112">Wszystkie składowe mają zestaw atrybutów, które są zdefiniowane w odniesieniu do określonego typu elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="5aedc-112">All members have a set of attributes, which are defined in relation to the specific type of member.</span></span>  
  
 <span data-ttu-id="5aedc-113">Aby uzyskać <xref:System.Reflection.MethodAttributes>, najpierw Pobierz typ.</span><span class="sxs-lookup"><span data-stu-id="5aedc-113">To get the <xref:System.Reflection.MethodAttributes>, first get the type.</span></span> <span data-ttu-id="5aedc-114">Z typu należy uzyskać metodę.</span><span class="sxs-lookup"><span data-stu-id="5aedc-114">From the type, get the method.</span></span> <span data-ttu-id="5aedc-115">Z metody Pobierz <xref:System.Reflection.MethodAttributes>.</span><span class="sxs-lookup"><span data-stu-id="5aedc-115">From the method, get the <xref:System.Reflection.MethodAttributes>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5aedc-116">Poniższy przykład kodu wyświetla atrybuty metody metoda zdefiniowana przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="5aedc-116">The following code example displays the attributes of the user-defined method Mymethod.</span></span>  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 <span data-ttu-id="5aedc-117">Ten kod generuje następujące dane wyjściowe:</span><span class="sxs-lookup"><span data-stu-id="5aedc-117">This code produces the following output:</span></span>  
  
 <span data-ttu-id="5aedc-118">Przykład odbicia. element MethodBase. Attributes</span><span class="sxs-lookup"><span data-stu-id="5aedc-118">Reflection.MethodBase.Attributes Sample</span></span>  
  
 <span data-ttu-id="5aedc-119">Mymethodbase = void nomethod (Int32, system. String ByRef, system. String ByRef)</span><span class="sxs-lookup"><span data-stu-id="5aedc-119">Mymethodbase = Void Mymethod(Int32, System.String ByRef, System.String ByRef)</span></span>  
  
 <span data-ttu-id="5aedc-120">PrivateScope</span><span class="sxs-lookup"><span data-stu-id="5aedc-120">PrivateScope</span></span>  
  
 <span data-ttu-id="5aedc-121">FamANDAssem</span><span class="sxs-lookup"><span data-stu-id="5aedc-121">FamANDAssem</span></span>  
  
 <span data-ttu-id="5aedc-122">Rodzina</span><span class="sxs-lookup"><span data-stu-id="5aedc-122">Family</span></span>  
  
 <span data-ttu-id="5aedc-123">Public</span><span class="sxs-lookup"><span data-stu-id="5aedc-123">Public</span></span>  
  
 <span data-ttu-id="5aedc-124">HideBySig</span><span class="sxs-lookup"><span data-stu-id="5aedc-124">HideBySig</span></span>  
  
 <span data-ttu-id="5aedc-125">ReuseSlot</span><span class="sxs-lookup"><span data-stu-id="5aedc-125">ReuseSlot</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="5aedc-126"><see langword="virtual" /> <see langword="final" /> <see langword="private" /> <see langword="public" />Użyj właściwości, aby określić, czy metoda jest,,, i tak dalej. <see cref="P:System.Reflection.MethodBase.Attributes" /></span><span class="sxs-lookup"><span data-stu-id="5aedc-126">Use the <see cref="P:System.Reflection.MethodBase.Attributes" /> property to determine whether a method is <see langword="public" />, <see langword="private" />, <see langword="final" />, <see langword="virtual" />, and so on.</span></span></para></block>
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.MethodBase.CallingConvention" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.CallingConvention</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-127">Pobiera wartość wskazującą konwencje wywoływania dla tej metody.</span><span class="sxs-lookup"><span data-stu-id="5aedc-127">Gets a value indicating the calling conventions for this method.</span></span></summary>
        <value><span data-ttu-id="5aedc-128"><see cref="T:System.Reflection.CallingConventions" /> Dla tej metody.</span><span class="sxs-lookup"><span data-stu-id="5aedc-128">The <see cref="T:System.Reflection.CallingConventions" /> for this method.</span></span></value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Reflection.CallingConventions" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Reflection.MethodBase.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-129">Pobiera wartość wskazującą, czy metoda generyczna zawiera nieprzypisane parametry typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="5aedc-129">Gets a value indicating whether the generic method contains unassigned generic type parameters.</span></span></summary>
        <value><span data-ttu-id="5aedc-130"><see langword="true" />Jeśli bieżący <see cref="T:System.Reflection.MethodBase" /> obiekt reprezentuje metodę rodzajową, która zawiera nieprzypisane parametry typu ogólnego; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-130"><see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> object represents a generic method that contains unassigned generic type parameters; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-131">Metoda generyczna może być wywoływana tylko wtedy, gdy nie istnieją definicje typów ogólnych lub nie można otwierać typów skonstruowanych w argumentach typu samej metody lub w żadnym typie otaczającym.</span><span class="sxs-lookup"><span data-stu-id="5aedc-131">A generic method can be invoked only if there are no generic type definitions or open constructed types in the type arguments of the method itself or in any enclosing types.</span></span> <span data-ttu-id="5aedc-132">Ponieważ typy mogą być arbitralnie skomplikowane, wykonywanie tego cyklicznego wyznaczania jest trudne.</span><span class="sxs-lookup"><span data-stu-id="5aedc-132">Because types can be arbitrarily complex, making this recursive determination is difficult.</span></span> <span data-ttu-id="5aedc-133">Dla wygody i zmniejszenia prawdopodobieństwa wystąpienia błędu <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> Właściwość zapewnia standardowy sposób odróżnienia od zamkniętych metod skonstruowanych, które mogą być wywoływane i otwierać metody skonstruowane, które nie mogą.</span><span class="sxs-lookup"><span data-stu-id="5aedc-133">For convenience, and to reduce the chance of error, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed methods, which can be invoked, and open constructed methods, which cannot.</span></span> <span data-ttu-id="5aedc-134">Jeśli właściwość zwróci wartość `true`, nie można wywołać metody. <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A></span><span class="sxs-lookup"><span data-stu-id="5aedc-134">If the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`, the method cannot be invoked.</span></span>  
  
 <span data-ttu-id="5aedc-135"><xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> Właściwość przeszukuje rekursywnie dla parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-135">The <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property searches recursively for type parameters.</span></span> <span data-ttu-id="5aedc-136">Na przykład zwraca `true` dla każdej metody w otwartym typie `A<T>` (`A(Of T)` w Visual Basic), mimo że sama metoda nie jest rodzajowa.</span><span class="sxs-lookup"><span data-stu-id="5aedc-136">For example, it returns `true` for any method in an open type `A<T>` (`A(Of T)` in Visual Basic), even though the method itself is not generic.</span></span> <span data-ttu-id="5aedc-137">Jest to kontrast z zachowaniem <xref:System.Reflection.MethodBase.IsGenericMethod%2A> właściwości, która zwraca `false` dla tej metody.</span><span class="sxs-lookup"><span data-stu-id="5aedc-137">Contrast this with the behavior of the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property, which returns `false` for such a method.</span></span>  
  
 <span data-ttu-id="5aedc-138">Analogicznie, <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> parametr właściwości zwraca `true` dla dowolnego konstruktora w otwartym typie, chociaż konstruktory nie mogą mieć własnych parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-138">Similarly, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property parameter returns `true` for any constructor in an open type, even though constructors cannot have type parameters of their own.</span></span>  
  
 <span data-ttu-id="5aedc-139">Aby zapoznać się z listą warunków niewariantów dla warunków specyficznych dla metod ogólnych, <xref:System.Reflection.MethodBase.IsGenericMethod%2A> Zobacz właściwość.</span><span class="sxs-lookup"><span data-stu-id="5aedc-139">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="5aedc-140">Aby uzyskać listę niezmiennych warunków dla innych terminów używanych w odbiciu ogólnym, zobacz <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> właściwość.</span><span class="sxs-lookup"><span data-stu-id="5aedc-140">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="methodBase.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="5aedc-141">Obiekt, <see langword="null" />który ma zostać porównany z tym wystąpieniem.</span><span class="sxs-lookup"><span data-stu-id="5aedc-141">An object to compare with this instance, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="5aedc-142">Zwraca wartość wskazującą, czy to wystąpienie jest równe podanemu obiektowi.</span><span class="sxs-lookup"><span data-stu-id="5aedc-142">Returns a value that indicates whether this instance is equal to a specified object.</span></span></summary>
        <returns><span data-ttu-id="5aedc-143"><see langword="true" />Jeśli <paramref name="obj" /> jest równa typu i wartości tego wystąpienia; w przeciwnym <see langword="false" />razie,.</span><span class="sxs-lookup"><span data-stu-id="5aedc-143"><see langword="true" /> if <paramref name="obj" /> equals the type and value of this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetCurrentMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetCurrentMethod() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetCurrentMethod" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentMethod () As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetCurrentMethod();" />
      <MemberSignature Language="F#" Value="static member GetCurrentMethod : unit -&gt; System.Reflection.MethodBase" Usage="System.Reflection.MethodBase.GetCurrentMethod " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5aedc-144"><see langword="MethodBase" /> Zwraca obiekt reprezentujący aktualnie wykonywaną metodę.</span><span class="sxs-lookup"><span data-stu-id="5aedc-144">Returns a <see langword="MethodBase" /> object representing the currently executing method.</span></span></summary>
        <returns><span data-ttu-id="5aedc-145"><see cref="M:System.Reflection.MethodBase.GetCurrentMethod" />to metoda statyczna, która jest wywoływana z poziomu metody wykonującej i która zwraca informacje o tej metodzie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-145"><see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /> is a static method that is called from within an executing method and that returns information about that method.</span></span>  
  
<span data-ttu-id="5aedc-146"><see langword="MethodBase" /> Obiekt reprezentujący aktualnie wykonywaną metodę.</span><span class="sxs-lookup"><span data-stu-id="5aedc-146">A <see langword="MethodBase" /> object representing the currently executing method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-147">Jeśli aktualnie wykonywana metoda jest zdefiniowana w typie <xref:System.Reflection.MethodInfo> ogólnym, zwracany przez <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> jest uzyskiwany z definicji typu ogólnego (oznacza to, <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType> zwraca `true`).</span><span class="sxs-lookup"><span data-stu-id="5aedc-147">If the currently executing method is defined on a generic type, the <xref:System.Reflection.MethodInfo> that is returned by <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> is obtained from the generic type definition (that is, <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType> returns `true`).</span></span> <span data-ttu-id="5aedc-148">W związku z tym nie odzwierciedla argumentów typu, które były używane podczas wywoływania metody.</span><span class="sxs-lookup"><span data-stu-id="5aedc-148">Therefore, it does not reflect the type arguments that were used when the method was called.</span></span> <span data-ttu-id="5aedc-149">Na `M()` przykład jeśli metoda jest zdefiniowana w typie `C<T>` ogólnym (`C(Of T)` w Visual Basic) i <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> jest wywoływana z `C<string>.M()`, następnie <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> zwraca `C<T>.M()` (`C(Of T).M()` w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="5aedc-149">For example, if a method `M()` is defined on a generic type `C<T>` (`C(Of T)` in Visual Basic), and <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> is called from `C<string>.M()`, then <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> returns `C<T>.M()` (`C(Of T).M()` in Visual Basic).</span></span>  
  
 <span data-ttu-id="5aedc-150">Jeśli aktualnie wykonywana metoda jest metodą rodzajową, <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> zwraca definicję metody ogólnej.</span><span class="sxs-lookup"><span data-stu-id="5aedc-150">If the currently executing method is a generic method, <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> returns the generic method definition.</span></span> <span data-ttu-id="5aedc-151">Jeśli metoda generyczna jest zdefiniowana w typie ogólnym, <xref:System.Reflection.MethodInfo> jest uzyskiwana z definicji typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="5aedc-151">If the generic method is defined on a generic type, the <xref:System.Reflection.MethodInfo> is obtained from the generic type definition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5aedc-152">W poniższym przykładzie zdefiniowano dwa typy.</span><span class="sxs-lookup"><span data-stu-id="5aedc-152">The following example defines two types.</span></span> <span data-ttu-id="5aedc-153">Pierwszy jest klasą nieogólną, `TestClass`, zawiera Konstruktor, metodę o nazwie `GetValue`i właściwość do odczytu i zapisu o nazwie `GetValue`.</span><span class="sxs-lookup"><span data-stu-id="5aedc-153">The first is a non-generic class, `TestClass`, includes a constructor, a method named `GetValue`, and a read-write property named `GetValue`.</span></span> <span data-ttu-id="5aedc-154">Druga jest klasą generyczną o `TestClass<T>` nazwie, która zawiera Konstruktor `GetValue` , metodę `ConvertValue<Y>`i metodę rodzajową.</span><span class="sxs-lookup"><span data-stu-id="5aedc-154">The second is a generic class named `TestClass<T>` that includes a constructor, a `GetValue` method, and a generic method, `ConvertValue<Y>`.</span></span> <span data-ttu-id="5aedc-155">Każdy akcesor konstruktora, metody i właściwości zawiera wywołanie <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="5aedc-155">Each constructor, method, and property accessor includes a call to the <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> method.</span></span>  
  
 [!code-csharp[System.Reflection.MethodBase.GetCurrentMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/cs/GetCurentMethod1.cs#1)]
 [!code-vb[System.Reflection.MethodBase.GetCurrentMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/vb/GetCurentMethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="5aedc-156">Ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</span><span class="sxs-lookup"><span data-stu-id="5aedc-156">This member was invoked with a late-binding mechanism.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="5aedc-157">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="5aedc-157">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="5aedc-158">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="5aedc-158">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="methodBase.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5aedc-159">Zwraca tablicę <see cref="T:System.Type" /> obiektów, która reprezentuje argumenty typu metody ogólnej lub parametry typu definicji metody ogólnej.</span><span class="sxs-lookup"><span data-stu-id="5aedc-159">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span></span></summary>
        <returns><span data-ttu-id="5aedc-160">Tablica <see cref="T:System.Type" /> obiektów, która reprezentuje argumenty typu metody ogólnej lub parametry typu definicji metody ogólnej.</span><span class="sxs-lookup"><span data-stu-id="5aedc-160">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span></span> <span data-ttu-id="5aedc-161">Zwraca pustą tablicę, jeśli bieżąca metoda nie jest metodą rodzajową.</span><span class="sxs-lookup"><span data-stu-id="5aedc-161">Returns an empty array if the current method is not a generic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-162">Elementy tablicy zwracanej są w kolejności, w jakiej są wyświetlane na liście parametrów typu dla metody ogólnej.</span><span class="sxs-lookup"><span data-stu-id="5aedc-162">The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</span></span>  
  
-   <span data-ttu-id="5aedc-163">Jeśli bieżąca metoda jest zamkniętą metodą skonstruowaną (oznacza to, <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> że właściwość zwraca wartość `false`), tablica zwracana przez <xref:System.Reflection.MethodBase.GetGenericArguments%2A> metodę zawiera typy, które zostały przypisane do parametrów typu ogólnego metody ogólnej. definicji.</span><span class="sxs-lookup"><span data-stu-id="5aedc-163">If the current method is a closed constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Reflection.MethodBase.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic method definition.</span></span>  
  
-   <span data-ttu-id="5aedc-164">Jeśli bieżąca metoda jest definicją metody ogólnej, tablica zawiera parametry typu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-164">If the current method is a generic method definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="5aedc-165">Jeśli bieżąca metoda to otwarta metoda skonstruowana (oznacza to, <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> że właściwość zwraca `true`), w której określone typy zostały przypisane do niektórych parametrów typu, a parametry typu otaczających typy zostały przypisane do innego typu parametry, tablica zawiera typy i parametry typu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-165">If the current method is an open constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</span></span> <span data-ttu-id="5aedc-166">Użyj właściwości <xref:System.Type.IsGenericParameter%2A> , aby odróżnić je od siebie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-166">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="5aedc-167">Aby zapoznać się z prezentacją tego scenariusza, zobacz przykład kodu podany dla <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="5aedc-167">For a demonstration of this scenario, see the code example provided for the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="5aedc-168">Konstruktory generyczne nie są obsługiwane w .NET Framework w wersji 2,0.</span><span class="sxs-lookup"><span data-stu-id="5aedc-168">Generic constructors are not supported in the .NET Framework version 2.0.</span></span> <span data-ttu-id="5aedc-169">Ta właściwość zwraca <xref:System.NotSupportedException> wartość, jeśli nie została przesłonięta w klasie pochodnej, więc wyjątek jest zgłaszany, jeśli bieżące <xref:System.Reflection.ConstructorInfo>wystąpienie jest typu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-169">This property throws <xref:System.NotSupportedException> if not overridden in a derived class, so an exception is thrown if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 <span data-ttu-id="5aedc-170">Aby zapoznać się z listą warunków niewariantów dla warunków specyficznych dla metod ogólnych, <xref:System.Reflection.MethodBase.IsGenericMethod%2A> Zobacz właściwość.</span><span class="sxs-lookup"><span data-stu-id="5aedc-170">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="5aedc-171">Aby uzyskać listę niezmiennych warunków dla innych terminów używanych w odbiciu ogólnym, zobacz <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> właściwość.</span><span class="sxs-lookup"><span data-stu-id="5aedc-171">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5aedc-172">Bieżący obiekt to <see cref="T:System.Reflection.ConstructorInfo" />.</span><span class="sxs-lookup"><span data-stu-id="5aedc-172">The current object is a <see cref="T:System.Reflection.ConstructorInfo" />.</span></span> <span data-ttu-id="5aedc-173">Konstruktory generyczne nie są obsługiwane w .NET Framework w wersji 2,0.</span><span class="sxs-lookup"><span data-stu-id="5aedc-173">Generic constructors are not supported in the .NET Framework version 2.0.</span></span> <span data-ttu-id="5aedc-174">Ten wyjątek jest zachowaniem domyślnym, jeśli ta metoda nie została przesłonięta w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="5aedc-174">This exception is the default behavior if this method is not overridden in a derived class.</span></span></exception>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="M:System.Reflection.MethodInfo.GetGenericArguments" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="methodBase.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5aedc-175">Zwraca kod skrótu dla tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="5aedc-175">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="5aedc-176">Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="5aedc-176">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBody">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBody GetMethodBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBody GetMethodBody() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodBody" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMethodBody () As MethodBody" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodBody ^ GetMethodBody();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodBody : unit -&gt; System.Reflection.MethodBody&#xA;override this.GetMethodBody : unit -&gt; System.Reflection.MethodBody" Usage="methodBase.GetMethodBody " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBody</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5aedc-177">Gdy jest zastępowany w klasie pochodnej, pobiera <see cref="T:System.Reflection.MethodBody" /> obiekt, który zapewnia dostęp do strumienia MSIL, zmiennych lokalnych i wyjątków dla bieżącej metody.</span><span class="sxs-lookup"><span data-stu-id="5aedc-177">When overridden in a derived class, gets a <see cref="T:System.Reflection.MethodBody" /> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</span></span></summary>
        <returns><span data-ttu-id="5aedc-178"><see cref="T:System.Reflection.MethodBody" /> Obiekt, który zapewnia dostęp do strumienia MSIL, zmiennych lokalnych i wyjątków dla bieżącej metody.</span><span class="sxs-lookup"><span data-stu-id="5aedc-178">A <see cref="T:System.Reflection.MethodBody" /> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-179">Nie trzeba przesłonić, <xref:System.Reflection.MethodBase.GetMethodBody%2A> aby można było go użyć.</span><span class="sxs-lookup"><span data-stu-id="5aedc-179">You do not have to override the <xref:System.Reflection.MethodBase.GetMethodBody%2A> in order to use it.</span></span> <span data-ttu-id="5aedc-180">Można wywołać <xref:System.Reflection.MethodBase.GetMethodBody%2A> metodę dla <xref:System.Reflection.MethodInfo> i <xref:System.Reflection.ConstructorInfo> obiektów, ponieważ metoda jest zastępowana w wersjach środowiska uruchomieniowego tych klas.</span><span class="sxs-lookup"><span data-stu-id="5aedc-180">You can call the <xref:System.Reflection.MethodBase.GetMethodBody%2A> method on <xref:System.Reflection.MethodInfo> and <xref:System.Reflection.ConstructorInfo> objects, because the method is overridden in the runtime versions of these classes.</span></span> <span data-ttu-id="5aedc-181">Na przykład wersja <xref:System.Reflection.MethodInfo> środowiska uruchomieniowego klasy pochodzi <xref:System.Reflection.MethodInfo> od klasy, która <xref:System.Reflection.MethodBase> z kolei dziedziczy z klasy.</span><span class="sxs-lookup"><span data-stu-id="5aedc-181">For example, the runtime version of the <xref:System.Reflection.MethodInfo> class derives from the <xref:System.Reflection.MethodInfo> class, which in turn derives from the <xref:System.Reflection.MethodBase> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5aedc-182">Poniższy przykład kodu definiuje metodę testową o nazwie `MethodBodyExample` i wyświetla jej informacje o zmiennej lokalnej oraz klauzule obsługi wyjątków.</span><span class="sxs-lookup"><span data-stu-id="5aedc-182">The following code example defines a test method named `MethodBodyExample` and displays its local variable information and exception-handling clauses.</span></span> <span data-ttu-id="5aedc-183">Metoda służy do <xref:System.Reflection.MethodBody> uzyskania obiektu dla metody testowej. <xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="5aedc-183">The <xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType> method is used to obtain a <xref:System.Reflection.MethodBody> object for the test method.</span></span>  
  
 <span data-ttu-id="5aedc-184">Właściwość służy do uzyskiwania <xref:System.Reflection.LocalVariableInfo> listy obiektów i wyświetlania ich typów i kolejności indeksowania. <xref:System.Reflection.MethodBody.LocalVariables%2A></span><span class="sxs-lookup"><span data-stu-id="5aedc-184">The <xref:System.Reflection.MethodBody.LocalVariables%2A> property is used to obtain a list of <xref:System.Reflection.LocalVariableInfo> objects and display their types and index order.</span></span> <span data-ttu-id="5aedc-185"><xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A> Właściwość służy do uzyskiwania listy klauzul obsługi wyjątków.</span><span class="sxs-lookup"><span data-stu-id="5aedc-185">The <xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A> property is used to obtain a list of exception-handling clauses.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5aedc-186">Nie wszystkie języki komputera mogą generować <xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType> klauzule.</span><span class="sxs-lookup"><span data-stu-id="5aedc-186">Not all computer languages can generate <xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType> clauses.</span></span> <span data-ttu-id="5aedc-187">W Visual Basic przykładzie przedstawiono klauzulę filtru, używając wyrażenia Visual Basic `When` , które jest pomijane w przykładach dla innych języków.</span><span class="sxs-lookup"><span data-stu-id="5aedc-187">The Visual Basic example shows a filter clause, using a Visual Basic `When` expression, which is omitted from the examples for other languages.</span></span>  
  
 [!code-cpp[MethodBody#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBody/cpp/source.cpp#1)]
 [!code-csharp[MethodBody#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBody/CS/source.cs#1)]
 [!code-vb[MethodBody#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBody/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5aedc-188">Ta metoda jest nieprawidłowa, chyba że zostanie zastąpiona w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="5aedc-188">This method is invalid unless overridden in a derived class.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="5aedc-189">Aby uzyskać dostęp do metadanych dla elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="5aedc-189">for the access to metadata for members.</span></span> <span data-ttu-id="5aedc-190">Wartość uprawnienia:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="5aedc-190">Permission value: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethodFromHandle">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5aedc-191">Pobiera informacje o metodzie przy użyciu określonego dojścia.</span><span class="sxs-lookup"><span data-stu-id="5aedc-191">Gets method information using the specified handle.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodFromHandle (handle As RuntimeMethodHandle) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodFromHandle(RuntimeMethodHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetMethodFromHandle : RuntimeMethodHandle -&gt; System.Reflection.MethodBase" Usage="System.Reflection.MethodBase.GetMethodFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="5aedc-192">Uchwyt metody.</span><span class="sxs-lookup"><span data-stu-id="5aedc-192">The method's handle.</span></span></param>
        <summary><span data-ttu-id="5aedc-193">Pobiera informacje o metodzie przy użyciu wewnętrznej reprezentacji metadanych metody (uchwytu).</span><span class="sxs-lookup"><span data-stu-id="5aedc-193">Gets method information by using the method's internal metadata representation (handle).</span></span></summary>
        <returns><span data-ttu-id="5aedc-194"><see langword="MethodBase" /> Zawierający informacje o metodzie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-194">A <see langword="MethodBase" /> containing information about the method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-195">Uchwyty są prawidłowe tylko w domenie aplikacji, w której zostały uzyskane.</span><span class="sxs-lookup"><span data-stu-id="5aedc-195">Handles are valid only in the application domain in which they were obtained.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5aedc-196"><paramref name="handle" /> jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="5aedc-196"><paramref name="handle" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="5aedc-197">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="5aedc-197">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="5aedc-198">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="5aedc-198">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle, valuetype System.RuntimeTypeHandle declaringType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodFromHandle (handle As RuntimeMethodHandle, declaringType As RuntimeTypeHandle) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberSignature Language="F#" Value="static member GetMethodFromHandle : RuntimeMethodHandle * RuntimeTypeHandle -&gt; System.Reflection.MethodBase" Usage="System.Reflection.MethodBase.GetMethodFromHandle (handle, declaringType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="declaringType" Type="System.RuntimeTypeHandle" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="5aedc-199">Dojście do wewnętrznej reprezentacji metadanych konstruktora lub metody.</span><span class="sxs-lookup"><span data-stu-id="5aedc-199">A handle to the internal metadata representation of a constructor or method.</span></span></param>
        <param name="declaringType"><span data-ttu-id="5aedc-200">Dojście do typu ogólnego, który definiuje konstruktora lub metodę.</span><span class="sxs-lookup"><span data-stu-id="5aedc-200">A handle to the generic type that defines the constructor or method.</span></span></param>
        <summary><span data-ttu-id="5aedc-201"><see cref="T:System.Reflection.MethodBase" /> Pobiera obiekt dla konstruktora lub metody reprezentowanej przez określone dojście dla określonego typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="5aedc-201">Gets a <see cref="T:System.Reflection.MethodBase" /> object for the constructor or method represented by the specified handle, for the specified generic type.</span></span></summary>
        <returns><span data-ttu-id="5aedc-202">Obiekt reprezentujący metodę lub Konstruktor określony przez <paramref name="handle" />, w typie ogólnym określonym przez <paramref name="declaringType" />. <see cref="T:System.Reflection.MethodBase" /></span><span class="sxs-lookup"><span data-stu-id="5aedc-202">A <see cref="T:System.Reflection.MethodBase" /> object representing the method or constructor specified by <paramref name="handle" />, in the generic type specified by <paramref name="declaringType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-203">Uchwyty są prawidłowe tylko w domenie aplikacji, w której zostały uzyskane.</span><span class="sxs-lookup"><span data-stu-id="5aedc-203">Handles are valid only in the application domain in which they were obtained.</span></span>  
  
 <span data-ttu-id="5aedc-204">Struktura konstruktora lub metody typu ogólnego może reprezentować różne <xref:System.Reflection.MethodBase> obiekty, w zależności od typów określonych dla parametrów typu ogólnego typu. <xref:System.RuntimeMethodHandle></span><span class="sxs-lookup"><span data-stu-id="5aedc-204">A <xref:System.RuntimeMethodHandle> structure for a constructor or method of a generic type can represent different <xref:System.Reflection.MethodBase> objects, depending on the types specified for the type parameters of the generic type.</span></span> <span data-ttu-id="5aedc-205">Na przykład, jeśli `class G<T>` (`class G(Of T)` w Visual Basic, `generic <T> ref class G` w C++) ma metodę, która zwraca typ `T`, <xref:System.Reflection.MethodBase> obiekt dla tej metody w konstruowanej klasie, takiej jak `G<int>` różni się od <xref:System.Reflection.MethodBase> obiekt dla tej metody w definicji typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="5aedc-205">For example, if `class G<T>` (`class G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) has a method that returns type `T`, the <xref:System.Reflection.MethodBase> object for that method in a constructed class such as `G<int>` is different from the <xref:System.Reflection.MethodBase> object for that method in the generic type definition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5aedc-206"><paramref name="handle" /> jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="5aedc-206"><paramref name="handle" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="5aedc-207">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="5aedc-207">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="5aedc-208">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="5aedc-208">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="methodBase.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetMethodImplementationFlags</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5aedc-209">Gdy jest zastępowany w klasie pochodnej, zwraca <see cref="T:System.Reflection.MethodImplAttributes" /> flagi.</span><span class="sxs-lookup"><span data-stu-id="5aedc-209">When overridden in a derived class, returns the <see cref="T:System.Reflection.MethodImplAttributes" /> flags.</span></span></summary>
        <returns><span data-ttu-id="5aedc-210"><see langword="MethodImplAttributes" /> Flagi.</span><span class="sxs-lookup"><span data-stu-id="5aedc-210">The <see langword="MethodImplAttributes" /> flags.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="5aedc-211">Poniższy przykład definiuje konstruktora w zestawie dynamicznym, a następnie używa <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> metody do wyświetlania flag implementacji metody ustawionych domyślnie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-211">The following example defines a constructor in a dynamic assembly and then uses the <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> method to display the method implementation flags that are set by default.</span></span>  
  
 [!code-cpp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CPP/constructorbuilder_getmodule_4.cpp#3)]
 [!code-csharp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CS/constructorbuilder_getmodule_4.cs#3)]
 [!code-vb[ConstructorBuilder_GetModule_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/VB/constructorbuilder_getmodule_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="5aedc-212">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="5aedc-212">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="5aedc-213">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="5aedc-213">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Reflection.MethodImplAttributes" />
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="abstract member GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="methodBase.GetParameters " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5aedc-214">Gdy jest zastępowany w klasie pochodnej, pobiera parametry określonej metody lub konstruktora.</span><span class="sxs-lookup"><span data-stu-id="5aedc-214">When overridden in a derived class, gets the parameters of the specified method or constructor.</span></span></summary>
        <returns><span data-ttu-id="5aedc-215">Tablica typu <see langword="ParameterInfo" /> zawierającego informacje, które pasują do sygnatury metody (lub konstruktora) odzwierciedlonej przez to <see langword="MethodBase" /> wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-215">An array of type <see langword="ParameterInfo" /> containing information that matches the signature of the method (or constructor) reflected by this <see langword="MethodBase" /> instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="5aedc-216">W poniższym przykładzie zastosowano <xref:System.Reflection.MethodBase.GetParameters%2A> metodę, aby pobrać parametry `Invoke` metody delegata.</span><span class="sxs-lookup"><span data-stu-id="5aedc-216">The following example uses the <xref:System.Reflection.MethodBase.GetParameters%2A> method to retrieve the parameters of the `Invoke` method of a delegate.</span></span>  
  
 <span data-ttu-id="5aedc-217">W przykładzie zdefiniowano delegata `MyDelegate` o nazwie i zdarzeniu o `MyDelegate`nazwie `ev` typu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-217">The example defines a delegate named `MyDelegate` and an event named `ev` of type `MyDelegate`.</span></span> <span data-ttu-id="5aedc-218">Kod w `Main` metodzie odnajduje sygnaturę zdarzenia, pobierając typ delegata zdarzenia, `Invoke` pobierając metodę typu delegata, a następnie pobierając i wyświetlając parametry.</span><span class="sxs-lookup"><span data-stu-id="5aedc-218">The code in the `Main` method discovers the event signature by getting the delegate type of the event, getting the `Invoke` method of the delegate type, and then retrieving and displaying the parameters.</span></span>  
  
 [!code-cpp[eventarg#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventArg/CPP/eventarg.cpp#1)]
 [!code-csharp[eventarg#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventArg/CS/eventarg.cs#1)]
 [!code-vb[eventarg#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventArg/VB/eventarg.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="5aedc-219">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="5aedc-219">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="5aedc-220">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="5aedc-220">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Reflection.ParameterInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="methodBase.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5aedc-221">Wywołuje metodę lub Konstruktor odzwierciedlony przez to <see langword="MethodInfo" /> wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-221">Invokes the method or constructor reflected by this <see langword="MethodInfo" /> instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (object obj, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (obj As Object, parameters As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(System::Object ^ obj, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="abstract member Invoke : obj * obj[] -&gt; obj&#xA;override this.Invoke : obj * obj[] -&gt; obj" Usage="methodBase.Invoke (obj, parameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="5aedc-222">Obiekt, dla którego ma zostać wywołana metoda lub Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="5aedc-222">The object on which to invoke the method or constructor.</span></span> <span data-ttu-id="5aedc-223">Jeśli metoda jest statyczna, ten argument jest ignorowany.</span><span class="sxs-lookup"><span data-stu-id="5aedc-223">If a method is static, this argument is ignored.</span></span> <span data-ttu-id="5aedc-224">Jeśli Konstruktor jest statyczny, ten argument musi być <see langword="null" /> lub wystąpienie klasy, która definiuje konstruktora.</span><span class="sxs-lookup"><span data-stu-id="5aedc-224">If a constructor is static, this argument must be <see langword="null" /> or an instance of the class that defines the constructor.</span></span></param>
        <param name="parameters"><span data-ttu-id="5aedc-225">Lista argumentów dla wywołanej metody lub konstruktora.</span><span class="sxs-lookup"><span data-stu-id="5aedc-225">An argument list for the invoked method or constructor.</span></span> <span data-ttu-id="5aedc-226">Jest to tablica obiektów o tej samej liczbie, kolejności i typie co parametry metody lub konstruktora, które mają być wywoływane.</span><span class="sxs-lookup"><span data-stu-id="5aedc-226">This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</span></span> <span data-ttu-id="5aedc-227">Jeśli nie ma żadnych parametrów, <paramref name="parameters" /> <see langword="null" />należy.</span><span class="sxs-lookup"><span data-stu-id="5aedc-227">If there are no parameters, <paramref name="parameters" /> should be <see langword="null" />.</span></span>  
  
<span data-ttu-id="5aedc-228">Jeśli metoda lub Konstruktor reprezentowane przez to wystąpienie przyjmuje <see langword="ref" /> parametr (<see langword="ByRef" /> w Visual Basic), nie jest wymagany żaden atrybut specjalny dla tego parametru, aby wywołać metodę lub Konstruktor przy użyciu tej funkcji.</span><span class="sxs-lookup"><span data-stu-id="5aedc-228">If the method or constructor represented by this instance takes a <see langword="ref" /> parameter (<see langword="ByRef" /> in Visual Basic), no special attribute is required for that parameter in order to invoke the method or constructor using this function.</span></span> <span data-ttu-id="5aedc-229">Każdy obiekt w tej tablicy, który nie jest jawnie zainicjowany przy użyciu wartości, będzie zawierać wartość domyślną dla tego typu obiektu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-229">Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</span></span> <span data-ttu-id="5aedc-230">Dla elementów typu odwołania ta wartość <see langword="null" />to.</span><span class="sxs-lookup"><span data-stu-id="5aedc-230">For reference-type elements, this value is <see langword="null" />.</span></span> <span data-ttu-id="5aedc-231">Dla elementów typu wartości ta wartość jest równa 0, 0,0 lub <see langword="false" />, w zależności od typu określonego elementu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-231">For value-type elements, this value is 0, 0.0, or <see langword="false" />, depending on the specific element type.</span></span></param>
        <summary><span data-ttu-id="5aedc-232">Wywołuje metodę lub konstruktora reprezentowane przez bieżące wystąpienie przy użyciu określonych parametrów.</span><span class="sxs-lookup"><span data-stu-id="5aedc-232">Invokes the method or constructor represented by the current instance, using the specified parameters.</span></span></summary>
        <returns><span data-ttu-id="5aedc-233">Obiekt zawierający wartość zwracaną wywołanej metody lub <see langword="null" /> w przypadku konstruktora.</span><span class="sxs-lookup"><span data-stu-id="5aedc-233">An object containing the return value of the invoked method, or <see langword="null" /> in the case of a constructor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-234">Jest to wygodna metoda, która wywołuje <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> Przeciążenie metody, przekazując <xref:System.Reflection.BindingFlags.Default> do `invokeAttr` i `null` dla `binder` i `culture`.</span><span class="sxs-lookup"><span data-stu-id="5aedc-234">This is a convenience method that calls the <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> method overload, passing <xref:System.Reflection.BindingFlags.Default> for `invokeAttr` and `null` for `binder` and `culture`.</span></span>  
  
 <span data-ttu-id="5aedc-235">Jeśli wywołana metoda zgłasza wyjątek, <xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType> Metoda zwraca wyjątek.</span><span class="sxs-lookup"><span data-stu-id="5aedc-235">If the invoked method throws an exception, the <xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType> method returns the exception.</span></span>  
  
 <span data-ttu-id="5aedc-236">Aby wywołać metodę statyczną za pomocą <xref:System.Reflection.MethodInfo> jej obiektu, `null` należy `obj`przekazać do.</span><span class="sxs-lookup"><span data-stu-id="5aedc-236">To invoke a static method using its <xref:System.Reflection.MethodInfo> object, pass `null` for `obj`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5aedc-237">Jeśli to Przeciążenie metody jest używane do wywołania konstruktora wystąpienia, obiekt dostarczony dla `obj` jest zainicjowany ponownie; oznacza to, że wszystkie inicjatory wystąpień są wykonywane.</span><span class="sxs-lookup"><span data-stu-id="5aedc-237">If this method overload is used to invoke an instance constructor, the object supplied for `obj` is reinitialized; that is, all instance initializers are executed.</span></span> <span data-ttu-id="5aedc-238">Wartość zwracana to `null`.</span><span class="sxs-lookup"><span data-stu-id="5aedc-238">The return value is `null`.</span></span> <span data-ttu-id="5aedc-239">Jeśli Konstruktor klasy jest wywoływany, Klasa zostanie zainicjowana ponownie; oznacza to, że wszystkie inicjatory klas są wykonywane.</span><span class="sxs-lookup"><span data-stu-id="5aedc-239">If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</span></span> <span data-ttu-id="5aedc-240">Wartość zwracana to `null`.</span><span class="sxs-lookup"><span data-stu-id="5aedc-240">The return value is `null`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5aedc-241">Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do niepublicznych elementów członkowskich, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw uprawnień niepublicznych składowych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję.</span><span class="sxs-lookup"><span data-stu-id="5aedc-241">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="5aedc-242">(Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).</span><span class="sxs-lookup"><span data-stu-id="5aedc-242">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="5aedc-243">Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.</span><span class="sxs-lookup"><span data-stu-id="5aedc-243">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 <span data-ttu-id="5aedc-244">Jeśli parametr bieżącej metody jest typem wartości, a odpowiadający mu argument w `parameters` to `null`, środowisko uruchomieniowe przekazuje wystąpienie typu wartości z inicjacją zero.</span><span class="sxs-lookup"><span data-stu-id="5aedc-244">If a parameter of the current method is a value type, and the corresponding argument in `parameters` is `null`, the runtime passes a zero-initialized instance of the value type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5aedc-245">Poniższy przykład kodu demonstruje metodę dynamiczną Lookup przy użyciu odbicia.</span><span class="sxs-lookup"><span data-stu-id="5aedc-245">The following code example demonstrates dynamic method lookup using reflection.</span></span> <span data-ttu-id="5aedc-246">Należy zauważyć, że nie można <xref:System.Reflection.MethodInfo> użyć obiektu z klasy bazowej do wywołania przesłoniętej metody w klasie pochodnej, ponieważ późne wiązanie nie może rozwiązać zastąpień.</span><span class="sxs-lookup"><span data-stu-id="5aedc-246">Note that you cannot use the <xref:System.Reflection.MethodInfo> object from the base class to invoke the overridden method in the derived class, because late binding cannot resolve overrides.</span></span>  
  
 [!code-cpp[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="5aedc-247">W<see href="https://go.microsoft.com/fwlink/?LinkID=247912">środowisku .NET dla aplikacji do sklepu Windows</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">przenośnej biblioteki klas</see>Przechwyć <see cref="T:System.Exception" /> zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="5aedc-247">In the<see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch <see cref="T:System.Exception" /> instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="5aedc-248"><paramref name="obj" /> Parametr jest<see langword="null" /> i metoda nie jest statyczna.</span><span class="sxs-lookup"><span data-stu-id="5aedc-248">The <paramref name="obj" /> parameter is <see langword="null" /> and the method is not static.</span></span>  
  
<span data-ttu-id="5aedc-249">—lub—</span><span class="sxs-lookup"><span data-stu-id="5aedc-249">-or-</span></span> 
<span data-ttu-id="5aedc-250">Metoda nie jest zadeklarowana ani dziedziczona przez klasę <paramref name="obj" />.</span><span class="sxs-lookup"><span data-stu-id="5aedc-250">The method is not declared or inherited by the class of <paramref name="obj" />.</span></span>  
  
<span data-ttu-id="5aedc-251">—lub—</span><span class="sxs-lookup"><span data-stu-id="5aedc-251">-or-</span></span> 
<span data-ttu-id="5aedc-252">Konstruktor statyczny jest wywoływany i <paramref name="obj" /> nie <see langword="null" /> jest ani wystąpieniem klasy, która deklaruje Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="5aedc-252">A static constructor is invoked, and <paramref name="obj" /> is neither <see langword="null" /> nor an instance of the class that declared the constructor.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5aedc-253">Elementy <paramref name="parameters" /> tablicy nie pasują do sygnatury metody lub konstruktora odzwierciedlonej przez to wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-253">The elements of the <paramref name="parameters" /> array do not match the signature of the method or constructor reflected by this instance.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="5aedc-254">Wywołana metoda lub Konstruktor zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="5aedc-254">The invoked method or constructor throws an exception.</span></span>  
  
<span data-ttu-id="5aedc-255">—lub—</span><span class="sxs-lookup"><span data-stu-id="5aedc-255">-or-</span></span> 
<span data-ttu-id="5aedc-256">Bieżące wystąpienie jest <see cref="T:System.Reflection.Emit.DynamicMethod" /> , które zawiera kod niemożliwy do zweryfikowania.</span><span class="sxs-lookup"><span data-stu-id="5aedc-256">The current instance is a <see cref="T:System.Reflection.Emit.DynamicMethod" /> that contains unverifiable code.</span></span> <span data-ttu-id="5aedc-257">Zobacz sekcję "weryfikacja" w artykule uwagi dla <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span><span class="sxs-lookup"><span data-stu-id="5aedc-257">See the "Verification" section in Remarks for <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetParameterCountException"><span data-ttu-id="5aedc-258"><paramref name="parameters" /> Tablica nie ma poprawnej liczby argumentów.</span><span class="sxs-lookup"><span data-stu-id="5aedc-258">The <paramref name="parameters" /> array does not have the correct number of arguments.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="5aedc-259">W programie <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET dla aplikacji ze sklepu Windows</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">przenośnej biblioteki klas</see>Przechwyć wyjątek <see cref="T:System.MemberAccessException" />klasy bazowej, zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="5aedc-259">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.MemberAccessException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="5aedc-260">Obiekt wywołujący nie ma uprawnień do wykonania metody lub konstruktora reprezentowanego przez bieżące wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-260">The caller does not have permission to execute the method or constructor that is represented by the current instance.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5aedc-261">Typ, który deklaruje metodę, jest otwartym typem ogólnym.</span><span class="sxs-lookup"><span data-stu-id="5aedc-261">The type that declares the method is an open generic type.</span></span> <span data-ttu-id="5aedc-262">Oznacza to, <see cref="P:System.Type.ContainsGenericParameters" /> że właściwość zwraca <see langword="true" /> typ deklarujący.</span><span class="sxs-lookup"><span data-stu-id="5aedc-262">That is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" /> for the declaring type.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5aedc-263">Bieżące wystąpienie to <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="5aedc-263">The current instance is a <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="5aedc-264">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="5aedc-264">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="5aedc-265">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="5aedc-265">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Missing" />
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public abstract object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="methodBase.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="parameters" Type="System.Object[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="5aedc-266">Obiekt, dla którego ma zostać wywołana metoda lub Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="5aedc-266">The object on which to invoke the method or constructor.</span></span> <span data-ttu-id="5aedc-267">Jeśli metoda jest statyczna, ten argument jest ignorowany.</span><span class="sxs-lookup"><span data-stu-id="5aedc-267">If a method is static, this argument is ignored.</span></span> <span data-ttu-id="5aedc-268">Jeśli Konstruktor jest statyczny, ten argument musi być <see langword="null" /> lub wystąpienie klasy, która definiuje konstruktora.</span><span class="sxs-lookup"><span data-stu-id="5aedc-268">If a constructor is static, this argument must be <see langword="null" /> or an instance of the class that defines the constructor.</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="5aedc-269">Maska bitów, która jest kombinacją 0 lub więcej flag bitowych z <see cref="T:System.Reflection.BindingFlags" />.</span><span class="sxs-lookup"><span data-stu-id="5aedc-269">A bitmask that is a combination of 0 or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span> <span data-ttu-id="5aedc-270">Jeśli <paramref name="binder" /> <see cref="F:System.Reflection.BindingFlags.Default" />jest <see langword="null" />, ten parametr ma przypisaną wartość. w ten sposób wszystkie przekazane dane zostaną zignorowane.</span><span class="sxs-lookup"><span data-stu-id="5aedc-270">If <paramref name="binder" /> is <see langword="null" />, this parameter is assigned the value <see cref="F:System.Reflection.BindingFlags.Default" />; thus, whatever you pass in is ignored.</span></span></param>
        <param name="binder"><span data-ttu-id="5aedc-271">Obiekt, który umożliwia powiązanie, przekształcenie typów argumentów, wywoływanie elementów członkowskich oraz pobieranie <see langword="MemberInfo" /> obiektów przez odbicie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-271">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects via reflection.</span></span> <span data-ttu-id="5aedc-272">Jeśli <paramref name="binder" /> jest<see langword="null" />, używany jest domyślny spinacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-272">If <paramref name="binder" /> is <see langword="null" />, the default binder is used.</span></span></param>
        <param name="parameters"><span data-ttu-id="5aedc-273">Lista argumentów dla wywołanej metody lub konstruktora.</span><span class="sxs-lookup"><span data-stu-id="5aedc-273">An argument list for the invoked method or constructor.</span></span> <span data-ttu-id="5aedc-274">Jest to tablica obiektów o tej samej liczbie, kolejności i typie co parametry metody lub konstruktora, które mają być wywoływane.</span><span class="sxs-lookup"><span data-stu-id="5aedc-274">This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</span></span> <span data-ttu-id="5aedc-275">Jeśli nie ma żadnych parametrów, powinna to być <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5aedc-275">If there are no parameters, this should be <see langword="null" />.</span></span>  
  
<span data-ttu-id="5aedc-276">Jeśli metoda lub Konstruktor reprezentowane przez to wystąpienie przyjmuje parametr ByRef, nie istnieje specjalny atrybut wymagany dla tego parametru, aby wywołać metodę lub Konstruktor przy użyciu tej funkcji.</span><span class="sxs-lookup"><span data-stu-id="5aedc-276">If the method or constructor represented by this instance takes a ByRef parameter, there is no special attribute required for that parameter in order to invoke the method or constructor using this function.</span></span> <span data-ttu-id="5aedc-277">Każdy obiekt w tej tablicy, który nie jest jawnie zainicjowany przy użyciu wartości, będzie zawierać wartość domyślną dla tego typu obiektu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-277">Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</span></span> <span data-ttu-id="5aedc-278">Dla elementów typu odwołania ta wartość <see langword="null" />to.</span><span class="sxs-lookup"><span data-stu-id="5aedc-278">For reference-type elements, this value is <see langword="null" />.</span></span> <span data-ttu-id="5aedc-279">Dla elementów typu wartości ta wartość jest równa 0, 0,0 lub <see langword="false" />, w zależności od typu określonego elementu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-279">For value-type elements, this value is 0, 0.0, or <see langword="false" />, depending on the specific element type.</span></span></param>
        <param name="culture"><span data-ttu-id="5aedc-280">Wystąpienie <see langword="CultureInfo" /> używane do zarządzania przymusem typów.</span><span class="sxs-lookup"><span data-stu-id="5aedc-280">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span></span> <span data-ttu-id="5aedc-281">Jeśli tak <see langword="null" /> <see langword="CultureInfo" /> , jest używany dla bieżącego wątku.</span><span class="sxs-lookup"><span data-stu-id="5aedc-281">If this is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span></span> <span data-ttu-id="5aedc-282">(Jest to konieczne do konwersji a <see langword="String" /> , która reprezentuje 1000 <see langword="Double" /> do wartości, na przykład, ponieważ 1000 jest reprezentowana inaczej w różnych kulturach).</span><span class="sxs-lookup"><span data-stu-id="5aedc-282">(This is necessary to convert a <see langword="String" /> that represents 1000 to a <see langword="Double" /> value, for example, since 1000 is represented differently by different cultures.)</span></span></param>
        <summary><span data-ttu-id="5aedc-283">Gdy jest zastępowany w klasie pochodnej, wywołuje odbitej metody lub konstruktora z podanym parametrem.</span><span class="sxs-lookup"><span data-stu-id="5aedc-283">When overridden in a derived class, invokes the reflected method or constructor with the given parameters.</span></span></summary>
        <returns><span data-ttu-id="5aedc-284">Zawierająca wartość zwracaną wywoływanej metody lub <see langword="null" /> w przypadku konstruktora lub <see langword="null" /> typ <see langword="void" />zwracany metody. <see langword="Object" /></span><span class="sxs-lookup"><span data-stu-id="5aedc-284">An <see langword="Object" /> containing the return value of the invoked method, or <see langword="null" /> in the case of a constructor, or <see langword="null" /> if the method's return type is <see langword="void" />.</span></span> <span data-ttu-id="5aedc-285">Przed wywołaniem metody lub konstruktora sprawdza <see langword="Invoke" /> , czy użytkownik ma uprawnienia dostępu i sprawdza, czy parametry są prawidłowe.</span><span class="sxs-lookup"><span data-stu-id="5aedc-285">Before calling the method or constructor, <see langword="Invoke" /> checks to see if the user has access permission and verifies that the parameters are valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-286">Dynamicznie wywołuje metodę odzwierciedloną przez to wystąpienie w `obj`systemie i przekazuje je do określonych parametrów.</span><span class="sxs-lookup"><span data-stu-id="5aedc-286">Dynamically invokes the method reflected by this instance on `obj`, and passes along the specified parameters.</span></span> <span data-ttu-id="5aedc-287">Jeśli metoda jest statyczna, `obj` parametr jest ignorowany.</span><span class="sxs-lookup"><span data-stu-id="5aedc-287">If the method is static, the `obj` parameter is ignored.</span></span> <span data-ttu-id="5aedc-288">W przypadku metod `obj` niestatycznych powinna być wystąpieniem klasy, która dziedziczy lub deklaruje metodę i musi być tego samego typu co Klasa.</span><span class="sxs-lookup"><span data-stu-id="5aedc-288">For non-static methods, `obj` should be an instance of a class that inherits or declares the method and must be the same type as this class.</span></span> <span data-ttu-id="5aedc-289">Jeśli metoda nie ma parametrów, wartość `parameters` powinna być. `null`</span><span class="sxs-lookup"><span data-stu-id="5aedc-289">If the method has no parameters, the value of `parameters` should be `null`.</span></span> <span data-ttu-id="5aedc-290">W przeciwnym razie liczba, typ i kolejność elementów w programie `parameters` powinna być taka sama jak liczba, typ i kolejność parametrów dla metody odzwierciedlonej przez to wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-290">Otherwise, the number, type, and order of elements in `parameters` should be identical to the number, type, and order of parameters for the method reflected by this instance.</span></span>  
  
 <span data-ttu-id="5aedc-291">Nie można pominąć parametrów opcjonalnych w wywołaniach `Invoke`do.</span><span class="sxs-lookup"><span data-stu-id="5aedc-291">You may not omit optional parameters in calls to `Invoke`.</span></span> <span data-ttu-id="5aedc-292">Aby wywołać metodę pomijania parametrów opcjonalnych, należy wywołać `Type.InvokeMember` zamiast.</span><span class="sxs-lookup"><span data-stu-id="5aedc-292">To invoke a method omitting optional parameters, you should call `Type.InvokeMember` instead.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5aedc-293">Jeśli to Przeciążenie metody jest używane do wywołania konstruktora wystąpienia, obiekt dostarczony dla `obj` jest zainicjowany ponownie; oznacza to, że wszystkie inicjatory wystąpień są wykonywane.</span><span class="sxs-lookup"><span data-stu-id="5aedc-293">If this method overload is used to invoke an instance constructor, the object supplied for `obj` is reinitialized; that is, all instance initializers are executed.</span></span> <span data-ttu-id="5aedc-294">Wartość zwracana to `null`.</span><span class="sxs-lookup"><span data-stu-id="5aedc-294">The return value is `null`.</span></span> <span data-ttu-id="5aedc-295">Jeśli Konstruktor klasy jest wywoływany, Klasa zostanie zainicjowana ponownie; oznacza to, że wszystkie inicjatory klas są wykonywane.</span><span class="sxs-lookup"><span data-stu-id="5aedc-295">If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</span></span> <span data-ttu-id="5aedc-296">Wartość zwracana to `null`.</span><span class="sxs-lookup"><span data-stu-id="5aedc-296">The return value is `null`.</span></span>  
  
 <span data-ttu-id="5aedc-297">W przypadku parametrów pierwotnych przekazywanych przez wartość normalne rozszerzanie jest wykonywane (na przykład Int16-> Int32).</span><span class="sxs-lookup"><span data-stu-id="5aedc-297">For pass-by-value primitive parameters, normal widening is performed (Int16 -> Int32, for example).</span></span> <span data-ttu-id="5aedc-298">W przypadku parametrów odniesienia przekazywanych przez wartość normalne rozszerzanie odwołania jest dozwolone (Klasa pochodna do klasy podstawowej i Klasa bazowa do typu interfejsu).</span><span class="sxs-lookup"><span data-stu-id="5aedc-298">For pass-by-value reference parameters, normal reference widening is allowed (derived class to base class, and base class to interface type).</span></span> <span data-ttu-id="5aedc-299">Jednak w przypadku parametrów pierwotnych przekazywanych przez odwołanie typy muszą dokładnie pasować.</span><span class="sxs-lookup"><span data-stu-id="5aedc-299">However, for pass-by-reference primitive parameters, the types must match exactly.</span></span> <span data-ttu-id="5aedc-300">W przypadku parametrów referencyjnych przekazywanych przez odwołanie nadal obowiązuje normalne rozszerzanie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-300">For pass-by-reference reference parameters, the normal widening still applies.</span></span>  
  
 <span data-ttu-id="5aedc-301">Na przykład jeśli metoda odzwierciedlona przez to wystąpienie jest zadeklarowana jako `public boolean Compare(String a, String b)` `parameters` , `Objects` powinna być tablicą o długości 2, takiej `parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`jak.</span><span class="sxs-lookup"><span data-stu-id="5aedc-301">For example, if the method reflected by this instance is declared as `public boolean Compare(String a, String b)`, then `parameters` should be an array of `Objects` with length 2 such that `parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`.</span></span>  
  
 <span data-ttu-id="5aedc-302">Jeśli parametr bieżącej metody jest typem wartości, a odpowiadający mu argument w `parameters` to `null`, środowisko uruchomieniowe przekazuje wystąpienie typu wartości z inicjacją zero.</span><span class="sxs-lookup"><span data-stu-id="5aedc-302">If a parameter of the current method is a value type, and the corresponding argument in `parameters` is `null`, the runtime passes a zero-initialized instance of the value type.</span></span>  
  
 <span data-ttu-id="5aedc-303">Odbicie używa metody dynamicznej Lookup podczas wywoływania metod wirtualnych.</span><span class="sxs-lookup"><span data-stu-id="5aedc-303">Reflection uses dynamic method lookup when invoking virtual methods.</span></span> <span data-ttu-id="5aedc-304">Załóżmy na przykład, że klasa B dziedziczy z klasy A i obie implementują metodę wirtualną o nazwie M. Teraz Załóżmy, że masz `MethodInfo` obiekt, który reprezentuje M w klasie a. Jeśli używasz `Invoke` metody do wywołania M na obiekcie typu B, odbicie będzie używać implementacji podaną przez klasę B. Nawet jeśli obiekt typu B jest rzutowany do, używana jest implementacja określona przez klasę B (Zobacz przykład kodu poniżej).</span><span class="sxs-lookup"><span data-stu-id="5aedc-304">For example, suppose that class B inherits from class A and both implement a virtual method named M. Now suppose that you have a `MethodInfo` object that represents M on class A. If you use the `Invoke` method to invoke M on an object of type B, then reflection will use the implementation given by class B. Even if the object of type B is cast to A, the implementation given by class B is used (see code sample below).</span></span>  
  
 <span data-ttu-id="5aedc-305">Z drugiej strony, jeśli metoda jest niewirtualna, odbicie będzie używać implementacji podaną przez typ, z którego `MethodInfo` uzyskano, niezależnie od typu obiektu przekazanego jako element docelowy.</span><span class="sxs-lookup"><span data-stu-id="5aedc-305">On the other hand, if the method is non-virtual, then reflection will use the implementation given by the type from which the `MethodInfo` was obtained, regardless of the type of the object passed as the target.</span></span>  
  
 <span data-ttu-id="5aedc-306">Ograniczenia dostępu są ignorowane dla w pełni zaufanego kodu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-306">Access restrictions are ignored for fully trusted code.</span></span> <span data-ttu-id="5aedc-307">Oznacza to, że prywatne konstruktory, metody, pola i właściwości są dostępne i wywoływane za pośrednictwem odbicia za każdym razem, gdy kod jest w pełni zaufany.</span><span class="sxs-lookup"><span data-stu-id="5aedc-307">That is, private constructors, methods, fields, and properties can be accessed and invoked via reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="5aedc-308">Jeśli wywołana metoda zgłasza wyjątek, `TargetInvocationException.GetException` zwraca wyjątek.</span><span class="sxs-lookup"><span data-stu-id="5aedc-308">If the invoked method throws an exception, `TargetInvocationException.GetException` returns the exception.</span></span> <span data-ttu-id="5aedc-309">Ta implementacja zgłasza `NotSupportedException`.</span><span class="sxs-lookup"><span data-stu-id="5aedc-309">This implementation throws a `NotSupportedException`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5aedc-310">Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do niepublicznych elementów członkowskich, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw uprawnień niepublicznych składowych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję.</span><span class="sxs-lookup"><span data-stu-id="5aedc-310">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="5aedc-311">(Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).</span><span class="sxs-lookup"><span data-stu-id="5aedc-311">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="5aedc-312">Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.</span><span class="sxs-lookup"><span data-stu-id="5aedc-312">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5aedc-313">Poniższy przykład demonstruje wszystkie elementy członkowskie <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy przy użyciu <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="5aedc-313">The following example demonstrates all members of the <xref:System.Reflection.Binder?displayProperty=nameWithType> class using an overload of <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5aedc-314">Metoda `CanConvertFrom` prywatna znajduje zgodne typy dla danego typu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-314">The private method `CanConvertFrom` finds compatible types for a given type.</span></span> <span data-ttu-id="5aedc-315">Aby uzyskać inny przykład wywoływania elementów członkowskich w scenariuszu powiązania niestandardowego, zobacz [dynamiczne ładowanie i używanie typów](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md).</span><span class="sxs-lookup"><span data-stu-id="5aedc-315">For another example of invoking members in a custom binding scenario, see [Dynamically Loading and Using Types](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md).</span></span>  
  
 [!code-cpp[Binder_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Binder_1/CPP/binder.cpp#1)]
 [!code-csharp[Binder_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Binder_1/CS/binder.cs#1)]
 [!code-vb[Binder_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Binder_1/VB/binder.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="5aedc-316"><paramref name="obj" /> Parametr jest<see langword="null" /> i metoda nie jest statyczna.</span><span class="sxs-lookup"><span data-stu-id="5aedc-316">The <paramref name="obj" /> parameter is <see langword="null" /> and the method is not static.</span></span>  
  
<span data-ttu-id="5aedc-317">—lub—</span><span class="sxs-lookup"><span data-stu-id="5aedc-317">-or-</span></span> 
<span data-ttu-id="5aedc-318">Metoda nie jest zadeklarowana ani dziedziczona przez klasę <paramref name="obj" />.</span><span class="sxs-lookup"><span data-stu-id="5aedc-318">The method is not declared or inherited by the class of <paramref name="obj" />.</span></span>  
  
<span data-ttu-id="5aedc-319">—lub—</span><span class="sxs-lookup"><span data-stu-id="5aedc-319">-or-</span></span> 
<span data-ttu-id="5aedc-320">Konstruktor statyczny jest wywoływany i <paramref name="obj" /> nie <see langword="null" /> jest ani wystąpieniem klasy, która deklaruje Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="5aedc-320">A static constructor is invoked, and <paramref name="obj" /> is neither <see langword="null" /> nor an instance of the class that declared the constructor.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5aedc-321">Typ <paramref name="parameters" /> parametru jest niezgodny z podpisem metody lub konstruktora odzwierciedlonej przez to wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-321">The type of the <paramref name="parameters" /> parameter does not match the signature of the method or constructor reflected by this instance.</span></span></exception>
        <exception cref="T:System.Reflection.TargetParameterCountException"><span data-ttu-id="5aedc-322"><paramref name="parameters" /> Tablica nie ma poprawnej liczby argumentów.</span><span class="sxs-lookup"><span data-stu-id="5aedc-322">The <paramref name="parameters" /> array does not have the correct number of arguments.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="5aedc-323">Wywołana metoda lub Konstruktor zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="5aedc-323">The invoked method or constructor throws an exception.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="5aedc-324">Obiekt wywołujący nie ma uprawnień do wykonania metody lub konstruktora reprezentowanego przez bieżące wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-324">The caller does not have permission to execute the method or constructor that is represented by the current instance.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5aedc-325">Typ, który deklaruje metodę, jest otwartym typem ogólnym.</span><span class="sxs-lookup"><span data-stu-id="5aedc-325">The type that declares the method is an open generic type.</span></span> <span data-ttu-id="5aedc-326">Oznacza to, <see cref="P:System.Type.ContainsGenericParameters" /> że właściwość zwraca <see langword="true" /> typ deklarujący.</span><span class="sxs-lookup"><span data-stu-id="5aedc-326">That is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" /> for the declaring type.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="5aedc-327">wywoływany z późnym wiązaniem przez mechanizmy <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />takie jak.</span><span class="sxs-lookup"><span data-stu-id="5aedc-327">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="5aedc-328">Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span><span class="sxs-lookup"><span data-stu-id="5aedc-328">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md"><span data-ttu-id="5aedc-329">Dynamiczne ładowanie i używanie typów</span><span class="sxs-lookup"><span data-stu-id="5aedc-329">Dynamically Loading and Using Types</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Reflection.MethodBase.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-330">Pobiera wartość wskazującą, czy metoda jest abstrakcyjna.</span><span class="sxs-lookup"><span data-stu-id="5aedc-330">Gets a value indicating whether the method is abstract.</span></span></summary>
        <value><span data-ttu-id="5aedc-331"><see langword="true" />Jeśli metoda jest abstrakcyjna; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="5aedc-331"><see langword="true" /> if the method is abstract; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-332">Abstrakcyjny element członkowski jest zadeklarowany w klasie bazowej i nie ma podanej implementacji.</span><span class="sxs-lookup"><span data-stu-id="5aedc-332">An abstract member is declared on a base class and has no implementation supplied.</span></span>  
  
 <span data-ttu-id="5aedc-333">Aby uzyskać <xref:System.Reflection.MethodBase>, najpierw Pobierz typ.</span><span class="sxs-lookup"><span data-stu-id="5aedc-333">To get the <xref:System.Reflection.MethodBase>, first get the type.</span></span> <span data-ttu-id="5aedc-334">Z typu należy uzyskać metodę.</span><span class="sxs-lookup"><span data-stu-id="5aedc-334">From the type, get the method.</span></span> <span data-ttu-id="5aedc-335">Z metody Pobierz `MethodBase`.</span><span class="sxs-lookup"><span data-stu-id="5aedc-335">From the method, get the `MethodBase`.</span></span> <span data-ttu-id="5aedc-336">Jeśli Konstruktor `MethodBase` or jest inny niż publiczny, jest chroniony i nie można uzyskać do niego dostępu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-336">If the `MethodBase` or constructor is other than public, it is protected and cannot be readily accessed.</span></span> <span data-ttu-id="5aedc-337">Aby uzyskać dostęp do metody niepublicznej, należy <xref:System.Reflection.BindingFlags> ustawić maskę `GetMethod`na `NonPublic` wartość w.</span><span class="sxs-lookup"><span data-stu-id="5aedc-337">To access a non-public method, set the <xref:System.Reflection.BindingFlags> mask to `NonPublic` in `GetMethod`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5aedc-338">Poniższy przykład określa, czy określona metoda jest abstrakcyjna i wyświetla wynik.</span><span class="sxs-lookup"><span data-stu-id="5aedc-338">The following example determines whether specified the method is abstract and displays the result.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsAssembly">
      <MemberSignature Language="C#" Value="public bool IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAssembly : bool" Usage="System.Reflection.MethodBase.IsAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-339">Pobiera wartość wskazującą, czy potencjalna widoczność tej metody lub konstruktora jest opisywana przez <see cref="F:System.Reflection.MethodAttributes.Assembly" />; oznacza to, że metoda lub Konstruktor jest widoczny w większości do innych typów w tym samym zestawie i nie jest widoczny dla typów pochodnych poza zestawem.</span><span class="sxs-lookup"><span data-stu-id="5aedc-339">Gets a value indicating whether the potential visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.Assembly" />; that is, the method or constructor is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.</span></span></summary>
        <value><span data-ttu-id="5aedc-340"><see langword="true" />Jeśli widoczność tej metody lub konstruktora jest dokładnie opisana przez <see cref="F:System.Reflection.MethodAttributes.Assembly" />; w przeciwnym razie,. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="5aedc-340"><see langword="true" /> if the visibility of this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.Assembly" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-341">Rzeczywista widoczność metody jest ograniczona przez widoczność jej typu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-341">The actual visibility of a method is limited by the visibility of its type.</span></span> <span data-ttu-id="5aedc-342">Właściwość może być `true` dla metody, ale jeśli jest to metoda typu zagnieżdżonego Private, metoda nie jest widoczna poza typem zawierającym. <xref:System.Reflection.MethodBase.IsAssembly%2A></span><span class="sxs-lookup"><span data-stu-id="5aedc-342">The <xref:System.Reflection.MethodBase.IsAssembly%2A> property might be `true` for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</span></span>  
  
 <span data-ttu-id="5aedc-343">Widoczność metody lub konstruktora jest dokładnie opisana przez <xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType> , jeśli jedynym modyfikatorem widoczności jest `internal` (`Friend` w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="5aedc-343">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType> if the only visibility modifier is `internal` (`Friend` in Visual Basic).</span></span> <span data-ttu-id="5aedc-344">Ta właściwość dotyczy `false` metod, które znajdują C# się`Protected Friend` `protected internal` `protected public` w (w Visual Basic C++w). Użyj <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> właściwości, aby zidentyfikować takie metody.</span><span class="sxs-lookup"><span data-stu-id="5aedc-344">This property is `false` for methods that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property to identify such methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5aedc-345">Poniższy przykład kodu definiuje metody z <xref:System.Reflection.MethodBase.IsAssembly%2A>różnymi poziomami widoczności i wyświetla wartości ich właściwości, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, i <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> .</span><span class="sxs-lookup"><span data-stu-id="5aedc-345">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5aedc-346">Visual Basic i C# Języki nie mogą definiować metod z <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> widocznością; ten poziom dostępu jest wyświetlany tylko C++ w przykładzie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-346">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructedGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericMethod { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericMethod : bool" Usage="System.Reflection.MethodBase.IsConstructedGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructor">
      <MemberSignature Language="C#" Value="public bool IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructor" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsConstructor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsConstructor { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructor : bool" Usage="System.Reflection.MethodBase.IsConstructor" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsConstructor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-347">Pobiera wartość wskazującą, czy metoda jest konstruktorem.</span><span class="sxs-lookup"><span data-stu-id="5aedc-347">Gets a value indicating whether the method is a constructor.</span></span></summary>
        <value><span data-ttu-id="5aedc-348"><see langword="true" />Jeśli ta metoda jest konstruktorem reprezentowanym <see cref="T:System.Reflection.ConstructorInfo" /> przez obiekt (patrz Uwaga w uwagi <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> dotyczące <see langword="false" />obiektów); w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-348"><see langword="true" /> if this method is a constructor represented by a <see cref="T:System.Reflection.ConstructorInfo" /> object (see note in Remarks about <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> objects); otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="5aedc-349"><xref:System.Reflection.MethodBase.IsConstructor%2A> Właściwość zwraca `false` dla <xref:System.Reflection.Emit.ConstructorBuilder> obiektuw`attributes` typie dynamicznym, chyba że flagazostałauwzględnionaw<xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType> parametrze, gdy Konstruktor został zdefiniowany.</span><span class="sxs-lookup"><span data-stu-id="5aedc-349">The <xref:System.Reflection.MethodBase.IsConstructor%2A> property returns `false` for a <xref:System.Reflection.Emit.ConstructorBuilder> object in a dynamic type, unless the <xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType> flag was included in the `attributes` parameter when the constructor was defined.</span></span> <span data-ttu-id="5aedc-350"><xref:System.Reflection.MethodAttributes.RTSpecialName> Pominięcie flagi nie ma wpływu na poprawność emitowanego konstruktora.</span><span class="sxs-lookup"><span data-stu-id="5aedc-350">Omitting the <xref:System.Reflection.MethodAttributes.RTSpecialName> flag does not affect the correctness of the emitted constructor.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsFamily">
      <MemberSignature Language="C#" Value="public bool IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFamily : bool" Usage="System.Reflection.MethodBase.IsFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-351">Pobiera wartość wskazującą, czy widoczność tej metody lub konstruktora jest opisywana przez <see cref="F:System.Reflection.MethodAttributes.Family" />. oznacza to, że metoda lub Konstruktor jest widoczny tylko w obrębie klasy i klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="5aedc-351">Gets a value indicating whether the visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.Family" />; that is, the method or constructor is visible only within its class and derived classes.</span></span></summary>
        <value><span data-ttu-id="5aedc-352"><see langword="true" />Jeśli dostęp do tej metody lub konstruktora jest dokładnie opisany przez <see cref="F:System.Reflection.MethodAttributes.Family" />; w przeciwnym <see langword="false" />razie,.</span><span class="sxs-lookup"><span data-stu-id="5aedc-352"><see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.Family" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-353">Widoczność metody lub konstruktora jest dokładnie opisana przez <xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType> , jeśli jedynym modyfikatorem widoczności jest. `protected`</span><span class="sxs-lookup"><span data-stu-id="5aedc-353">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType> if the only visibility modifier is `protected`.</span></span> <span data-ttu-id="5aedc-354">Ta właściwość dotyczy `false` metod, które znajdują C# się`Protected Friend` `protected internal` `protected public` w (w Visual Basic C++w). Użyj <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> właściwości, aby zidentyfikować takie metody.</span><span class="sxs-lookup"><span data-stu-id="5aedc-354">This property is `false` for methods that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property to identify such methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5aedc-355">Poniższy przykład kodu definiuje metody z <xref:System.Reflection.MethodBase.IsAssembly%2A>różnymi poziomami widoczności i wyświetla wartości ich właściwości, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, i <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> .</span><span class="sxs-lookup"><span data-stu-id="5aedc-355">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5aedc-356">Visual Basic i C# Języki nie mogą definiować metod z <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> widocznością; ten poziom dostępu jest wyświetlany tylko C++ w przykładzie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-356">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyAndAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyAndAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFamilyAndAssembly : bool" Usage="System.Reflection.MethodBase.IsFamilyAndAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-357">Pobiera wartość wskazującą, czy widoczność tej metody lub konstruktora jest opisywana przez <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />. oznacza to, że metoda lub Konstruktor mogą być wywoływane przez klasy pochodne, ale tylko wtedy, gdy znajdują się w tym samym zestawie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-357">Gets a value indicating whether the visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; that is, the method or constructor can be called by derived classes, but only if they are in the same assembly.</span></span></summary>
        <value><span data-ttu-id="5aedc-358"><see langword="true" />Jeśli dostęp do tej metody lub konstruktora jest dokładnie opisany przez <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; w przeciwnym <see langword="false" />razie,.</span><span class="sxs-lookup"><span data-stu-id="5aedc-358"><see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-359">Widoczność metody lub konstruktora jest dokładnie opisana przez <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> , jeśli modyfikator widoczności znajduje się `protected private` w. C++</span><span class="sxs-lookup"><span data-stu-id="5aedc-359">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> if the visibility modifier is `protected private` in C++.</span></span> <span data-ttu-id="5aedc-360">Nie można definiować metod o tej widoczności w Visual Basic lub C#.</span><span class="sxs-lookup"><span data-stu-id="5aedc-360">Methods with this visibility cannot be defined in Visual Basic or C#.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5aedc-361">Poniższy przykład kodu definiuje metody z <xref:System.Reflection.MethodBase.IsAssembly%2A>różnymi poziomami widoczności i wyświetla wartości ich właściwości, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, i <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> .</span><span class="sxs-lookup"><span data-stu-id="5aedc-361">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5aedc-362">Visual Basic i C# Języki nie mogą definiować metod z <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> widocznością; ten poziom dostępu jest wyświetlany tylko C++ w przykładzie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-362">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyOrAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyOrAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFamilyOrAssembly : bool" Usage="System.Reflection.MethodBase.IsFamilyOrAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-363">Pobiera wartość wskazującą, czy potencjalna widoczność tej metody lub konstruktora jest opisywana przez <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />. oznacza to, że metoda lub Konstruktor mogą być wywoływane przez klasy pochodne wszędzie tam, gdzie są, i według klas w tym samym zestawie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-363">Gets a value indicating whether the potential visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; that is, the method or constructor can be called by derived classes wherever they are, and by classes in the same assembly.</span></span></summary>
        <value><span data-ttu-id="5aedc-364"><see langword="true" />Jeśli dostęp do tej metody lub konstruktora jest dokładnie opisany przez <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; w przeciwnym <see langword="false" />razie,.</span><span class="sxs-lookup"><span data-stu-id="5aedc-364"><see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-365">Jeśli element członkowski typu ma <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> widoczność, może być wywoływana z dowolnego elementu członkowskiego klasy pochodnej lub dowolnego elementu członkowskiego w tym samym zestawie, ale nie z dowolnego innego typu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-365">If a type member has <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> visibility, it can be called from any member in a derived class or any member in the same assembly, but not from any other type.</span></span>  
  
 <span data-ttu-id="5aedc-366">Rzeczywista widoczność metody jest ograniczona przez widoczność jej typu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-366">The actual visibility of a method is limited by the visibility of its type.</span></span> <span data-ttu-id="5aedc-367">Właściwość może być `true` dla metody, ale jeśli jest to metoda typu zagnieżdżonego Private, metoda nie jest widoczna poza typem zawierającym. <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A></span><span class="sxs-lookup"><span data-stu-id="5aedc-367">The <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property might be `true` for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</span></span>  
  
 <span data-ttu-id="5aedc-368">Widoczność metody lub konstruktora <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> jest dokładnie opisana przez, jeśli modyfikator widoczności jest `protected internal` w C# (`Protected Friend` w Visual Basic, `protected public` w C++).</span><span class="sxs-lookup"><span data-stu-id="5aedc-368">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> if the visibility modifier is `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5aedc-369">Poniższy przykład kodu definiuje metody z <xref:System.Reflection.MethodBase.IsAssembly%2A>różnymi poziomami widoczności i wyświetla wartości ich właściwości, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, i <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> .</span><span class="sxs-lookup"><span data-stu-id="5aedc-369">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5aedc-370">Visual Basic i C# Języki nie mogą definiować metod z <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> widocznością; ten poziom dostępu jest wyświetlany tylko C++ w przykładzie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-370">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFinal">
      <MemberSignature Language="C#" Value="public bool IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFinal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFinal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFinal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFinal : bool" Usage="System.Reflection.MethodBase.IsFinal" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFinal</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-371">Pobiera wartość wskazującą, czy ta metoda jest <see langword="final" />.</span><span class="sxs-lookup"><span data-stu-id="5aedc-371">Gets a value indicating whether this method is <see langword="final" />.</span></span></summary>
        <value><span data-ttu-id="5aedc-372"><see langword="true" />Jeśli ta metoda jest <see langword="final" />; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-372"><see langword="true" /> if this method is <see langword="final" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-373">Aby określić, czy metoda jest za, nie wystarcza do sprawdzenia, czy <xref:System.Reflection.MethodBase.IsVirtual%2A> jest `true`.</span><span class="sxs-lookup"><span data-stu-id="5aedc-373">To determine if a method is overridable, it is not sufficient to check that <xref:System.Reflection.MethodBase.IsVirtual%2A> is `true`.</span></span> <span data-ttu-id="5aedc-374">W przypadku metody `IsVirtual` do zastąpienia, musi być `true` i `IsFinal` musi być `false`.</span><span class="sxs-lookup"><span data-stu-id="5aedc-374">For a method to be overridable, `IsVirtual` must be `true` and `IsFinal` must be `false`.</span></span> <span data-ttu-id="5aedc-375">Na przykład metoda może być niewirtualna, ale implementuje metodę interfejsu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-375">For example, a method might be non-virtual, but it implements an interface method.</span></span> <span data-ttu-id="5aedc-376">Środowisko uruchomieniowe języka wspólnego wymaga, aby wszystkie metody implementujące składowe interfejsu muszą `virtual`być oznaczone jako; w związku z tym `virtual final`, kompilator oznacza metodę.</span><span class="sxs-lookup"><span data-stu-id="5aedc-376">The common language runtime requires that all methods that implement interface members must be marked as `virtual`; therefore, the compiler marks the method `virtual final`.</span></span> <span data-ttu-id="5aedc-377">Istnieją przypadki, w których metoda jest oznaczona jako, `virtual` ale nadal nie jest możliwy do zastąpienia.</span><span class="sxs-lookup"><span data-stu-id="5aedc-377">So there are cases where a method is marked as `virtual` but is still not overridable.</span></span>  
  
 <span data-ttu-id="5aedc-378">Aby ustalić, czy metoda jest niedostosowana, należy użyć kodu takiego jak:</span><span class="sxs-lookup"><span data-stu-id="5aedc-378">To establish with certainty whether a method is overridable, use code such as this:</span></span>  
  
 `if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)`  
  
 <span data-ttu-id="5aedc-379">Jeśli `IsVirtual` jest `false` lub `IsFinal` jest ,metodaniemożezostaćzastąpiona.`true`</span><span class="sxs-lookup"><span data-stu-id="5aedc-379">If `IsVirtual` is `false` or `IsFinal` is `true`, then the method cannot be overridden.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5aedc-380">Poniższy przykład wyświetla `false` dla `IsFinal`, co może prowadzić do podejrzeń, że metoda ma wartość.</span><span class="sxs-lookup"><span data-stu-id="5aedc-380">The following example displays `false` for `IsFinal`, which might lead you to think that MyMethod is overridable.</span></span> <span data-ttu-id="5aedc-381">Kod drukuje `false` , mimo że metoda nie jest oznaczona `virtual` i w tym przypadku nie można jej zastąpić.</span><span class="sxs-lookup"><span data-stu-id="5aedc-381">The code prints `false` even though MyMethod is not marked `virtual` and thus cannot be overridden.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethod : bool" Usage="System.Reflection.MethodBase.IsGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-382">Pobiera wartość wskazującą, czy metoda jest ogólna.</span><span class="sxs-lookup"><span data-stu-id="5aedc-382">Gets a value indicating whether the method is generic.</span></span></summary>
        <value><span data-ttu-id="5aedc-383"><see langword="true" />Jeśli bieżąca <see cref="T:System.Reflection.MethodBase" /> reprezentuje metodę rodzajową; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-383"><see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> represents a generic method; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-384">Użyj właściwości, aby określić, czy bieżący <xref:System.Reflection.MethodBase> obiekt reprezentuje metodę rodzajową. <xref:System.Reflection.MethodBase.IsGenericMethod%2A></span><span class="sxs-lookup"><span data-stu-id="5aedc-384">Use the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property to determine whether the current <xref:System.Reflection.MethodBase> object represents a generic method.</span></span> <span data-ttu-id="5aedc-385">Użyj właściwości, aby określić, czy bieżący <xref:System.Reflection.MethodBase> obiekt reprezentuje metodę Open skonstruowane lub zamkniętą metodę skonstruowaną. <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A></span><span class="sxs-lookup"><span data-stu-id="5aedc-385">Use the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property to determine whether the current <xref:System.Reflection.MethodBase> object represents an open constructed method or a closed constructed method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5aedc-386">Typy ogólne nie są domyślnie obsługiwane. Ta właściwość zwraca `false` wartość, jeśli nie została przesłonięta w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="5aedc-386">Generics are not supported by default; this property returns `false` if not overridden in a derived class.</span></span> <span data-ttu-id="5aedc-387">Konstruktory generyczne nie są obsługiwane w .NET Framework w wersji 2,0, dlatego ta `false` Właściwość zwraca wartość, jeśli bieżące wystąpienie <xref:System.Reflection.ConstructorInfo>jest typu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-387">Generic constructors are not supported in the .NET Framework version 2.0, so this property returns `false` if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
<span data-ttu-id="5aedc-388">W poniższej tabeli zestawiono niezmienne warunki dotyczące warunków specyficznych dla metod ogólnych.</span><span class="sxs-lookup"><span data-stu-id="5aedc-388">The following table summarizes the invariant conditions for terms specific to generic methods.</span></span> <span data-ttu-id="5aedc-389">W przypadku innych terminów używanych w odbiciu ogólnym, takich jak *parametr typu ogólnego* i *typ ogólny* <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> , zobacz Właściwość.</span><span class="sxs-lookup"><span data-stu-id="5aedc-389">For other terms used in generic reflection, such as *generic type parameter* and *generic type*, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>   

|<span data-ttu-id="5aedc-390">Termin</span><span class="sxs-lookup"><span data-stu-id="5aedc-390">Term</span></span>|<span data-ttu-id="5aedc-391">Niezmienny warunek</span><span class="sxs-lookup"><span data-stu-id="5aedc-391">Invariant condition</span></span>| 
|---|---| 
|<span data-ttu-id="5aedc-392">definicja metody ogólnej</span><span class="sxs-lookup"><span data-stu-id="5aedc-392">generic method definition</span></span>| <span data-ttu-id="5aedc-393"><xref:System.Reflection.MethodBase.IsGenericMethodDefinition> Właściwość jest`true`.</span><span class="sxs-lookup"><span data-stu-id="5aedc-393">The <xref:System.Reflection.MethodBase.IsGenericMethodDefinition> property is `true`.</span></span> <br /><span data-ttu-id="5aedc-394">Definiuje metodę rodzajową.</span><span class="sxs-lookup"><span data-stu-id="5aedc-394">Defines a generic method.</span></span> <span data-ttu-id="5aedc-395">Skonstruowana Metoda jest tworzona przez wywołanie <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> metody <xref:System.Reflection.MethodInfo> dla obiektu, który reprezentuje definicję metody ogólnej i określenie tablicy argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-395">A constructed method is created by calling the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> method on a <xref:System.Reflection.MethodInfo> object that represents a generic method definition, and specifying an array of type arguments.</span></span> <br /><span data-ttu-id="5aedc-396"><xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> Metodę można wywołać tylko w definicjach metod ogólnych.</span><span class="sxs-lookup"><span data-stu-id="5aedc-396">The <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method can be called only on generic method definitions.</span></span> <br/><span data-ttu-id="5aedc-397">Każda definicja metody ogólnej jest metodą rodzajową, ale nie ma wartości true.</span><span class="sxs-lookup"><span data-stu-id="5aedc-397">Any generic method definition is a generic method, but the converse is not true.</span></span>|    
|<span data-ttu-id="5aedc-398">Metoda generyczna</span><span class="sxs-lookup"><span data-stu-id="5aedc-398">generic method</span></span>|<span data-ttu-id="5aedc-399">`IsGenericMethod` Właściwość jest`true`.</span><span class="sxs-lookup"><span data-stu-id="5aedc-399">The `IsGenericMethod` property is `true`.</span></span> <br/> <span data-ttu-id="5aedc-400">Może to być definicja metody ogólnej, otwarta metoda skonstruowana lub ZAMKNIĘTA Metoda skonstruowana.</span><span class="sxs-lookup"><span data-stu-id="5aedc-400">Can be a generic method definition, an open constructed method, or a closed constructed method.</span></span>| 
|<span data-ttu-id="5aedc-401">Otwórz skonstruowaną metodę</span><span class="sxs-lookup"><span data-stu-id="5aedc-401">open constructed method</span></span>|<span data-ttu-id="5aedc-402"><xref:System.Reflection.MethodBase.ContainsGenericParameters> Właściwość jest`true`.</span><span class="sxs-lookup"><span data-stu-id="5aedc-402">The <xref:System.Reflection.MethodBase.ContainsGenericParameters> property is `true`.</span></span> <br/><span data-ttu-id="5aedc-403">Nie można wywołać otwartej metody.</span><span class="sxs-lookup"><span data-stu-id="5aedc-403">It is not possible to invoke an open constructed method.</span></span>|  
|<span data-ttu-id="5aedc-404">ZAMKNIĘTA Metoda skonstruowana</span><span class="sxs-lookup"><span data-stu-id="5aedc-404">closed constructed method</span></span>|<span data-ttu-id="5aedc-405"><xref:System.Reflection.MethodBase.ContainsGenericParameters> Właściwość jest`false`.</span><span class="sxs-lookup"><span data-stu-id="5aedc-405">The <xref:System.Reflection.MethodBase.ContainsGenericParameters> property is `false`.</span></span> <br/><span data-ttu-id="5aedc-406">Gdy badane cyklicznie, metoda nie ma żadnych nieprzypisanych parametrów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="5aedc-406">When examined recursively, the method has no unassigned generic parameters.</span></span> <span data-ttu-id="5aedc-407">Typ zawierający nie ma parametrów typu ogólnego, a żaden z argumentów typu nie ma parametrów typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="5aedc-407">The containing type has no generic type parameters, and none of the type arguments have generic type parameters.</span></span> <br/><span data-ttu-id="5aedc-408">Metoda może być wywoływana.</span><span class="sxs-lookup"><span data-stu-id="5aedc-408">The method can be invoked.</span></span>|   

 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodDefinition : bool" Usage="System.Reflection.MethodBase.IsGenericMethodDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-409">Pobiera wartość wskazującą, czy metoda jest definicją metody ogólnej.</span><span class="sxs-lookup"><span data-stu-id="5aedc-409">Gets a value indicating whether the method is a generic method definition.</span></span></summary>
        <value><span data-ttu-id="5aedc-410"><see langword="true" />Jeśli bieżący <see cref="T:System.Reflection.MethodBase" /> obiekt reprezentuje definicję metody generycznej; w przeciwnym razie, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5aedc-410"><see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> object represents the definition of a generic method; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-411">Jeśli bieżąca <xref:System.Reflection.MethodBase> reprezentuje definicję metody ogólnej, wówczas:</span><span class="sxs-lookup"><span data-stu-id="5aedc-411">If the current <xref:System.Reflection.MethodBase> represents a generic method definition, then:</span></span>  
  
-   <span data-ttu-id="5aedc-412"><xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> Właściwość jest`true`.</span><span class="sxs-lookup"><span data-stu-id="5aedc-412">The <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> property is `true`.</span></span>  
  
-   <span data-ttu-id="5aedc-413">Dla każdego <xref:System.Type> obiektu w tablicy zwracanej <xref:System.Reflection.MethodBase.GetGenericArguments%2A> przez metodę:</span><span class="sxs-lookup"><span data-stu-id="5aedc-413">For each <xref:System.Type> object in the array returned by the <xref:System.Reflection.MethodBase.GetGenericArguments%2A> method:</span></span>  
  
    -   <span data-ttu-id="5aedc-414"><xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType> Właściwość jest`true`.</span><span class="sxs-lookup"><span data-stu-id="5aedc-414">The <xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType> property is `true`.</span></span>  
  
    -   <span data-ttu-id="5aedc-415"><xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType> Właściwość zwraca bieżące wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-415">The <xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType> property returns the current instance.</span></span>  
  
    -   <span data-ttu-id="5aedc-416">Właściwość jest taka sama jak pozycja <xref:System.Type> obiektu w tablicy. <xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="5aedc-416">The <xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType> property is the same as the position of the <xref:System.Type> object in the array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5aedc-417">Typy ogólne nie są domyślnie obsługiwane. Ta właściwość zwraca `false` wartość, jeśli nie została przesłonięta w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="5aedc-417">Generics are not supported by default; this property returns `false` if not overridden in a derived class.</span></span> <span data-ttu-id="5aedc-418">Konstruktory generyczne nie są obsługiwane w .NET Framework w wersji 2,0, dlatego ta `false` Właściwość zwraca wartość, jeśli bieżące wystąpienie <xref:System.Reflection.ConstructorInfo>jest typu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-418">Generic constructors are not supported in the .NET Framework version 2.0, so this property returns `false` if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 <span data-ttu-id="5aedc-419">Aby zapoznać się z listą warunków niewariantów dla warunków specyficznych dla metod ogólnych, <xref:System.Reflection.MethodBase.IsGenericMethod%2A> Zobacz właściwość.</span><span class="sxs-lookup"><span data-stu-id="5aedc-419">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="5aedc-420">Aby uzyskać listę niezmiennych warunków dla innych terminów używanych w odbiciu ogólnym, zobacz <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> właściwość.</span><span class="sxs-lookup"><span data-stu-id="5aedc-420">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsHideBySig">
      <MemberSignature Language="C#" Value="public bool IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsHideBySig" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHideBySig As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHideBySig { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHideBySig : bool" Usage="System.Reflection.MethodBase.IsHideBySig" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsHideBySig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-421">Pobiera wartość wskazującą, czy tylko element członkowski tego samego rodzaju o dokładnie takiej samej sygnaturze jest ukryty w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="5aedc-421">Gets a value indicating whether only a member of the same kind with exactly the same signature is hidden in the derived class.</span></span></summary>
        <value><span data-ttu-id="5aedc-422"><see langword="true" />Jeśli element członkowski jest ukryty za pomocą podpisu; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="5aedc-422"><see langword="true" /> if the member is hidden by signature; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-423">Gdy element członkowski klasy pochodnej jest zadeklarowany za pomocą C# `new` modyfikatora lub modyfikatora `Shadows` Visual Basic, można ukryć składową o tej samej nazwie w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="5aedc-423">When a member in a derived class is declared with the C# `new` modifier or the Visual Basic `Shadows` modifier, it can hide a member of the same name in the base class.</span></span> <span data-ttu-id="5aedc-424">C#ukrywa składowe klasy bazowej według podpisu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-424">C# hides base class members by signature.</span></span> <span data-ttu-id="5aedc-425">Oznacza to, że jeśli składowa klasy bazowej ma wiele przeciążeń, jedyna ukryta jest taka, która ma identyczny podpis.</span><span class="sxs-lookup"><span data-stu-id="5aedc-425">That is, if the base class member has multiple overloads, the only one that is hidden is the one that has the identical signature.</span></span> <span data-ttu-id="5aedc-426">Z kolei Visual Basic ukrywa wszystkie przeciążenia klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="5aedc-426">By contrast, Visual Basic hides all the base class overloads.</span></span> <span data-ttu-id="5aedc-427">C# `new` `true` `Shadows` W ten sposób `false`zwracawartość z elementu członkowskiego zadeklarowanego za pomocą modyfikatora Visual Basic i na elemencie członkowskim zadeklarowanym z modyfikatorem. <xref:System.Reflection.MethodBase.IsHideBySig%2A></span><span class="sxs-lookup"><span data-stu-id="5aedc-427">Thus, <xref:System.Reflection.MethodBase.IsHideBySig%2A> returns `false` on a member declared with the Visual Basic `Shadows` modifier, and `true` on a member declared with the C# `new` modifier.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="5aedc-428">Ta właściwość nie określa, <xref:System.Reflection.MethodAttributes.NewSlot> czy metoda ma atrybut.</span><span class="sxs-lookup"><span data-stu-id="5aedc-428">This property does not determine whether a method has the <xref:System.Reflection.MethodAttributes.NewSlot> attribute.</span></span> <span data-ttu-id="5aedc-429">Metoda zadeklarowana przy `new` użyciu `Shadows` lub modyfikatora będzie miała <xref:System.Reflection.MethodAttributes.NewSlot> atrybut, ale tylko metody zadeklarowane za pomocą `new` (czyli tylko C# metody) będą miały <xref:System.Reflection.MethodBase.IsHideBySig%2A> ustawioną właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="5aedc-429">A method that is declared with either the `new` or the `Shadows` modifier will have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, but only methods declared with `new` (that is, only C# methods) will have the <xref:System.Reflection.MethodBase.IsHideBySig%2A> property set to `true`.</span></span>  <span data-ttu-id="5aedc-430">Aby określić <xref:System.Reflection.MethodAttributes.NewSlot> , czy metoda ma atrybut, należy użyć kodu podobnego do następującego: `if ((myMethodInfo.Attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)` w C# lub `If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot` w Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="5aedc-430">To determine whether a method has the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, use code similar to the following: `if ((myMethodInfo.Attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)` in C# or `If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot` in Visual Basic.</span></span> <span data-ttu-id="5aedc-431">Należy jednak pamiętać, że mimo że wszystkie metody zadeklarowane `Shadows` z `new` lub <xref:System.Reflection.MethodAttributes.NewSlot> mają <xref:System.Reflection.MethodAttributes.NewSlot> atrybut, nie wszystkie metody, które mają atrybut są zadeklarowane `Shadows`z `new` lub.</span><span class="sxs-lookup"><span data-stu-id="5aedc-431">Note, however, that although all methods declared with `new` or `Shadows` have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, not all methods that have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute are declared with `new` or `Shadows`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5aedc-432">Poniższy przykład kodu zawiera klasę bazową ze przeciążoną metodą i klasę pochodną, która ukrywa jedno z przeciążeń.</span><span class="sxs-lookup"><span data-stu-id="5aedc-432">The following code example contains a base class with an overloaded method, and a derived class that hides one of the overloads.</span></span> <span data-ttu-id="5aedc-433">W Visual Basic wersji przykładu kodu, <xref:System.Reflection.MethodBase.IsHideBySig%2A> Właściwość zwraca `false` dla elementu członkowskiego klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="5aedc-433">In the Visual Basic version of the code example, the <xref:System.Reflection.MethodBase.IsHideBySig%2A> property returns `false` for the member in the derived class.</span></span> <span data-ttu-id="5aedc-434">W C# wersji przykładu kodu, właściwość zwraca `true` dla elementu członkowskiego klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="5aedc-434">In the C# version of the code sample, the property returns `true` for the member in the derived class.</span></span>  
  
 [!code-cpp[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/cpp/hide.cpp#1)]
 [!code-csharp[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/CS/hide.cs#1)]
 [!code-vb[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/VB/hide.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrivate">
      <MemberSignature Language="C#" Value="public bool IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrivate : bool" Usage="System.Reflection.MethodBase.IsPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-435">Pobiera wartość wskazującą, czy ten element członkowski jest prywatny.</span><span class="sxs-lookup"><span data-stu-id="5aedc-435">Gets a value indicating whether this member is private.</span></span></summary>
        <value><span data-ttu-id="5aedc-436"><see langword="true" />Jeśli dostęp do tej metody jest ograniczony do innych członków klasy; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="5aedc-436"><see langword="true" /> if access to this method is restricted to other members of the class itself; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-437">Jeśli element członkowski typu ma `Private` widoczność poziomu, może być wywoływana z dowolnego elementu członkowskiego w tej samej klasie i nie ma innych.</span><span class="sxs-lookup"><span data-stu-id="5aedc-437">If a type member has `Private` level visibility, it can be called from any member in the same class and no others.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Reflection.MethodBase.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-438">Pobiera wartość wskazującą, czy jest to metoda publiczna.</span><span class="sxs-lookup"><span data-stu-id="5aedc-438">Gets a value indicating whether this is a public method.</span></span></summary>
        <value><span data-ttu-id="5aedc-439"><see langword="true" />Jeśli ta metoda jest publiczna; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="5aedc-439"><see langword="true" /> if this method is public; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-440">Aby uzyskać <xref:System.Reflection.MethodBase>, najpierw Pobierz typ.</span><span class="sxs-lookup"><span data-stu-id="5aedc-440">To get the <xref:System.Reflection.MethodBase>, first get the type.</span></span> <span data-ttu-id="5aedc-441">Z typu należy uzyskać metodę.</span><span class="sxs-lookup"><span data-stu-id="5aedc-441">From the type, get the method.</span></span> <span data-ttu-id="5aedc-442">Z metody Pobierz `MethodBase`.</span><span class="sxs-lookup"><span data-stu-id="5aedc-442">From the method, get the `MethodBase`.</span></span> <span data-ttu-id="5aedc-443">Jeśli Konstruktor `MethodBase` or jest inny niż publiczny, jest chroniony i nie można uzyskać do niego dostępu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-443">If the `MethodBase` or constructor is other than public, it is protected and cannot be readily accessed.</span></span> <span data-ttu-id="5aedc-444">Aby uzyskać dostęp do metody niepublicznej, należy <xref:System.Reflection.BindingFlags> ustawić maskę `GetMethod`na `NonPublic` wartość w.</span><span class="sxs-lookup"><span data-stu-id="5aedc-444">To access a non-public method, set the <xref:System.Reflection.BindingFlags> mask to `NonPublic` in `GetMethod`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5aedc-445">Poniższy przykład używa <xref:System.Reflection.MethodBase.IsPublic%2A> właściwości, aby wyświetlić komunikat wskazujący, czy określona metoda jest publiczna.</span><span class="sxs-lookup"><span data-stu-id="5aedc-445">The following example uses the <xref:System.Reflection.MethodBase.IsPublic%2A> property to display a message that indicates whether the specified method is public.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.MethodBase.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-446">Pobiera wartość wskazującą, czy bieżąca metoda lub Konstruktor ma krytyczne znaczenie dla zabezpieczeń lub zabezpieczenia-krytycznie na bieżącym poziomie zaufania, dlatego może wykonywać krytyczne operacje.</span><span class="sxs-lookup"><span data-stu-id="5aedc-446">Gets a value that indicates whether the current method or constructor is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</span></span></summary>
        <value><span data-ttu-id="5aedc-447"><see langword="true" />Jeśli bieżąca metoda lub Konstruktor jest krytyczna dla zabezpieczeń lub bezpieczna-krytycznie na bieżącym poziomie zaufania; <see langword="false" /> jeśli jest przezroczysty.</span><span class="sxs-lookup"><span data-stu-id="5aedc-447"><see langword="true" /> if the current method or constructor is security-critical or security-safe-critical at the current trust level; <see langword="false" /> if it is transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-448">Właściwości <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> i<xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> raportują poziom przezroczystości metody lub konstruktora na bieżącym poziomie zaufania, zgodnie z opisem w środowisku uruchomieniowym języka wspólnego (CLR).</span><span class="sxs-lookup"><span data-stu-id="5aedc-448">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="5aedc-449">W poniższej tabeli przedstawiono kombinacje tych właściwości:</span><span class="sxs-lookup"><span data-stu-id="5aedc-449">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="5aedc-450">Poziom zabezpieczeń</span><span class="sxs-lookup"><span data-stu-id="5aedc-450">Security level</span></span>|<span data-ttu-id="5aedc-451">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="5aedc-451">IsSecurityCritical</span></span>|<span data-ttu-id="5aedc-452">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="5aedc-452">IsSecuritySafeCritical</span></span>|<span data-ttu-id="5aedc-453">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="5aedc-453">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="5aedc-454">Krytyczny</span><span class="sxs-lookup"><span data-stu-id="5aedc-454">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="5aedc-455">Bezpieczne krytyczne</span><span class="sxs-lookup"><span data-stu-id="5aedc-455">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="5aedc-456">Przezroczyste</span><span class="sxs-lookup"><span data-stu-id="5aedc-456">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="5aedc-457">Korzystanie z tych właściwości jest znacznie prostsze niż badanie adnotacji zabezpieczeń zestawu i jego typów i członków, sprawdzanie bieżącego poziomu zaufania i próba duplikowania reguł środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="5aedc-457">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="5aedc-458">Dla zestawów częściowego zaufania wartość tej właściwości zależy od bieżącego poziomu zaufania dla zestawu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-458">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="5aedc-459">Jeśli zestaw jest ładowany do domeny częściowo zaufanej aplikacji (na przykład w domenie aplikacji w trybie piaskownicy), środowisko uruchomieniowe ignoruje adnotacje zabezpieczeń zestawu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-459">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="5aedc-460">Zestaw i wszystkie jego typy są traktowane jako przezroczyste.</span><span class="sxs-lookup"><span data-stu-id="5aedc-460">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="5aedc-461">Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń zestawu częściowego zaufania tylko wtedy, gdy zestaw ten jest ładowany do w pełni zaufanej domeny aplikacji (na przykład, do domyślnej domeny aplikacji z aplikacji pulpitu).</span><span class="sxs-lookup"><span data-stu-id="5aedc-461">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="5aedc-462">Z drugiej strony zaufany zestaw (czyli zestaw z silną nazwą zainstalowaną w globalnej pamięci podręcznej zestawów) zawsze jest ładowany z pełnym zaufaniem, bez względu na poziom zaufania domeny aplikacji, więc jego bieżący poziom zaufania zawsze jest w pełni zaufany.</span><span class="sxs-lookup"><span data-stu-id="5aedc-462">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="5aedc-463">Bieżące poziomy zaufania zestawów i domen aplikacji można określić przy użyciu <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości i. <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="5aedc-463">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="5aedc-464">Aby uzyskać więcej informacji o odbiciu i przezroczystości, zobacz Zagadnienia dotyczące [zabezpieczeń dotyczące odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="5aedc-464">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="5aedc-465">Aby uzyskać informacje na temat przejrzystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="5aedc-465">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="5aedc-466">Zagadnienia dotyczące zabezpieczeń dla odbicia</span><span class="sxs-lookup"><span data-stu-id="5aedc-466">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="5aedc-467">Zmiany zabezpieczeń w .NET Framework w wersji 4,0</span><span class="sxs-lookup"><span data-stu-id="5aedc-467">Security Changes in the .NET Framework Version 4.0</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.MethodBase.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-468">Pobiera wartość wskazującą, czy bieżąca metoda lub Konstruktor zapewnia zabezpieczenia — krytycznie na bieżącym poziomie zaufania; oznacza to, czy może wykonywać krytyczne operacje i można uzyskać do nich dostęp za pomocą przezroczystego kodu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-468">Gets a value that indicates whether the current method or constructor is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</span></span></summary>
        <value><span data-ttu-id="5aedc-469"><see langword="true" />Jeśli metoda lub Konstruktor jest bezpieczny dla bezpieczeństwa-krytyczny na bieżącym poziomie zaufania; <see langword="false" /> jeśli jest to zabezpieczenia krytyczne lub przezroczyste.</span><span class="sxs-lookup"><span data-stu-id="5aedc-469"><see langword="true" /> if the method or constructor is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-470">Właściwości <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> i<xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> raportują poziom przezroczystości metody lub konstruktora na bieżącym poziomie zaufania, zgodnie z opisem w środowisku uruchomieniowym języka wspólnego (CLR).</span><span class="sxs-lookup"><span data-stu-id="5aedc-470">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="5aedc-471">W poniższej tabeli przedstawiono kombinacje tych właściwości:</span><span class="sxs-lookup"><span data-stu-id="5aedc-471">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="5aedc-472">Poziom zabezpieczeń</span><span class="sxs-lookup"><span data-stu-id="5aedc-472">Security level</span></span>|<span data-ttu-id="5aedc-473">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="5aedc-473">IsSecurityCritical</span></span>|<span data-ttu-id="5aedc-474">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="5aedc-474">IsSecuritySafeCritical</span></span>|<span data-ttu-id="5aedc-475">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="5aedc-475">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="5aedc-476">Krytyczny</span><span class="sxs-lookup"><span data-stu-id="5aedc-476">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="5aedc-477">Bezpieczne krytyczne</span><span class="sxs-lookup"><span data-stu-id="5aedc-477">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="5aedc-478">Przezroczyste</span><span class="sxs-lookup"><span data-stu-id="5aedc-478">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="5aedc-479">Korzystanie z tych właściwości jest znacznie prostsze niż badanie adnotacji zabezpieczeń zestawu i jego typów i członków, sprawdzanie bieżącego poziomu zaufania i próba duplikowania reguł środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="5aedc-479">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="5aedc-480">Dla zestawów częściowego zaufania wartość tej właściwości zależy od bieżącego poziomu zaufania dla zestawu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-480">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="5aedc-481">Jeśli zestaw jest ładowany do domeny częściowo zaufanej aplikacji (na przykład w domenie aplikacji w trybie piaskownicy), środowisko uruchomieniowe ignoruje adnotacje zabezpieczeń zestawu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-481">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="5aedc-482">Zestaw i wszystkie jego typy są traktowane jako przezroczyste.</span><span class="sxs-lookup"><span data-stu-id="5aedc-482">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="5aedc-483">Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń zestawu częściowego zaufania tylko wtedy, gdy zestaw ten jest ładowany do w pełni zaufanej domeny aplikacji (na przykład, do domyślnej domeny aplikacji z aplikacji pulpitu).</span><span class="sxs-lookup"><span data-stu-id="5aedc-483">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="5aedc-484">Z drugiej strony zaufany zestaw (czyli zestaw z silną nazwą zainstalowaną w globalnej pamięci podręcznej zestawów) zawsze jest ładowany z pełnym zaufaniem, bez względu na poziom zaufania domeny aplikacji, więc jego bieżący poziom zaufania zawsze jest w pełni zaufany.</span><span class="sxs-lookup"><span data-stu-id="5aedc-484">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="5aedc-485">Bieżące poziomy zaufania zestawów i domen aplikacji można określić przy użyciu <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości i. <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="5aedc-485">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="5aedc-486">Aby uzyskać więcej informacji o odbiciu i przezroczystości, zobacz Zagadnienia dotyczące [zabezpieczeń dotyczące odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="5aedc-486">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="5aedc-487">Aby uzyskać informacje na temat przejrzystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="5aedc-487">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="5aedc-488">Zagadnienia dotyczące zabezpieczeń dla odbicia</span><span class="sxs-lookup"><span data-stu-id="5aedc-488">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="5aedc-489">Zmiany zabezpieczeń w .NET Framework w wersji 4,0</span><span class="sxs-lookup"><span data-stu-id="5aedc-489">Security Changes in the .NET Framework Version 4.0</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.MethodBase.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-490">Pobiera wartość wskazującą, czy bieżąca metoda lub Konstruktor jest przezroczysty na bieżącym poziomie zaufania, w związku z czym nie można wykonać operacji krytycznych.</span><span class="sxs-lookup"><span data-stu-id="5aedc-490">Gets a value that indicates whether the current method or constructor is transparent at the current trust level, and therefore cannot perform critical operations.</span></span></summary>
        <value><span data-ttu-id="5aedc-491"><see langword="true" />Jeśli metoda lub Konstruktor są przezroczyste dla zabezpieczeń na bieżącym poziomie zaufania; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="5aedc-491"><see langword="true" /> if the method or constructor is security-transparent at the current trust level; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-492">Jeśli ta właściwość zwróci `true`wartość, <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> zwracane <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> `false`są właściwości i.</span><span class="sxs-lookup"><span data-stu-id="5aedc-492">If this property returns `true`, the <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> and <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> properties return `false`.</span></span>  
  
 <span data-ttu-id="5aedc-493">Właściwości <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> i<xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> raportują poziom przezroczystości metody lub konstruktora na bieżącym poziomie zaufania, zgodnie z opisem w środowisku uruchomieniowym języka wspólnego (CLR).</span><span class="sxs-lookup"><span data-stu-id="5aedc-493">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="5aedc-494">Korzystanie z tych właściwości jest znacznie prostsze niż badanie adnotacji zabezpieczeń zestawu i jego typów i członków, sprawdzanie bieżącego poziomu zaufania i próba duplikowania reguł środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="5aedc-494">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="5aedc-495">Dla zestawów częściowego zaufania wartość tej właściwości zależy od bieżącego poziomu zaufania dla zestawu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-495">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="5aedc-496">Jeśli zestaw jest ładowany do domeny częściowo zaufanej aplikacji (na przykład w domenie aplikacji w trybie piaskownicy), środowisko uruchomieniowe ignoruje adnotacje zabezpieczeń zestawu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-496">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="5aedc-497">Zestaw i wszystkie jego typy są traktowane jako przezroczyste.</span><span class="sxs-lookup"><span data-stu-id="5aedc-497">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="5aedc-498">Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń zestawu częściowego zaufania tylko wtedy, gdy zestaw ten jest ładowany do w pełni zaufanej domeny aplikacji (na przykład, do domyślnej domeny aplikacji z aplikacji pulpitu).</span><span class="sxs-lookup"><span data-stu-id="5aedc-498">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="5aedc-499">Z drugiej strony zaufany zestaw (czyli zestaw z silną nazwą zainstalowaną w globalnej pamięci podręcznej zestawów) zawsze jest ładowany z pełnym zaufaniem, bez względu na poziom zaufania domeny aplikacji, więc jego bieżący poziom zaufania zawsze jest w pełni zaufany.</span><span class="sxs-lookup"><span data-stu-id="5aedc-499">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="5aedc-500">Bieżące poziomy zaufania zestawów i domen aplikacji można określić przy użyciu <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości i. <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="5aedc-500">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="5aedc-501">Aby uzyskać więcej informacji o odbiciu i przezroczystości, zobacz Zagadnienia dotyczące [zabezpieczeń dotyczące odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="5aedc-501">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="5aedc-502">Aby uzyskać informacje na temat przejrzystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="5aedc-502">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="5aedc-503">Zagadnienia dotyczące zabezpieczeń dla odbicia</span><span class="sxs-lookup"><span data-stu-id="5aedc-503">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="5aedc-504">Zmiany zabezpieczeń w .NET Framework w wersji 4,0</span><span class="sxs-lookup"><span data-stu-id="5aedc-504">Security Changes in the .NET Framework Version 4.0</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Reflection.MethodBase.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-505">Pobiera wartość wskazującą, czy ta metoda ma specjalną nazwę.</span><span class="sxs-lookup"><span data-stu-id="5aedc-505">Gets a value indicating whether this method has a special name.</span></span></summary>
        <value><span data-ttu-id="5aedc-506"><see langword="true" />Jeśli ta metoda ma specjalną nazwę; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="5aedc-506"><see langword="true" /> if this method has a special name; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-507"><xref:System.Reflection.MethodAttributes.SpecialName> Bit jest ustawiony na Flagowanie elementów członkowskich, które są traktowane w specjalny sposób przez niektóre kompilatory (takie jak metody dostępu do właściwości i przeciążania operatora).</span><span class="sxs-lookup"><span data-stu-id="5aedc-507">The <xref:System.Reflection.MethodAttributes.SpecialName> bit is set to flag members that are treated in a special way by some compilers (such as property accessors and operator overloading methods).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5aedc-508">W tym przykładzie pokazano, jak <xref:System.Reflection.MethodBase.IsSpecialName%2A> użyć do odfiltrowania wewnętrznych lub prywatnych elementów członkowskich poza listą.</span><span class="sxs-lookup"><span data-stu-id="5aedc-508">This example shows a use of <xref:System.Reflection.MethodBase.IsSpecialName%2A> to filter internal or private members out of a list.</span></span>  
  
 [!code-cpp[Classic Type.IsSpecialName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsSpecialName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsSpecialName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsStatic">
      <MemberSignature Language="C#" Value="public bool IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsStatic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStatic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStatic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStatic : bool" Usage="System.Reflection.MethodBase.IsStatic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-509">Pobiera wartość wskazującą, czy metoda jest <see langword="static" />.</span><span class="sxs-lookup"><span data-stu-id="5aedc-509">Gets a value indicating whether the method is <see langword="static" />.</span></span></summary>
        <value><span data-ttu-id="5aedc-510"><see langword="true" />Jeśli ta metoda jest <see langword="static" />; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-510"><see langword="true" /> if this method is <see langword="static" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-511">Statyczny element członkowski nie może niejawnie odwoływać się do danych wystąpienia w klasie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-511">A static member cannot implicitly reference instance data in a class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsVirtual">
      <MemberSignature Language="C#" Value="public bool IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsVirtual" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVirtual As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVirtual { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVirtual : bool" Usage="System.Reflection.MethodBase.IsVirtual" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsVirtual</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-512">Pobiera wartość wskazującą, czy metoda jest <see langword="virtual" />.</span><span class="sxs-lookup"><span data-stu-id="5aedc-512">Gets a value indicating whether the method is <see langword="virtual" />.</span></span></summary>
        <value><span data-ttu-id="5aedc-513"><see langword="true" />Jeśli ta metoda jest <see langword="virtual" />; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-513"><see langword="true" /> if this method is <see langword="virtual" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-514">Wirtualny element członkowski może odwoływać się do danych wystąpienia w klasie i musi być przywoływany przez wystąpienie klasy.</span><span class="sxs-lookup"><span data-stu-id="5aedc-514">A virtual member may reference instance data in a class and must be referenced through an instance of the class.</span></span>  
  
 <span data-ttu-id="5aedc-515">Aby określić, czy metoda jest za, nie wystarcza do sprawdzenia, czy `IsVirtual` jest `true`.</span><span class="sxs-lookup"><span data-stu-id="5aedc-515">To determine if a method is overridable, it is not sufficient to check that `IsVirtual` is `true`.</span></span> <span data-ttu-id="5aedc-516">W przypadku metody `IsVirtual` do zastąpienia, musi być `true` i <xref:System.Reflection.MethodBase.IsFinal%2A> musi być `false`.</span><span class="sxs-lookup"><span data-stu-id="5aedc-516">For a method to be overridable, `IsVirtual` must be `true` and <xref:System.Reflection.MethodBase.IsFinal%2A> must be `false`.</span></span> <span data-ttu-id="5aedc-517">Na przykład metoda może być niewirtualna, ale implementuje metodę interfejsu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-517">For example, a method might be non-virtual, but it implements an interface method.</span></span> <span data-ttu-id="5aedc-518">Środowisko uruchomieniowe języka wspólnego wymaga, aby wszystkie metody implementujące składowe interfejsu muszą `virtual`być oznaczone jako; w związku z tym `virtual final`, kompilator oznacza metodę.</span><span class="sxs-lookup"><span data-stu-id="5aedc-518">The common language runtime requires that all methods that implement interface members must be marked as `virtual`; therefore, the compiler marks the method `virtual final`.</span></span> <span data-ttu-id="5aedc-519">Istnieją przypadki, w których metoda jest oznaczona jako, `virtual` ale nadal nie jest możliwy do zastąpienia.</span><span class="sxs-lookup"><span data-stu-id="5aedc-519">So there are cases where a method is marked as `virtual` but is still not overridable.</span></span>  
  
 <span data-ttu-id="5aedc-520">Aby ustalić, czy metoda jest niedostosowana, należy użyć kodu takiego jak:</span><span class="sxs-lookup"><span data-stu-id="5aedc-520">To establish with certainty whether a method is overridable, use code such as this:</span></span>  
  
```csharp  
if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)  
```  
  
```vb  
If MethodInfo.IsVirtual AndAlso Not MethodInfo.IsFinal Then  
```  
  
 <span data-ttu-id="5aedc-521">Jeśli `IsVirtual` jest `false` lub `IsFinal` jest ,metodaniemożezostaćzastąpiona.`true`</span><span class="sxs-lookup"><span data-stu-id="5aedc-521">If `IsVirtual` is `false` or `IsFinal` is `true`, then the method cannot be overridden.</span></span>  
  
 <span data-ttu-id="5aedc-522">Można określić, czy bieżąca metoda przesłania metodę w klasie bazowej przez wywołanie <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="5aedc-522">You can determine whether the current method overrides a method in a base class by calling the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="5aedc-523">Poniższy przykład implementuje `IsOverride` metodę, która robi to.</span><span class="sxs-lookup"><span data-stu-id="5aedc-523">The following example implements an `IsOverride` method that does this.</span></span>  
  
 [!code-csharp[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/IsOverride1.cs#2)]
 [!code-vb[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/IsOverride1.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="5aedc-524">Poniższy przykład wyświetla `false` dla `IsFinal`, co może `MyMethod` prowadzić do zaopiniowania.</span><span class="sxs-lookup"><span data-stu-id="5aedc-524">The following example displays `false` for `IsFinal`, which might lead you to think that `MyMethod` is overridable.</span></span> <span data-ttu-id="5aedc-525">Kod `MyMethod` jest drukowany `false` , chociaż nie jest oznaczony `virtual` i w ten sposób nie może zostać zastąpiony.</span><span class="sxs-lookup"><span data-stu-id="5aedc-525">The code prints `false` even though `MyMethod` is not marked `virtual` and thus cannot be overridden.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public abstract RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.MethodBase.MethodHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.MethodHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-526">Pobiera dojście do wewnętrznej reprezentacji metadanych metody.</span><span class="sxs-lookup"><span data-stu-id="5aedc-526">Gets a handle to the internal metadata representation of a method.</span></span></summary>
        <value><span data-ttu-id="5aedc-527">Element <see cref="T:System.RuntimeMethodHandle" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-527">A <see cref="T:System.RuntimeMethodHandle" /> object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-528">Dojścia są prawidłowe tylko w domenie aplikacji, w której zostały uzyskane.</span><span class="sxs-lookup"><span data-stu-id="5aedc-528">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.MethodBase.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-529"><see cref="T:System.Reflection.MethodImplAttributes" /> Pobiera flagi określające atrybuty implementacji metody.</span><span class="sxs-lookup"><span data-stu-id="5aedc-529">Gets the <see cref="T:System.Reflection.MethodImplAttributes" /> flags that specify the attributes of a method implementation.</span></span></summary>
        <value><span data-ttu-id="5aedc-530">Flagi implementacji metody.</span><span class="sxs-lookup"><span data-stu-id="5aedc-530">The method implementation flags.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-531">Aby uzyskać <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> więcej informacji, zobacz metodę.</span><span class="sxs-lookup"><span data-stu-id="5aedc-531">See the <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> method for more information.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As MethodBase, right As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::MethodBase ^ left, System::Reflection::MethodBase ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.MethodBase * System.Reflection.MethodBase -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="5aedc-532">Pierwszy obiekt, który ma zostać porównany.</span><span class="sxs-lookup"><span data-stu-id="5aedc-532">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="5aedc-533">Drugi obiekt, który będzie porównywany.</span><span class="sxs-lookup"><span data-stu-id="5aedc-533">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="5aedc-534">Wskazuje, czy <see cref="T:System.Reflection.MethodBase" /> dwa obiekty są równe.</span><span class="sxs-lookup"><span data-stu-id="5aedc-534">Indicates whether two <see cref="T:System.Reflection.MethodBase" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="5aedc-535"><see langword="true" />Jeśli <paramref name="left" /> jest <see langword="false" />równa; w przeciwnym razie,. <paramref name="right" /></span><span class="sxs-lookup"><span data-stu-id="5aedc-535"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As MethodBase, right As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::MethodBase ^ left, System::Reflection::MethodBase ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.MethodBase * System.Reflection.MethodBase -&gt; bool" Usage="System.Reflection.MethodBase.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="5aedc-536">Pierwszy obiekt, który ma zostać porównany.</span><span class="sxs-lookup"><span data-stu-id="5aedc-536">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="5aedc-537">Drugi obiekt, który będzie porównywany.</span><span class="sxs-lookup"><span data-stu-id="5aedc-537">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="5aedc-538">Wskazuje, czy <see cref="T:System.Reflection.MethodBase" /> dwa obiekty nie są równe.</span><span class="sxs-lookup"><span data-stu-id="5aedc-538">Indicates whether two <see cref="T:System.Reflection.MethodBase" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="5aedc-539"><see langword="true" />Jeśli <paramref name="left" /> nie jest <paramref name="right" />równe; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5aedc-539"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodBase.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodBase.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodBase::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="5aedc-540">Zarezerwowane do użytku w przyszłości.</span><span class="sxs-lookup"><span data-stu-id="5aedc-540">Reserved for future use.</span></span> <span data-ttu-id="5aedc-541">Musi być wartością IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="5aedc-541">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="5aedc-542">Przekazana tablica nazw ma być mapowana.</span><span class="sxs-lookup"><span data-stu-id="5aedc-542">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="5aedc-543">Liczba nazw, które mają być mapowane.</span><span class="sxs-lookup"><span data-stu-id="5aedc-543">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="5aedc-544">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</span><span class="sxs-lookup"><span data-stu-id="5aedc-544">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="5aedc-545">Tablica przydzielana przez obiekt wywołujący, który otrzymuje numery identyfikacyjne odpowiadających nazw.</span><span class="sxs-lookup"><span data-stu-id="5aedc-545">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="5aedc-546">Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania.</span><span class="sxs-lookup"><span data-stu-id="5aedc-546">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-547">Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="5aedc-547">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="5aedc-548">Więcej informacji o `IDispatch::GetIDsOfNames`programie znajduje się w bibliotece MSDN.</span><span class="sxs-lookup"><span data-stu-id="5aedc-548">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="5aedc-549">Dostęp z późnym wiązaniem przy użyciu interfejsu COM <c>IDispatch</c> nie jest obsługiwany.</span><span class="sxs-lookup"><span data-stu-id="5aedc-549">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetType">
      <MemberSignature Language="C#" Value="Type _MethodBase.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._MethodBase.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _MethodBase.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._MethodBase.GetType() = System::Runtime::InteropServices::_MethodBase::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5aedc-550">Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-550">For a description of this member, see <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span></span></summary>
        <returns><span data-ttu-id="5aedc-551">Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-551">For a description of this member, see <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-552">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="5aedc-552">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5aedc-553">Może być używana tylko wtedy, <xref:System.Reflection.MethodBase> gdy wystąpienie jest rzutowane <xref:System.Runtime.InteropServices._MethodBase> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-553">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodBase.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodBase::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="5aedc-554">Informacje o typie, który będzie zwracany.</span><span class="sxs-lookup"><span data-stu-id="5aedc-554">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="5aedc-555">Identyfikator regionalny dla informacji o typie.</span><span class="sxs-lookup"><span data-stu-id="5aedc-555">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="5aedc-556">Otrzymuje wskaźnik do obiektu informacji żądanego typu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-556">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="5aedc-557">Pobiera informacje o typie dla obiektu, których następnie można użyć do uzyskania informacji o typie interfejsu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-557">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-558">Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="5aedc-558">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="5aedc-559">Więcej informacji o `IDispatch::GetTypeInfo`programie znajduje się w bibliotece MSDN.</span><span class="sxs-lookup"><span data-stu-id="5aedc-559">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="5aedc-560">Dostęp z późnym wiązaniem przy użyciu interfejsu COM <c>IDispatch</c> nie jest obsługiwany.</span><span class="sxs-lookup"><span data-stu-id="5aedc-560">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodBase.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodBase::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="5aedc-561">Wskazuje lokalizację, która odbiera informację o liczbie typów dostarczanych przez obiekt.</span><span class="sxs-lookup"><span data-stu-id="5aedc-561">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="5aedc-562">Pobiera informację o liczbie typów interfejsów, jakie zawiera obiekt (0 lub 1).</span><span class="sxs-lookup"><span data-stu-id="5aedc-562">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-563">Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="5aedc-563">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="5aedc-564">Więcej informacji o `IDispatch::GetTypeInfoCount`programie znajduje się w bibliotece MSDN.</span><span class="sxs-lookup"><span data-stu-id="5aedc-564">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="5aedc-565">Dostęp z późnym wiązaniem przy użyciu interfejsu COM <c>IDispatch</c> nie jest obsługiwany.</span><span class="sxs-lookup"><span data-stu-id="5aedc-565">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.Invoke">
      <MemberSignature Language="C#" Value="void _MethodBase.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodBase.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodBase::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="5aedc-566">Określa element członkowski.</span><span class="sxs-lookup"><span data-stu-id="5aedc-566">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="5aedc-567">Zarezerwowane do użytku w przyszłości.</span><span class="sxs-lookup"><span data-stu-id="5aedc-567">Reserved for future use.</span></span> <span data-ttu-id="5aedc-568">Musi być wartością IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="5aedc-568">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="5aedc-569">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</span><span class="sxs-lookup"><span data-stu-id="5aedc-569">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="5aedc-570">Flagi opisujące kontekst wywołania.</span><span class="sxs-lookup"><span data-stu-id="5aedc-570">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="5aedc-571">Wskaźnik do struktury zawiera tablicę argumentów, tablicę identyfikatorów DISPID argumentu dla nazwanych argumentów i zlicza liczbę elementów w tablicach.</span><span class="sxs-lookup"><span data-stu-id="5aedc-571">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="5aedc-572">Wskaźnik miejsca, gdzie ma być przechowywany wynik.</span><span class="sxs-lookup"><span data-stu-id="5aedc-572">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="5aedc-573">Wskaźnik do struktury, która zawiera informacje o wyjątku.</span><span class="sxs-lookup"><span data-stu-id="5aedc-573">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="5aedc-574">Indeks pierwszego argumentu, który zawiera błąd.</span><span class="sxs-lookup"><span data-stu-id="5aedc-574">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="5aedc-575">Umożliwia dostęp do właściwości i metod udostępnianych przez obiekt.</span><span class="sxs-lookup"><span data-stu-id="5aedc-575">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-576">Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="5aedc-576">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="5aedc-577">Więcej informacji o `IDispatch::Invoke`programie znajduje się w bibliotece MSDN.</span><span class="sxs-lookup"><span data-stu-id="5aedc-577">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="5aedc-578">Dostęp z późnym wiązaniem przy użyciu interfejsu COM <c>IDispatch</c> nie jest obsługiwany.</span><span class="sxs-lookup"><span data-stu-id="5aedc-578">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAbstract">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAbstract As Boolean Implements _MethodBase.IsAbstract" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-579">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-579">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span></span></summary>
        <value><span data-ttu-id="5aedc-580">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-580">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-581">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="5aedc-581">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5aedc-582">Może być używana tylko wtedy, <xref:System.Reflection.MethodBase> gdy wystąpienie jest rzutowane <xref:System.Runtime.InteropServices._MethodBase> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-582">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAssembly As Boolean Implements _MethodBase.IsAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsAssembly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-583">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-583">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span></span></summary>
        <value><span data-ttu-id="5aedc-584">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-584">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-585">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="5aedc-585">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5aedc-586">Może być używana tylko wtedy, <xref:System.Reflection.MethodBase> gdy wystąpienie jest rzutowane <xref:System.Runtime.InteropServices._MethodBase> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-586">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsConstructor">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsConstructor As Boolean Implements _MethodBase.IsConstructor" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsConstructor { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsConstructor" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsConstructor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-587">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-587">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span></span></summary>
        <value><span data-ttu-id="5aedc-588">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-588">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-589">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="5aedc-589">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5aedc-590">Może być używana tylko wtedy, <xref:System.Reflection.MethodBase> gdy wystąpienie jest rzutowane <xref:System.Runtime.InteropServices._MethodBase> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-590">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamily">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamily As Boolean Implements _MethodBase.IsFamily" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsFamily { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-591">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-591">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span></span></summary>
        <value><span data-ttu-id="5aedc-592">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-592">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-593">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="5aedc-593">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5aedc-594">Może być używana tylko wtedy, <xref:System.Reflection.MethodBase> gdy wystąpienie jest rzutowane <xref:System.Runtime.InteropServices._MethodBase> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-594">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamilyAndAssembly As Boolean Implements _MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsFamilyAndAssembly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-595">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-595">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span></span></summary>
        <value><span data-ttu-id="5aedc-596">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-596">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-597">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="5aedc-597">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5aedc-598">Może być używana tylko wtedy, <xref:System.Reflection.MethodBase> gdy wystąpienie jest rzutowane <xref:System.Runtime.InteropServices._MethodBase> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-598">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamilyOrAssembly As Boolean Implements _MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsFamilyOrAssembly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-599">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-599">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span></span></summary>
        <value><span data-ttu-id="5aedc-600">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-600">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-601">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="5aedc-601">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5aedc-602">Może być używana tylko wtedy, <xref:System.Reflection.MethodBase> gdy wystąpienie jest rzutowane <xref:System.Runtime.InteropServices._MethodBase> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-602">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFinal">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFinal As Boolean Implements _MethodBase.IsFinal" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsFinal { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsFinal" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFinal</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-603">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-603">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span></span></summary>
        <value><span data-ttu-id="5aedc-604">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-604">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-605">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="5aedc-605">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5aedc-606">Może być używana tylko wtedy, <xref:System.Reflection.MethodBase> gdy wystąpienie jest rzutowane <xref:System.Runtime.InteropServices._MethodBase> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-606">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsHideBySig">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsHideBySig As Boolean Implements _MethodBase.IsHideBySig" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsHideBySig { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsHideBySig" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsHideBySig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-607">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-607">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span></span></summary>
        <value><span data-ttu-id="5aedc-608">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-608">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-609">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="5aedc-609">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5aedc-610">Może być używana tylko wtedy, <xref:System.Reflection.MethodBase> gdy wystąpienie jest rzutowane <xref:System.Runtime.InteropServices._MethodBase> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-610">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPrivate">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPrivate As Boolean Implements _MethodBase.IsPrivate" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsPrivate { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-611">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-611">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span></span></summary>
        <value><span data-ttu-id="5aedc-612">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-612">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-613">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="5aedc-613">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5aedc-614">Może być używana tylko wtedy, <xref:System.Reflection.MethodBase> gdy wystąpienie jest rzutowane <xref:System.Runtime.InteropServices._MethodBase> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-614">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPublic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPublic As Boolean Implements _MethodBase.IsPublic" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-615">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-615">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span></span></summary>
        <value><span data-ttu-id="5aedc-616">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-616">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-617">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="5aedc-617">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5aedc-618">Może być używana tylko wtedy, <xref:System.Reflection.MethodBase> gdy wystąpienie jest rzutowane <xref:System.Runtime.InteropServices._MethodBase> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-618">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsSpecialName">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSpecialName As Boolean Implements _MethodBase.IsSpecialName" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-619">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-619">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span></span></summary>
        <value><span data-ttu-id="5aedc-620">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-620">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-621">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="5aedc-621">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5aedc-622">Może być używana tylko wtedy, <xref:System.Reflection.MethodBase> gdy wystąpienie jest rzutowane <xref:System.Runtime.InteropServices._MethodBase> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-622">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsStatic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsStatic As Boolean Implements _MethodBase.IsStatic" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsStatic { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsStatic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-623">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-623">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span></span></summary>
        <value><span data-ttu-id="5aedc-624">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-624">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-625">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="5aedc-625">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5aedc-626">Może być używana tylko wtedy, <xref:System.Reflection.MethodBase> gdy wystąpienie jest rzutowane <xref:System.Runtime.InteropServices._MethodBase> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-626">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsVirtual">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsVirtual As Boolean Implements _MethodBase.IsVirtual" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsVirtual { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsVirtual" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsVirtual</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5aedc-627">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-627">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span></span></summary>
        <value><span data-ttu-id="5aedc-628">Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />Zobacz.</span><span class="sxs-lookup"><span data-stu-id="5aedc-628">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5aedc-629">Ten element jest jawną implementacją członków.</span><span class="sxs-lookup"><span data-stu-id="5aedc-629">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5aedc-630">Może być używana tylko wtedy, <xref:System.Reflection.MethodBase> gdy wystąpienie jest rzutowane <xref:System.Runtime.InteropServices._MethodBase> do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="5aedc-630">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
